<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>UNP 学习笔记 | Aurora</title><meta name="author" content="AuroraFish"><meta name="copyright" content="AuroraFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频和书籍的一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="UNP 学习笔记">
<meta property="og:url" content="http://example.com/2023/03/17/UNP%20note/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="视频和书籍的一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cat8.png">
<meta property="article:published_time" content="2023-03-17T09:38:55.000Z">
<meta property="article:modified_time" content="2023-04-27T03:05:38.017Z">
<meta property="article:author" content="AuroraFish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cat8.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/17/UNP%20note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UNP 学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-27 11:05:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/headd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/cat8.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aurora</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UNP 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-17T09:38:55.000Z" title="发表于 2023-03-17 17:38:55">2023-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-27T03:05:38.017Z" title="更新于 2023-04-27 11:05:38">2023-04-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UNP 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Unix-网络编程"><a href="#Unix-网络编程" class="headerlink" title="Unix 网络编程"></a>Unix 网络编程</h1><h2 id="视频笔记部分"><a href="#视频笔记部分" class="headerlink" title="视频笔记部分"></a>视频笔记部分</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>了解啥是协议，大概就是 <strong>规则</strong>的意思，数据传输和解释时的规则，毕竟数据传输的时候本质是二进制，要按一定的格式才能解释过来</p>
<p><strong>典型协议</strong>:</p>
<ol>
<li>传输层 常见协议有TCP&#x2F;UDP协议。</li>
<li>应用层 常见的协议有HTTP协议，FTP协议。</li>
<li>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</li>
<li>网络接口层 常见协议有ARP协议、RARP协议。</li>
<li>TCP<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/544903.htm">传输控制协议</a>（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/239605.htm">传输层</a>通信协议。</li>
<li>UDP用户数据报协议（User Datagram Protocol）是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/113948.htm">OSI</a>参考模型中一种无连接的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/239605.htm">传输层</a>协议，提供面向事务的简单不可靠信息传送服务。</li>
<li>HTTP<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/468465.htm">超文本传输协议</a>（Hyper Text Transfer Protocol）是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/6825.htm">互联网</a>上应用最为广泛的一种<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/16603.htm">网络协议</a>。</li>
<li>FTP文件传输协议（File Transfer Protocol）</li>
<li>IP协议是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1706.htm">因特网</a>互联协议（Internet Protocol）</li>
<li>ICMP协议是Internet控制<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/175122.htm">报文</a>协议（Internet Control Message Protocol）它是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/2221037.htm">TCP&#x2F;IP协议族</a>的一个子协议，用于在IP<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/23880.htm">主机</a>、<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/18655.htm">路由</a>器之间传递控制消息。</li>
<li>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</li>
<li><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/32698.htm">ARP</a>协议是正向<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/149421.htm">地址解析协议</a>（Address Resolution Protocol），通过已知的IP，寻找对应主机的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/69334.htm">MAC地址</a>。</li>
<li><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/32772.htm">RARP</a>是反向地址转换协议，通过MAC地址确定IP地址。</li>
</ol>
<h3 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h3><p><strong>C&#x2F;S模式</strong></p>
<p>​     传统的网络应用设计模式，客户机(client)&#x2F;服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<p><strong>B&#x2F;S模式</strong></p>
<p>浏览器()&#x2F;服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<p>优缺点，cs模式，开发量大，采用的协议相对灵活，数据传输效率高，因为提前缓存了数据在客户端；bs模式，开发量相对于cs模式小，但采用的协议固定</p>
<h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><p><strong>OSI七层模型</strong></p>
<p>物数网传会表应</p>
<p><img src="/./../pic/image-20221108194017832-1682516261251-1.png" alt="image-20221108194017832"></p>
<ol>
<li><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</li>
<li><strong>数据链路层</strong>：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</li>
<li><strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li>
<li><strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li>
<li><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li>
<li><strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>
<li><strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li>
</ol>
<p><strong>TCP&#x2F;IP四层模型</strong></p>
<p><img src="/./../pic/image-20221108194100793.png" alt="image-20221108194100793"></p>
<h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><p>简单来说就是数据一层层的封包，然后进入网络，到达目的地后，再一层层的解包</p>
<p><img src="/./../pic/image-20221108194240036.png" alt="image-20221108194240036"></p>
<h3 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h3><p><strong>数据包封装</strong></p>
<p>数据-应用-传输-网络-链路 类似如此封装</p>
<p>传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装</p>
<p><img src="/./../pic/image-20221108194500659.png" alt="image-20221108194500659"></p>
<p><strong>以太网帧格式</strong></p>
<p>格式如下，类型有三种：</p>
<ol>
<li>基础格式: [ [目的地址(6)] [源地址6] [类型2] [数据46-1500] [crc4]]  </li>
<li>类型0800: [ [目的地址(6)] [源地址6] [0800] [数据46-1500] [crc4]]  </li>
<li>类型0806: [ [目的地址(6)] [源地址6] [0806] [ARP请求&#x2F;应答(28) + PAD(18)] [crc4]]  </li>
<li>类型8035: [ [目的地址(6)] [源地址6] [类型2] [RARP请求&#x2F;应答(28) + PAD(18)] [crc4]]</li>
</ol>
<p>不同的类型用于路由器寻路的时候，获取下一跳的mac地址</p>
<p><strong>ARP数据报格式</strong></p>
<p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p>
<p><img src="/./../pic/image-20221108195022490.png" alt="image-20221108195022490"></p>
<p><strong>IP段格式</strong></p>
<p><img src="/./../pic/image-20221108202749686.png" alt="image-20221108202749686"></p>
<p><strong>UDP数据报格式</strong></p>
<p><img src="/./../pic/image-20221108202811024.png" alt="image-20221108202811024"></p>
<h3 id="NAT映射-打洞机制"><a href="#NAT映射-打洞机制" class="headerlink" title="NAT映射 打洞机制"></a>NAT映射 打洞机制</h3><p>这里简单了解一下，NAT映射，内网IP由路由器到公网IP之间的映射，因为内网IP外部访问不到，打洞机制，就在目的地和起源地之间直接创建一条通路，借由某公网IP</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>成对出现，和FIFO有点像，但是是全双工的，且一个socket文件对应两个缓冲区，一个读缓冲区，一个写缓冲区</p>
<p>然后就是一些函数的使用 如:</p>
<ol>
<li>socket 创建套接字 </li>
<li>bind 绑定IP和端口</li>
<li>listen 指定最大同时发起连接数</li>
<li>accept 阻塞等待客户端发起连接</li>
<li>connect 发起连接</li>
</ol>
<p>然后常见的C&#x2F;S模型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nc 命令 nc + ip + duan&#x27;kou&#x27;ha</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;172.23.155.242&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd, cfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clie_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="type">int</span> n, ret;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ], clie_IP[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定IP和端口</span></span><br><span class="line">    ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许最大同时连接数</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>)</span><br><span class="line">;    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待连接</span></span><br><span class="line">    clie_addr_len = <span class="built_in">sizeof</span>(clie_addr);</span><br><span class="line">    cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect success\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client IP:%s, client port:%d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;clie_addr.sin_addr.s_addr,</span><br><span class="line">    clie_IP, <span class="built_in">sizeof</span>(clie_IP)), <span class="built_in">ntohs</span>(clie_addr.sin_port));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//处理数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">read</span>(cfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写回数据</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;172.23.155.242&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="comment">// socklen_t serv_addr_len;</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    cfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(cfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), stdin);</span><br><span class="line">        <span class="built_in">write</span>(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        n = <span class="built_in">read</span>(cfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三次握手-x2F-四次握手"><a href="#三次握手-x2F-四次握手" class="headerlink" title="三次握手&#x2F;四次握手"></a>三次握手&#x2F;四次握手</h3><p>三次握手发生在建立连接时期，1.主动发起方发送SYN请求 2.被动接收方ACK应答，并发送SYN请求 3.主动发起方ACK应答 三次握手完成</p>
<p>四次握手发送在关闭时期，		1.主动关闭方发送FIN请求 2.被动接收方ACK应答 3.被动接收方发送FIN请求并再次发送ACK应答 4.主动关闭方ACK应答</p>
<p><img src="/./../pic/image-20221110111253616.png" alt="image-20221110111253616"></p>
<p>建立连接的过程是三方握手，而关闭连接通常需要4个段，<strong>服务器的应答和关闭连接请求通常不合并在一个段中</strong>，因为有<strong>连接半关闭</strong>的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p>
<h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>通信术语:最大传输单元</p>
<p>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。</p>
<p>以下是一些协议的MTU：</p>
<ol>
<li>FDDI协议：4352字节</li>
<li><strong>以太网（Ethernet）协议：1500字节</strong></li>
<li>PPPoE（ADSL）协议：1492字节</li>
<li>X.25协议（Dial Up&#x2F;Modem）：576字节</li>
<li>Point-to-Point：4470字节</li>
<li><strong>ip地址: 65535</strong></li>
</ol>
<p>mss 受MTU影响，除开协议头以外，纯数据部分所占多大</p>
<h3 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口(TCP流量控制)"></a>滑动窗口(TCP流量控制)</h3><p><img src="/./../pic/image-20221110112502842.png" alt="image-20221110112502842"></p>
<ol>
<li>发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</li>
<li>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</li>
<li>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</li>
<li>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</li>
<li>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</li>
<li>接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</li>
<li>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</li>
<li>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</li>
<li>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。</li>
</ol>
<h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h3><p>用netstat -apn 可以查看端口的部分状态，如之前经常见到的 TIME_WAIT</p>
<p><img src="/./../pic/image-20221110113839140.png" alt="image-20221110113839140"></p>
<p>实线表示主动发起方，虚线表示被动接受方，细线表示某些接受和发送同时进行。基本就是三次握手和四次握手直接，状态变化的具体过程</p>
<ol>
<li><strong>CLOSED</strong>：表示初始状态。</li>
<li><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>
<li><strong>SYN_RCVD:</strong> 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><strong>ESTABLISHED：</strong>表示连接已经建立。</li>
<li><strong>FIN_WAIT_1:</strong>  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</li>
<li>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</li>
<li>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li>
<li><strong>FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。</strong>该状态下的socket只能接收数据，不能发。</li>
<li><strong>TIME_WAIT:</strong> 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li><strong>CLOSING:</strong> 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>
<li><strong>CLOSE_WAIT:</strong> 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</li>
<li><strong>LAST_ACK:</strong> 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</li>
</ol>
<h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p>TIME_WAIT状态等待的时间，具体时长取决于实现</p>
<p>TIME_WAIT和2MSL存在的意义，确保最后一次ACK应答被收到</p>
<h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><p>TCP连接中，A发送FIN请求，进入到FIN_WAIT_1状态，B端回应ACK后，(A端进入FIN_WAIT_2状态)，B没立即使，发送FIN请求，此时就处于半关闭状态，此时A可以接受B发送的数据，但不能像A发送数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line">	<span class="comment">//sockfd:需要关闭的socket描述符</span></span><br><span class="line">	<span class="comment">//how:</span></span><br><span class="line">	<span class="comment">//SHUT_RD(0):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span></span><br><span class="line">	<span class="comment">//			 该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span></span><br><span class="line">	<span class="comment">//SHUT_WR(1):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span></span><br><span class="line">	<span class="comment">//SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span></span><br></pre></td></tr></table></figure>

<p>close和shutdown的区别，close只是减少描述符的引用计数，引用计数为0时才关闭连接，shutdown不考虑描述符的引用计数，直接关闭描述符</p>
<h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>用于解决TIME_WAIT期间，TCP连接没有完全断开之前不允许重新监听的问题</p>
<p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在socket和bind之间插入下列代码</span></span><br><span class="line">	<span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<p>setsockopt和fcntl函数一样，用途很多，具体参考UNP第七章，这里只使用到他的端口复用功能</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">			fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">	nfds: 		监控的文件描述符集里最大文件描述符加<span class="number">1</span>，因为此参数会告诉内核检测前多少个文件描述符的状态</span><br><span class="line">	readfds：	监控有读数据到达文件描述符集合，传入传出参数</span><br><span class="line">	writefds：	监控写数据到达文件描述符集合，传入传出参数</span><br><span class="line">	exceptfds：	监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span><br><span class="line">	timeout：	定时阻塞监控时间，<span class="number">3</span>种情况</span><br><span class="line">				<span class="number">1.</span><span class="literal">NULL</span>，永远等下去</span><br><span class="line">				<span class="number">2.</span>设置timeval，等待固定时间</span><br><span class="line">				<span class="number">3.</span>设置timeval里时间均为<span class="number">0</span>，检查描述字后立即返回，轮询</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">		<span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">		<span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; 	<span class="comment">//把文件描述符集合里fd清0</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; 	<span class="comment">//测试文件描述符集合里fd是否置1</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>; 	<span class="comment">//把文件描述符集合里fd位置1</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>; 			<span class="comment">//把文件描述符集合里所有位清0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, maxi;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nready, client[FD_SETSIZE];         <span class="comment">/* client数组方便遍历文件描述符 */</span></span><br><span class="line">    <span class="type">int</span> maxfd, listenfd, connfd, sockfd;    </span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ], str[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clie_addr, serv_addr;</span><br><span class="line">    <span class="type">socklen_t</span> cile_addr_len;</span><br><span class="line">    fd_set rset, allset;                    <span class="comment">/* reset表示select正在操作的监听集合，allset表示所有的监听 */</span></span><br><span class="line"></span><br><span class="line">    listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="built_in">Listen</span>(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 起初listenfd 即为最大文件描述符 */</span></span><br><span class="line">    maxfd = listenfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用作client[]的下表，初值为第0个元素之前 */</span></span><br><span class="line">    maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    <span class="comment">/* 用-1 初始化client[] */</span></span><br><span class="line">        client[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造select监听集合 */</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;allset);</span><br><span class="line">    <span class="built_in">FD_SET</span>(listenfd, &amp;allset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 每次循环重新设置监听集合 */</span></span><br><span class="line">        rset = allset;</span><br><span class="line">        nready = <span class="built_in">select</span>(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">perr_exit</span>(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 说明有新客户端连接 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(listenfd, &amp;rset)) &#123;</span><br><span class="line">            cile_addr_len = <span class="built_in">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = <span class="built_in">Accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;clie_addr, <span class="built_in">sizeof</span>(clie_addr));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clie_addr.sin_addr, str, <span class="built_in">sizeof</span>(str)), </span><br><span class="line">                    <span class="built_in">ntohs</span>(clie_addr.sin_port));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 寻找client中可用的位置，并将connfd加入 */</span> </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i] = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE) &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;too many clients\n&quot;</span>, stderr);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 向监听集合加入新的client */</span></span><br><span class="line">            <span class="built_in">FD_SET</span>(connfd, &amp;allset);</span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* maxi总是指向最后一个使用到的文件描述符 */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;</span><br><span class="line">            <span class="comment">/* 检测那个clients 有数据就绪*/</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;rset)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = <span class="built_in">Read</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf))) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">Close</span>(sockfd);</span><br><span class="line">                    <span class="built_in">FD_CLR</span>(sockfd, &amp;allset);</span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">                    <span class="built_in">Write</span>(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><p>poll和select的区别，select有上限1024，且除了重新编译内核之外没有办法修改，poll可以修改系统中的最大上限来更改。其次select中用于遍历文件描述符的数组，poll中变成了自带的，不需要再自定义了，其次select可以跨平台，poll针对linux</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">		<span class="type">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">		<span class="type">short</span> events; <span class="comment">/* 监控的事件 */</span></span><br><span class="line">		<span class="type">short</span> revents; <span class="comment">/* 监控事件中满足条件返回的事件 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	POLLIN			普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span><br><span class="line">	POLLRDNORM		数据可读</span><br><span class="line">	POLLRDBAND		优先级带数据可读</span><br><span class="line">	POLLPRI 		高优先级可读数据</span><br><span class="line">	POLLOUT		普通或带外数据可写</span><br><span class="line">	POLLWRNORM		数据可写</span><br><span class="line">	POLLWRBAND		优先级带数据可写</span><br><span class="line">	POLLERR 		发生错误</span><br><span class="line">	POLLHUP 		发生挂起</span><br><span class="line">	POLLNVAL 		描述字不是一个打开的文件</span><br><span class="line"></span><br><span class="line">	nfds 			监控数组中有多少文件描述符需要被监控</span><br><span class="line"></span><br><span class="line">	timeout 		毫秒级等待</span><br><span class="line">		<span class="number">-1</span>：阻塞等，<span class="meta">#<span class="keyword">define</span> INFTIM -1 				Linux中没有定义此宏</span></span><br><span class="line">		<span class="number">0</span>：立即返回，不阻塞进程</span><br><span class="line">		&gt;<span class="number">0</span>：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="comment">/* 接收poll返回值，记录满足监听事件的fd个数 */</span></span><br><span class="line">    <span class="type">int</span> nready;               </span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> client[OPEN_MAX];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">    listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置端口复用 */</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">    <span class="built_in">Listen</span>(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要监听的一个文件描述符 */</span></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    <span class="comment">/* listenfd监听普通读事件 */</span></span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* 阻塞监听是否有客户端连接请求 */</span></span><br><span class="line">        nready = <span class="built_in">poll</span>(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listenfd有读事件就绪 */</span></span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"></span><br><span class="line">            clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = <span class="built_in">Accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, clilen);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr, str, <span class="built_in">sizeof</span>(str)), </span><br><span class="line">                    <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">                <span class="built_in">perr_exit</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">            client[i].events = POLLIN;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;</span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i =<span class="number">1</span> ;i &lt;= maxi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = <span class="built_in">Read</span>(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* connection reset by client*/</span></span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        <span class="comment">/* 收到RST标志 */</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>,i);</span><br><span class="line">                        <span class="built_in">Close</span>(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> </span><br><span class="line">                        <span class="built_in">perr_exit</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, i);</span><br><span class="line">                    <span class="built_in">Close</span>(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    <span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><p>poll跟epoll的区别，epoll通过创建一颗红黑树来帮忙管理监听事件，比起我们自己处理监听数组，更方便快捷</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规用法</span></span><br><span class="line"><span class="comment">// #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="type">int</span> n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nready, efd, res;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], str[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clien_addr, serv_addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> tep, ep[OPEN_MAX];           <span class="comment">/* TEP: epoll_ctl参数 , ep[]: epoll_wait参数*/</span></span><br><span class="line"></span><br><span class="line">    listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置端口复用 */</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="built_in">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Listen</span>(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建epoll模型，实际上创建了一个文件描述符指向一颗红黑树，这棵红黑树就起到了之前select 和 poll里面数组的作用 */</span></span><br><span class="line">    efd = <span class="built_in">epoll_create</span>(OPEN_MAX);</span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">perr_exit</span>(<span class="string">&quot;epoll_Create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对listenfd进行设置，监听读事件，data存放listenfd */</span></span><br><span class="line">    tep.events = EPOLLIN; tep.data.fd = listenfd;</span><br><span class="line">    res = <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">perr_exit</span>(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* epoll_wait server阻塞监听事件，ep为struct epoll_event类型数组, open_max为数组容量, -1表示永久阻塞(就是阻塞时长那个参数) */</span></span><br><span class="line">        nready = <span class="built_in">epoll_wait</span>(efd, ep, OPEN_MAX, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>) </span><br><span class="line">            <span class="built_in">perr_exit</span>(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; nready; i++) &#123;</span><br><span class="line">            <span class="comment">/* 如果不是监听读事件，继续循环 */</span></span><br><span class="line">            <span class="keyword">if</span> (!(ep[i].events &amp; EPOLLIN))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 判断是否是listenfd, listenfd用来处理客户端的连接，其他的则是对应的read事件 */</span></span><br><span class="line">            <span class="keyword">if</span> (ep[i].data.fd == listenfd) &#123;</span><br><span class="line">                clilen = <span class="built_in">sizeof</span>(clien_addr);</span><br><span class="line">                connfd = <span class="built_in">Accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;clien_addr, &amp;clilen);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>, </span><br><span class="line">                        <span class="built_in">inet_ntop</span>(AF_INET, &amp;clien_addr.sin_addr, str, <span class="built_in">sizeof</span>(str)), </span><br><span class="line">                        <span class="built_in">ntohs</span>(clien_addr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cfd %d---client %d\n&quot;</span>, connfd, ++num);</span><br><span class="line"></span><br><span class="line">                tep.events = EPOLLIN; tep.data.fd = connfd;</span><br><span class="line">                res = <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                    <span class="built_in">perr_exit</span>(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sockfd = ep[i].data.fd;</span><br><span class="line">                n = <span class="built_in">Read</span>(sockfd, buf, MAXLINE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                        <span class="built_in">perr_exit</span>(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">                    <span class="built_in">Close</span>(sockfd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read n &lt; 0 error: &quot;</span>);</span><br><span class="line">                    res = <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">Close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">Write</span>(STDOUT_FILENO, buf, n);</span><br><span class="line">                        <span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Close</span>(listenfd);</span><br><span class="line">    <span class="built_in">Close</span>(efd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种触发模式，边缘触发ET和水平触发LT，区别就是水平触发，在socket中有内容可读时，会反复调用epoll_wait触发然后继续读，直到读完，而边缘触发，只会调用读一次，读完继续阻塞到epoll_wait，等待下一个监听事件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子，每次写10个数据，但每次只读5个，如果是水平触发，由于其特性回能够读完，而边沿触发</span></span><br><span class="line"><span class="comment">//每次只能读5个，socket中的数据会积累的越来越多</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> efd, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(pfd);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(pfd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;   </span><br><span class="line">            <span class="comment">//aaaa\n</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">//bbbb\n</span></span><br><span class="line">            <span class="keyword">for</span> (;i &lt; MAXLINE; i++)</span><br><span class="line">                buf[i] = ch;</span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            ch++;</span><br><span class="line">            <span class="comment">//aaaa\nbbbb\n</span></span><br><span class="line">            <span class="built_in">write</span>(pfd[<span class="number">1</span>], buf, MAXLINE);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(pfd[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//father</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> epoll_event event;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> resevent[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res, len;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(pfd[<span class="number">1</span>]);</span><br><span class="line">        efd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        event.events = EPOLLIN | EPOLLET;           <span class="comment">/* ET边沿触发 */</span></span><br><span class="line">        <span class="comment">// event.events = EPOLLIN;                     /* 默认LT水平触发 */</span></span><br><span class="line">        event.data.fd = pfd[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, pfd[<span class="number">0</span>], &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">epoll_wait</span>(efd, resevent, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;res = %d\n&quot;</span>, res);</span><br><span class="line">            <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>]) &#123;</span><br><span class="line">                len = <span class="built_in">read</span>(pfd[<span class="number">0</span>], buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(pfd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(efd);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个借助socket实现的例子，上述例子是通过管道实现的，也就是epoll不仅仅只是适用于socket的情况下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路同上，socket实现</span></span><br><span class="line"><span class="comment">//1.server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> cliaddr_len;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">int</span> efd;</span><br><span class="line"></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> resevent[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    efd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;       <span class="comment">/* ET 边沿触发 */</span></span><br><span class="line">    <span class="comment">// event.events = EPOLLIN;                 /* 默认 LT 水平触发 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cliaddr_len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr, str, <span class="built_in">sizeof</span>(str)), </span><br><span class="line">            <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = <span class="built_in">epoll_wait</span>(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;res %d\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">            len = <span class="built_in">read</span>(connfd, buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> sockfd, i;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//aaaa\n</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="comment">//bbbb\n</span></span><br><span class="line">        <span class="keyword">for</span> (;i &lt; MAXLINE; i++)</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="comment">//aaaa\nbbbb\n</span></span><br><span class="line">        <span class="built_in">write</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非阻塞I&#x2F;O方式，设置socket非阻塞，并且使用边沿触发ET模式，通常为我们选择的方式，ET能够减少epoll_wait的调用次数，通过while轮询，也能解决ET模式无法将缓冲区读完的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 10  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, cli_addr;</span><br><span class="line">    <span class="type">socklen_t</span> cli_addr_len;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">int</span> efd, flag;</span><br><span class="line"></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> resevent[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> res, len;</span><br><span class="line"></span><br><span class="line">    efd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="comment">// event.events = EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connecton ...\n&quot;</span>);</span><br><span class="line">    cli_addr_len = <span class="built_in">sizeof</span>(cli_addr);</span><br><span class="line">    connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cli_addr, &amp;cli_addr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;cli_addr.sin_addr, str, <span class="built_in">sizeof</span>(str)), </span><br><span class="line">            <span class="built_in">ntohs</span>(cli_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改connfd为非阻塞 */</span></span><br><span class="line">    flag = <span class="built_in">fcntl</span>(connfd, F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(connfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    event.data.fd = connfd;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait begin\n&quot;</span>);</span><br><span class="line">        res = <span class="built_in">epoll_wait</span>(efd, resevent, <span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait end res %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((len = <span class="built_in">read</span>(connfd, buf, MAXLINE/<span class="number">2</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> sockfd, i;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//aaaa\n</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; MAXLINE; i++)</span><br><span class="line">            buf[i] = ch;</span><br><span class="line">        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        ch++;</span><br><span class="line">        <span class="comment">//aaaa\nbbbb\n</span></span><br><span class="line">        <span class="built_in">write</span>(sockfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll反应堆模型</p>
<p><img src="/./../pic/image-20221114215628129.png" alt="image-20221114215628129"></p>
<p>与普通模型相比，多了一步重新设置监听事件，这样的作用，可以判断是否能向客户端写事件，因为客户端不一定能写，同时用到了epoll_event的arg参数，自定义了一个回调函数，可以看看一些比较好的代码思路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不是特别难，看的时候从main逐步向后看就能理解</span></span><br><span class="line"><span class="comment">/* libevent 简易模型 */</span></span><br><span class="line"><span class="comment">/* epoll 基于非阻塞I/O事件驱动 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 1024             <span class="comment">/* 监听上限数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recvdata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">senddata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll_event data段结构 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_events</span> &#123;</span><br><span class="line">    <span class="type">int</span>     fd;                                         <span class="comment">// 监听的文件描述符</span></span><br><span class="line">    <span class="type">int</span>     events;                                     <span class="comment">// 对应的监听事件</span></span><br><span class="line">    <span class="type">void</span>*   arg;                                        <span class="comment">// 泛型参数</span></span><br><span class="line">    <span class="built_in">void</span> (*call_back)(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* arg);   <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="type">int</span>     status;                                     <span class="comment">// 是否在监听 : 1.在红黑树上监听  0.不在</span></span><br><span class="line">    <span class="type">char</span>    buf[BUFLEN];                    </span><br><span class="line">    <span class="type">int</span>     len;                            </span><br><span class="line">    <span class="type">long</span>    last_active;                                <span class="comment">// 记录每次加入红黑树 g_efd 的时间值 用于超时判断，长时间不连接的话，将其从g_efd上删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_efd;                                              <span class="comment">// 全局变量，保存epoll_create返回的文件描述符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_events</span> g_events[MAX_EVENTS+<span class="number">1</span>];                <span class="comment">// 自定义结构类型数组 最后一位储存listenfd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将结构体my_events 初始化 */</span></span><br><span class="line"><span class="comment">// void eventset(struct my_events *ev, int fd, void (*call_back)(int, int, void*), void* arg) &#123;</span></span><br><span class="line"><span class="comment">//     ev-&gt;fd = fd;</span></span><br><span class="line"><span class="comment">//     ev-&gt;call_back = call_back;</span></span><br><span class="line"><span class="comment">//     ev-&gt;events = 0;</span></span><br><span class="line"><span class="comment">//     ev-&gt;status = 0;</span></span><br><span class="line"><span class="comment">//     ev-&gt;last_active = time(NULL);</span></span><br><span class="line"><span class="comment">//     return;</span></span><br><span class="line"><span class="comment">//                                                      // 错误代码 arg 没有初始化，导致后续回调的时候，无法写入到监听事件的buf中，段错误</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eventset</span><span class="params">(<span class="keyword">struct</span> my_events *ev, <span class="type">int</span> fd, <span class="type">void</span> (*call_back)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span> *), <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ev-&gt;fd = fd;</span><br><span class="line">    ev-&gt;call_back = call_back;</span><br><span class="line">    ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">    ev-&gt;arg = arg;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));</span></span><br><span class="line">    <span class="comment">//ev-&gt;len = 0;</span></span><br><span class="line">    ev-&gt;last_active = <span class="built_in">time</span>(<span class="literal">NULL</span>);                       <span class="comment">//调用eventset函数的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 想epoll监听的红黑树 添加一个 文件描述符 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eventadd</span><span class="params">(<span class="type">int</span> efd, <span class="type">int</span> events, <span class="keyword">struct</span> my_events* ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    epv.events = ev-&gt;events = events;                   <span class="comment">// EPOLLIN 或 EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status == <span class="number">1</span>) &#123;                              <span class="comment">// 已经在红黑树g_efd中，修改其属性</span></span><br><span class="line">        op = EPOLL_CTL_MOD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op = EPOLL_CTL_ADD;                             <span class="comment">// 不在，将其加入</span></span><br><span class="line">        ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(efd, op, ev-&gt;fd, &amp;epv) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add failed [fd=%d], events[%d]\n&quot;</span>, ev-&gt;fd, events);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;event add OK [fd=%d], op =%d, events[%0X]\n&quot;</span>, ev-&gt;fd, op, events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accpetconn</span><span class="params">(<span class="type">int</span> lfd, <span class="type">int</span> events, <span class="type">void</span>* arg)</span> </span>&#123;       <span class="comment">//</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cin;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(cin);</span><br><span class="line">    <span class="type">int</span> cfd, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cin, &amp;len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line">            <span class="comment">/* 出错处理 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:accept, %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_EVENTS; i++)                <span class="comment">// 从g_events中找出一个空闲元素</span></span><br><span class="line">            <span class="keyword">if</span> (g_events[i].status == <span class="number">0</span>)                <span class="comment">// 类似于select中找一个-1元素</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == MAX_EVENTS) &#123;                          <span class="comment">// 跳出do while 不执行后续，实现了类似goto的功能</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: max connect limit[%d]\n&quot;</span>, __func__, MAX_EVENTS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;                                   <span class="comment">// 设置cfd为非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> ((flag = <span class="built_in">fcntl</span>(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: fcntl nonblocking failed, %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给cfd设置一个结构体，回调函数设置为recvdata */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">eventset</span>(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);</span><br><span class="line">        <span class="built_in">eventadd</span>(g_efd, EPOLLIN, &amp;g_events[i]);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntoa</span>(cin.sin_addr), <span class="built_in">ntohs</span>(cin.sin_port), g_events[i].last_active, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从epoll监听的红黑树中删除一个文件描述符 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eventdel</span><span class="params">(<span class="type">int</span> efd, <span class="keyword">struct</span> my_events* ev)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------------------------------waht ?&quot;</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epv = &#123;<span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev-&gt;status != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    epv.data.ptr = ev;</span><br><span class="line">    ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);        <span class="comment">// 从gefd上将ev-&gt;fd摘除</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------------------------------------------waht? after&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recvdata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------receive before\n&quot;</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">my_events</span>* ev = (<span class="keyword">struct</span> my_events*)arg;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------len = recv before\n&quot;</span>);</span><br><span class="line">    len = <span class="built_in">recv</span>(fd, ev-&gt;buf, <span class="built_in">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);        <span class="comment">// 读文件描述符，将数据读入my_events.buf</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------len = recv after------------------------------------ len = %d\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">eventdel</span>(g_efd, ev);                                <span class="comment">// 从红黑树上删除</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len = %d\n------------------------------------&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ev-&gt;len = len;</span><br><span class="line">        ev-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C[%d]:%s\n&quot;</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">eventset</span>(ev, fd, senddata, ev);                 <span class="comment">// 将回调函数设置为senddata</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;between set and add\n&quot;</span>);</span><br><span class="line">        <span class="built_in">eventadd</span>(g_efd, EPOLLOUT, ev);                  <span class="comment">// 将fd重新加入，但是改为监听其写事件</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------what error?&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] pos[%ld], closed\n&quot;</span>, fd, ev-g_events);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv[fd=%d] error[%d]:%s\n&quot;</span>, fd, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------receive after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">senddata</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">my_events</span>* ev = (<span class="keyword">struct</span> my_events*)arg;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    len = <span class="built_in">send</span>(fd, ev-&gt;buf, ev-&gt;len, <span class="number">0</span>);                <span class="comment">// 将数据写回客户端 。未作处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] , [%d]%s\n&quot;</span>, fd, len, ev-&gt;buf);</span><br><span class="line">        <span class="built_in">eventdel</span>(g_efd, ev);</span><br><span class="line">        <span class="built_in">eventset</span>(ev, fd, recvdata, ev);</span><br><span class="line">        <span class="built_in">eventadd</span>(g_efd, EPOLLIN, ev);</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">        <span class="built_in">eventdel</span>(g_efd, ev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send[fd=%d] error %s\n&quot;</span>, fd, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initlistensocket</span><span class="params">(<span class="type">int</span> efd, <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(lfd, F_SETFL, O_NONBLOCK);                    <span class="comment">// 设置为非阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */</span></span><br><span class="line">    <span class="built_in">eventset</span>(&amp;g_events[MAX_EVENTS], lfd, accpetconn, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* void eventadd(int efd, int events, struct myevent_s *ev) */</span></span><br><span class="line">    <span class="built_in">eventadd</span>(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sin;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sin, <span class="number">0</span>, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = SERV_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)                                      <span class="comment">// 命令行指定自定义端口，还是默认短裤</span></span><br><span class="line">        port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    g_efd = <span class="built_in">epoll_create</span>(MAX_EVENTS+<span class="number">1</span>);                 <span class="comment">// 创建epoll那棵树</span></span><br><span class="line">    <span class="keyword">if</span> (g_efd &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create efd in %s err %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initlistensocket</span>(g_efd, port);                      <span class="comment">// 初始化监听socket 就是listenfd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> evetns[MAX_EVENTS + <span class="number">1</span>];          <span class="comment">// 保存已满足就绪事件的文件描述符数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server running:port[%d]\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> chekpos = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 超时验证，每次测试100个连接，不测试listenfd，当客户端60秒没有和服务器通信，关闭客户端连接 */</span></span><br><span class="line">        <span class="type">long</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++, chekpos++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chekpos == MAX_EVENTS)</span><br><span class="line">                chekpos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (g_events[chekpos].status != <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> duration = now - g_events[chekpos].last_active;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (duration &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="built_in">close</span>(g_events[chekpos].fd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[fd=%d] timeout\n&quot;</span>, g_events[chekpos].fd);</span><br><span class="line">                <span class="built_in">eventdel</span>(g_efd, &amp;g_events[chekpos]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------epoll_wait before\n&quot;</span>);</span><br><span class="line">        <span class="comment">/* 监听红黑树g_efd, 将满足的事件的文件描述符添加至events数组，1秒钟没有事件返回，返回0 */</span></span><br><span class="line">        <span class="type">int</span> nfd = <span class="built_in">epoll_wait</span>(g_efd, evetns, MAX_EVENTS+<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait error, exit\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------------------------------epoll_wait after\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfd; i++) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">my_events</span>* ev = (<span class="keyword">struct</span> my_events*)evetns[i].data.ptr;</span><br><span class="line">                                                        <span class="comment">// 读就绪事件</span></span><br><span class="line">            <span class="keyword">if</span> ((evetns[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">call_back</span>(ev-&gt;fd, evetns[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">                                                        <span class="comment">// 写就绪事件</span></span><br><span class="line">            <span class="keyword">if</span> ((evetns[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;</span><br><span class="line">                ev-&gt;<span class="built_in">call_back</span>(ev-&gt;fd, evetns[i].events, ev-&gt;arg);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出前释放所有资源 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h3><p>在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。</p>
<p>Heart-Beat线程</p>
<p>这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，定时发送Heart-Beat包，客户端&#x2F;服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。</p>
<p>该方法的好处是通用，但缺点就是会改变现有的通讯协议！大家一般都是使用业务层心跳来处理，主要是灵活可控。</p>
<p>UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。</p>
<p>三种方式 1.心跳包  2.乒乓包(携带一些数据) 3.自带的机制(如下)</p>
<p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="/./../pic/image-20221114220152684.png" alt="image-20221114220152684"></p>
<p>把之前的一些芝士结合在一起了，不错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __THREADPOOL_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __THREADPOOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">threadpool_t</span> <span class="type">threadpool_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_create</span></span><br><span class="line"><span class="comment"> * @descCreates a threadpool_t object.</span></span><br><span class="line"><span class="comment"> * @param thr_num  thread num</span></span><br><span class="line"><span class="comment"> * @param max_thr_num  max thread size</span></span><br><span class="line"><span class="comment"> * @param queue_max_size   size of the queue.</span></span><br><span class="line"><span class="comment"> * @return a newly created thread pool or NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">threadpool_t</span> *<span class="title">threadpool_create</span><span class="params">(<span class="type">int</span> min_thr_num, <span class="type">int</span> max_thr_num, <span class="type">int</span> queue_max_size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_add</span></span><br><span class="line"><span class="comment"> * @desc add a new task in the queue of a thread pool</span></span><br><span class="line"><span class="comment"> * @param pool     Thread pool to which add the task.</span></span><br><span class="line"><span class="comment"> * @param function Pointer to the function that will perform the task.</span></span><br><span class="line"><span class="comment"> * @param argument Argument to be passed to the function.</span></span><br><span class="line"><span class="comment"> * @return 0 if all goes well,else -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="type">threadpool_t</span> *pool, <span class="type">void</span>*(*function)(<span class="type">void</span> *arg), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function threadpool_destroy</span></span><br><span class="line"><span class="comment"> * @desc Stops and destroys a thread pool.</span></span><br><span class="line"><span class="comment"> * @param pool  Thread pool to destroy.</span></span><br><span class="line"><span class="comment"> * @return 0 if destory success else -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc get the thread num</span></span><br><span class="line"><span class="comment"> * @pool pool threadpool</span></span><br><span class="line"><span class="comment"> * @return # of the thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * desc get the busy thread num</span></span><br><span class="line"><span class="comment"> * @param pool threadpool</span></span><br><span class="line"><span class="comment"> * return # of the busy thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.threadpool.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TIME 10                 <span class="comment">/*10s检测一次*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_WAIT_TASK_NUM 10            <span class="comment">/*如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新线程到线程池*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_THREAD_VARY 10          <span class="comment">/*每次创建或销毁线程的个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">void</span>*(*function)(<span class="type">void</span>*);            <span class="comment">/*函数指针，回调函数*/</span></span><br><span class="line">    <span class="type">void</span>* arg;                          <span class="comment">/*回调函数的参数*/</span></span><br><span class="line">&#125; <span class="type">threadpool_task_t</span>;                    <span class="comment">/*各子线程任务结构体*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*描述线程池相关信息*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">threadpool_t</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;               <span class="comment">/*锁住本结构体*/</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thread_counter;     <span class="comment">/*锁住忙状态个数 -- busy_thr_num*/</span></span><br><span class="line">    <span class="type">pthread_cond_t</span>  queue_not_full;     <span class="comment">/*当任务队列满时，添加任务的线程阻塞，等待此条件变量*/</span></span><br><span class="line">    <span class="type">pthread_cond_t</span>  queue_not_empty;    <span class="comment">/*任务队列不为空时，通知等待的线程*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">threadpool_task_t</span>* task_queue;      <span class="comment">/*任务队列*/</span></span><br><span class="line">    <span class="type">pthread_t</span>*          threads;        <span class="comment">/*存放线程池中每个线程的tid数组*/</span></span><br><span class="line">    <span class="type">pthread_t</span>           adjust_tid;     <span class="comment">/*管理线程tid*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min_thr_num;                    <span class="comment">/*线程池最小线程数*/</span></span><br><span class="line">    <span class="type">int</span> max_thr_num;                    <span class="comment">/*线程池最大线程数*/</span></span><br><span class="line">    <span class="type">int</span> live_thr_num;                   <span class="comment">/*当前存活线程个数*/</span></span><br><span class="line">    <span class="type">int</span> busy_thr_num;                   <span class="comment">/*忙状态线程个数*/</span></span><br><span class="line">    <span class="type">int</span> wait_exit_thr_num;              <span class="comment">/*要销毁的线程个数*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_front;                    <span class="comment">/*task_queue队头下标*/</span></span><br><span class="line">    <span class="type">int</span> queue_rear;                     <span class="comment">/*task_queue队尾下表*/</span></span><br><span class="line">    <span class="type">int</span> queue_size;                     <span class="comment">/*task_queue队中实际任务数*/</span></span><br><span class="line">    <span class="type">int</span> queue_max_size;                 <span class="comment">/*task_queue队列可容纳任务数上限*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;                       <span class="comment">/*标志位，线程池使用状态*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function void *threadpool_thread(void *threadpool)</span></span><br><span class="line"><span class="comment"> * @desc the worker thread</span></span><br><span class="line"><span class="comment"> * @param threadpool the pool which own the thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadpool_thread</span><span class="params">(<span class="type">void</span>* threadpool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function void *adjust_thread(void *threadpool);</span></span><br><span class="line"><span class="comment"> * @desc manager thread</span></span><br><span class="line"><span class="comment"> * @param threadpool the threadpool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">adjust_thread</span><span class="params">(<span class="type">void</span>* threadpool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check a thread is alive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span>* pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">threadpool_t</span>* <span class="title">threadpool_create</span><span class="params">(<span class="type">int</span> min_thr_num, <span class="type">int</span> max_thr_num, <span class="type">int</span> queue_max_size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pool = (<span class="type">threadpool_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">threadpool_t</span>))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">/*跳出*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;min_thr_num = min_thr_num;</span><br><span class="line">        pool-&gt;max_thr_num = max_thr_num;</span><br><span class="line">        pool-&gt;busy_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;live_thr_num = min_thr_num;           <span class="comment">/*活着的线程数 初值=最小线程数*/</span></span><br><span class="line">        pool-&gt;queue_size = <span class="number">0</span>;                       <span class="comment">/*有0个产品*/</span></span><br><span class="line">        pool-&gt;queue_max_size = queue_max_size;</span><br><span class="line">        pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_rear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="literal">false</span>;                     <span class="comment">/*不关闭线程池*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*根据最大线程数，给工作线程数组开辟空间，并清零*/</span></span><br><span class="line">        pool-&gt;threads = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>)*max_thr_num);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threads fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>)*max_thr_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*队列开辟空间*/</span></span><br><span class="line">        pool-&gt;task_queue = (<span class="type">threadpool_task_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">threadpool_task_t</span>)*queue_max_size);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc task_queue fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*初始化互斥锁，条件变量*/</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;(pool-&gt;lock), <span class="literal">NULL</span>) != <span class="number">0</span> </span><br><span class="line">                || <span class="built_in">pthread_mutex_init</span>(&amp;(pool-&gt;thread_counter), <span class="literal">NULL</span>) != <span class="number">0</span> </span><br><span class="line">                || <span class="built_in">pthread_cond_init</span>(&amp;(pool-&gt;queue_not_empty), <span class="literal">NULL</span>) != <span class="number">0</span> </span><br><span class="line">                || <span class="built_in">pthread_cond_init</span>(&amp;(pool-&gt;queue_not_full), <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init the lock or cond fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*启动min_thr_num个work_thread*/</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min_thr_num; i++) &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="type">void</span>*)pool);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;start thread 0x%x...\n&quot;</span>, (<span class="type">unsigned</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;(pool-&gt;adjust_tid), <span class="literal">NULL</span>, adjust_thread, (<span class="type">void</span>*)pool);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadpool_free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_add</span><span class="params">(<span class="type">threadpool_t</span> *pool, <span class="type">void</span>*(*function)(<span class="type">void</span> *arg), <span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ==为真，队列已满，调wait阻塞*/</span></span><br><span class="line">    <span class="keyword">while</span> ((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*清空 工作线程 调用的回调函数 的参数arg*/</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue[pool-&gt;queue_rear].arg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue[pool-&gt;queue_rear].arg);</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;queue_rear].arg = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加任务到任务队列里*/</span></span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].function = function;</span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg;</span><br><span class="line">    pool-&gt;queue_rear = (pool-&gt;queue_rear + <span class="number">1</span>) % pool-&gt;queue_max_size;</span><br><span class="line">    pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加完任务后，队列不为空，唤醒线程池。等待处理任务的线程*/</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadpool_thread</span><span class="params">(<span class="type">void</span>* threadpool)</span> </span>&#123;</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = (<span class="type">threadpool_t</span>*)threadpool;</span><br><span class="line">    <span class="type">threadpool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒*/</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*queue_size == 0 说明没有任务，调wait阻塞在条件变量上，若有任务，跳过该while*/</span></span><br><span class="line">        <span class="keyword">while</span> ((pool-&gt;queue_size == <span class="number">0</span>) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is waiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">pthread_self</span>());</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;wait_exit_thr_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;wait_exit_thr_num--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*如果线程池里线程个数大于最小值时可以结束当前前程*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">pthread_self</span>());</span><br><span class="line">                    pool-&gt;live_thr_num--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">                    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果指定了true，要关闭线程池里每一个线程，自行退出处理*/</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">pthread_self</span>());</span><br><span class="line">            <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); <span class="comment">/*线程自行结束*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从任务队列里获取一个任务*/</span></span><br><span class="line">        task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">        task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg;</span><br><span class="line"></span><br><span class="line">        pool-&gt;queue_front = (pool-&gt;queue_front+<span class="number">1</span>) % pool-&gt;queue_max_size;<span class="comment">/*出队*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通知可以有新的任务添加进来*/</span></span><br><span class="line">        <span class="built_in">pthread_cond_broadcast</span>(&amp;(pool-&gt;queue_not_full));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务取出后，立即将线程池锁释放*/</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*执行任务*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x start working\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">pthread_self</span>());</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;thread_counter));        <span class="comment">/*忙线程+1*/</span></span><br><span class="line">        pool-&gt;busy_thr_num++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        (*(task.function))(task.arg);                       <span class="comment">/*执行回调函数*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务结束处理*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x end working\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">pthread_self</span>());</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pool-&gt;busy_thr_num--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">adjust_thread</span><span class="params">(<span class="type">void</span>* threadpool)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">threadpool_t</span>* pool = (<span class="type">threadpool_t</span>*)threadpool;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(DEFAULT_TIME);                                <span class="comment">/*定时 对线程池管理，而不是一直执行*/</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="type">int</span> queue_size = pool-&gt;queue_size;</span><br><span class="line">        <span class="type">int</span> live_thr_num = pool-&gt;live_thr_num;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;thread_counter);</span><br><span class="line">        <span class="type">int</span> busy_thr_num = pool-&gt;busy_thr_num;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30&gt;=10 &amp;&amp; 40&lt;100*/</span></span><br><span class="line">        <span class="keyword">if</span> (queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));  </span><br><span class="line">            <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*一次增加 DEFAULT_THREAD 个线程*/</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_VARY</span><br><span class="line">                    &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threads[i] == <span class="number">0</span> || !<span class="built_in">is_thread_alive</span>(pool-&gt;threads[i])) &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="type">void</span> *)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;live_thr_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/</span></span><br><span class="line">        <span class="keyword">if</span> ((busy_thr_num * <span class="number">2</span>) &lt; live_thr_num  &amp;&amp;  live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">            pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY;      <span class="comment">/* 要销毁的线程数 设置为10 */</span></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; i++) &#123;</span><br><span class="line">                <span class="comment">/* 通知处在空闲状态的线程, 他们会自行终止*/</span></span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_destroy</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*销毁管理线程*/</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(pool-&gt;adjust_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        <span class="comment">/*通知所有空闲线程*/</span></span><br><span class="line">        <span class="built_in">pthread_cond_broadcast</span>(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(pool-&gt;threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">threadpool_free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span>* pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;(pool-&gt;queue_not_full));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_all_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> all_threadnum = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">    all_threadnum = pool-&gt;live_thr_num;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;lock));</span><br><span class="line">    <span class="keyword">return</span> all_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadpool_busy_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> busy_threadnum = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    busy_threadnum = pool-&gt;busy_thr_num;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    <span class="keyword">return</span> busy_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_thread_alive</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> kill_rc = <span class="built_in">pthread_kill</span>(tid, <span class="number">0</span>);     <span class="comment">//发0号信号，测试线程是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (kill_rc == ESRCH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试*/</span></span><br><span class="line"><span class="comment">/*线程池中的线程，模拟处理业务*/</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">process</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x working on task %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">pthread_self</span>(), *(<span class="type">int</span>*)arg);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task %d is end\n&quot;</span>, *(<span class="type">int</span>*)arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">threadpool_t</span>* thp = <span class="built_in">threadpool_create</span>(<span class="number">3</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">/*创建线程池，池里最小3个线程，最大100，队列100*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pool inited&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num[<span class="number">20</span>], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        num[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">threadpool_add</span>(thp, process, (<span class="type">void</span>*)&amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>与TCP相比，TCP为流式协议，UDP为报式协议</p>
<p><strong>TCP：优势:1.数据稳定(丢包回传) 2.流率稳定 3.流量稳定(滑动窗口)</strong></p>
<p>​	   	<strong>劣势 效率低，速度慢</strong></p>
<p><strong>UDP： 优势 效率高，速度快</strong></p>
<p>​			<strong>劣势 数据，流率，流量不稳定</strong></p>
<p>UDP为了防止丢包，可以通过改变缓冲区大小，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span>* optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">220</span>x1024		<span class="comment">/*推荐值,通过经验得出的, 可以根据自己的需求更改*/</span></span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;N, <span class="built_in">sizeof</span>(n));</span><br></pre></td></tr></table></figure>



<h3 id="UDP-C-x2F-S模型"><a href="#UDP-C-x2F-S模型" class="headerlink" title="UDP C&#x2F;S模型"></a>UDP C&#x2F;S模型</h3><p>和TCP的区别，不需要accpet和客户端连接了，直接读就行了，所以也可以引出另一个特点，UDP通信自带多线程&#x2F;多进程了，不需要向TCP那样必须使用多进程&#x2F;多线程才能完成与多个客户端的通信</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clie_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clie_addr_len = <span class="built_in">sizeof</span>(clie_addr);</span><br><span class="line">        n = <span class="built_in">recvfrom</span>(sockfd, buf, BUFSIZ, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clie_addr, &amp;clie_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Recvfrom error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;clie_addr.sin_addr, str, <span class="built_in">sizeof</span>(str)),</span><br><span class="line">                <span class="built_in">ntohs</span>(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">sendto</span>(sockfd, buf, n, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clie_addr, <span class="built_in">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">int</span> sockfd, n;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, BUFSIZ, stdin) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        n = <span class="built_in">sendto</span>(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">recvfrom</span>(sockfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>通过特殊的IP地址 当前网段.255(xxx.xxx.xxx.255)，同时需要借助setsockopt函数更改socket的选项(允许发送广播数据报)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BROADCAST_IP <span class="string">&quot;172.23.175.255&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clie_addr;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造UDP通信的套接字*/</span></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*构造 client 地址 IP+端口 172.23.175.255+9000*/</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;clie_addr, <span class="built_in">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, BROADCAST_IP, &amp;clie_addr.sin_addr.s_addr);</span><br><span class="line">    clie_addr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Drink %d glasses of water\n&quot;</span>, i++);</span><br><span class="line">        <span class="built_in">sendto</span>(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;clie_addr, <span class="built_in">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> localaddr;</span><br><span class="line">    <span class="type">int</span> confd;</span><br><span class="line">    <span class="type">ssize_t</span> len;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    confd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;localaddr, <span class="built_in">sizeof</span>(localaddr));</span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">    localaddr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(confd, (<span class="keyword">struct</span> sockaddr*)&amp;localaddr, <span class="built_in">sizeof</span>(localaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;...bind ok...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="built_in">recvfrom</span>(confd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(confd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<ol>
<li>224.0.0.0～224.0.0.255   为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</li>
<li>224.0.1.0～224.0.1.255   是公用组播地址，可以用于Internet；欲使用需申请。</li>
<li>224.0.2.0～238.255.255.255 为用户可用的组播地址（临时组地址），全网范围内有效；</li>
<li>239.0.0.0～239.255.255.255 为本地管理组播地址，仅在特定的本地范围内有效。</li>
</ol>
<p>使用ip ad命令查看网卡编号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.例子</span></span><br><span class="line">itcast$ ip ad</span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group <span class="keyword">default</span> </span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">2</span>: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="number">1500</span> qdisc pfifo_fast state DOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:<span class="number">0</span>a:c4:f4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet6 fe80::<span class="number">20</span>c:<span class="number">29f</span>f:fe0a:c4f4/<span class="number">64</span> scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment">//2.实际</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">2</span>: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu <span class="number">1500</span> qdisc noop state DOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">1</span>a:fc:<span class="number">2</span>a:<span class="number">2</span>e:<span class="number">5</span>a:<span class="number">28</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line"><span class="number">3</span>: dummy0: &lt;BROADCAST,NOARP&gt; mtu <span class="number">1500</span> qdisc noop state DOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ether ca:<span class="number">9</span>d:<span class="number">9f</span>:<span class="number">9b</span>:<span class="number">96</span>:<span class="number">7f</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line"><span class="number">4</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc mq state UP group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">00</span>:<span class="number">15</span>:<span class="number">5</span>d:<span class="number">6</span>e:db:<span class="number">0</span>c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">172.23</span><span class="number">.164</span><span class="number">.160</span>/<span class="number">20</span> brd <span class="number">172.23</span><span class="number">.175</span><span class="number">.255</span> scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">215</span>:<span class="number">5</span>dff:fe6e:db0c/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">5</span>: tunl0@NONE: &lt;NOARP&gt; mtu <span class="number">1480</span> qdisc noop state DOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/ipip <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> brd <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="number">6</span>: sit0@NONE: &lt;NOARP&gt; mtu <span class="number">1480</span> qdisc noop state DOWN group <span class="keyword">default</span> qlen <span class="number">1000</span></span><br><span class="line">    link/sit <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> brd <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>代码部分和广播有点像，但有一点区别，首先同样也得开发组播权限通过setsockopt ，其次服务器端和客户端有一定区别，服务器端是向某组播地址广播，客户端是加入某组播地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP <span class="string">&quot;239.0.0.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clie_addr;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE] = <span class="string">&quot;itcast\n&quot;</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreqn</span> group;</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, GROUP, &amp;group.imr_multiaddr);            <span class="comment">// 设置组地址</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);          <span class="comment">// 本地任意IP</span></span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">&quot;eth0&quot;</span>);                 <span class="comment">// 网卡编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setsockopt</span>(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="built_in">sizeof</span>(group));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;clie_addr, <span class="built_in">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, GROUP, &amp;clie_addr.sin_addr.s_addr);</span><br><span class="line">    clie_addr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;itcast %d\n&quot;</span>, i++);</span><br><span class="line">        <span class="built_in">sendto</span>(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span> ,(<span class="keyword">struct</span> sockaddr*)&amp;clie_addr, <span class="built_in">sizeof</span>(clie_addr));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP <span class="string">&quot;239.0.0.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> localaddr;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">ssize_t</span> len;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreqn</span> group;</span><br><span class="line"></span><br><span class="line">    connfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;localaddr, <span class="built_in">sizeof</span>(localaddr));</span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">    localaddr.sin_port = <span class="built_in">htons</span>(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(connfd, (<span class="keyword">struct</span> sockaddr*)&amp;localaddr, <span class="built_in">sizeof</span>(localaddr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;group.imr_address);</span><br><span class="line">    group.imr_ifindex = if_nametoindex(<span class="string">&quot;eth0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setsockopt</span>(connfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="built_in">sizeof</span>(group));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        len = <span class="built_in">recvfrom</span>(connfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h3><p>总结目前用过的该函数的功能</p>
<ol>
<li>端口复用</li>
<li>设置缓冲区大小(udp开头)</li>
<li>开放广播权限</li>
<li>开放组播权限</li>
<li>加入组播组</li>
</ol>
<h2 id="UNP书籍部分笔记"><a href="#UNP书籍部分笔记" class="headerlink" title="UNP书籍部分笔记"></a>UNP书籍部分笔记</h2><h3 id="第1章-简介和TCP-x2F-IP"><a href="#第1章-简介和TCP-x2F-IP" class="headerlink" title="第1章 简介和TCP&#x2F;IP"></a>第1章 简介和TCP&#x2F;IP</h3><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/./../pic/image-20230307151029244.png" alt="image-20230307151029244"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图1.5 client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LISTENQ		1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					sockfd, n, counter = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span>				recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	servaddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;usage: a.out &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( (sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port   = <span class="built_in">htons</span>(<span class="number">6666</span>);	<span class="comment">/* daytime server */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;inet_pton error for&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ( (n = <span class="built_in">read</span>(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">		recvline[n] = <span class="number">0</span>;	<span class="comment">/* null terminate */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fputs</span>(recvline, stdout) == EOF)</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;fputs error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter=%d\n&quot;</span>, counter);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图1.9 server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LISTENQ		1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					listenfd, connfd, i;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	servaddr;</span><br><span class="line">	<span class="type">char</span>				buff[MAXLINE];</span><br><span class="line">	<span class="type">time_t</span>				ticks;</span><br><span class="line"></span><br><span class="line">	listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family      = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port        = <span class="built_in">htons</span>(<span class="number">6666</span>);	<span class="comment">/* daytime server */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaadr*) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">listen</span>(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buff, <span class="built_in">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, <span class="built_in">ctime</span>(&amp;ticks));</span><br><span class="line">        <span class="comment">// write(connfd, buff, strlen(buff));</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(buff); i++)</span><br><span class="line">            <span class="built_in">write</span>(connfd, &amp;buff[i], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">close</span>(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尽管服务器端，write时分开26次write，但客户端counter仍然只会累计一次，其结果随客户主机和服务器主机而定。如果客户端和服务器运行在同一台主机上，就如同上述情况(7.9节，就Nagle算法讨论解释如此行为的原因)</p>
<h3 id="第2章-传输层TCP-x2F-UDP"><a href="#第2章-传输层TCP-x2F-UDP" class="headerlink" title="第2章 传输层TCP&#x2F;UDP"></a>第2章 传输层TCP&#x2F;UDP</h3><p>重点为分层模型，三次握手和四次握手，以及TCP状态转换，TCP&#x2F;UDP协议格式，TIME_WAIT状态</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><img src="/./../pic/image-20230307160041739.png" alt="image-20230307160041739"></p>
<h3 id="第3章-套接口简介"><a href="#第3章-套接口简介" class="headerlink" title="第3章 套接口简介"></a>第3章 套接口简介</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>本章主要内容，套接口结构，主要分为IPV4和IPV6两种格式，以及主机字节序到网络字节序的一系列函数，开发了更好的字节操纵函数，以及与协议无关的一套套接口函数</p>
<h4 id="3-2-套接口结构-sockaadr-in-sockaddr"><a href="#3-2-套接口结构-sockaadr-in-sockaddr" class="headerlink" title="3.2 套接口结构(sockaadr_in,sockaddr)"></a>3.2 套接口结构(sockaadr_in,sockaddr)</h4><p><strong>IPV4套接口地址结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它以sockaddr_in命名，定义在头文件&lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> 	s_addr;			<span class="comment">/* 32-bit IPV4 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>		sin_len;		<span class="comment">/* length of structure (16) */</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;		<span class="comment">/* AF_INET	*/</span></span><br><span class="line">    <span class="type">in_port_t</span> 	sin_port;		<span class="comment">/* 16-bit TCP or UDP port number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	<span class="title">sin_addr</span>;</span>	<span class="comment">/* 32-bit IPV4 address */</span></span><br><span class="line">    <span class="type">char</span> 		sin_zero[<span class="number">8</span>];	<span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sin_addr成员由于历史原因是一个结构，早期定义为不同结构的联合。</p>
<p><strong>POSIX规范要求的数据类型</strong></p>
<p><img src="/./../pic/image-20230308201525275.png" alt="image-20230308201525275"></p>
<p><strong>通用套接口地址结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> 	sa_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;		<span class="comment">/* address family: AF_XXX value */</span></span><br><span class="line">    <span class="type">char</span> 		sa_data[<span class="number">14</span>];	<span class="comment">/* protocol-specific address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>套接口函数被定义为采用指向通用套接口地址结构的指针，如bind函数的原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span>, <span class="keyword">struct</span> sockaddr*, <span class="type">socklen_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其实可以更好的采用void<em>来实现，最终为sockaddr</em>同样因为历史原因，套接口函数的定义早于void*</p>
<p><strong>IPV6套接口地址结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> 	s6_addr[<span class="number">16</span>];	<span class="comment">/* 128-bit IPV6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIN6_LEN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_int6</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> 	sin6_len;		<span class="comment">/* length of thie struct (28) */</span></span><br><span class="line">    <span class="type">uint8_t</span> 	sin6_family;	<span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin6_port;		<span class="comment">/* transport layer port */</span></span><br><span class="line">    <span class="type">uint32_t</span> 	sin6_flowinfo;	<span class="comment">/* flow information undefined */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>	<span class="title">sin6_addr</span>;</span> 	<span class="comment">/* IPV6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span> 	sin6_scope_id;	<span class="comment">/* set of interfaces for a scope */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体成员说面，见书</p>
<p><strong>新的通用套接口地址结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> 	ss_len;</span><br><span class="line">    	<span class="comment">/* length of this struct */</span></span><br><span class="line">    <span class="type">sa_family_t</span>	ss_family;</span><br><span class="line">    	<span class="comment">/* address family: AF_XXX value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与原先的通用结构的差别:</p>
<ol>
<li>如果系统支持的任何套接口地址结构又对齐需求，那么sockaddr_storage能够满足最苛刻的对齐要求</li>
<li>sockaddr_storage足够大，能够容纳系统支持的任何套接口地址结构</li>
</ol>
<p><strong>套接口地址结构的比较</strong></p>
<p>看图即可</p>
<p><img src="/./../pic/image-20230308203012731.png" alt="image-20230308203012731"></p>
<h4 id="3-3-值结果参数"><a href="#3-3-值结果参数" class="headerlink" title="3.3 值结果参数"></a>3.3 值结果参数</h4><p>简单来说，函数的定义传进时作为值，给函数提供条件，结束时将结果返回给这个参数，所以这个参数可以是指针类型，能够将函数内改动的结果带出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cil</span>;</span>		<span class="comment">/* unix domain */</span></span><br><span class="line"><span class="type">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cil);</span><br><span class="line">getpeername(unixfd, (sturct sockaddr*)&amp;cil, &amp;len);</span><br><span class="line"><span class="comment">//后参数类型: 套接口地址结构指针和表示结构大小的整数的指针</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230308203414732.png" alt="image-20230308203414732"></p>
<h4 id="3-4-字节排序函数-htons-htonl-ntohs-ntols"><a href="#3-4-字节排序函数-htons-htonl-ntohs-ntols" class="headerlink" title="3.4 字节排序函数(htons,htonl,ntohs,ntols)"></a>3.4 字节排序函数(htons,htonl,ntohs,ntols)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检验主机字节序的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_big_or_little_endian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">        <span class="type">char</span> c[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; fn;</span><br><span class="line">    fn.s = <span class="number">0x0102</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">short</span> == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; fn.c[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fn.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; fn.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这两种字节序没有标准，且都有系统使用，而网络协议在处理这些多字节整数时，使用大端字节序，所以需要一系列转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span>;</span><br><span class="line">	<span class="comment">//均返回:网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> net16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> net32bitvalue)</span>;</span><br><span class="line">	<span class="comment">//均返回:主机字节序</span></span><br></pre></td></tr></table></figure>

<p>h代表host，n代表network，s代表short，l代表long，s的两个函数可看作用于端口转换的，l的两个函数为IP地址</p>
<h4 id="3-5-字节操纵函数-bzero-memset…"><a href="#3-5-字节操纵函数-bzero-memset…" class="headerlink" title="3.5 字节操纵函数(bzero,memset….)"></a>3.5 字节操纵函数(bzero,memset….)</h4><p>就memset和bzero那一系列，主要用到的就bzero，其他用到的时候再看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span>* dest, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bcopy</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* src, <span class="type">void</span>* dest, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, cosnt <span class="type">void</span>* ptr2, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line">	<span class="comment">//返回:0--相等， 非0--不相等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dest, <span class="type">int</span> c, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> nbytest)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, <span class="type">const</span> <span class="type">void</span>* ptr2, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line">	<span class="comment">//返回:0--相等， &gt;0 or &lt;0 -- 不相等</span></span><br></pre></td></tr></table></figure>



<h4 id="3-6-inet-aton-inet-addr-inet-ntoa函数"><a href="#3-6-inet-aton-inet-addr-inet-ntoa函数" class="headerlink" title="3.6 inet_aton, inet_addr, inet_ntoa函数"></a>3.6 inet_aton, inet_addr, inet_ntoa函数</h4><ol>
<li>inet_aton，inet_addr，inet_ntoa在点分十进制数串(如:”206.168.112.96”)与它的网络字节序二进制值间转换IPV4地址</li>
<li>两个较新的函数:inet_pton和inet_ntop对IPV4和IPV6都能处理</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr, <span class="keyword">struct</span> in_addr* addrptr)</span>;</span><br><span class="line">	<span class="comment">//返回:1--串有效， 0--串有错</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr)</span>;</span><br><span class="line">	<span class="comment">//若成功，返回32位二进制的网络字节序地址；若有错，返回INADDR_NONE</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr inaddr)</span>;</span><br><span class="line">	<span class="comment">//返回指向点分十进制数串的指针</span></span><br></pre></td></tr></table></figure>

<p>inet_addr可能出现的一个问题，出错时返回的INADDR_NONE 其值为一个32位均为1的值，也就意味着255.255.255.255不能由该函数处理，它的二进制值与INADDR_NONE一样</p>
<h4 id="3-7-inet-pton和inet-ntop函数"><a href="#3-7-inet-pton和inet-ntop函数" class="headerlink" title="3.7 inet_pton和inet_ntop函数"></a>3.7 inet_pton和inet_ntop函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span>* strptr, <span class="type">void</span>* addrptr)</span></span>;</span><br><span class="line">	<span class="comment">//返回: 1 -- 成功， 0 -- 输入的不是有效的表达式， -1 -- 出错</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span>* addrptr, <span class="type">char</span>* strptr, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">	<span class="comment">//返回: 指向结果的指针 -- 成功， NULL -- 出错</span></span><br></pre></td></tr></table></figure>

<p>两函数均以参数作为结果的返回值，pton以addrptr为转换后的结果，ntop以strptr为储存的结果，所以strptr不能时空指针，len的大小，为有助于规定这个大小，在**&lt;netinet&#x2F;in.h&gt;**中有如下定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16 		<span class="comment">/* for IPV4 dotted-decimal */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46 	<span class="comment">/* for IPV6 hex string */</span></span></span><br></pre></td></tr></table></figure>



<p><strong>所有转换函数图示一览</strong></p>
<p><img src="/./../pic/image-20230308210046191.png" alt="image-20230308210046191"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, cp, &amp;foo.sin_addr);</span><br><span class="line"><span class="comment">//替代</span></span><br><span class="line">foo.sin.addr_s_addr = <span class="built_in">inet_addr</span>(cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">ptr = <span class="built_in">inet_ntop</span>(AF_INET, &amp;foo.sin_addr, str, <span class="built_in">sizeof</span>(str));</span><br><span class="line"><span class="comment">//替代</span></span><br><span class="line">ptr = <span class="built_in">inet_ntoa</span>(foo.sin_addr);</span><br></pre></td></tr></table></figure>



<h4 id="3-8-sock-ntop和相关函数"><a href="#3-8-sock-ntop和相关函数" class="headerlink" title="3.8 sock_ntop和相关函数"></a>3.8 sock_ntop和相关函数</h4><p>对于一般的ntop和pton函数来说，我们必须知道结构的地址族，sock_ntop及其他一系列函数，则将这种情况避免，实现协议无关的套接字函数，如下为其一的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">sock_ntop</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen)</span></span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//简略实现，仅考虑AF_INET的情况</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">sock_ntop</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sa, <span class="type">socklen_t</span> salen)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> 		portstr[<span class="number">8</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (sa-&gt;sa_family) &#123;</span><br><span class="line">        <span class="keyword">case</span> AF_INET: &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>*		sin = (<span class="keyword">struct</span> sockaddr_in*)sa;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inet_ntop</span>(AF_INET, &amp;sin-&gt;sin_addr, str, <span class="built_in">sizeof</span>(str) <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ntohs</span>(sin-&gt;sinport) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(portstr, <span class="built_in">sizeof</span>(portstr), <span class="string">&quot;:%d&quot;</span>, <span class="built_in">ntohs</span>(sin-&gt;sin_port));</span><br><span class="line">                <span class="built_in">strcat</span>(str, portstr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> (str); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它的</p>
<p><img src="/./../pic/image-20230308211531794.png" alt="image-20230308211531794"></p>
<h4 id="3-9-readn-writen-和-readline函数"><a href="#3-9-readn-writen-和-readline函数" class="headerlink" title="3.9 readn, writen 和 readline函数"></a>3.9 readn, writen 和 readline函数</h4><p>同样是本书开发的一系列函数，简单来说就是，不回出现read或write由于某些影响没有执行完的情况，这些函数遇到这种情况后，会再次调用，也就是不需要使用者操心这些没有执行完的情况了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readn</span><span class="params">(<span class="type">int</span> filedes, <span class="type">void</span>* buff, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="type">void</span>* buff, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readline</span><span class="params">(<span class="type">int</span> filedes, <span class="type">void</span>* buff, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line">	<span class="comment">//均返回:读写字节数, -1出错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readn实现</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* vptr, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> 	nleft;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* 	ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = <span class="built_in">read</span>(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>;			<span class="comment">/* and call read() again */</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n-nleft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writen实现</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* vptr, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> 	nleft;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>;		<span class="comment">/* and call write() again */</span></span><br><span class="line">            <span class="keyword">else</span> 	</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        ptr += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//readline</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* vptr, <span class="type">size_t</span> maxlen)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> 	n, rc;</span><br><span class="line">    <span class="type">char</span> c, *ptr;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        again: </span><br><span class="line">        <span class="keyword">if</span> ((rc = read(fd, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *ptr+</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-10-小结"><a href="#3-10-小结" class="headerlink" title="3.10 小结"></a>3.10 小结</h4><p><img src="/./../pic/image-20230308212753534.png" alt="image-20230308212753534"></p>
<p><strong>疑:</strong></p>
<ol>
<li>为什么诸如套接口地址结构的长度这样的值-结果参数要用指针来传递?</li>
<li>为什么函数readn和writen都将void<em>型指针转换为char</em>型指针</li>
</ol>
<p>1：只有这样才能将改变后的值传出函数</p>
<p>2：指针增长需按所读或所写的字节增长，void由于不知道所指类型，不知道如何增长</p>
<h3 id="第4章-基本TCP套接口"><a href="#第4章-基本TCP套接口" class="headerlink" title="第4章 基本TCP套接口"></a>第4章 基本TCP套接口</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>基本的接口，socket，bind，connect，listen，accept</p>
<h4 id="4-2-socket函数"><a href="#4-2-socket函数" class="headerlink" title="4.2 socket函数"></a>4.2 socket函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">	<span class="comment">//非负描述字 -- 成功， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p><strong>family(图4.2)</strong></p>
<p><img src="/./../pic/image-20230316103135642.png" alt="image-20230316103135642"></p>
<p><strong>type(图4.3)</strong></p>
<p><img src="/./../pic/image-20230316103158285.png" alt="image-20230316103158285"></p>
<p><strong>protocol(图4.4)</strong></p>
<p><img src="/./../pic/image-20230316103216478.png" alt="image-20230316103216478"></p>
<p>通常来说，family为AF_INET或AF_INET6，type根据TCP还是UDP分别设置为SOCK_STREAM或SOCK_DGRAM，protocol设置为0，选择缺省值</p>
<h4 id="4-3-connect函数"><a href="#4-3-connect函数" class="headerlink" title="4.3 connect函数"></a>4.3 connect函数</h4><p>TCP客户用connect函数来建立与TCP服务器的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* servaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	<span class="comment">//返回0 -- 成功 , -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>sockfd是由socket函数返回的套接口描述字，第二第三参数分别是一个指向套接口地址的结构的指针和该结构的大小。客户在调用函数connect前不必非得调用bind函数，需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。如果是TCP套接口，调用connect函数将激发TCP的三路握手过程(2.6)，并且仅在连接建立成功或出错时菜返回</p>
<h4 id="4-4-bind函数"><a href="#4-4-bind函数" class="headerlink" title="4.4 bind函数"></a>4.4 bind函数</h4><p>bind函数把一个本地协议地址赋予一个套接口，对于网际协议，协议地址是32位的IPV4地址或128位的IPV6地址与16位的TCP或UDP端口号的组合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* myaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 , -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>指定端口号为0，或指定地址值为INADDR_ANY则由内核选择端口号或指定IP地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//to IPV4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//to IPV6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure>

<p>如果让内核来选择临时值，由于第二参数有const修饰，它无法返回所选之值。为了得到内核所选择的这个临时端口值，必须调用函数 <strong>getsockname</strong> 来返回协议地址</p>
<h4 id="4-5-listen函数"><a href="#4-5-listen函数" class="headerlink" title="4.5 listen函数"></a>4.5 listen函数</h4><p>listen函数仅由TCP服务器调用，它做两件事</p>
<ol>
<li>当socket函数创建一个套接口时，它被假设为一个主动套接口，也就是说，他是一个将调用connect发起连接的客户套接口。listen函数把一个未连接的套接口，转换成一个被动套接口。由TCP状态转换图，调用listen导致套接口从CLOSED状态转换到LISTEN状态</li>
<li>该函数的第二个参数规定了内核应该为相应套接口排队的最大连接个数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>



<h4 id="4-6-accept函数"><a href="#4-6-accept函数" class="headerlink" title="4.6 accept函数"></a>4.6 accept函数</h4><p>accpet函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* cliaddr, <span class="type">soclen_t</span>* addrlen)</span>;</span><br><span class="line">	<span class="comment">//非负描述字 -- 成功 ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>参数cliaddr，addrlen用来返回对端进程的协议地址，如果不需要这两个参数，可以置为NULL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用例</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection from %s. port %d\n&quot;</span>,</span><br><span class="line">          <span class="built_in">Inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr, buff, <span class="built_in">sizeof</span>(buff)),</span><br><span class="line">          <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-fork和exec函数"><a href="#4-7-fork和exec函数" class="headerlink" title="4.7 fork和exec函数"></a>4.7 fork和exec函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">	<span class="comment">//子进程中返回0 ， 父进程中返回子进程ID ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>详细的参考APUE note</p>
<p><img src="/./../pic/image-20230316110717151.png" alt="image-20230316110717151"></p>
<p>进程在调用exec之前打开着的描述字通常跨exec继续保持打开，但可以通过fcntl设置FD_CLOEXEC描述字标志禁止掉</p>
<h4 id="4-8-并发服务器"><a href="#4-8-并发服务器" class="headerlink" title="4.8 并发服务器"></a>4.8 并发服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的轮廓</span></span><br><span class="line"><span class="type">pid_t</span>		pid;</span><br><span class="line"><span class="type">int</span> 		listenfd, connfd;</span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">	<span class="comment">/*fill in sockaddr_in &#123;&#125; with server&#x27;s well-known port */</span></span><br><span class="line">Bind(listenfd, ...);</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    connfd = Accept(listenfd, ...);	</span><br><span class="line">    <span class="comment">/* probably blocks */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Close(listenfd);			<span class="comment">/* child close listening socket */</span></span><br><span class="line">        doit(connfd);				<span class="comment">/* process the requet */</span></span><br><span class="line">        Close(connfd);				<span class="comment">/*done with this client */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);					<span class="comment">/* child terminates */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);					<span class="comment">/* parent closes connected socket */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么close两次，因为每个文件或套接口都有一次引用计数，而fork返回后，描述字在父子进程间共享，因此着两个套接口的计数为2</p>
<h4 id="4-9-close函数"><a href="#4-9-close函数" class="headerlink" title="4.9 close函数"></a>4.9 close函数</h4><p>Unix通常的close函数也用来关闭套接口，并终止TCP连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>close实际上是引用计数减一并不会发送FIN，只有在计数为0后，才能达到我们想要的效果，如果想在某个TCP连接发送一个FIN，可以改用shutdown函数(6.6)</p>
<h4 id="4-10-getsockname和getpeername函数"><a href="#4-10-getsockname和getpeername函数" class="headerlink" title="4.10 getsockname和getpeername函数"></a>4.10 getsockname和getpeername函数</h4><p>这两个函数返回与某个套接口关联的本体协议地址，或者返回与某个套接口关联的远地协议地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* localaddr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* peeraddr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230316112355057.png" alt="image-20230316112355057"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockfd_to_family</span><span class="params">(<span class="type">int</span> sockfd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line">    </span><br><span class="line">    len = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">    <span class="keyword">if</span> (getsockname(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;ss, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (ss.ss_family);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11 小结"></a>4.11 小结</h4><p>所有客户和服务器都从调用socket开始，它返回一个套接字描述字。客户随后调用connect，服务器则调用bind，listen和accept 。套接口通常使用标准close函数关闭，不过将看到使用shutdown函数关闭套接口的另一种方法(6.6)，还将查看SO_LINGER套接口选项对于关闭套接口的效果</p>
<p><strong>疑:</strong></p>
<p>1.图4.11中，如果把服务器程序中的listen调用函数，会发生什么。</p>
<p>accept返回EINVAL，因为它的第1个参数不是一个监听套接口描述字</p>
<h3 id="第5章-TCP客户-x2F-服务器程序例子"><a href="#第5章-TCP客户-x2F-服务器程序例子" class="headerlink" title="第5章 TCP客户&#x2F;服务器程序例子"></a>第5章 TCP客户&#x2F;服务器程序例子</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p>一个简单的cs模型的回射服务器</p>
<h4 id="5-2-TCP回射服务器"><a href="#5-2-TCP回射服务器" class="headerlink" title="5.2 TCP回射服务器"></a>5.2 TCP回射服务器</h4><h4 id="5-3-TCP回射服务器"><a href="#5-3-TCP回射服务器" class="headerlink" title="5.3 TCP回射服务器"></a>5.3 TCP回射服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span>         listenfd, connfd;</span><br><span class="line">    <span class="type">pid_t</span>       childpid;</span><br><span class="line">    <span class="type">socklen_t</span>   clilen;</span><br><span class="line">    <span class="type">char</span> clie_IP[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ready for accept\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;Connect success from IP: %s , PORT: %d\n&quot;, </span></span><br><span class="line">        <span class="comment">//         inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,cli_ip, sizeof(cli_ip)), </span></span><br><span class="line">        <span class="comment">//         ntohs(cliaddr.sin_port));</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect success form,client IP:**, client port:%d\n&quot;</span>, </span><br><span class="line">                <span class="comment">// inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,clie_IP, sizeof(clie_IP)), </span></span><br><span class="line">                ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            close(listenfd);</span><br><span class="line">            str_echo(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> connfd)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span>     n;</span><br><span class="line">    <span class="type">char</span>        buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">while</span> ((n = read(connfd, buf, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(connfd, buf, n);</span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;str_echo: read error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-TCP回射客户端"><a href="#5-4-TCP回射客户端" class="headerlink" title="5.4 TCP回射客户端"></a>5.4 TCP回射客户端</h4><h4 id="5-5-TCP回射客户端"><a href="#5-5-TCP回射客户端" class="headerlink" title="5.5 TCP回射客户端"></a>5.5 TCP回射客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>         sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, SERV_IP, &amp;servaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    str_cli(<span class="built_in">stdin</span>, sockfd);</span><br><span class="line">    <span class="comment">// read(sockfd, buf, sizeof(buf));</span></span><br><span class="line">    <span class="comment">// int n = write(sockfd, buf, sizeof(buf));</span></span><br><span class="line">    <span class="comment">// fputs(buf, stdout);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd)</span> &#123;</span><br><span class="line">    <span class="type">char</span>        sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">    <span class="type">int</span>         n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((n = read(sockfd, recvline, MAXLINE) )== <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        write(STDOUT_FILENO, recvline, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-正常启动"><a href="#5-6-正常启动" class="headerlink" title="5.6 正常启动"></a>5.6 正常启动</h4><h4 id="5-7-正常终止"><a href="#5-7-正常终止" class="headerlink" title="5.7 正常终止"></a>5.7 正常终止</h4><h4 id="5-8-POSIX信号处理"><a href="#5-8-POSIX信号处理" class="headerlink" title="5.8 POSIX信号处理"></a>5.8 POSIX信号处理</h4><p>信号部分包括后面的wait处理子进程，AUPE有详细的描述，这边简单描述一下</p>
<h4 id="5-9-SIGCHLD"><a href="#5-9-SIGCHLD" class="headerlink" title="5.9 SIGCHLD"></a>5.9 SIGCHLD</h4><p>子进程终止时，将SIGCHLD信号发送给父进程，此时可以调用wait &#x2F; waitpid 清理僵尸进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> 	pid;</span><br><span class="line">    <span class="type">int</span> 	stat;</span><br><span class="line">    </span><br><span class="line">    pid = wait(&amp;stat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;			<span class="comment">//在信号处理函数中显式的给出return语句</span></span><br><span class="line">    				<span class="comment">//当某个系统调用被我们编写的信号处理函数中断时，可以得到被哪个信号处理函数终端的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-10-wait和waitpid函数"><a href="#5-10-wait和waitpid函数" class="headerlink" title="5.10 wait和waitpid函数"></a>5.10 wait和waitpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* statloc)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options)</span>;</span><br><span class="line">	<span class="comment">//返回: 进程ID -- 成功 ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>详细的区别见AUPE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述处理函数用wait，在并发多个子进程的时候，由于信号只会处理一次，后续无论排队多少个信号，仍然只会处理一次，所以需要循环wait</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> 	pid;</span><br><span class="line">    <span class="type">int</span> 	stat;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WNOHANG设置为非阻塞，它告知waitpid在有尚未终止子进程在运行时不要阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 				listenfd, connfd;</span><br><span class="line">    <span class="type">pid_t</span> 				childpid;</span><br><span class="line">    <span class="type">socklen_t</span>			clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servadd.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    </span><br><span class="line">    Bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    Listen(listenfd, LISTENQ);</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sig_chld);				<span class="comment">/* must call waitpid */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (strucr sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;					<span class="comment">/* back to for */</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                err_sys(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((childpid = Fork()) == <span class="number">0</span>) &#123;		<span class="comment">/* child process */</span></span><br><span class="line">            Close(listenfd);				<span class="comment">/* close listening socket */</span></span><br><span class="line">            str_echo(connfd);				<span class="comment">/* process the request */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        close(connfd);						<span class="comment">/* parent close connected socket */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节示范的三个目的:</p>
<p>1.当fork子进程时，必须捕获SIGCHLD信号</p>
<p>2.当捕获信号时，必须处理被中断的系统调用，如父进程的ACCEPT可能被 SIGCHLD的处理函数中断，所以需要放在循环内</p>
<p>3.SIGCHLD处理函数的正确编写，使用waitpid循环处理</p>
<h4 id="5-11-accept返回前连接夭折"><a href="#5-11-accept返回前连接夭折" class="headerlink" title="5.11 accept返回前连接夭折"></a>5.11 accept返回前连接夭折</h4><p><img src="/./../pic/image-20230319195602639.png" alt="image-20230319195602639"></p>
<p>如何模拟改方法，TCP三路握手完成后，客户却发送一个RST（复位）</p>
<p><strong>启动服务器，让它调用socket,bind和listen, 在调用accept之前睡眠一小段时间。在服务器进程睡眠时, 启动客户，让它调用socket和connect。一旦connect返回，就设置SO_LINGER套接口选项以产生一个RST</strong></p>
<h4 id="5-12-服务器进程终止"><a href="#5-12-服务器进程终止" class="headerlink" title="5.12 服务器进程终止"></a>5.12 服务器进程终止</h4><p><img src="/./../pic/image-20230319200205488.png" alt="image-20230319200205488"></p>
<p>当我们杀死服务器子进程时，SIGCHLD信号被发送给服务器父进程，然后得到处理。<strong>客户上没有发生任何特殊之事。客户TCP接受来自服务器TCP的FIN并响应以一个ACK，然而问题是客户进程阻塞在fgets调用上，等待终端接收一行文本</strong> , 此时netstat -a 查看套接口状态</p>
<p><img src="/./../pic/image-20230319200436697.png" alt="image-20230319200436697"></p>
<p>当我们键入 <strong>another line</strong> 时，客户TCP把数据发送给服务器。TCP允许这么做，客户TCP收到FIN只是表示服务器进程已关闭了连接的服务器端，从而不再往其中发送数据。FIN的接受没有告知客户TCP服务器进程已经终止(虽然本例中已经终止)。 <strong>当服务器TCP接受道来自客户的数据时，既然先前打开的哪个套接口的进程已经终止，于是响应一个RST</strong></p>
<p><strong>但是客户进程看不到这个RST，因为它在调用write(即向服务器写数据)， 后立即调用readline(即从服务器读数据), 并且由于第二步接收的FIN，所调用的readline立即返回0，于是以出错信息退出</strong></p>
<p><strong>本例的问题：</strong>当FIN到达套接口时，客户正阻塞在fgets调用上。客户实际有两个描述字——-套接口和用户输入，他不能单纯阻塞在这两个源中某个特定的输入上，而是 <strong>应该阻塞在其中任何一个源的输入上</strong>。后续select和poll两个函数的目的之一</p>
<h4 id="5-13-SIGPIPE信号"><a href="#5-13-SIGPIPE信号" class="headerlink" title="5.13 SIGPIPE信号"></a>5.13 SIGPIPE信号</h4><p>当一个进程向某个已收到RST的套接口执行写操作时，内核向该进程发送一个SIGPIPE信号。该信号缺省行为是终止进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//掩饰SIGPIPE信号会发生什么</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd)</span> &#123;</span><br><span class="line">    <span class="type">char</span> 		sendline[MAXLINE], recvline[MAXLIEN];</span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Writen(sockfd, sendline, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        Writen(sockfd, sendline+<span class="number">1</span> ,<span class="built_in">strlen</span>(sendline) <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Readlien(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">            err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230319201406431.png" alt="image-20230319201406431"></p>
<p>sleep(1)把一次数据，分两次写入，当服务器子进程被杀死后，bye的第一次写入，将b写入已经关闭的服务器，收到RST，sleep完后，再次写入，收到SIGPIPE信号</p>
<h4 id="5-14-服务器主机崩溃"><a href="#5-14-服务器主机崩溃" class="headerlink" title="5.14 服务器主机崩溃"></a>5.14 服务器主机崩溃</h4><p>查看主机崩溃时会发生什么，先启动服务器，再启动客户，接着键入一行文本以确认连接工作正常，然后从网络上断开服务器主机，并在客户上键入另一行文本。</p>
<p>当服务器主机崩溃时，网络连接发不出任何东西。这里假设是主机崩溃，而不是操作员执行关机。在客户上键入一行文本，由writen写入内核，再由客户TCP作为一个数据分节送出，随后阻塞与readline等待回射应答。 <strong>如果用tcpdump观察网络会发现，客户TCP持续重传数据分节，试图从服务器上接收一个ACK。 TCPV2的25.11节，给出TCP重传一个典型模式:源自Berkeley的实现重传数据分节12次，共等待9分钟才放弃重传</strong></p>
<p>为了更快的检测这种情况，可以对readline调用设置一个超时，14.2节将讨论这一点。</p>
<p>我们刚才讨论的情况只有在向服务器发送数据时，才能检测出他已经崩溃。如果想不主动发送数据也能检测服务器主机崩溃，需要采用另一个技术， <strong>7.5讨论的SO_KEEPALIVE套接口选项</strong></p>
<h4 id="5-15-服务器主机崩溃后重启"><a href="#5-15-服务器主机崩溃后重启" class="headerlink" title="5.15 服务器主机崩溃后重启"></a>5.15 服务器主机崩溃后重启</h4><p>我们启动服务器和客户，并在客户键入一行文本确认连接已经建立。</p>
<p>服务器主机崩溃并重启</p>
<p>在客户上键入一行文本，它将作为一个TCP数据分节发送到服务器主机</p>
<p>当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户的数据分节响应一个RST</p>
<p>当客户TCP收到RST时，客户正阻塞与readline调用，导致该调用返回ECONNRESET错误</p>
<h4 id="5-16-服务器主机关机"><a href="#5-16-服务器主机关机" class="headerlink" title="5.16 服务器主机关机"></a>5.16 服务器主机关机</h4><p>Unix系统关机时，init进程通常献给所有进程发送SIGTERM信号，再等待固定一段时间，然后给所有仍在运行的进程发送SIGKILL信号，这么做是留给所有运行的进程一小段时间来清除和终止。如果我们不捕获SIGTERM信号并终止，我们的服务器将由SIGKILL信号终止。 所以我们需要使用select或poll函数，使得服务器进程的终止一经发生，客户就马上检测到</p>
<h4 id="5-17-TCP程序例子小结"><a href="#5-17-TCP程序例子小结" class="headerlink" title="5.17 TCP程序例子小结"></a>5.17 TCP程序例子小结</h4><p><img src="/./../pic/image-20230319221641380.png" alt="image-20230319221641380"></p>
<p><img src="/./../pic/image-20230319221655492.png" alt="image-20230319221655492"></p>
<h4 id="5-18数据格式"><a href="#5-18数据格式" class="headerlink" title="5.18数据格式"></a>5.18数据格式</h4><p>一些常见的问题，如 <strong>不同主机字节序不同产生的影响</strong>， <strong>不同实现在存储相同的C数据类型上可能存在差异</strong> , <strong>不同的实现给结构打包的方式，可能由于内存对齐的限制，产生不同</strong> , 常用的解决办法:</p>
<ol>
<li>所有数值采用文本串来传递，图5.17的做法</li>
<li>显示定义所支持数据类型的二进制格式</li>
</ol>
<h4 id="5-19-小结"><a href="#5-19-小结" class="headerlink" title="5.19 小结"></a>5.19 小结</h4><p><img src="/./../pic/image-20230319201918209.png" alt="image-20230319201918209"></p>
<h3 id="第6章-I-x2F-O复用-select-和-poll函数"><a href="#第6章-I-x2F-O复用-select-和-poll函数" class="headerlink" title="第6章 I&#x2F;O复用:select 和 poll函数"></a>第6章 I&#x2F;O复用:select 和 poll函数</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p>这章主要用来解决5.12遇到的问题，客户阻塞在fgets上，而忽略了tcp套接口的输入</p>
<p>如果进程具有一种预先告知内核的1能力，使得内核一旦发现进程指定的一个或多个I&#x2F;O条件就绪，它就通知进程。这个能力称为I&#x2F;O复用，是由select和poll两个函数支持的</p>
<p>I&#x2F;O复用典型使用在下列网络应用场合:</p>
<ol>
<li>当客户处理多个描述字(如5.12的交互式输入和网络套接口)，必须使用I&#x2F;O复用</li>
<li>一个客户同时处理多个套接口是可能的，不过比较少见。见16.5节</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已经连接的套接口，参考后面的示例</li>
<li>如果一个服务器既要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用</li>
<li>如果一个服务器需要处理多个服务或多个协议</li>
</ol>
<h4 id="6-2-I-x2F-O模型"><a href="#6-2-I-x2F-O模型" class="headerlink" title="6.2 I&#x2F;O模型"></a>6.2 I&#x2F;O模型</h4><p><strong>Unix可用的I&#x2F;O模型有5种:</strong></p>
<ol>
<li>阻塞I&#x2F;O</li>
<li>非阻塞I&#x2F;O</li>
<li>I&#x2F;O复用(select 和 poll)</li>
<li>信号驱动I&#x2F;O(SIGIO)</li>
<li>异步I&#x2F;O(POSIX的aio_系列函数)</li>
</ol>
<p><strong>一个输入操作通常包括两个不同的阶段</strong></p>
<ol>
<li>等待数据准备好</li>
<li>从内核到进程拷贝数据</li>
</ol>
<p><strong>阻塞I&#x2F;O模型</strong></p>
<p>本书截至目前为止，所有的例子都为阻塞I&#x2F;O</p>
<p><img src="/./../pic/image-20230320223757124.png" alt="image-20230320223757124"></p>
<p><strong>非阻塞I&#x2F;O模型</strong></p>
<p>当所请求的I&#x2F;O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误，此处为EWOULDBLOCK </p>
<p><img src="/./../pic/image-20230320223934229.png" alt="image-20230320223934229"></p>
<p><strong>I&#x2F;O复用模型</strong></p>
<p>阻塞与select或poll这两个系统调用的某一个之上，而不是阻塞在真正的I&#x2F;O系统调用上</p>
<p><img src="/./../pic/image-20230320224023238.png" alt="image-20230320224023238"></p>
<p>目前看来I&#x2F;O复用没有什么优势，还多了一个系统调用，优势参考后面的详解</p>
<p><strong>信号驱动I&#x2F;O模型</strong></p>
<p>优势在于等待数据包到达期间，进程不被阻塞。主循环可用继续执行，只要不时等待来自信号处理函数的通知：既可以是已数据已被准备好被处理，也可以是数据报已准备好被读取</p>
<p><img src="/./../pic/image-20230320225255836.png" alt="image-20230320225255836"></p>
<p><strong>异步I&#x2F;O模型</strong></p>
<p>异步I&#x2F;O由POSIX规范定义。后来演变成当前POSIX规范的各种早期标准定义的实时函数中存在的差异已经取得一致。这些函数的工作机制是：告诉内核启动某个操作，并让内核在整个操作完成后通知我们。</p>
<p>和信号驱动I&#x2F;O的区别在于：后者是内核通知我们何时可用启动一个I&#x2F;O操作，而前者是通知我们何时完成</p>
<p><img src="/./../pic/image-20230320225554298.png" alt="image-20230320225554298"></p>
<p><strong>各种I&#x2F;O模型的比较</strong></p>
<p><img src="/./../pic/image-20230320225633999.png" alt="image-20230320225633999"></p>
<p><strong>同步I&#x2F;O和异步I&#x2F;O</strong></p>
<p>同步：导致请求进程阻塞，直到I&#x2F;O操作完成</p>
<p>异步：不导致请求进程阻塞</p>
<p>上述的前四种为同步I&#x2F;O，只有异步I&#x2F;O模型和与POSIX定义的异步I&#x2F;O相匹配</p>
<h4 id="6-3-select函数"><a href="#6-3-select函数" class="headerlink" title="6.3 select函数"></a>6.3 select函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set* readset, fd_set* writeset, fd_set* exceptset, </span></span><br><span class="line"><span class="params">          	<span class="type">const</span> <span class="keyword">struct</span> timeval* timeout)</span>;</span><br><span class="line">	<span class="comment">//返回: 就绪描述字的正数目， 0 -- 超时， -1 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;		<span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> tv_usec;	 	<span class="comment">/* mircroseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>timeout有三种可能:</p>
<ol>
<li>设置为空指针，永远等下去</li>
<li>等待一定固定时间，不超过该参数设置的值</li>
<li>不等待，检查描述字后立即返回，<strong>轮询</strong>。 参数设置为0</li>
</ol>
<p>中间的三个参数分别为：我们要让内核测试的读，写和异常条件的描述字。目前支持异常条件只有两个：</p>
<ol>
<li>某个套接口的带外数据的到达。24章</li>
<li>某个已设为分组方式的伪终端存在可从其主端读取的控制状态信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fd_set的实现细节不深究，可能是数组，第一个元素对应描述字0-31，一次类推</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set* fdset)</span>;			<span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* fdset)</span>;		<span class="comment">/* turn on the bit for fd in fdset*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* fdset)</span>;		<span class="comment">/* turn off the bit for fd in fdset*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fdset)</span>;	<span class="comment">/* is the bit for fd on in fdset*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line">fd_set rset;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(<span class="number">1</span>, &amp;rest);</span><br><span class="line">FD_SET(<span class="number">4</span>, &amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>, &amp;rest);</span><br></pre></td></tr></table></figure>



<h4 id="6-4-str-cli函数"><a href="#6-4-str-cli函数" class="headerlink" title="6.4 str_cli函数"></a>6.4 str_cli函数</h4><p><img src="/./../pic/image-20230323154701175.png" alt="image-20230323154701175"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书中的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>			maxfdp1;</span><br><span class="line">	fd_set		rset;</span><br><span class="line">	<span class="type">char</span>		sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">		FD_SET(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">		Select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;	<span class="comment">/* socket is readable */</span></span><br><span class="line">			<span class="keyword">if</span> (Readline(sockfd, recvline, MAXLINE) == <span class="number">0</span>)</span><br><span class="line">				err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">			Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;  <span class="comment">/* input is readable */</span></span><br><span class="line">			<span class="keyword">if</span> (Fgets(sendline, MAXLINE, fp) == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span>;		<span class="comment">/* all done */</span></span><br><span class="line">			Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//my</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli2</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd)</span> &#123;</span><br><span class="line">    <span class="type">int</span>         maxfdp1, n;</span><br><span class="line">    fd_set      rset;</span><br><span class="line">    <span class="type">char</span>        sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">        FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">        FD_SET(sockfd, &amp;rset);</span><br><span class="line">        maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">        select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = read(sockfd, recvline, MAXLINE)) == <span class="number">-1</span>)</span><br><span class="line">                perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            write(STDOUT_FILENO, recvline, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(sendline, MAXLINE, fp) == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意maxfdp1参数，要比实际最大描述字大1</p>
<h4 id="6-6-批量输入"><a href="#6-6-批量输入" class="headerlink" title="6.6 批量输入"></a>6.6 批量输入</h4><p><img src="/./../pic/image-20230323155448747.png" alt="image-20230323155448747"></p>
<p>6.5改进后仍存在问题，假设输入文件只有9行。最后一行在时刻8发出，如上图(6.11)所示。写完这个请求后，我们不能立即关闭连接，因为管道中还有其他的请求和应答。问题的引起在于我们对标准输入中的EOF的处理：str_cli函数就此返回到main函数，而main函数随后终止。然而在批量方式下，标准输入中的EOF并不意味着我们同时也完成了从套接口的读入；可能仍有请求在去往服务器的路上，或者仍有应答在返回客户的路上。所以我们需要一种半关闭的方式，这也是下章介绍的</p>
<h4 id="6-6-shutdown函数"><a href="#6-6-shutdown函数" class="headerlink" title="6.6 shutdown函数"></a>6.6 shutdown函数</h4><p>close的两个限制:</p>
<ol>
<li>close把引用计数减1，仅在该计数变为0的时候才关闭接口。</li>
<li>close终止数据传送的两个方向：读和写。既然TCP连接是双全工的，有时候我们只需要关闭一般</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span>;</span><br><span class="line">	<span class="comment">//返回: 0 -- 成功 ， -1 -- 出错</span></span><br><span class="line"></span><br><span class="line">howto的参数值：</span><br><span class="line">    SHUT_RD:关闭连接读的这一半</span><br><span class="line">    SHUT_WR:关闭连接写的这一半 -- 对于TCP套接口，这称为半关闭(half-close)</span><br><span class="line">    SHUT_RDWR:读写都关闭 -- 这与调用两次shutdown分别SHUT_RD 和 SHUT_WR等效</span><br></pre></td></tr></table></figure>



<h4 id="6-7-str-cli函数-再修订版"><a href="#6-7-str-cli函数-再修订版" class="headerlink" title="6.7 str_cli函数(再修订版)"></a>6.7 str_cli函数(再修订版)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">str_cli3</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd)</span> &#123;</span><br><span class="line">    <span class="type">int</span>         maxfdp1, stdineof;</span><br><span class="line">    fd_set      rset;</span><br><span class="line">    <span class="type">char</span>        buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span>         n;</span><br><span class="line"></span><br><span class="line">    stdineof = <span class="number">0</span>;</span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stdineof == <span class="number">0</span>)</span><br><span class="line">            FD_SET(fileno(fp), &amp;rset);</span><br><span class="line"></span><br><span class="line">        FD_SET(sockfd, &amp;rset);</span><br><span class="line">        maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">        select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stdineof == <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    perror(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            write(STDOUT_FILENO, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                stdineof = <span class="number">1</span>;</span><br><span class="line">                shutdown(sockfd, SHUT_WR);</span><br><span class="line">                FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(sockfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用stdineof标记是否stdin端读到EOF，若读到，则将stdin描述字从rset中清除，等sockfd读完后，返回main函数</p>
<h4 id="6-8-TCP回射服务器程序-修订版"><a href="#6-8-TCP回射服务器程序-修订版" class="headerlink" title="6.8 TCP回射服务器程序(修订版)"></a>6.8 TCP回射服务器程序(修订版)</h4><p>用select 单线程来重写之前的回射服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span>         i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="type">int</span>         nready, client[FD_SETSIZE];</span><br><span class="line">    <span class="type">ssize_t</span>     n;</span><br><span class="line">    fd_set      rset, allset;</span><br><span class="line">    <span class="type">char</span>        buf[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span>   clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ready to accept\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;</span><br><span class="line">    maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        client[i] = <span class="number">-1</span>;</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;</span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connect success form,client IP:**, client port:%d\n&quot;</span>, </span><br><span class="line">                <span class="comment">// inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,clie_IP, sizeof(clie_IP)), </span></span><br><span class="line">                    ntohs(cliaddr.sin_port));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i] = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;too many clients\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);</span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;=maxi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);</span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> </span><br><span class="line">                    write(sockfd, buf, n);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍存在问题，如果某一客户端，发送一个字节的数据（不是换行符）后进入睡眠。服务器读入这一个字节的数据后，会阻塞与下一个read调用，以等待来自客户的其余数据。这样，服务器就被单个用户阻塞了。</p>
<p>解决方法：</p>
<ol>
<li>使用非阻塞I&#x2F;O</li>
<li>让每个客户由单独的控制线程提供服务</li>
<li>对I&#x2F;O操作设置一个超时</li>
</ol>
<h4 id="6-9-pselect函数"><a href="#6-9-pselect函数" class="headerlink" title="6.9 pselect函数"></a>6.9 pselect函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pselect</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set* readset, fd_set* writeset, fd_set* exceptset, <span class="type">const</span> <span class="keyword">struct</span> timesepc* timeout, <span class="type">const</span> <span class="type">sigset_t</span>* sigmask)</span>;</span><br><span class="line">	<span class="comment">//返回: 就绪的描述字的个数 0 -- 超时 ， -1 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span> </span><br><span class="line">    <span class="type">time_t</span> 	tv_sec;		<span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> 	tv_nsec; 	<span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与select的相比两个变化:</p>
<ol>
<li>使用timespec结构，精度由微妙到纳秒了</li>
<li>增加了第六个参数：一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号，再由测试这些当前被禁止的信号的信号处理函数设置的全局变量，然后调用pselect，告诉它重新设置信号掩码</li>
</ol>
<p>简单来说，在pselect期间，以一新的信号屏蔽集替换当前的，pselect返回之后替换回来</p>
<h4 id="6-10-poll函数"><a href="#6-10-poll函数" class="headerlink" title="6.10 poll函数"></a>6.10 poll函数</h4><p>poll函数提供的功能与select类似，但在处理流设备时，它能提供额外的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fdarray, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">	<span class="comment">//返回: 就绪描述字的个数， 0 -- 超时， -1 -- 出错</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">short</span> events;</span><br><span class="line">    <span class="type">short</span> revents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fd:指定描述字</span></span><br><span class="line"><span class="comment">//events:指定要测试的条件</span></span><br><span class="line"><span class="comment">//revents:返回该描述字的状态</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230323192851591.png" alt="image-20230323192851591"></p>
<p>结构数组中元素的个数由nfds参数指定。timeout参数指定poll函数返回前等待多长时间。</p>
<p><img src="/./../pic/image-20230323193042302.png" alt="image-20230323193042302"></p>
<p>如果不关心某个特定描述字，可以把它对应的pollf的fd成员设置成一个负值</p>
<h4 id="6-11-TCP回射服务器程序-再修订版"><a href="#6-11-TCP回射服务器程序-再修订版" class="headerlink" title="6.11 TCP回射服务器程序(再修订版)"></a>6.11 TCP回射服务器程序(再修订版)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFTIM -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span>             i, maxi, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="type">int</span>             nready;</span><br><span class="line">    <span class="type">ssize_t</span>         n;</span><br><span class="line">    <span class="type">char</span>            buf[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span>       clilen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>   <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>) </span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd,<span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ready to accept\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nready = poll(client, maxi+<span class="number">1</span>, INFTIM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;</span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connect success form,client IP:**, client port:%d\n&quot;</span>, </span><br><span class="line">                <span class="comment">// inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr,clie_IP, sizeof(clie_IP)), </span></span><br><span class="line">                    ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;too many client\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            client[i].events = POLLRDNORM;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi) </span><br><span class="line">                maxi = i;</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span>  </span><br><span class="line">                        perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    write(sockfd, buf, n);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-12-小结"><a href="#6-12-小结" class="headerlink" title="6.12 小结"></a>6.12 小结</h4><p>Unix提供了5种不同的I&#x2F;O模型:</p>
<ol>
<li>阻塞I&#x2F;O模型</li>
<li>非阻塞I&#x2F;O模型</li>
<li>I&#x2F;O复用模型</li>
<li>信号驱动I&#x2F;O模型</li>
<li>异步I&#x2F;O模型</li>
</ol>
<p><img src="/./../pic/image-20230323195342448.png" alt="image-20230323195342448"></p>
<h3 id="第7章-套接口选项"><a href="#第7章-套接口选项" class="headerlink" title="第7章 套接口选项"></a>第7章 套接口选项</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><h3 id="第8章-基本UDP套接口编程"><a href="#第8章-基本UDP套接口编程" class="headerlink" title="第8章 基本UDP套接口编程"></a>第8章 基本UDP套接口编程</h3><h4 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h4><p>UDP是无连接不可靠的数据报协议，不同于TCP提供的面向连接的可靠字节流</p>
<p><img src="/./../pic/image-20230325190607416.png" alt="image-20230325190607416"></p>
<h4 id="8-2-recvfrom和sendto函数"><a href="#8-2-recvfrom和sendto函数" class="headerlink" title="8.2 recvfrom和sendto函数"></a>8.2 recvfrom和sendto函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> sockaddr* from, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">              <span class="type">const</span> sturct sockaddr* to, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">	<span class="comment">//据返回: 读写字节数 -- 成功， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>**flags:**在14章讨论，目前总把flags设为0</p>
<p>**to:**指向一个含有数据报接收者的协议地址的套接口地址结构，其大小由addrlen参数指定</p>
<p>**from:**类似于accept的后两个参数，告诉我们是谁发送了数据报(udp情况下)或是谁发起了连接(tcp情况下)</p>
<p>写一个长度为0的数据报是可行的。在UDP情况下，这导致一个只包含一个IP头部(IPV4 20字节，IPV6 40字节)和一个8字节的UDP头部而没有数据的IP数据报。</p>
<h4 id="8-3-UDP回射服务器程序"><a href="#8-3-UDP回射服务器程序" class="headerlink" title="8.3 UDP回射服务器程序"></a>8.3 UDP回射服务器程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 			sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servadddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    </span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    dg_echo(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-4-UDP回射服务器程序-dg-echo函数"><a href="#8-4-UDP回射服务器程序-dg-echo函数" class="headerlink" title="8.4 UDP回射服务器程序:dg_echo函数"></a>8.4 UDP回射服务器程序:dg_echo函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dg_echo</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* pcliaddr, <span class="type">socklen_t</span> clilen)</span> &#123;</span><br><span class="line">    <span class="type">int</span>             n;</span><br><span class="line">    <span class="type">socklen_t</span>       len;</span><br><span class="line">    <span class="type">char</span>            mesg[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        len = clilen;</span><br><span class="line">        n = recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>, pcliaddr, &amp;len);</span><br><span class="line">        sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说TCP服务器是并发的，而大多数UDP服务器是迭代的</p>
<p>UDP为了防止丢包，可以通过改变缓冲区大小，通过使用setsockpot，见第七章</p>
<p><img src="/./../pic/image-20230325192958120.png" alt="image-20230325192958120"></p>
<h4 id="8-5-UDP回射客户程序"><a href="#8-5-UDP回射客户程序" class="headerlink" title="8.5 UDP回射客户程序"></a>8.5 UDP回射客户程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span>                 sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, SERV_IP, &amp;servaddr.sin_addr.s_addr);</span><br><span class="line">    </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dg_cli(<span class="built_in">stdin</span>, sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-6-UDP回射客户程序-dg-cli函数"><a href="#8-6-UDP回射客户程序-dg-cli函数" class="headerlink" title="8.6 UDP回射客户程序:dg_cli函数"></a>8.6 UDP回射客户程序:dg_cli函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dg_cli(FILE* fp, int sockfd, const struct sockaddr* pservaddr, socklen_t servlen) &#123;</span><br><span class="line">    int     n;</span><br><span class="line">    char    sendline[MAXLINE], recvline[MAXLINE+1];</span><br><span class="line"></span><br><span class="line">    while (fgets(sendline, MAXLINE, fp) != NULL) &#123;</span><br><span class="line">        sendto(sockfd, sendline, strlen(sendline), 0, pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">        n = recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL);</span><br><span class="line"></span><br><span class="line">        recvline[n] = 0;</span><br><span class="line">        fputs(recvline, stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-7-数据包的丢失"><a href="#8-7-数据包的丢失" class="headerlink" title="8.7 数据包的丢失"></a>8.7 数据包的丢失</h4><p>如果一个客户数据报丢失(譬如被客户主机与服务器主机之间的某个服务器丢弃)，客户讲永远阻塞于recvfrom调用</p>
<h4 id="8-8-验证收到的响应"><a href="#8-8-验证收到的响应" class="headerlink" title="8.8 验证收到的响应"></a>8.8 验证收到的响应</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dg_cli</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* pservaddr, <span class="type">socklen_t</span> servlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 			n;</span><br><span class="line">    <span class="type">char</span> 			sendline[MAXLINE], recvline[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">socklen_t</span> 		len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">preply_addr</span>;</span></span><br><span class="line">    </span><br><span class="line">    preply_addr = (<span class="keyword">struct</span> sockaddr*)<span class="built_in">malloc</span>(servlen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line">        </span><br><span class="line">        len = servlen;</span><br><span class="line">        n = recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, preply_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (len != servlen || <span class="built_in">memcmp</span>(pservaddr, prepl_addr, len) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;reply from %s (ignored)\n&quot;</span>),</span><br><span class="line">            	Sock_ntop(preply_addr, len));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当服务器运行在具有多个接口和ip地址的主机上时，可能失败</p>
<p><img src="/./../pic/image-20230325202720956.png" alt="image-20230325202720956"></p>
<h4 id="8-9-服务器进程未运行"><a href="#8-9-服务器进程未运行" class="headerlink" title="8.9 服务器进程未运行"></a>8.9 服务器进程未运行</h4><p>运行客户端，但不启动服务器</p>
<p><img src="/./../pic/image-20230325203912892.png" alt="image-20230325203912892"></p>
<p>tcpdump的输出</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20230325203923515.png" alt="image-20230325203923515"></p>
<p>可以看到服务器响应一个”port unreadchable”ICMP消息，但这个错误不返回给客户进程</p>
<p>该ICMP错误为异步错误，由sendto引起，但sendto本身却成功返回。UDP输出操作成功返回，仅仅表示在接口输出队列中具有存放所导致IP数据报的空间。该ICMP错误直到后来才返回，所以称之为异步.</p>
<p>一个基本规则：对于一个UDP套接口，由它引发的异步错误不返回给它，除非它已连接。</p>
<h4 id="8-10-UDP程序例子小结"><a href="#8-10-UDP程序例子小结" class="headerlink" title="8.10 UDP程序例子小结"></a>8.10 UDP程序例子小结</h4><p><img src="/./../pic/image-20230325204832271.png" alt="image-20230325204832271"></p>
<p><img src="/./../pic/image-20230325204842082.png" alt="image-20230325204842082"></p>
<h4 id="8-11-UDP的connect函数"><a href="#8-11-UDP的connect函数" class="headerlink" title="8.11 UDP的connect函数"></a>8.11 UDP的connect函数</h4><ol>
<li>未连接UDP套接口，新创建UDP套接口缺省如此</li>
<li>已连接UDP套接口，对UDP套接口调用connect的结果</li>
</ol>
<p>对于已连接套接口，与缺省的未连接UDP套接口相比，发生了三个变化:</p>
<ol>
<li>我们不能给输出操作指定宿IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接口上的任何内容都自动发送到由connect指定的协议地址</li>
<li>我们不必使用recvfrom以获得数据报的发送者，而改用read，recv或recvmsg。在一个已连接UDP套接口上由内核为输入操作返回的数据报仅仅是那些来自connect所指定协议地址的数据报。这样就限制一个已连接UDP套接口能且仅能与一个对端交换数据报</li>
<li>由已连接UDP套接口引发的异步错误将返回给它们所在的进程。</li>
</ol>
<p><img src="/./../pic/image-20230325212037647.png" alt="image-20230325212037647"></p>
<p><img src="/./../pic/image-20230325212124151.png" alt="image-20230325212124151"></p>
<p><strong>给一个UDP套接口多次调用connect</strong></p>
<p>两个目的:</p>
<ol>
<li>指定新的IP地址和端口号</li>
<li>断开套接口</li>
</ol>
<p>不同于TCP套接口中的connect的使用：对于TCP套接口，connect只能调用一次</p>
<p>为断开一个已连接的UDP套接口，再次调用connect时，把套接口地址结构成员设置为AF_UNSPEC</p>
<p><strong>性能</strong></p>
<p>对于一个未连接的UDP套接口调用sendto的步骤如下:</p>
<ol>
<li>连接套接口</li>
<li>输出第一个数据报</li>
<li>断开套接口连接</li>
<li>连接套接口</li>
<li>输出第二个数据报</li>
<li>断开套接口</li>
</ol>
<p>对于已连接的</p>
<ol>
<li>连接套接口</li>
<li>输出第一个</li>
<li>输出第二个</li>
</ol>
<h4 id="8-12-dg-cli函数-修订"><a href="#8-12-dg-cli函数-修订" class="headerlink" title="8.12 dg_cli函数(修订)"></a>8.12 dg_cli函数(修订)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dg_cli2</span><span class="params">(FILE* fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* pservaddr, <span class="type">socklen_t</span> servlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span>     n;</span><br><span class="line">    <span class="type">char</span>    sendline[MAXLINE], recvline[MAXLINE+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line"></span><br><span class="line">        n = read(sockfd, recvline, MAXLINE);</span><br><span class="line"></span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230325213942215.png" alt="image-20230325213942215"></p>
<h4 id="8-13-UDP缺乏流量控制"><a href="#8-13-UDP缺乏流量控制" class="headerlink" title="8.13 UDP缺乏流量控制"></a>8.13 UDP缺乏流量控制</h4><p>本小节执行了一个测试函数，发送2000个1400字节大小的UDP数据报给服务器</p>
<p>发出2000个数据报，但服务器只收到其中的30个，丢失率未98%。对于服务器或客户端都没有给出任何指示说这些数据报已丢失。证实了我们说过的话，即UDP没有流量控制，是不可靠。本例表面UDP发送端淹没其接受端是轻而易举的事情。</p>
<p>由UDP给某个特定套接口排队的UDP数据报数目受限于该套接口接收缓冲区的大小。我们可以使用SO_RCVBUF套接口修改该值，见前一章，以及上述视频笔记部分 <strong>UDP</strong></p>
<h4 id="8-14-UDP中的外出接口的确定"><a href="#8-14-UDP中的外出接口的确定" class="headerlink" title="8.14 UDP中的外出接口的确定"></a>8.14 UDP中的外出接口的确定</h4><p>以连接UDP套接口还可以用来确定用于某个特定目的地的外出接口。这是由connect函数应用到UDP套接口时的一个副作用造成的：内核选择本地IP地址(假设其进程未曾调用bind显示指派他)。这个本地IP地址搜索路由表得到外出接口，然后选用该接口的主IP地址而选定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 			sockfd;</span><br><span class="line">    <span class="type">socklen_t</span> 		len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">        err_quit(<span class="string">&quot;usage: udpcli &lt;IPaddrss&gt;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">       bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr.s_addr);</span><br><span class="line">    </span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    getsockname(sockfd, (<span class="keyword">struct</span> sokcaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local addrss %s\n&quot;</span>, Sock_ntop((<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230325215140101.png" alt="image-20230325215140101"></p>
<h4 id="8-15-使用select函数的TCP和UDP回射服务器程序"><a href="#8-15-使用select函数的TCP和UDP回射服务器程序" class="headerlink" title="8.15 使用select函数的TCP和UDP回射服务器程序"></a>8.15 使用select函数的TCP和UDP回射服务器程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致思路，没编译</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span>             listenfd, connfd, updfd, nready, maxfdp1;</span><br><span class="line">    <span class="type">char</span>            mesg[MAXLINE];</span><br><span class="line">    <span class="type">pid_t</span>           childpid;</span><br><span class="line">    fd_set          rset;</span><br><span class="line">    <span class="type">ssize_t</span>         n;</span><br><span class="line">    <span class="type">socklen_t</span>       len;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>       on = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//tcp</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置端口复用</span></span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (sturct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//udp</span></span><br><span class="line">    updfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(updfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置信号捕捉函数，wait回收子进程，避免产生僵尸进程</span></span><br><span class="line">    signal(SIGCHLD, sig_chld);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    maxfdp1 = max(listenfd, updfd) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nready = select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                perror(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;</span><br><span class="line">            len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">                close(listenfd);</span><br><span class="line">                str_echo(connfd);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(updfd, &amp;rset)) &#123;</span><br><span class="line">            len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            n = recvfrom(udpfd, mesg, MAXLINE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">            sendto(updfd, mesg, n, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-16-小结"><a href="#8-16-小结" class="headerlink" title="8.16 小结"></a>8.16 小结</h4><p>把TCP客户&#x2F;服务器更换成UDP很容易，但失去了许多功能：检测丢失的分组并重传，验证响应是否来自正确的对端等等</p>
<p>UDP套接口可能产生异步错误，它们是在其引发分组发送完一段时间之后才报告错误。TCP套接口总是给应用进程报告这些错误，但是UDP套接口必须已连接才能接收这些错误。</p>
<p>UDP没有流量控制，这一点很容易演示。但由于UDP的应用程序构造模式一般为请求-应答，不传送大数据，所以一般不成问题</p>
<h3 id="第11章-名字与地址转换"><a href="#第11章-名字与地址转换" class="headerlink" title="第11章 名字与地址转换"></a>第11章 名字与地址转换</h3><h4 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h4><p>到目前为止，本书所有的例子都用数值地址来表示主机(如206.6.226.33)，用数值端口号来标识服务器(如端口13代表标准的daytime服务器)。我们处于许多理由，我们应该使用名字而不是数值。本章讲述在名字和数值地址间进行转换的函数：gethostbyname和gethostbyaddr在主机名字与IPV4地址之间进行转换；getservbyname和getservbyport在服务名字和端口之间进行转换。以及两个协议无关的转换函数：getaddrinfo和getnameinfo</p>
<h4 id="11-2-域名系统"><a href="#11-2-域名系统" class="headerlink" title="11.2 域名系统"></a>11.2 域名系统</h4><p><strong>域名系统(Domain Name System),简称DNS</strong></p>
<p>用于主机名字与IP地址之间的映射。</p>
<p>主机名既可以是一个简单名字，例如solaris或freebsd，也可以是一个全限定域名(Fully Qualified Domain Name，简称FQDN)，例如solaris.unpbook.com</p>
<p><strong>资源记录</strong></p>
<p>DNS中的条目称为资源记录(resource record，简称RR)，我们感兴趣的RR类型只有若干个</p>
<p><img src="/./../pic/image-20230327220412889.png" alt="image-20230327220412889"></p>
<p><strong>解析器和名字服务器</strong></p>
<p>每个组织机构往往运行一个或多个名字服务器(name server)，它们通常就是所谓的BIND(Berkeley Internet Name Domain的简称)程序。诸如偶们在本书中编写的客户和服务器等应用程序通过调用称为 <strong>解析器(resolver)</strong> 的函数库接触DNS服务器。常见的解析器函数是将在本章讲都gethostbyname和gethostbyaddr</p>
<p>解析器代码通常包含在一个系统函数库中，在构造应用程序时被 <strong>链编</strong> 到应用程序中。另有些系统提供一个由全体应用程序共享的集中式解析器守护进程，并提供相这个守护进程执行RPC的系统函数库代码。</p>
<p><img src="/./../pic/image-20230327221159710.png" alt="image-20230327221159710"></p>
<p>解析器代码通常读取其系统相关配置文件确定本组织机构的名字服务器们的所在位置。文件&#x2F;etc&#x2F;resolv.conf通常包含本地名字服务器主机的IP地址</p>
<p>解析器使用UDP向本地名字服务器发出查询，如果本地名字服务器不知道答案，它通常就会使用UDP在整个因特网上查询其他名字服务器。如果名字太长，超出UDP消息的承载能力，本地名字服务器和解析器会切换到TCP</p>
<p><img src="/./../pic/image-20230327221539654.png" alt="image-20230327221539654"></p>
<h4 id="11-3-gethostbyname函数"><a href="#11-3-gethostbyname函数" class="headerlink" title="11.3 gethostbyname函数"></a>11.3 gethostbyname函数</h4><p>查找主机名最基本的函数是gethostbyname。如果调用成功，它就返回一个指向hostent结构的指针，该结构中含有所查找主机的所有IPV4地址。这个函数的局限是只能返回IPV4地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname)</span>;</span><br><span class="line">	<span class="comment">//返回: 非空指针 -- 成功， 空指针 -- 出错，同时设置h_errno</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//hostent结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>*	h_name;			<span class="comment">/* official (canonical) name of host */</span></span><br><span class="line">    <span class="type">char</span>** 	h_aliases;		<span class="comment">/* pointer to array of pointers to alias names */</span></span><br><span class="line">    <span class="type">int</span> 	h_addrtype;		<span class="comment">/* host addrss type: AF_INET */</span></span><br><span class="line">    <span class="type">int</span> 	h_length;		<span class="comment">/* length of aadrss: 4 */</span></span><br><span class="line">    <span class="type">char</span>** 	h_addr_list;	<span class="comment">/* ptr to array of ptrs with IPV4 addrs */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照DNS的说法，getbyname执行的是对A记录的查询。他只能返回IPV4地址。</p>
<p>下图所查询的主机名有2个别名和3个IPV4地址。</p>
<p><img src="/./../pic/image-20230327224928223.png" alt="image-20230327224928223"></p>
<p>gethostbyname发生错误时，它不设置errno变量，而是将全局整数变量h_errno设置为在&lt;netdb.h&gt;中定义的下列常值之一：</p>
<ol>
<li>HOST_NOT_FOUND</li>
<li>TRY_AGAIN</li>
<li>NO_RECOVERY</li>
<li>NO_DATA(等同于NO_ADDRESS)</li>
</ol>
<p>多数解析器提供名为hstrerror的函数，以某个h_errno值作为唯一的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span>    *ptr, **pptr;</span><br><span class="line">    <span class="type">char</span>    str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ptr = *++argv;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((hptr = gethostbyname(ptr)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;gethostbyname error for host%s:%s&quot;</span>,</span><br><span class="line">                    ptr, hstrerror(h_errno));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;official hostname%s\n&quot;</span>, hptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (pptr = hptr-&gt;h_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\talias: %s\n&quot;</span>, *pptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(hptr-&gt;h_addrtype) &#123;</span><br><span class="line">            <span class="keyword">case</span> AF_INET:</span><br><span class="line">                pptr = hptr-&gt;h_addr_list;</span><br><span class="line">                <span class="keyword">for</span> (; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\taddress: %s\n&quot;</span>,</span><br><span class="line">                        inet_ntop(hptr-&gt;h_addrtype, *pptr,</span><br><span class="line">                                  str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                perror(<span class="string">&quot;unkonwn address type&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行示例</span></span><br><span class="line">ubuntu@VM<span class="number">-0</span><span class="number">-14</span>-ubuntu:~/learning/<span class="number">2023</span>/UnpStudy/chapter11$ hostnamectl </span><br><span class="line">   Static hostname: VM<span class="number">-0</span><span class="number">-14</span>-ubuntu</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: <span class="number">075097</span>c3da50476181f422ef916e1460</span><br><span class="line">           Boot ID: <span class="number">149585e4</span>f7384a71833fa6a9f2b6293d</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: Ubuntu <span class="number">20.04</span> LTS</span><br><span class="line">            Kernel: Linux <span class="number">5.4</span><span class="number">.0</span><span class="number">-126</span>-generic</span><br><span class="line">      Architecture: x86<span class="number">-64</span></span><br><span class="line">ubuntu@VM<span class="number">-0</span><span class="number">-14</span>-ubuntu:~/learning/<span class="number">2023</span>/UnpStudy/chapter11$ ./hostent VM<span class="number">-0</span><span class="number">-14</span>-ubuntu</span><br><span class="line">official hostnamelocalhost.localdomain</span><br><span class="line">        alias: VM<span class="number">-0</span><span class="number">-14</span>-ubuntu</span><br><span class="line">        address: <span class="number">127.0</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>正式主机名就是FQDN</p>
<h4 id="11-4-gethostbyaddr函数"><a href="#11-4-gethostbyaddr函数" class="headerlink" title="11.4 gethostbyaddr函数"></a>11.4 gethostbyaddr函数</h4><p>gethostbyaddr函数试图由一个二进制的IP地址找到响应的主机名，与gethostbyname的行为刚好相反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family)</span>;</span><br><span class="line">	<span class="comment">//返回: 非空指针 -- 成功 ， 空指针 -- 出错 ， 同时设置h_errno</span></span><br></pre></td></tr></table></figure>

<p>adrr参数实际上不是char* 类型， 而是一个指向存放ipv4地址的某个in_addr结构的指针，len参数是这个结构的大小，对于IPV4地址为4,family参数为AF_INET</p>
<p>按照DNS的说法，gethostbyaddr在in_addr.arpa域中向一个名字服务器查询PTR记录</p>
<h4 id="11-5-getservbyname和getservbyport函数"><a href="#11-5-getservbyname和getservbyport函数" class="headerlink" title="11.5 getservbyname和getservbyport函数"></a>11.5 getservbyname和getservbyport函数</h4><p>如果我们在程序代码中通过其名字而不是其端口号来指代一个服务，而且从名字到端口号的映射关系保存在一个文件中(通常是&#x2F;etc&#x2F;services)。getservbyname函数用于根据给定名字查找相应服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent* <span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * servname, <span class="type">const</span> <span class="type">char</span> * protoname)</span>;</span><br><span class="line">	<span class="comment">//返回: 非空指针 -- 成功 ， 空指针 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//servent结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name; 		<span class="comment">/* official service name */</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;	<span class="comment">/* alias list */</span></span><br><span class="line">    <span class="type">int</span>  s_port;		<span class="comment">/* port number, network-byte order */</span></span><br><span class="line">    <span class="type">char</span> *s_proto;		<span class="comment">/* protocol to ues */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器参数servname必须指定。如果同时指定了协议(protoname参数为非空指针)，那么指定服务必须有匹配的协议。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本函数的典型调用如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">sptr</span>;</span></span><br><span class="line">sptr = getservbyname(<span class="string">&quot;domain&quot;</span>, <span class="string">&quot;udp&quot;</span>);		<span class="comment">/* DNS using UDP */</span></span><br><span class="line">sptr = getservbyname(<span class="string">&quot;ftp&quot;</span>, <span class="string">&quot;tcp&quot;</span>);			<span class="comment">/* FTP using TCP */</span></span><br><span class="line">sptr = getservbyname(<span class="string">&quot;ftp&quot;</span>, <span class="literal">NULL</span>);			<span class="comment">/* FTP using TCP */</span></span><br><span class="line">sptr = getservbyname(<span class="string">&quot;ftp&quot;</span>, <span class="string">&quot;udp&quot;</span>);			<span class="comment">/* this call with fail */</span></span><br></pre></td></tr></table></figure>

<p>既然FTP仅支持TCP，第2个调用和第3个调用等效，第4个调用则会失败。以下是&#x2F;etc&#x2F;services文件中的典型文本行:</p>
<p><img src="/./../pic/image-20230328193908589.png" alt="image-20230328193908589"></p>
<p>getservbyport用于根据端口号和可选协议查找相应服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent* <span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> * protoname)</span>;	</span><br><span class="line">	<span class="comment">//返回: 非空指针 -- 成功 ， 空指针 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>port的参数值必须为网络字节序，典型调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">sptr</span>;</span></span><br><span class="line">sptr = getservbyport(htons(<span class="number">53</span>), <span class="string">&quot;udp&quot;</span>);		<span class="comment">/* DNS using UDP */</span></span><br><span class="line">sptr = getservbyport(htons(<span class="number">21</span>), <span class="string">&quot;tcp&quot;</span>);		<span class="comment">/* FTP using TCP */</span></span><br><span class="line">sptr = getservbyport(htons(<span class="number">21</span>), <span class="literal">NULL</span>);		<span class="comment">/* FTP using TCP */</span></span><br><span class="line">sptr = getservbyport(htons(<span class="number">21</span>), <span class="string">&quot;udp&quot;</span>);		<span class="comment">/* this call will fail */</span></span><br></pre></td></tr></table></figure>

<p>既然UDP上没有服务使用端口21， 最后一个调用将失败</p>
<p>有些端口号在TCP上用于一种服务，在UDP上却用于完全不同的另一种服务，例如</p>
<p><img src="/./../pic/image-20230328194404404.png" alt="image-20230328194404404"></p>
<p>例子：使用gethostbyname和getservbyname</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 		sockfd, n;</span><br><span class="line">    <span class="type">char</span> 		recvline[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	**<span class="title">pptr</span>;</span>  	<span class="comment">/* in_addr 结构体表示32位IPV4地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	*<span class="title">inetaddrp</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> 	<span class="title">inetaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>	*<span class="title">hp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span>	*<span class="title">sp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) </span><br><span class="line">        err_quit(<span class="string">&quot;usage: daytimetcpcli1 &lt;hostname&gt; &lt;service&gt; &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找地址，若没有找到，则采用inet_aton确定其参数是否以是ASCII格式的地址</span></span><br><span class="line">    <span class="keyword">if</span> ((hp = gethostbyname(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inet_aton(argv[<span class="number">1</span>], &amp;inetaddr) == <span class="number">0</span>) &#123;</span><br><span class="line">            err_quit(<span class="string">&quot;hostname error for %s: %s&quot;</span>, argv[<span class="number">1</span>], hstrerror(h_error));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inetaddrp[<span class="number">0</span>] = &amp;inetaddr;</span><br><span class="line">            inetaddrp[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">            pptr = inetaddrp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pptr = (<span class="keyword">struct</span> in_addr **)hp-&gt;h_addr_list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取服务器端口</span></span><br><span class="line">    <span class="keyword">if</span> ((sp = getservbyname(argv[<span class="number">2</span>], <span class="string">&quot;tcp&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;getservbyname error for %s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环尝试每个服务器主机地址</span></span><br><span class="line">    <span class="keyword">for</span> (; *pptr != <span class="literal">NULL</span>; pptr++) &#123;</span><br><span class="line">        sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = sp-&gt;s_port;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, *pptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;trying %s\n&quot;</span>, Sock_ntop((<span class="keyword">struct</span> sockaddr*)&amp;servaddr,</span><br><span class="line">                <span class="keyword">sizeof</span>(servaddr)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;		<span class="comment">/* success */</span></span><br><span class="line">        err_ret(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*pptr == <span class="literal">NULL</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;unable to connect&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<p><img src="/./../pic/image-20230328200202286.png" alt="image-20230328200202286"></p>
<h4 id="11-6-getaddrinfo-函数"><a href="#11-6-getaddrinfo-函数" class="headerlink" title="11.6 getaddrinfo 函数"></a>11.6 getaddrinfo 函数</h4><p><strong>gehostbyname</strong>和<strong>gethostbyaddr</strong>这两个函数仅仅支持IPV4。解析IPV6地址的API经历了若干次反复：最终结果是<strong>getaddrinfo</strong>函数。</p>
<p><strong>getaadrinfo</strong>函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个sockaddr结构的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaadrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> addrinfo * hints, <span class="keyword">struct</span> addrinfo **result)</span>;</span><br><span class="line">	<span class="comment">//返回: 0 -- 成功 ， 非0 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//addrinfo结构定义在&lt;netdb.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> 			ai_flags; 		<span class="comment">/* AI_PASSIVE, AI_CANONNAME */</span></span><br><span class="line">    <span class="type">int</span> 			ai_family;		<span class="comment">/* AF_XXX */</span></span><br><span class="line">    <span class="type">int</span> 			ai_socktype;	<span class="comment">/* SOCK_XXX */</span></span><br><span class="line">    <span class="type">int</span> 			ai_protocol;	<span class="comment">/* 0 or IPPROTO_xxx for IPV4 and IPV6 */</span></span><br><span class="line">    <span class="type">socklen_t</span> 		ai_addrlen;		<span class="comment">/* length of ai_addr */</span></span><br><span class="line">    <span class="type">char</span>		    *ai_canonname;	<span class="comment">/* ptr to canonical name for host */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>		<span class="comment">/* ptr to socket address structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>		<span class="comment">/* ptr to next structure in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前两个参数没啥好说的，第3个hints参数，调用者在这个结构中填入关于期望返回的信息类型的暗示。比如希望指定的服务返回UDP的套接口，则可以把hints结构中的ai_socktype成员设置为SOCK_DGRAM	</p>
<p>hints结构中调用者可以设置的成员有:</p>
<ol>
<li>ai_flags(零个或多个或在一起的AI_xxx值)</li>
<li>ai_family(某个AF_xxx值)</li>
<li>ai_socktype(某个SOCK_xxx值)</li>
<li>ai_protocol</li>
</ol>
<p><img src="/./../pic/image-20230328201451528.png" alt="image-20230328201451528"></p>
<p>如果函数成功返回0，那么由result参数指向的变量被填入一个指针，指向该结构链表的指针。可导致返回多个addrinfo结构的情形有以下两个:</p>
<ol>
<li>hostname有多个关联地址的话，每个满足hints参数的地址都返回一个对应的结构</li>
<li>service指定的服务支持多个套接口类型的话，同上，每个套接口返回一个对应结构</li>
</ol>
<p>举例来说，在没有提供hints参数的情况下，请求查找2个IP地址的某个主机上的domain服务(DNS服务既支持TCP也支持UDP)，那么将返回4个addrinfo结构:</p>
<ol>
<li>第1个IP地址+SOCK_STREAM</li>
<li>第1个IP地址+SOCK_DGREAM</li>
<li>第2个IP地址+SOCK_STREAM</li>
<li>第2个IP地址+SOCK_DGRAM</li>
</ol>
<p>addrinfo结构中返回的信息，可以直接用于socket调用</p>
<p>如果结构中设置了 <strong>AI_CANONNAME</strong> 标志，那么本函数返回的第一个addrinfo结构的ai_canonname成员指向所查找主机的规范名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图11.5 给出了执行下列程序片段返回的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>;</span></span><br><span class="line">bzero(&amp;hints, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">hints.ai_flags = AI_CANONNAME;</span><br><span class="line">hints.ai_family = AF_INET;</span><br><span class="line">getaadrinfo(<span class="string">&quot;freebsd4&quot;</span>, <span class="string">&quot;domain&quot;</span>, &amp;hints, &amp;res);</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230328203433043.png" alt="image-20230328203433043"></p>
<p>getaddrinfo解决了把主机名和服务名转换成套接口地址结构的问题。11.17节讲解它的反义函数getnameinfo，它把套接口地址结构转换成主机名和服务名</p>
<h4 id="11-7-gai-strerror-函数"><a href="#11-7-gai-strerror-函数" class="headerlink" title="11.7 gai_strerror 函数"></a>11.7 gai_strerror 函数</h4><p>和之前的strerror和hstrerror差不多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> error)</span>;</span><br><span class="line">	<span class="comment">//返回:指向错误描述信息字符串的指针</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230328204148071.png" alt="image-20230328204148071"></p>
<h4 id="11-8-freeaddrinfo-函数"><a href="#11-8-freeaddrinfo-函数" class="headerlink" title="11.8 freeaddrinfo 函数"></a>11.8 freeaddrinfo 函数</h4><p>用来清除getaddrinfo返回的addrinfo链表，这个链表的所有结构以及由它们指向的任何动态存储空间(譬如套接口地址结构和规范主机名)都被释放掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo * ai)</span>;</span><br></pre></td></tr></table></figure>





<h4 id="11-9-getaddrinfo函数-IPV6"><a href="#11-9-getaddrinfo函数-IPV6" class="headerlink" title="11.9 getaddrinfo函数: IPV6"></a>11.9 getaddrinfo函数: IPV6</h4><p>POSIX规范定义了getaddrinfo函数以及该函数为IPV4或IPV6返回的信息。在以图11.8汇总这些返回值之前，我们注意以下几点:</p>
<p><img src="/./../pic/image-20230328210420621.png" alt="image-20230328210420621"></p>
<h4 id="11-10-getaadrinfo-函数-例子"><a href="#11-10-getaadrinfo-函数-例子" class="headerlink" title="11.10 getaadrinfo 函数:例子"></a>11.10 getaadrinfo 函数:例子</h4><p>在附加hitns期望时的，返回结果</p>
<p><img src="/./../pic/image-20230328214641223.png" alt="image-20230328214641223"></p>
<p><img src="/./../pic/image-20230328214912425.png" alt="image-20230328214912425"></p>
<p><img src="/./../pic/image-20230328214922655.png" alt="image-20230328214922655"></p>
<p><img src="/./../pic/image-20230328214940460.png" alt="image-20230328214940460"></p>
<h4 id="11-11-host-serv-函数"><a href="#11-11-host-serv-函数" class="headerlink" title="11.11 host_serv 函数"></a>11.11 host_serv 函数</h4><p>一个getaddrinfo的接口函数，增加我们刚兴趣的两个成员，family和socktype作为参数，其他实现在函数内部进行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> addrinfo * <span class="title function_">host_serv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service, </span></span><br><span class="line"><span class="params">                           <span class="type">int</span> family, <span class="type">int</span> socktype)</span>;</span><br><span class="line">	<span class="comment">//返回: 指向addrinfo结构的指针 -- 成功 ， NULL -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> addrinfo * <span class="title function_">host_serv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service, </span></span><br><span class="line"><span class="params">                           <span class="type">int</span> family, <span class="type">int</span> socktype)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 	n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>;</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_flags = AI_CANONNAME;		<span class="comment">/* always return canonical name */</span></span><br><span class="line">    hints.ai_family = family;			<span class="comment">/* AF_UNSPEC, AF_INET, AF_INET6 etc. */</span></span><br><span class="line">    hints.ai_socktype = socktype;		<span class="comment">/* 0, SOCK_STREAM, SOCK_DGRAM, etc. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;			<span class="comment">/* return pointer to first on linked list */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-12-tcp-connect-函数"><a href="#11-12-tcp-connect-函数" class="headerlink" title="11.12 tcp_connect 函数"></a>11.12 tcp_connect 函数</h4><p>也是一个自定义函数。处理TCP客户和服务器大多数情形的两个函数。第一个即tcp_connect执行客户的通常步骤：创建一个TCP套接口并连接到一个服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service)</span>;	</span><br><span class="line">	<span class="comment">//已连接套接口描述字 -- 成功 ， 不返回 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			sockfd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;tcp_connect error for %s, %s: %s&quot;</span>,</span><br><span class="line">                 host, serv, gai_strerror(n));</span><br><span class="line">    ressave = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;		<span class="comment">/* ignore this one */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        close(sockfd);		<span class="comment">/* success */</span></span><br><span class="line">    &#125; <span class="keyword">while</span>((res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) 		<span class="comment">/* errno set from final connect() */</span></span><br><span class="line">        err_sys(<span class="string">&quot;tcp_connect error for %s, %s&quot;</span>, host, serv);</span><br><span class="line">    </span><br><span class="line">    freeaddrinfo(ressave);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包裹函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Tcp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * host, <span class="type">const</span> <span class="type">char</span> * serv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (tcp_connect(host, serv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg 将图1.5的时间获取客户程序改用tcp_connect重新编写</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>			sockfd, n;</span><br><span class="line">    <span class="type">char</span>		recvline[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">socklen_t</span>	len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;usage: daytimetcpcli &lt;hostname/IPaddress&gt; &lt;service/port# &gt;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    sockfd = Tcp_connect(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    len = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">    Getpeername(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;ss, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connected to %s\n&quot;</span>, Sock_ntop_host((<span class="keyword">struct</span> sockaddr*)&amp;ss, len));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-13-tcp-listen-函数"><a href="#11-13-tcp-listen-函数" class="headerlink" title="11.13 tcp_listen 函数"></a>11.13 tcp_listen 函数</h4><p>创建一个TCP套接口，给它捆绑服务器众所周知端口，并允许接受外来的连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;10.0.0.14&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_listen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * host, <span class="type">const</span> <span class="type">char</span> * serv, <span class="type">socklen_t</span> * addrlenp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span>   len;</span><br><span class="line">    <span class="type">char</span>        buf[MAXLINE];</span><br><span class="line">    <span class="type">time_t</span>      ticks;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: daytimetcpservl &lt;service or port#&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = tcp_listen(<span class="literal">NULL</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection success\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;% .24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">        write(connfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_listen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * host, <span class="type">const</span> <span class="type">char</span> * serv, <span class="type">socklen_t</span> * addrlenp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>             listenfd, n;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>       on = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>) &#123;</span><br><span class="line">        gai_strerror(n);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ressave = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        listenfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">        <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        close(listenfd);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcp_listen error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证addrinfo获取的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;information of aadrinfo:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;ai_family == AF_INET);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ai_family = AI_INET\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;ai_socktype == SOCK_STREAM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ai_socktype = SOCK_STREAM\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在AF_INET的情况下，sockaddr等同于sockaadr_in，两者内存布局一样</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;<span class="built_in">sin</span>, res-&gt;ai_addr, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ai_addr = %s\n&quot;</span>, inet_ntoa(<span class="built_in">sin</span>.sin_addr));</span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addrlenp)</span><br><span class="line">        *addrlenp = res-&gt;ai_addrlen;</span><br><span class="line">    </span><br><span class="line">    freeaddrinfo(ressave);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (listenfd);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230330122526163.png" alt="image-20230330122526163"></p>
<h4 id="11-4-udp-client-函数"><a href="#11-4-udp-client-函数" class="headerlink" title="11.4 udp_client 函数"></a>11.4 udp_client 函数</h4><p>本节创建一个未连接UDP套接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_client</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sockaddr **saptr, <span class="type">socklen_t</span> *lenp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_client</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sockaddr **saptr, <span class="type">socklen_t</span> *lenp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			sockfd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_DGREAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = getaadrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;udp_client error for %s, %s: %s&quot;</span>,</span><br><span class="line">                host, serv, gai_strerror(n));</span><br><span class="line">    </span><br><span class="line">    ressave = res;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype,</span><br><span class="line">                       res-&gt;ai_protocol);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sockfd &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;udp_client error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    *saptr = (<span class="keyword">struct</span> sockaddr*)<span class="built_in">malloc</span>(res-&gt;ai_addrlen);</span><br><span class="line">    <span class="built_in">memcpy</span>(*saptr, res-&gt;ai_addr, res-&gt;ai_addrlen);</span><br><span class="line">    *lenp = res-&gt;ai_addrlen;</span><br><span class="line">    </span><br><span class="line">    freeaddrinfo(ressave);</span><br><span class="line">    </span><br><span class="line">    retrun (sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议无关的时间获取客户程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			sockfd, n;</span><br><span class="line">    <span class="type">char</span> 			recvline[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">socklen_t</span> 		salen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">sa</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;usage:daytimeupdcil &lt;hostname/IPaddress&gt; &lt;service/port#&gt;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    sockfd = udp_client(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;sa, &amp;salen);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sending to %s\n&quot;</span>, sock_ntop_host(sa, salen));</span><br><span class="line">    </span><br><span class="line">    sendto(sockfd, <span class="string">&quot;&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, sa, salen);</span><br><span class="line">    </span><br><span class="line">    n = recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    recvline[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230330201416346.png" alt="image-20230330201416346"></p>
<h4 id="11-15-udp-connect函数"><a href="#11-15-udp-connect函数" class="headerlink" title="11.15 udp_connect函数"></a>11.15 udp_connect函数</h4><p>udp_connect函数创建一个已连接UDP套接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>					sockfd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> 	<span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_DGRAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = getaadrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">        err_quit(......);</span><br><span class="line">    </span><br><span class="line">    ressave = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktyep, res-&gt;ai_protocol);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        close(sockfd);</span><br><span class="line">    &#125; <span class="keyword">while</span>((res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(....);</span><br><span class="line">    </span><br><span class="line">    freeaddrinfo(ressave);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与未连接的区别，不需要把addrinfo获取的对端地址返回出去了，连接后，后续只需要通过write和read即可</p>
<h4 id="11-16-udp-server函数"><a href="#11-16-udp-server函数" class="headerlink" title="11.16 udp_server函数"></a>11.16 udp_server函数</h4><p>用于简化访问getaddrinfo的最后一个UDP接口函数是udp_server</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_server</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service,</span></span><br><span class="line"><span class="params">              <span class="type">socklen_t</span> *lenp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_server</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname, <span class="type">const</span> <span class="type">char</span> * service,</span></span><br><span class="line"><span class="params">              <span class="type">socklen_t</span> *lenp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 				sockfd, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line">    </span><br><span class="line">    bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_flgas = AI_PASSIVE;</span><br><span class="line">    hints.ai_family = AF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_DGRAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = getaadrinfo(hotsname, service, &amp;hints, &amp;res)) != <span class="number">0</span>) </span><br><span class="line">        err_quit(...);</span><br><span class="line">    </span><br><span class="line">    ressave = res;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        close(sockfd);    </span><br><span class="line">    &#125; <span class="keyword">while</span>((res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(...);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (addrlenp)</span><br><span class="line">        *addrlenp = res-&gt;ai_addrlen;</span><br><span class="line">    </span><br><span class="line">    freeaddrinfo(ressave);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议无关时间获取服务器程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			sockfd;</span><br><span class="line">    <span class="type">ssize_t</span> 		n;</span><br><span class="line">    <span class="type">time_t</span>			ticks;</span><br><span class="line">    <span class="type">char</span>			buff[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span>		len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        sockfd = udp_server(<span class="literal">NULL</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">        sockfd = udp_server(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err_quit(<span class="string">&quot;usage: daytimeudpserv [ &lt;host&gt; ] &lt;service or port&gt; &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        n = recvfrom(sockfd, buff, MAXLIEN, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;lne);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;datagram from %s\n&quot;</span>, sock_ntop((<span class="keyword">struct</span> sockaddr*)&amp;ciladdr, len));</span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">        sendto(sockfd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-17-getnameinfo-函数"><a href="#11-17-getnameinfo-函数" class="headerlink" title="11.17 getnameinfo 函数"></a>11.17 getnameinfo 函数</h4><p>getnameinfo是getaddrinfo的互补函数：它以一个套接口地址为参数，返回描述其中的主机的一个字符串和描述其中服务的另一个字符串。本函数以协议无关的方式提供信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="type">socklen_t</span> addrlen,</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 非0 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>addrlen参数的长度，通常由accept,recvfrom,getsockname或getpeername返回</p>
<p><strong>sock_ntop和getnameinfo的区别</strong>：前者不涉及DNS，单纯返回IP地址和端口号的一个可显示版本，后者通常尝试获取主机和服务的名字</p>
<p><strong>flags的六个标志</strong>:</p>
<p><img src="/./../pic/image-20230330204551248.png" alt="image-20230330204551248"></p>
<p>当知道处理的是数据报套接口时，应设置NI_DGRAM标志，因为getnameinfo无法根据套接口给出的地址和端口号，确定所用协议(tcp or udp)。</p>
<p>设置NI_NAMEREQD，如果无法使用DNS反向解析出主机名，将导致返回一个错误。需要把客户的IP地址映射成主机名的那些服务器可以使用这个特性。</p>
<p>NI_NOFQDN标志导致返回的主机名被截去第一个点号之后的内容。例如aix.unpbook.com，如果设置了本标志，返回的主机名为aix</p>
<p>NI_NUMERICHOST标志告知getnameinfo不要调用DNS，而是以数值表达式格式作为字符串返回IP地址(实现可能为inet_ntop)，NI_NUMERICSERV标志指定以十进制数格式作为字符串返回端口号，以代替查找服务名，NI_NUMERICSOPE标志指定以数值格式作为字符串返回范围标识，以代替其名字。</p>
<p>既然客户的端口号通常没有关联的服务名，它们是临时端口，服务器通常应该设置NI_NUMERICSERV</p>
<h4 id="11-18-可重入函数"><a href="#11-18-可重入函数" class="headerlink" title="11.18 可重入函数"></a>11.18 可重入函数</h4><p>首先指出gethostbyname函数是不可重入函数。原因如下</p>
<p><img src="/./../pic/image-20230330211033616.png" alt="image-20230330211033616"></p>
<p>参考之前APUE对不可重入函数的定义：它们使用静态数据结构</p>
<p>很明显，<strong>static struct hostent host</strong> 符合这一条件</p>
<p>在一个普遍的UNIX进程中发生重入问题的条件是：从它的主控制流中和某个信号处理函数中同时调用不可重入函数(比如此处的gethostbyname或gethostbyaddr)。考虑如下例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    signal(SIGALRM, sig_alrm);</span><br><span class="line">    ...</span><br><span class="line">    hptr = gethostbyname(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    hptr = gethostbyname(...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果主控制流被暂停时正处于执行gethostbyname期间(比如已经填写好host变量准备返回)，由于随后信号处理函数再一次调用gethostbyname，该host变量被重用，原先主控制流计算出的值被重写成了信号处理函数调用计算出的值。</p>
<p><img src="/./../pic/image-20230330211637062.png" alt="image-20230330211637062"></p>
<p>同理ernno变量，存在同样的问题，比如如下例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;close error, errno = %d\n&quot;</span>, errno);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输出errno的值之前，一个信号处理函数被执行，同时执行另一个系统调用发生错误，则由close设置的errno值被覆写</p>
<p>一种解决方法</p>
<p>在信号处理函数，提前保存，返回之前在恢复</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">int</span> 	errno_save;</span><br><span class="line">    errno_save = errno;</span><br><span class="line">    <span class="keyword">if</span> (write(...) != nbytes)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write error, errno = %d\n&quot;</span>, errno);</span><br><span class="line">    errno = errno_save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-19-gethostbyname-r-和-gethostbyaddr-r-函数"><a href="#11-19-gethostbyname-r-和-gethostbyaddr-r-函数" class="headerlink" title="11.19 gethostbyname_r 和 gethostbyaddr_r 函数"></a>11.19 gethostbyname_r 和 gethostbyaddr_r 函数</h4><p>两种将诸如gethostbyname之类不可重入函数改为可重入函数的方法</p>
<ol>
<li>把由不可重入函数填写并返回静态结构的做法改为由调用者分配再由可重入函数填写结构。比如对于gethostbyname来说，调用者需要提供一个填写hostent结构的指针，存放其他信息所用缓冲区，以及该缓冲区大小，以及h_errnop变量存放错误码</li>
<li>由可重入函数调用malloc ( ? )</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyname_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * hostname,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> hostent * result,</span></span><br><span class="line"><span class="params">                                <span class="type">char</span> * buf, <span class="type">int</span> bufflen, <span class="type">int</span> *h_errnop)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyaddr_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * addr, <span class="type">int</span> len, <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> hostent * result,</span></span><br><span class="line"><span class="params">                                <span class="type">char</span> * buf, <span class="type">int</span> bufflen, <span class="type">int</span> *h_errnop)</span>;</span><br><span class="line">	<span class="comment">// 非空指针 -- 成功 NULL -- 出错</span></span><br></pre></td></tr></table></figure>

<p>每个函数都需要4个额外的参数。result参数指向调用者分配并由被调用函数填写的hostent结构</p>
<p>buf参数指向由调用者分配且大小为buflen的缓冲区。如果出错，错误通过h_errnop返回</p>
<h4 id="11-20-作废的IPV6地址解析函数"><a href="#11-20-作废的IPV6地址解析函数" class="headerlink" title="11.20 作废的IPV6地址解析函数"></a>11.20 作废的IPV6地址解析函数</h4><p>在开发IPV6期间，用于查找IPV6地址的API经历了若干次反复。最终在RFC 3493中被简单替换成getaddrinfo和getnameinfo。</p>
<p><strong>RES_UES_INET6常值</strong></p>
<p><img src="/./../pic/image-20230330221555853.png" alt="image-20230330221555853"></p>
<p><strong>gethostbyname2函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyname2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> af)</span>;</span><br><span class="line">	<span class="comment">//非空指针 -- 成功 ， NULL -- 出错，同时设置h_errno</span></span><br></pre></td></tr></table></figure>

<p>当af参数为AF_INET时，gethostbyname2的行为与gethostbyname一样，即查找并返回IPV4地址。当af参数为AF_INET6时，gethostbyname2只查找AAAA记录并返回IPV6地址</p>
<p><strong>getipnodebyname函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">getipnodebyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">int</span> af, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">                                <span class="type">int</span> *error_num)</span>;</span><br><span class="line">	<span class="comment">//非空指针 -- 成功 ， NULL -- 出错，同时设置error_num</span></span><br></pre></td></tr></table></figure>

<p>af和flags参数映射到getaadrinfo的hints.ai_family和hints.ai_flags参数。</p>
<p>为了线程安全，返回值是动态的，因而必须使用freehostent函数释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freehostent</span><span class="params">(<span class="keyword">struct</span> hostent *ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>getidnodebyname和与之匹配的getipnodebyaddr函数被 RFC 3493废除，并代之以getaddrinfo和getnameinfo函数</p>
<h4 id="11-21-其他网络相关信息"><a href="#11-21-其他网络相关信息" class="headerlink" title="11.21 其他网络相关信息"></a>11.21 其他网络相关信息</h4><p>本章主讲主机名和IP地址以及服务名和端口号。总的来看，应用进程可能想要查找四类与网络有关的信息：主机，网络，协议和服务。比如针对主机的gethostbyname和gethostbyaddr，针对服务的getservbyname和getservbyport</p>
<p>每类信息都定义了各自的结构，包括:hostent，netent，protoent和servent</p>
<p><img src="/./../pic/image-20230330223346592.png" alt="image-20230330223346592"></p>
<p>只有主机和网络信息可通过DNS获取，协议和服务信息总是从相应的文件中读取。</p>
<h4 id="11-22-小结"><a href="#11-22-小结" class="headerlink" title="11.22 小结"></a>11.22 小结</h4><p>应用程序用来把主机名转换成IP地址或做相反转换的一组函数被称为解析器。gethostbyname和gethostbyaddr时解析器历史性的入口点。随着IPV6和线程化编程的模型的转移，getaddrinfo和getnameinfo显得更为有用，因为它们既能解析IPV6地址，又符合线程安全。</p>
<p><img src="/./../pic/image-20230330224020866.png" alt="image-20230330224020866"></p>
<h3 id="第14章-高级I-x2F-O函数"><a href="#第14章-高级I-x2F-O函数" class="headerlink" title="第14章 高级I&#x2F;O函数"></a>第14章 高级I&#x2F;O函数</h3><h4 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h4><p>在I&#x2F;O操作上设置超时，有三种方法。read和write这两个函数的三个变体：recv和send(允许通过从它们的第4个参数从进程到内核传递标志)，readv和writev以及recvmsg和sendmsg</p>
<p>考虑如何确定套接口接收缓冲区中的数据量，如何在套接口上使用C的标准I&#x2F;O函数库</p>
<h4 id="14-2-套接口超时"><a href="#14-2-套接口超时" class="headerlink" title="14.2 套接口超时"></a>14.2 套接口超时</h4><p>在涉及套接口I&#x2F;O操作上设置超时的三种方法：</p>
<ol>
<li>调用alarm，产生信号，利用信号处理打断系统调用</li>
<li>调用select，select有内置的时间限制</li>
<li>套接口选项，SO_RCVTIMEO和SO_SNDTIMEO。但并非所有实现都支持这两个套接口选项</li>
</ol>
<p>前两个技术适用于任何描述字，而第三个技术仅仅适用于套接口描述字，且对connect不适用</p>
<p><strong>使用SIGALRM为connect设置超时</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">connect_alarm</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect_timeo</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *saptr, <span class="type">socklen_t</span> salen, <span class="type">int</span> nsec)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sigfunc *sigfunc;</span><br><span class="line">    <span class="type">int</span> 	n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置信号处理函数，并保存原先的handler用于恢复</span></span><br><span class="line">    sigfunc = Signal(SIGALRM, connect_alarm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置报警</span></span><br><span class="line">    <span class="keyword">if</span> (alarm(nsec) != <span class="number">0</span>)</span><br><span class="line">        err_msg(<span class="string">&quot;connect_timeo: alarm was alrady set&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = connect(sockfd, saptr, salen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="comment">//如果是因为系统调用被信号打断，将errno设置为ETIMEDOUT</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            errno = ETIMEDOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    alarm(<span class="number">0</span>);					<span class="comment">/* turn off the alarm */</span></span><br><span class="line">    Signal(SIGALRM, sigfunc);	<span class="comment">/* restore previous signal handler */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">conncet_alarm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两点问题:</p>
<p>1.由于connect的超时通常为75s，此技术可以指定比75s小的值，但指定大于75的值，conncet仍将在75s超时</p>
<p>2.存在一些系统调用返回EINTR时，会重新执行同一个系统调用</p>
<p><strong>使用SIGALRM为recvfrom设置超时</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置handler</span></span><br><span class="line">    Signal(SIGALRM, sig_alrm);</span><br><span class="line">    <span class="keyword">while</span>(Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置警报</span></span><br><span class="line">        alarm(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                err_sys(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alarm(<span class="number">0</span>);</span><br><span class="line">            recvline[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用select为recvfrom设置超时</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待一个描述字变为可读</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readabl_timeo</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> sec)</span></span><br><span class="line">&#123;</span><br><span class="line">    fd_set 		rset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>			<span class="comment">/* 超时时间设置参数 */</span></span><br><span class="line">    </span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    FD_SET(fd, &amp;rset);</span><br><span class="line">    </span><br><span class="line">    tv.tv_sec = sec;</span><br><span class="line">    tc.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (select(fd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv));</span><br><span class="line">    <span class="comment">/* &gt;0 if descriptor is readable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用readable_timeo的dg_cli函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		n;</span><br><span class="line">    <span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaadr, servlen);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Readable_timeo(sockfd, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket timeout\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = Recvfrom(sockfd, recvline, MAXLIEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            recvline[n] = <span class="number">0</span>;</span><br><span class="line">            Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用SO_RCVTIMEO套接口选项为recvfrom设置超时</strong></p>
<p>SO_RCVTIMEO仅适用于读操作，SO_SNDTIMEO仅适用与写操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 	n;</span><br><span class="line">    <span class="type">char</span>	sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    </span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tc.tv_usec = <span class="number">0</span>;</span><br><span class="line">    Setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line">        </span><br><span class="line">        n = recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果I/O操作超时，将返回一个EWOULDBLOCK错误</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;socket timeout\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                err_sys(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        recvline[n] = <span class="number">0</span>;</span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-3-recv和send函数"><a href="#14-3-recv和send函数" class="headerlink" title="14.3 recv和send函数"></a>14.3 recv和send函数</h4><p>类似标准read和write函数，不过需要一个额外的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line">	<span class="comment">//返回：读入或写出字节数 -- 成功 ， -1 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>flags的参数要么为0，要么为下值</p>
<p><img src="/./../pic/image-20230402121054804.png" alt="image-20230402121054804"></p>
<p><img src="/./../pic/image-20230402121604291.png" alt="image-20230402121604291"></p>
<p>flags参数设计成值传递，而不是值-结果参数，因此只能从进程向内核，而不能把内核的标志传回来。后续提出了这个需求，但没有改变这个函数的参数，将这个需求加入了recvmsg和sendmsg所用的msghdr结构。该结构新增了一个整数msg_flags成员。</p>
<h4 id="14-4-readv和writev函数"><a href="#14-4-readv和writev函数" class="headerlink" title="14.4 readv和writev函数"></a>14.4 readv和writev函数</h4><p>readv和writev允许单个系统调用读入到或写出自一个或多个缓冲区。分散读和集中写，将读操作的数据分散到多个应用缓冲区，将多个应用缓冲区的数据提供给单个写操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="type">ssizr_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line">	<span class="comment">//返回: 读入或写出字节数 -- 成功 ， -1 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//struct iovec</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base;			<span class="comment">/* starting address of buffer */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;			<span class="comment">/* size of buffer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第2个参数指向某个iovec结构数组的一个指针，iovcnt应该是这个数组元素的数量</p>
<p>readv和writev这两个函数可用于任何描述字，而不仅限于套接口。另外writev是一个原子操作</p>
<h4 id="14-5-recvmsg和sendmsg函数"><a href="#14-5-recvmsg和sendmsg函数" class="headerlink" title="14.5 recvmsg和sendmsg函数"></a>14.5 recvmsg和sendmsg函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line">	<span class="comment">//返回: 读入或写出字节数 -- 成功 ， -1 -- 出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//msghdr结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> 		*msg_name;			<span class="comment">/* protocol address */</span></span><br><span class="line">    <span class="type">socklen_t</span> 	msg_namelen;		<span class="comment">/* size of protocol address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>			<span class="comment">/* scatter/gather array */</span></span><br><span class="line">    <span class="type">int</span> 		msg_iovlen;			<span class="comment">/* elements in msg_iov */</span></span><br><span class="line">    <span class="type">void</span> 		*msg_control;		<span class="comment">/* ancillary data (cmsghdr struct) */</span></span><br><span class="line">    <span class="type">socklen_t</span> 	msg_controllen;		<span class="comment">/*length of ancillary data */</span></span><br><span class="line">    <span class="type">int</span> 		msg_flags;			<span class="comment">/* flags returned by recvmsg */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>msg_name和msg_namelen参数，类似于recvfrom和sendto的第5和第6参数，适用于套接口未连接的场合（如未连接UDP套接口）。对于已连接UDP套接口或TCP套即口，应置为空指针</p>
<p>msg_iov和msg_iovlen参数，类似readv和writev的第2和第3参数</p>
<p>msg_contorl和msg_controllen指定可选的辅助数据的位置和大小。见14.6</p>
<p>对于函数参数中的flags和结构中的msg_flags参数，flags参数由sendmsg直接使用，sendmsg忽略msg_flags成员。msg_flags成员由recvmsg使用，recvmsg调用时，flags参数被拷贝到msg_flags成员。内核还依据recvmsg的结果更新其值。</p>
<p>flags参数解释见p336</p>
<p><img src="/./../pic/image-20230402140900487.png" alt="image-20230402140900487"></p>
<h4 id="14-6-辅助数据"><a href="#14-6-辅助数据" class="headerlink" title="14.6 辅助数据"></a>14.6 辅助数据</h4><p>辅助数据可通过调用sendmsg和recvmsg这两个函数，使用msghdr结构中的msg_control和msg_controllen这两个成员发送和接收。</p>
<p>辅助数据的各种用途见下图:</p>
<p><img src="/./../pic/image-20230402141110761.png" alt="image-20230402141110761"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">    <span class="type">socklen_t</span> 		cmsg_len;	<span class="comment">/* length in bytes, including this structure */</span></span><br><span class="line">    <span class="type">int</span> 			cmsg_level;	<span class="comment">/* roiginating protocol */</span></span><br><span class="line">    <span class="type">int</span> 			cmsg_type;	<span class="comment">/* protocol-specific type */</span></span><br><span class="line">     <span class="comment">/* followed by unsigned char cmsg_data[] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于recvmsg返回的辅助数据可含有任意数目的辅助数据对象，为了对应用程序屏蔽可能出现的填充文字，头文件种定义了以下5个宏，以简化对辅助数据的对处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> cmsghdr * <span class="title function_">CMSG_FIRSTHDR</span><span class="params">(<span class="keyword">struct</span> msghdr *mhdrptr)</span>;</span><br><span class="line">	<span class="comment">//返回:指向第一个cmsghdr结构的指针，无辅助数据时为NULL</span></span><br><span class="line"><span class="keyword">struct</span> cmsghdr * <span class="title function_">CMSG_NXTHDR</span><span class="params">(<span class="keyword">struct</span> msghdr *mhdrptr, <span class="keyword">struct</span> cmsghdr *cmsgptr)</span>;</span><br><span class="line">	<span class="comment">//返回:指向下一个cmsghdr结构的指针，不再有辅助数据对象时为NULL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * <span class="title function_">CMSG_DATA</span><span class="params">(<span class="keyword">struct</span> cmsghdr *cmsgptr)</span>;</span><br><span class="line">	<span class="comment">//返回:指向与cmsghdr结构关联的数据的第一个字节的指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">CMSG_LEN</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> lenght)</span>;</span><br><span class="line">	<span class="comment">//返回:给定数据量下存放到cmsg_len中的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">CMSG_SPACE</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> lenght)</span>;</span><br><span class="line">	<span class="comment">//返回:给定数据量下一个辅助数据对象总的大小</span></span><br></pre></td></tr></table></figure>

<p>CMSG_LEN和CMSG_SPACE的区别：前者不考虑数据部分之后可能填充的字节，返回的时存放在cmsg_len中的值，后者计上结尾处可能的填充字节</p>
<h4 id="14-7-排队的数据量"><a href="#14-7-排队的数据量" class="headerlink" title="14.7 排队的数据量"></a>14.7 排队的数据量</h4><p>有时我们想要在不真正读取数据的前提下直到一个套接口上已有多少数据排队等着读取。</p>
<ol>
<li>如果我们获悉已排队数据量的目的在于避免读操作阻塞在内核中，可以使用非阻塞I&#x2F;O</li>
<li>如果我们既想查看数据，又想数据留在接收队列中以供本进程其他部分稍后读取，可以使用MSG_PEEK标志(图14.6)</li>
<li>一些实现支持ioctl的FIONREAD命令。该命令的第3个ioctl参数是指向某个整数的一个指针，内核通过该整数返回的值就是套接口接收队列的当前字节数。</li>
</ol>
<p>p342</p>
<h4 id="14-8-套接口和标准I-x2F-O"><a href="#14-8-套接口和标准I-x2F-O" class="headerlink" title="14.8 套接口和标准I&#x2F;O"></a>14.8 套接口和标准I&#x2F;O</h4><p>标准I&#x2F;O函数库可用于套接口，不过需要考虑以下几点:</p>
<ol>
<li>通过调用fdopen函数，为描述字创建一个标准I&#x2F;O流。</li>
<li>TCP和UDP套接口是全双工的。标准I&#x2F;O流也是，只要以r+类型打开流即可。但是在这样的流上，输入和输出操作之间必须要有fflush，fseek，fsetpos或rewind其中一个，但问题是，它们都会调用lseek，而lseek在套接口上会失败</li>
<li>解决上述问题最简单的方法，为一个给定套接口，打开两个标准I&#x2F;O流：一个用于读，一个用于写</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准I/O重写图5.3的TCP回射服务器程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> 	line[MAXLINE];</span><br><span class="line">    FILE 	*fpin, *fpout;</span><br><span class="line">    </span><br><span class="line">    fpin = Fdopen(sockfd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fpout = Fdopen(sockfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(lien, MAXLINE, fpin) != <span class="literal">NULL</span>)</span><br><span class="line">        Fputs(line, fpout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">hputx % tcp cli02 <span class="number">206.168</span><span class="number">.112</span><span class="number">.96</span></span><br><span class="line">hello, world			键入本行，但无回射输出</span><br><span class="line">and hi					再键入本行，仍无回射输出</span><br><span class="line">hello??					再键入本行，仍无回射输出</span><br><span class="line">^D						键入EOF字符</span><br><span class="line">hello,world				至此才输出那三个回射行</span><br><span class="line">and hi		</span><br><span class="line">hello??</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230402144635544.png" alt="image-20230402144635544"></p>
<p>问题出去，标准I&#x2F;O执行缓冲的策略上。标准I&#x2F;O执行以下三类缓冲:</p>
<ol>
<li>完全缓冲：缓冲区满，进程显示调用fflush或者进程调用exit终止自身</li>
<li>行缓冲：碰到一个换行符，进程调用fflush或者进程调用exit终止自身</li>
<li>不缓冲：每次调用标准I&#x2F;O都发生I&#x2F;O</li>
</ol>
<p>标准I&#x2F;O函数库的大多数Unix实现使用如下规则：</p>
<ol>
<li>标准错误输出总是不缓冲</li>
<li>标准输入和标准输出是完全缓冲，除非它们指代终端设备，这种情况下行缓冲</li>
<li>所有其他I&#x2F;O流都是完全缓冲，除非它们指代终端设备，这种情况下行缓冲</li>
</ol>
<p>套接口不是终端设备，所以完全缓冲。解决方法：1.调用setvbuf迫使这个输出流变成行缓冲。2.显示调用fflush</p>
<h4 id="14-9-高级轮询技术"><a href="#14-9-高级轮询技术" class="headerlink" title="14.9 高级轮询技术"></a>14.9 高级轮询技术</h4><p><strong>&#x2F;dev&#x2F;poll 接口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dvpoll</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 	*<span class="title">dp_fds</span>;</span></span><br><span class="line">    <span class="type">int</span> 			dp_nfds;</span><br><span class="line">    <span class="type">int</span> 			dp_timeout;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dp_fds指向一个缓冲区，供ioctl返回时存放一个pollfd结构数组。</span><br><span class="line">dp_nfds指定该缓冲区的大小</span><br><span class="line">dp_timeout指定超时，非阻塞，和不设置超时(一直阻塞)</span><br><span class="line"></span><br><span class="line"><span class="comment">//图6.13 select的str_cli函数重写为使用/dev/poll的版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/devpoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 				stdineof;</span><br><span class="line">    <span class="type">char</span>				buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> 				n;</span><br><span class="line">    <span class="type">int</span> 				wfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>		<span class="title">pollfd</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dvpoll</span>		<span class="title">dopoll</span>;</span></span><br><span class="line">    <span class="type">int</span>					i;</span><br><span class="line">    <span class="type">int</span> 				result;</span><br><span class="line">    </span><br><span class="line">    wfd = Open(<span class="string">&quot;/dev/poll&quot;</span>, O_RDWR, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    pollfd[<span class="number">0</span>].fd = fileno(fp);</span><br><span class="line">    pollfd[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    pollfd[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    pollfd[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">    pollfd[<span class="number">1</span>].events = POLLIN;</span><br><span class="line">    pollfd[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Write(wfd, pollfd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd)*<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    stdineof = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* block until /dev/poll says something is ready */</span></span><br><span class="line">        dopoll.dp_timeout = <span class="number">-1</span>;</span><br><span class="line">        dopoll.dp_nfds = <span class="number">2</span>;</span><br><span class="line">        dopoll.dp_fds = pollfd;</span><br><span class="line">        result = Ioctl(wfd, DP_POLL, &amp;dopoll);</span><br><span class="line">        </span><br><span class="line">        FOR (i = <span class="number">0</span>; i &lt; result; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dopoll.dp_fds[i].fd == sockfd) &#123;</span><br><span class="line">                <span class="comment">/* socket is readable */</span></span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* input is readable */</span></span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>kqueue接口</strong></p>
<p>kqueue是一个用于异步事件通知的系统调用，最初由FreeBSD开发。它可以监视文件描述符、定时器和信号等事件，并在这些事件发生时通知进程。相比于传统的轮询方式，kqueue能够提供更高效的事件处理机制 – GPT3</p>
<p>本接口允许进程向内核注册描述所关注kqueue时间的事件过滤器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kqueue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kevent</span><span class="params">(<span class="type">int</span> kq, <span class="type">const</span> <span class="keyword">struct</span> kevent *changelist, <span class="type">int</span> nchanges,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> kevent *eventlist, <span class="type">int</span> nevents.</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EV_SET</span><span class="params">(<span class="keyword">struct</span> kevent *kev, <span class="type">uintptr_t</span> ident, <span class="type">short</span> filter,</span></span><br><span class="line"><span class="params">           u_short flags, u_int fflags, <span class="type">intptr_t</span> data, <span class="type">void</span> *udata)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct kevent</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> &#123;</span></span><br><span class="line">    <span class="type">uintptr_t</span> 	ident; 			<span class="comment">/* identifier (e.g, file descriptor) */</span></span><br><span class="line">    <span class="type">short</span> 		filter;			<span class="comment">/* filter type (e.g, EVFILT_READ) */</span></span><br><span class="line">    u_short 	flags;			<span class="comment">/* action flags (e.g, EV_ADD) */</span></span><br><span class="line">    u_int 		fflags;			<span class="comment">/* filter-specific flags */</span></span><br><span class="line">    <span class="type">intptr_t</span>	data;			<span class="comment">/* filter-specific data */</span></span><br><span class="line">    <span class="type">void</span> 		*udata;			<span class="comment">/* opaque user data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kevent函数通过eventlist参数返回</p>
<p><img src="/./../pic/image-20230402152351855.png" alt="image-20230402152351855"></p>
<p><img src="/./../pic/image-20230402152401524.png" alt="image-20230402152401524"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图6.13 select的str_cli函数重写使用kqueue版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		kq, i, n, nev, stdineof = <span class="number">0</span>, isfile;</span><br><span class="line">    <span class="type">char</span> 		buf[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> 	<span class="title">kev</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>		<span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    isfile = ((fstat(fileno(fp), &amp;st) == <span class="number">0</span>) &amp;&amp; (st.st_mode &amp; S_IFMT) == S_IFREG);</span><br><span class="line">    </span><br><span class="line">    EV_SET(&amp;kev[<span class="number">0</span>], fileno(fp), EVFILT_READ, EV_ADD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    EV_SET(&amp;kev[<span class="number">1</span>], sockfd, EVFILT_READ, EV_ADD, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    kq = Kqueue();</span><br><span class="line">    ts.tv_sec = ts.tv_nsec = <span class="number">0</span>;</span><br><span class="line">    Kevent(kq, kev, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ts);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        nev = Kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, kev, <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nev; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kev[i].ident == sockfd) &#123; <span class="comment">/* socket is readable */</span></span><br><span class="line">                <span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        err_quit(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                write(fileno(<span class="built_in">stdout</span>), buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (kev[i].ident == fileno(fp)) &#123; <span class="comment">/* input is readable */</span></span><br><span class="line">                n = read(fileno(fp), buf, MAXLINE);</span><br><span class="line">                <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">                    writen(sockfd, buf, n);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (n ==<span class="number">0</span> || (isfile &amp;&amp; n == kev[i].data)) &#123;</span><br><span class="line">                    stdineof = <span class="number">1</span>;</span><br><span class="line">                    shutdown(sockfd, SHUR_WR);			<span class="comment">/* send FIN */</span></span><br><span class="line">                    kev[i].flags = EV_DELETE;</span><br><span class="line">                    Kevent(kq, &amp;kev[i],<span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ts);<span class="comment">/* remove kevent */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-10-T-x2F-TCP-事务目的TCP"><a href="#14-10-T-x2F-TCP-事务目的TCP" class="headerlink" title="14.10 T&#x2F;TCP:事务目的TCP"></a>14.10 T&#x2F;TCP:事务目的TCP</h4><p>T&#x2F;TCP是对TCP的一个略微修改版本，能够避免近来彼此通信过的主机之间的三路握手。</p>
<p><img src="/./../pic/image-20230402181714414.png" alt="image-20230402181714414"></p>
<p>为了处理T&#x2F;TCP，套接口API需做些变动:</p>
<ol>
<li>客户调用sendto把数据的发送结合到连接的建立之中。该调用替换分离的connect和write调用。服务器的协议地址改为传递给sendto而不是connect</li>
<li>新增一个输出标志MSG_EOF，用于指示本套接口上不再有数据待发送。该标志允许我们把shutdown调用结合到输出操作(sendto或send)之中。给一个sendto调用同时指定本标志和服务器的协议地址有可能导致发送单个含有SYN,FIN和数据的分节。使用send而不是write也是为了设置该标志。</li>
<li>新定义一个级别为IPPROTO_TCP的套接口选项TCP_NOPUSH。放置TCP为腾空套接口发送缓冲区而发送分节。当某个客户准备以单个sendto发送一个请求，该请求大小超过MSS时，就需要设置本选项。</li>
<li>想使用T&#x2F;TCP建立连接的化，客户应调用socket, setsockopt(开启TCP_NOPUSH选项)和sendto(若只有一个请求待发送则指定MSG_EOF标志)。如果setsockopt返回ENOPROTOOPT错误或者sendto返回ENOTCONN错误，那么本机不支持T&#x2F;TCP。这种情况下考虑直接使用普通的TCP，connect+write</li>
<li>服务器的唯一变动，如果服务器想随应答一起发送FIN，它应该指定MSG_EOF标志调用send以发送，而不是调用write发送应答。</li>
</ol>
<h4 id="14-11-小结"><a href="#14-11-小结" class="headerlink" title="14.11 小结"></a>14.11 小结</h4><p>在套接口上设置时间限制的三种方法</p>
<p>五组I&#x2F;O函数：read&#x2F;write , recvfrom&#x2F;sendto, recv&#x2F;send, recvmsg&#x2F;sendmsg, readv&#x2F;writev。本节主讲了后三种</p>
<p>10种不同的辅助数据。</p>
<p>标准I&#x2F;O函数库在套接口上的使用</p>
<p>高级轮询技术，kqueue和&#x2F;dev&#x2F;poll接口</p>
<p>TCP的一个简单增强版，T&#x2F;TCP，避免三路握手，减少了分节数量</p>
<h3 id="第16章-非阻塞I-x2F-O"><a href="#第16章-非阻塞I-x2F-O" class="headerlink" title="第16章 非阻塞I&#x2F;O"></a>第16章 非阻塞I&#x2F;O</h3><h4 id="16-1-概述"><a href="#16-1-概述" class="headerlink" title="16.1 概述"></a>16.1 概述</h4><p>套接口缺省是阻塞的。意味着发出一个不能立即完成的套接口调用时，其进程将被投入睡眠，等待响应操作完成。可能阻塞套接口的调用分为以下四类：</p>
<p>1.输入操作：read, readv, recv, recvfrom 和 recvmsg5个函数。对于非阻塞的套接口，如果输入操作不能被满足，相应调用将立即返回一个EWOULDBLOCK错误。</p>
<p>2.输出操作：write, writev, send, sendto 和 sendmsg5个函数。对于阻塞的套接口，如果其发送缓冲区种没有空间，进程将被投入睡眠，直到有空间为止。对于非阻塞的套接口，如果没有空间，立即返回一个EWOULDBLOCK错误。</p>
<p>3.接受外来连接：accept函数。对阻塞调用，并且无新连接到达，调用进程将睡眠。对非阻塞调用，五新连接到达，立即返回一个EWOULDBLOCK错误。</p>
<p>4.发起外出连接：connect函数。由于三路握手需求等待对端的ACK应答，所以connect总是阻塞调用进程至少一个到服务器的RTT时间。如果对非阻塞TCP套接口调用，并且连接不能立即建立，连接的建立照样发起，不过返回一个EINPROGRESS错误。可以立即建立的连接：通常发生在服务器和客户处于同一个主机的情况。</p>
<h4 id="16-2-非阻塞读和写：str-cli函数-修订版"><a href="#16-2-非阻塞读和写：str-cli函数-修订版" class="headerlink" title="16.2 非阻塞读和写：str_cli函数(修订版)"></a>16.2 非阻塞读和写：str_cli函数(修订版)</h4><p>维护两个缓冲区:</p>
<p><img src="/./../pic/image-20230404194558924.png" alt="image-20230404194558924"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024  </span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">gf_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[<span class="number">30</span>];</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tv, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;gettimeofday error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ptr = ctime(&amp;tv.tv_sec);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, &amp;ptr[<span class="number">11</span>]);</span><br><span class="line">    <span class="comment">/* Fri Sep 13 00:00:00 1986\n\0*/</span></span><br><span class="line">    <span class="comment">/* 012345678901234567890123 4 5*/</span></span><br><span class="line">    <span class="built_in">snprintf</span>(str+<span class="number">8</span>, <span class="keyword">sizeof</span>(str)<span class="number">-8</span>, <span class="string">&quot;.%06ld&quot;</span>, tv.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* gf_time 函数返回一个当前时间的字符串 格式如下*/</span></span><br><span class="line">    <span class="comment">/* 12:34:56.123456*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>                 maxfdp1, val, stdineof;</span><br><span class="line">    <span class="type">ssize_t</span>             n, nwritten;</span><br><span class="line">    fd_set              rset, wset;</span><br><span class="line">    <span class="type">char</span>                to[MAXLINE], fr[MAXLINE];</span><br><span class="line">    <span class="type">char</span>                *toiptr, *tooptr, *friptr, *froptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//設置非阻塞</span></span><br><span class="line">    val = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    fcntl(sockfd, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    val = fcntl(STDIN_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    fcntl(STDIN_FILENO, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    val = fcntl(STDOUT_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    fcntl(STDOUT_FILENO, F_SETFL, VAL | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    toiptr = tooptr = to;</span><br><span class="line">    friptr = froptr = fr;</span><br><span class="line">    stdineof = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    maxfdp1 = max(max(STDIN_FILENO, STDOUT_FILENO), sockfd) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;rset);</span><br><span class="line">        FD_ZERO(&amp;wset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stdineof == <span class="number">0</span> &amp;&amp; toiptr &lt; &amp;to[MAXLINE])</span><br><span class="line">            FD_SET(STDIN_FILENO, &amp;rset);    <span class="comment">/*  从标准输入读数据 */</span></span><br><span class="line">        <span class="keyword">if</span> (friptr &lt; &amp;fr[MAXLINE])</span><br><span class="line">            FD_SET(sockfd, &amp;rset);          <span class="comment">/* 从套接字读数据 */</span></span><br><span class="line">        <span class="keyword">if</span> (tooptr != toiptr)           </span><br><span class="line">            FD_SET(sockfd, &amp;wset);          <span class="comment">/* 数据输出到套接字 */</span></span><br><span class="line">        <span class="keyword">if</span> (froptr != friptr)           </span><br><span class="line">            FD_SET(STDOUT_FILENO, &amp;wset);   <span class="comment">/* 数据输出到标准输出 */</span></span><br><span class="line"></span><br><span class="line">        select(maxfdp1, &amp;rset, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = read(STDIN_FILENO, toiptr, &amp;to[MAXLINE]-toiptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                    err_sys(<span class="string">&quot;read error on stdin&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: EOF on stdin\n&quot;</span>, gf_time());</span><br><span class="line">                stdineof = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (tooptr == toiptr)</span><br><span class="line">                    shutdown(sockfd, SHUT_WR);  <span class="comment">/* send FIN */</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: read %d bytes from stdin\n&quot;</span>, gf_time(), n);</span><br><span class="line">                toiptr += n;</span><br><span class="line">                <span class="comment">//此处调用FD_SET 使得在本循环内对应位测试为真，即FD_ISSET测试成功，执行对应操作</span></span><br><span class="line">                FD_SET(sockfd, &amp;wset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = read(sockfd, friptr, &amp;fr[MAXLINE]-friptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                    err_sys(<span class="string">&quot;read error on socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;EOF on socket&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (stdineof)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    err_quit(<span class="string">&quot;str_cli:server terminated prematurely&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:read %d bytes from socket\n&quot;</span>, gf_time(), n);</span><br><span class="line">                friptr += n;</span><br><span class="line">                FD_SET(STDOUT_FILENO, &amp;wset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDOUT_FILENO, &amp;wset) &amp;&amp; ((n = friptr - froptr) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nwritten = write(STDOUT_FILENO, froptr, n)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                    err_sys(<span class="string">&quot;write error on stdout&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: wrote %d bytes to stdout\n&quot;</span>, gf_time(), nwritten);</span><br><span class="line">                froptr += nwritten;</span><br><span class="line">                <span class="keyword">if</span> (froptr == friptr)</span><br><span class="line">                    froptr = friptr = fr; <span class="comment">/* back to beginning of buffer */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;wset) &amp;&amp; ((n = toiptr - tooptr) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nwritten = write(sockfd, tooptr, n)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                    err_sys(<span class="string">&quot;write error to socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: wrote %d bytes to socket\n&quot;</span>,gf_time(), nwritten);</span><br><span class="line">                tooptr += nwritten;</span><br><span class="line">                <span class="keyword">if</span> (tooptr == toiptr) &#123;</span><br><span class="line">                    toiptr = tooptr = to;               <span class="comment">/* back to beginning of buffer */</span></span><br><span class="line">                    <span class="keyword">if</span> (stdineof)</span><br><span class="line">                        shutdown(sockfd, SHUT_WR);      <span class="comment">/* send FIN */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>str_cli的较简单版本</strong></p>
<p>与代码的复杂性相比，使用非阻塞I&#x2F;O的方式不值得。当需要使用非阻塞I&#x2F;O时，更简单的办法通常是把应用程序任务划分到多个进程(fork或多线程)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* child: server-&gt;stdout */</span></span><br><span class="line">        <span class="keyword">while</span> (readline(sockfd, recvline, MAXLINE) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="comment">/* in case parent still running */</span></span><br><span class="line">        kill(getppid(), SIGTERM;)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parent: stdin-&gt;server */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">        writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">    shutdown(sockfd, SHUT_WR);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230404195046989.png" alt="image-20230404195046989"></p>
<p><strong>str_cli执行时间</strong></p>
<p><img src="/./../pic/image-20230404195246639.png" alt="image-20230404195246639"></p>
<p>&#96;&#96;</p>
<h4 id="16-3-非阻塞connect"><a href="#16-3-非阻塞connect" class="headerlink" title="16.3 非阻塞connect"></a><strong>16.3 非阻塞connect</strong></h4><p>当一个非阻塞的TCP套接口上调用connect时，connect将立即返回一个EINPROGRESS错误，不过已经发起的三路握手继续进行。接着使用select检测这个连接或成功或失败的已建立条件。非阻塞connect的三个用途：</p>
<p><img src="/./../pic/image-20230404195920427.png" alt="image-20230404195920427"></p>
<p>非阻塞connect需要处理的细节：</p>
<ol>
<li>如果连接的服务器在同一个主机上，调用connect时，连接通常立刻建立，需要处理这种情况</li>
<li>关于select和非阻塞connect的以下两个规则 a) 当连接建立成功时，描述字变为可写 b) 当连接建立遇到错误时，描述字变为既可读又可写</li>
</ol>
<h4 id="16-4-非阻塞connect-时间获取客户程序"><a href="#16-4-非阻塞connect-时间获取客户程序" class="headerlink" title="16.4 非阻塞connect:时间获取客户程序"></a>16.4 非阻塞connect:时间获取客户程序</h4><p>将图1.5的connect调用替换成 <code>if (connect_nonb(sockfd, (SA*)&amp;servaddr, sizeof(servaddr),0) &lt;0)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> sockaddr SA</span><br><span class="line"><span class="type">int</span> <span class="title function_">connect_nonb</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> SA *saptr, <span class="type">socklen_t</span> salen, <span class="type">int</span> nsec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		flags, n, error;</span><br><span class="line">    <span class="type">socklen_t</span> 	len;</span><br><span class="line">    fd_set		rset, wset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tval</span>;</span></span><br><span class="line">    </span><br><span class="line">    flags = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">    </span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((n = connect(sockfd, saptr, salen)) &lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (errno != EINPROGRESS)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* do whatever we want while the connect is taking place */</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> done;	<span class="comment">/* connect completed immediately */</span></span><br><span class="line">    </span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    FD_SET(sockfd, &amp;rset);</span><br><span class="line">    wset = rset;</span><br><span class="line">    tval.tv_Sec = nsec;</span><br><span class="line">    tval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((n = select(sockfd+<span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, </span><br><span class="line">                   nsec ? &amp;tval : <span class="literal">NULL</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        close(sockfd);			<span class="comment">/* timeout */</span></span><br><span class="line">        errno = ETIMDOUT;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset)) &#123;</span><br><span class="line">        len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">        <span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        err_quit(<span class="string">&quot;select error:sockfd not set&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    done:</span><br><span class="line">    fcntl(sockfd, F_SETFL, flags);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        close(sockfd);</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>被中断的connect</strong></p>
<p>对于一个正常的阻塞式套接口，如果其上的connect调用在TCP三路握手中被中断。假设被中断的connect调用不由内核自动重启，它将返回EINTR。我们不能再次调用connect等待未完成的连接继续完成。这样做将导致返回EADDRINUSE错误。</p>
<p>这种情况下只能调用select，就像本节这样对于非阻塞connect所作的那样。连接建立成功时select返回套接口可写条件，连接建立失败时select返回套接口既可读又可写条件。</p>
<h4 id="16-5-非阻塞connect-Web客户程序"><a href="#16-5-非阻塞connect-Web客户程序" class="headerlink" title="16.5 非阻塞connect: Web客户程序"></a>16.5 非阻塞connect: Web客户程序</h4><p>web程序出自13.4节，13章跳过了，本小节也先跳过。</p>
<h4 id="16-6-非阻塞accept"><a href="#16-6-非阻塞accept" class="headerlink" title="16.6 非阻塞accept"></a>16.6 非阻塞accept</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立连接并发送一个RST的TCP回射客户程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 7777</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">ling</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        perror(<span class="string">&quot;usage: tcpcli&lt;IPaddress&gt; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    ling.l_onoff = <span class="number">1</span>;</span><br><span class="line">    ling.l_linger = <span class="number">0</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_LINGER, &amp;ling, <span class="keyword">sizeof</span>(ling));</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的目的在于，建立连接后，发送一个RST，随后关闭该套接口</p>
<p>接着修改服务器程序部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FD_ISSET(listenfd, &amp;rset)) &#123;</span><br><span class="line">+   <span class="built_in">printf</span>(<span class="string">&quot;listening socket readable\n&quot;</span>);</span><br><span class="line">+   sleep(<span class="number">5</span>);</span><br><span class="line">    clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, clilen);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+行为图6.21和图6.22不同的新增行，意在模拟一个繁忙的TCP服务器，该服务器无法在收到select的可读条件后立马调用accept，结合上图发送一个RST的TCP回射客户程序，就会出现如下情况：</p>
<ol>
<li>客户如上图，建立一个连接并随后夭折它</li>
<li>select像服务器进程返回到调用accept期间，服务器TCP收到来自客户的RST</li>
<li>这个已完成的连接被服务器TCP驱除出队列，假设队列中没有其他已完成的连接</li>
<li>服务器调用accept，但是由于没有任何已完成的连接，服务器于是阻塞。</li>
</ol>
<p>服务器会一直阻塞在accept调用上，直到其他客户建立连接位置。在此期间，服务器无法处理任何其他已就绪的描述字，因为被accept调用所阻塞。</p>
<p>解决方法如下：</p>
<ol>
<li>当使用select获悉某个监听套接口上何时有已完成的连接准备好被accept时，将这个监听套接口设置为非阻塞。</li>
<li>在后续的accept调用中忽略以下错误：EWOULDBLOCK，ECONNABORTED，EPROTO，EINTR</li>
</ol>
<h4 id="16-7-小结"><a href="#16-7-小结" class="headerlink" title="16.7 小结"></a>16.7 小结</h4><p>select结合非阻塞I&#x2F;O一起使用，以便判断描述字何时可写可读。由此写出了所有str_cli版本中，执行速度最快的，但其代码同样也是最复杂的。使用fork，来替代非阻塞I&#x2F;O是个更好的选择。</p>
<p>非阻塞connect使得我们能够在TCP三路握手之间，做其他处理，而不光是阻塞在connect上。但非阻塞connect不可移植，不同的实现有不同的手段指示连接建立已成功完成或已碰到错误。使用非阻塞connect开发了一个新型客户程序，Web客户程序.</p>
<h3 id="第26章-线程"><a href="#第26章-线程" class="headerlink" title="第26章 线程"></a>第26章 线程</h3><h4 id="26-1-概述"><a href="#26-1-概述" class="headerlink" title="26.1 概述"></a>26.1 概述</h4><p>详细的在apue里已经讲过了，这节算是线程方面的一些基础，线程的创建和销毁设置分离，简单的线程控制，互斥锁和条件变量的使用，以及使用线程代替非阻塞connect</p>
<h4 id="26-2-基本线程函数-创建和终止"><a href="#26-2-基本线程函数-创建和终止" class="headerlink" title="26.2 基本线程函数: 创建和终止"></a>26.2 基本线程函数: 创建和终止</h4><p><strong>pthread_create函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*func)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>tid 返回创建的线程id，attr为线程属性，func线程处理函数，arg传递给线程处理函数的参数</p>
<p>线程属性等详细见apue</p>
<p><strong>pthread_join函数</strong></p>
<p>等待一个给定线程终止。对比线程，pthread_create类似于fork，pthread_join类似于waitpid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **status)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>status为线程返回值</p>
<p><strong>pthread_self函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthrad.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">	<span class="comment">//返回调用线程的线程ID</span></span><br></pre></td></tr></table></figure>

<p>类似于getpid</p>
<p><strong>pthread_detach函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>简单来说，设置线程分离后，该线程不需要我们在手动回收(pthread_join)，线程终止时，会将相关资源都释放</p>
<p><strong>pthread_exit函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *status)</span>;</span><br><span class="line">	<span class="comment">//不返回到调用者</span></span><br></pre></td></tr></table></figure>

<p>让一个线程终止的方法之一。</p>
<p>让一个线程终止的另两种方法:</p>
<ol>
<li>启动线程的函数可以返回。</li>
<li>进程main函数返回或者任何线程调用exit，整个进程终止。</li>
</ol>
<h4 id="26-3-使用线程的str-cli函数"><a href="#26-3-使用线程的str-cli函数" class="headerlink" title="26.3 使用线程的str_cli函数"></a>26.3 使用线程的str_cli函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unpthread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">copyto</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sockfd;			<span class="comment">/* global for both threads to access */</span></span><br><span class="line"><span class="type">static</span> FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp_arg, <span class="type">int</span> sockfd_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> 			recvline[MAXLINE];</span><br><span class="line">    <span class="type">pthread_t</span> 		tid;</span><br><span class="line">    </span><br><span class="line">    sockfd = sockfd_arg;</span><br><span class="line">    fp = fp_arg;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, copyto, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Readline(sockfd, recvline, MAXLINE) &gt; <span class="number">0</span>)</span><br><span class="line">        Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">copyto</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> 		sendline[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">        Writen(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">    </span><br><span class="line">    Shutdonw(sockfd, SHUT_WR);			<span class="comment">/* EOF on stdin, send FIN */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="26-4-使用线程的TCP回射服务器程序"><a href="#26-4-使用线程的TCP回射服务器程序" class="headerlink" title="26.4 使用线程的TCP回射服务器程序"></a>26.4 使用线程的TCP回射服务器程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unpthread.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> 		addrlen, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> 		tid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        listenfd = Tcp_listen(<span class="literal">NULL</span>, argv[<span class="number">1</span>], &amp;addrlen);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">        listenfd = Tcp_listen(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;addrlen);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err_quit(<span class="string">&quot;usage: tcpserv01 [&lt;host&gt;] &lt;service or port&gt; &quot;</span>);</span><br><span class="line">    cliaddr = Malloc(addrlen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        len = addrlen;</span><br><span class="line">        connfd = Accept(listenfd, cliaddr, &amp;len);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;doit, (<span class="type">void</span>*)connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    str_echo((<span class="type">int</span>)arg);				<span class="comment">/* same function as before */</span></span><br><span class="line">    CLose((<span class="type">int</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>给线程传递参数</strong></p>
<p>注意不能简单地把connfd的地址传递给新线程，如下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> 		listenfd, connfd;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        len = addrlen;</span><br><span class="line">        connfd = Accept(listenfd, cliaddr, &amp;len);</span><br><span class="line">        Phthrea_create(&amp;tid, <span class="literal">NULL</span>, &amp;doit, &amp;connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		connfd;</span><br><span class="line">    connfd = *((<span class="type">int</span>*)arg);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    str_echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于connfd指向同一块地址，connfd的值会受Accept的影响发生变动，要么使用最开始的直接传值的方式，要么对每个线程分配一块空间，再由线程释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unpthread.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			listenfd, connfd;</span><br><span class="line">    <span class="type">thread_t</span> 		tid;</span><br><span class="line">    <span class="type">socklen_t</span> 		addrlen, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">cliaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">    cliaddr = Malloc(addrlen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        len = addrlen;</span><br><span class="line">        iptr = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *iptr = Accept(listenfd, cliaddr, &amp;len);</span><br><span class="line">        Pthread_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;doit, iptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 			connfd;</span><br><span class="line">    connfd = *((<span class="type">int</span>*)arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    </span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    str_echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但由于引入了malloc和free这两个不可重入函数，产生了线程安全的问题</p>
<p><strong>线程安全函数</strong></p>
<p><img src="/./../pic/image-20230408194736742.png" alt="image-20230408194736742"></p>
<h4 id="26-5-线程特定数据"><a href="#26-5-线程特定数据" class="headerlink" title="26.5 线程特定数据"></a>26.5 线程特定数据</h4><p>处理将未线程化程序转换成使用线程的版本时，函数使用静态变量引起错误的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *onceptr, <span class="type">void</span> (*init)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *keyptr, <span class="type">void</span> (*destructor)(<span class="type">void</span>*value))</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>简单来说，pthread_key_create用来初始化线程特定数据，在进程范围内对于一个给定键，该函数只能被调用一次。pthread_once则用来确保该键只被调用一次，pthread_key_create在Key结构数组中，找到第一个未引用的元素，将它的索引返回给调用者</p>
<p><img src="/./../pic/image-20230408200528894.png" alt="image-20230408200528894"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用例</span></span><br><span class="line"><span class="type">pthread_key_t</span> 	r1_key;</span><br><span class="line"><span class="type">pthread_once_t</span>	r1_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readline_destructor</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readline_once</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_key_create(&amp;r1_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readline</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_once(&amp;r1_once, readline_once);</span><br><span class="line">    <span class="keyword">if</span> ((ptr = pthread_getspecific(r1_key)) == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        ptr = Malloc(...);</span><br><span class="line">        pthread_setspecific(r1_key, ptr);</span><br><span class="line">        <span class="comment">/* initialize memory pointed to by ptr */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">/* use the values pointed to by ptr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_getspecific 和 pthread_setspecific 用于获取和存放相关联的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line">	<span class="comment">//返回:指向线程特定数据的指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>图3.18函数的优化版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unpthread.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> 	r1_key;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> 	r1_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">readline_destructor</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_once</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_key_create(&amp;r1_key, readline_destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> 	r1_cnt;</span><br><span class="line">    <span class="type">char</span>	*r1_bufptr;</span><br><span class="line">    <span class="type">char</span> 	r1_buf[MAXLINE];</span><br><span class="line">&#125;Rline;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(Rline *tsd, <span class="type">int</span> fd, <span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tsd-&gt;r1_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        again:</span><br><span class="line">        <span class="keyword">if</span> ((tsd-&gt;r1_cnt = read(fd, tsd-&gt;r1_buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsd-&gt;r1_cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        tsd-&gt;r1_bufptr = tsd-&gt;r1_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tsd-&gt;r1_cnt--;</span><br><span class="line">    *ptr = *tsd-&gt;r1_bufptr++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		n, rc;</span><br><span class="line">    <span class="type">char</span> 		c, *ptr;</span><br><span class="line">    Rline 		*tsd;</span><br><span class="line">    </span><br><span class="line">    Pthread_once(&amp;r1_once, readline_once);</span><br><span class="line">    <span class="keyword">if</span> ((tsd = pthread_getspecific(r1_key)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tsd = Calloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(Rline));</span><br><span class="line">        Pthread_setspecific(r1_key, tsd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ptr = vptr;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = my_read(tsd, fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">            *ptr++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            *ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="26-6-Web客户与同时连接"><a href="#26-6-Web客户与同时连接" class="headerlink" title="26.6 Web客户与同时连接"></a>26.6 Web客户与同时连接</h4><p>用线程代替了非阻塞conncet的版本，原版本16.5节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unpthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILES 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV <span class="string">&quot;80&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>	*f_name;</span><br><span class="line">    <span class="type">char</span>	*f_host;</span><br><span class="line">    <span class="type">int</span>		f_fd;</span><br><span class="line">    <span class="type">int</span> 	f_flags;</span><br><span class="line">    <span class="type">pthread_t</span> f_tid;</span><br><span class="line">&#125; file[MAXFILES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F_CONNECTING 1		</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F_READING	 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F_DONE		 4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_CMD 	 <span class="string">&quot;GET %s HTTP/1.0\r\n\r\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> 	nconn, nfiles, nlefttoconn, nlefttoread;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">do_get_read</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">home_page</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_get_cmd</span><span class="params">(<span class="keyword">struct</span> file*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		i, n, maxnconn;</span><br><span class="line">    <span class="type">pthread_t</span> 	tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fptr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">5</span>)</span><br><span class="line">        err_quit(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    maxnconn = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    nfiles = min(argc - <span class="number">4</span>, MAXFILES);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfiles; i++) &#123;</span><br><span class="line">        file[i].f_name = argv[i+<span class="number">4</span>];</span><br><span class="line">        file[i].f_host = argv[<span class="number">2</span>];</span><br><span class="line">        file[i].f_flags = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nfiles = %d\n&quot;</span>, nfiles);</span><br><span class="line">    home_page(argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">    nlefttoread = nlefttoconn = nfiles;</span><br><span class="line">    nconn = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nlefttoread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nconn &lt; maxnconn &amp;&amp; nlefttoconn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* find a file to read */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfiles; i++)</span><br><span class="line">                <span class="keyword">if</span> (file[i].f_flags == <span class="number">0</span>)</span><br><span class="line">                    breka;</span><br><span class="line">            <span class="keyword">if</span> (i == nfiles)</span><br><span class="line">                err_quit(<span class="string">&quot;nlefttoconn = %d but nothing found&quot;</span>, nlefttoconn);</span><br><span class="line">            </span><br><span class="line">            file[i].f_flags = F_CONNECTING;</span><br><span class="line">            Pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;do_get_read, &amp;file[i]);</span><br><span class="line">            file[i].f_tid = tid;</span><br><span class="line">            nconn++;</span><br><span class="line">            nleftoconn--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((n = thr_join(<span class="number">0</span>, &amp;tid, (<span class="type">void</span>&amp;&amp;)&amp;fptr)) != <span class="number">0</span>)</span><br><span class="line">            errno = n, err_sys(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        nconn--;</span><br><span class="line">        nlefttoread--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread id %d for %s done\n&quot;</span>, tid, fptr-&gt;f_name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">do_get_read</span><span class="params">(<span class="type">void</span> *vptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 		fd, n;</span><br><span class="line">    <span class="type">char</span> 		line[MAXLINE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fptr</span>;</span></span><br><span class="line">    </span><br><span class="line">    fptr = (<span class="keyword">struct</span> file*)vptr;</span><br><span class="line">    fd = Tcp_connect(fptr-&gt;f_host, SERV);</span><br><span class="line">    fptr-&gt;f_fd = fd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;do_get_read for %s, fd %d, thread %d\n&quot;</span>,</span><br><span class="line">          fptr-&gt;f_name, fd, fptr-&gt;f_tid);</span><br><span class="line">    </span><br><span class="line">    write_get_cmd(fptr);		<span class="comment">/* write() thet GET conmmand */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Read server&#x27;s reply */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = Read(fd, line, MAXLINE)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d bytes from %s\n&quot;</span>, n, fptr-&gt;f_name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end-ofile on %s\n&quot;</span>, fptr-&gt;f_name);</span><br><span class="line">    Close(fd);</span><br><span class="line">    fptr-&gt;f_flags = F_DONE;</span><br><span class="line">    <span class="keyword">return</span> (fptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thr_join为一个Solaris线程函数，等待任一线程终止。原因在于Pthreads没有提供等待任一线程终止的手段；pthread_join需要显示指定想要等待的线程。后续将看到使用条件变量替换该线程函数的方法。</p>
<h4 id="26-7-互斥锁"><a href="#26-7-互斥锁" class="headerlink" title="26.7 互斥锁"></a>26.7 互斥锁</h4><p>处理线程之间竞争的问题，比如对于一变量arg，线程1使用的时候，可能在使用之前，该值被另一线程更改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mptr)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>如果试图上锁已被另外某个线程锁住的一个互斥锁，本线程将被阻塞，直到该互斥锁被解锁为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unpthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLOOP 5000</span></span><br><span class="line"><span class="type">int</span> counter;</span><br><span class="line"><span class="type">pthread_mutex_t</span> counter_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> 	tidA, tidB;</span><br><span class="line">    </span><br><span class="line">    Pthread_create(&amp;tidA, <span class="literal">NULL</span>, &amp;doit, <span class="literal">NULL</span>);</span><br><span class="line">    Pthraed_create(&amp;tidB, <span class="literal">NULL</span>, &amp;doit, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="comment">/* wait for both threads to terminate */</span></span><br><span class="line">    Pthread_join(tidA, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tidB, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">doit</span><span class="params">(<span class="type">void</span> *vptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> 	i, val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOP; i++) &#123;</span><br><span class="line">        <span class="comment">//shang&#x27;s</span></span><br><span class="line">        Pthread_mutex_lock(&amp;counter_mutex);</span><br><span class="line">        val = counter;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, pthread_self(), val+<span class="number">1</span>);</span><br><span class="line">        counter = val + <span class="number">1</span>;</span><br><span class="line">        Pthread_mutex_unlock(&amp;counter_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例为一个简单的不同线程对同一个变量递增，如果不采用互斥锁的话，由于竞争问题，会导致递增出现错误</p>
<h4 id="26-8-条件变量"><a href="#26-8-条件变量" class="headerlink" title="26.8 条件变量"></a>26.8 条件变量</h4><p>与互斥锁相比，互斥锁是主动上锁，避免竞争，条件变量，等待条件满足，然后处理相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr, <span class="type">pthread_mutex_t</span> *mptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr)</span>;</span><br><span class="line">	<span class="comment">//0 -- 成功 ， 正Exxx值 -- 出错</span></span><br></pre></td></tr></table></figure>

<p>举例来说明。条件变量的使用，同时也需要用到互斥锁的功能</p>
<p>对于26.6 thr_join的替代</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 		ndone;</span><br><span class="line"><span class="type">pthread_mutex_t</span> ndone_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> 	ndone_cond = PTHREAD_COND_INTIIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过在持有互斥锁期间递增该计数器并发送信号到该条件变量，一个线程通知主循环自身即将终止</span></span><br><span class="line">Pthread_mutex_lock(&amp;ndone_mutex);</span><br><span class="line">ndone++;</span><br><span class="line">Phtread_cond_signal(&amp;ndone_cond);</span><br><span class="line">Pthread_mutex_unlock(&amp;ndone_mutex);</span><br><span class="line"><span class="comment">//主循环阻塞在pthread_cond_wati调用中，等待某个即将终止的线程发送信号到与ndone关联的条件变量</span></span><br><span class="line"><span class="keyword">while</span> (nlefttoread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nconn &lt; maxnconn &amp;&amp; nlefttoconn &gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* find a file to read */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* wait for one of the threads to terminate */</span></span><br><span class="line">    Pthread_mutex_lock(&amp;ndond_mutex);</span><br><span class="line">    <span class="keyword">while</span> (ndone == <span class="number">0</span>) </span><br><span class="line">        Pthread_cond_wait(&amp;ndone_con, &amp;ndone_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfiles; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file[i].f_flags &amp; F_DONE) &#123;</span><br><span class="line">            Pthread_join(file[i].f_tid, (<span class="type">void</span>**)&amp;fptr);</span><br><span class="line">            <span class="comment">/* update file[i] for terminated thread */</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_mutex_unlock(&amp;ndone_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_cond_wait上的原子操作：将互斥锁解锁然后把调用线程投入睡眠</p>
<p>另外两个与signal作用类似的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *cptr, <span class="type">pthread_mutex_t</span> *mptr,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure>

<p>一个与signal对于，但是signal是唤醒单个等在相应条件变量上的线程，broadcast唤醒所有。</p>
<p>timewait则是给阻塞设置了一个时间限制，且此处的时间为绝对时间。</p>
<h4 id="26-9-Web客户与同时连接"><a href="#26-9-Web客户与同时连接" class="headerlink" title="26.9 Web客户与同时连接"></a>26.9 Web客户与同时连接</h4><p>用上述所讲的方法，替换26.6节中的thr_join函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量的唯一变动，增加一个新标志和一个条件变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F_JOINED 	8</span></span><br><span class="line"><span class="type">int</span> 	ndone;</span><br><span class="line"><span class="type">pthread_mutex_t</span> 	ndone_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> 		ndone_cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do_get_read函数的唯一变动是在本线程终止之前，递增ndone并通知主循环</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end-of-file on %s\n&quot;</span>, fptr-&gt;f_name);</span><br><span class="line">Close(fd);</span><br><span class="line">Pthread_mutex_lock(&amp;ndone_mutex);</span><br><span class="line">fptr-&gt;f_flags = F_DONE;</span><br><span class="line">ndone++;</span><br><span class="line">Pthread_cond_signal(&amp;ndone_cond);</span><br><span class="line">Pthread_mutex_unlock(&amp;ndone_mutex);</span><br><span class="line"><span class="keyword">return</span> (fptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主循环中的变动</span></span><br><span class="line"><span class="keyword">while</span> (nliefttoread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nconn &lt; maxnconn &amp;&amp; nlefttoconn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* find a file on read */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfiles; i++)</span><br><span class="line">            <span class="keyword">if</span> (file[i].f_flags == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == nfiles)</span><br><span class="line">            err_quit(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        file[i].f_flags = F_CONNECTING;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;do_get_read, &amp;file[i]);</span><br><span class="line">        file[i].f_tid = tid;</span><br><span class="line">        nconn++;</span><br><span class="line">        nlefttoconn--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* wait for one of the threds to terminate */</span></span><br><span class="line">    Pthread_mutex_lock(&amp;ndone_mutex);</span><br><span class="line">    <span class="keyword">while</span> (ndone == <span class="number">0</span>)</span><br><span class="line">        Pthread_cond_wait(&amp;ndone_cond, &amp;ndone_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfiles; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file[i].f_flags &amp; F_DONE) &#123;</span><br><span class="line">            Pthread_join(file[i].f_tid, (<span class="type">void</span>**)&amp;fptr);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (&amp;file[i] != fptr)</span><br><span class="line">                err_quit(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            fptr-&gt;f_flags = F_JOINED;</span><br><span class="line">            ndone--;</span><br><span class="line">            nconn--;</span><br><span class="line">            nlefttoread--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread %d for %s done\n&quot;</span>, fptr-&gt;f_tid, fptr-&gt;f_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_mutex_unlock(&amp;ndone_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="26-10-小结"><a href="#26-10-小结" class="headerlink" title="26.10 小结"></a>26.10 小结</h4><p>创建线程比fork更快，即体现线程在繁重使用的网络服务器上的优势。</p>
<p>同一进程内的所有线程共享全局变量和描述字，从而允许不同线程之间共享这些信息，但同时也引入了同步问题。</p>
<p>编写能够被线程化应用程序调用的函数时，这些函数必须做到线程安全。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AuroraFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/17/UNP%20note/">http://example.com/2023/03/17/UNP%20note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Aurora</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/cat8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/"><img class="prev-cover" src="/./img/cat1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux高性能服务器笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/16/APUE%20note/"><img class="next-cover" src="/./img/background.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">APUE 学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/headd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AuroraFish</div><div class="author-info__description">保持幻想</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AuroraFish"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AuroraFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:205878047@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只是睡着了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unix-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Unix 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">视频笔记部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">网络应用程序设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">分层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">通信过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.5.</span> <span class="toc-text">协议格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT%E6%98%A0%E5%B0%84-%E6%89%93%E6%B4%9E%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.6.</span> <span class="toc-text">NAT映射 打洞机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.1.7.</span> <span class="toc-text">套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-x2F-%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">三次握手&#x2F;四次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MTU"><span class="toc-number">1.1.9.</span> <span class="toc-text">MTU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.10.</span> <span class="toc-text">滑动窗口(TCP流量控制)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.11.</span> <span class="toc-text">TCP状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2MSL"><span class="toc-number">1.1.12.</span> <span class="toc-text">2MSL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-number">1.1.13.</span> <span class="toc-text">半关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">1.1.14.</span> <span class="toc-text">端口复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Select"><span class="toc-number">1.1.15.</span> <span class="toc-text">Select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Poll"><span class="toc-number">1.1.16.</span> <span class="toc-text">Poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Epoll"><span class="toc-number">1.1.17.</span> <span class="toc-text">Epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">1.1.18.</span> <span class="toc-text">心跳包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.19.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">1.1.20.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-C-x2F-S%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.21.</span> <span class="toc-text">UDP C&#x2F;S模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-number">1.1.22.</span> <span class="toc-text">广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%92%AD"><span class="toc-number">1.1.23.</span> <span class="toc-text">组播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setsockopt"><span class="toc-number">1.1.24.</span> <span class="toc-text">setsockopt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UNP%E4%B9%A6%E7%B1%8D%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0"><span class="toc-number">1.2.</span> <span class="toc-text">UNP书籍部分笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E7%AE%80%E4%BB%8B%E5%92%8CTCP-x2F-IP"><span class="toc-number">1.2.1.</span> <span class="toc-text">第1章 简介和TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82TCP-x2F-UDP"><span class="toc-number">1.2.2.</span> <span class="toc-text">第2章 传输层TCP&#x2F;UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">第3章 套接口简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%A5%97%E6%8E%A5%E5%8F%A3%E7%BB%93%E6%9E%84-sockaadr-in-sockaddr"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2 套接口结构(sockaadr_in,sockaddr)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%80%BC%E7%BB%93%E6%9E%9C%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.3 值结果参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%AD%97%E8%8A%82%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0-htons-htonl-ntohs-ntols"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">3.4 字节排序函数(htons,htonl,ntohs,ntols)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%AD%97%E8%8A%82%E6%93%8D%E7%BA%B5%E5%87%BD%E6%95%B0-bzero-memset%E2%80%A6"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">3.5 字节操纵函数(bzero,memset….)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-inet-aton-inet-addr-inet-ntoa%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">3.6 inet_aton, inet_addr, inet_ntoa函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-inet-pton%E5%92%8Cinet-ntop%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">3.7 inet_pton和inet_ntop函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-sock-ntop%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.8.</span> <span class="toc-text">3.8 sock_ntop和相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-readn-writen-%E5%92%8C-readline%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.9.</span> <span class="toc-text">3.9 readn, writen 和 readline函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.3.10.</span> <span class="toc-text">3.10 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%9F%BA%E6%9C%ACTCP%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">第4章 基本TCP套接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-socket%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">4.2 socket函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-connect%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">4.3 connect函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-bind%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4.4 bind函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-listen%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">4.5 listen函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-accept%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">4.6 accept函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-fork%E5%92%8Cexec%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">4.7 fork和exec函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">4.8 并发服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-close%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">4.9 close函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-10-getsockname%E5%92%8Cgetpeername%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.10.</span> <span class="toc-text">4.10 getsockname和getpeername函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-11-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.4.11.</span> <span class="toc-text">4.11 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-TCP%E5%AE%A2%E6%88%B7-x2F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">第5章 TCP客户&#x2F;服务器程序例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">5.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-TCP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">5.2 TCP回射服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-TCP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">5.3 TCP回射服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-TCP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">5.4 TCP回射客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-TCP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">5.5 TCP回射客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">5.6 正常启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2"><span class="toc-number">1.2.5.7.</span> <span class="toc-text">5.7 正常终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-POSIX%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">1.2.5.8.</span> <span class="toc-text">5.8 POSIX信号处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-SIGCHLD"><span class="toc-number">1.2.5.9.</span> <span class="toc-text">5.9 SIGCHLD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-wait%E5%92%8Cwaitpid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.10.</span> <span class="toc-text">5.10 wait和waitpid函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-accept%E8%BF%94%E5%9B%9E%E5%89%8D%E8%BF%9E%E6%8E%A5%E5%A4%AD%E6%8A%98"><span class="toc-number">1.2.5.11.</span> <span class="toc-text">5.11 accept返回前连接夭折</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.2.5.12.</span> <span class="toc-text">5.12 服务器进程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-13-SIGPIPE%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.5.13.</span> <span class="toc-text">5.13 SIGPIPE信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-14-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83"><span class="toc-number">1.2.5.14.</span> <span class="toc-text">5.14 服务器主机崩溃</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-15-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83%E5%90%8E%E9%87%8D%E5%90%AF"><span class="toc-number">1.2.5.15.</span> <span class="toc-text">5.15 服务器主机崩溃后重启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-16-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E6%9C%BA%E5%85%B3%E6%9C%BA"><span class="toc-number">1.2.5.16.</span> <span class="toc-text">5.16 服务器主机关机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-17-TCP%E7%A8%8B%E5%BA%8F%E4%BE%8B%E5%AD%90%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.5.17.</span> <span class="toc-text">5.17 TCP程序例子小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-18%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.18.</span> <span class="toc-text">5.18数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-19-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.5.19.</span> <span class="toc-text">5.19 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-I-x2F-O%E5%A4%8D%E7%94%A8-select-%E5%92%8C-poll%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">第6章 I&#x2F;O复用:select 和 poll函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">6.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">6.2 I&#x2F;O模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-select%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">6.3 select函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-str-cli%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">6.4 str_cli函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E6%89%B9%E9%87%8F%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">6.6 批量输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-shutdown%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.6.</span> <span class="toc-text">6.6 shutdown函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-str-cli%E5%87%BD%E6%95%B0-%E5%86%8D%E4%BF%AE%E8%AE%A2%E7%89%88"><span class="toc-number">1.2.6.7.</span> <span class="toc-text">6.7 str_cli函数(再修订版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-TCP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F-%E4%BF%AE%E8%AE%A2%E7%89%88"><span class="toc-number">1.2.6.8.</span> <span class="toc-text">6.8 TCP回射服务器程序(修订版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-pselect%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.9.</span> <span class="toc-text">6.9 pselect函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-10-poll%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.10.</span> <span class="toc-text">6.10 poll函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-11-TCP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F-%E5%86%8D%E4%BF%AE%E8%AE%A2%E7%89%88"><span class="toc-number">1.2.6.11.</span> <span class="toc-text">6.11 TCP回射服务器程序(再修订版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-12-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.6.12.</span> <span class="toc-text">6.12 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%8F%A3%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.7.</span> <span class="toc-text">第7章 套接口选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">7.1 概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%9F%BA%E6%9C%ACUDP%E5%A5%97%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">第8章 基本UDP套接口编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">8.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-recvfrom%E5%92%8Csendto%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">8.2 recvfrom和sendto函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-UDP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">8.3 UDP回射服务器程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-UDP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F-dg-echo%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">8.4 UDP回射服务器程序:dg_echo函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-UDP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">8.5 UDP回射客户程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-UDP%E5%9B%9E%E5%B0%84%E5%AE%A2%E6%88%B7%E7%A8%8B%E5%BA%8F-dg-cli%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">8.6 UDP回射客户程序:dg_cli函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">8.7 数据包的丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-%E9%AA%8C%E8%AF%81%E6%94%B6%E5%88%B0%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.8.8.</span> <span class="toc-text">8.8 验证收到的响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E6%9C%AA%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.8.9.</span> <span class="toc-text">8.9 服务器进程未运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-UDP%E7%A8%8B%E5%BA%8F%E4%BE%8B%E5%AD%90%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.8.10.</span> <span class="toc-text">8.10 UDP程序例子小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-11-UDP%E7%9A%84connect%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.11.</span> <span class="toc-text">8.11 UDP的connect函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-dg-cli%E5%87%BD%E6%95%B0-%E4%BF%AE%E8%AE%A2"><span class="toc-number">1.2.8.12.</span> <span class="toc-text">8.12 dg_cli函数(修订)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-13-UDP%E7%BC%BA%E4%B9%8F%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.8.13.</span> <span class="toc-text">8.13 UDP缺乏流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-14-UDP%E4%B8%AD%E7%9A%84%E5%A4%96%E5%87%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.2.8.14.</span> <span class="toc-text">8.14 UDP中的外出接口的确定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-15-%E4%BD%BF%E7%94%A8select%E5%87%BD%E6%95%B0%E7%9A%84TCP%E5%92%8CUDP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.8.15.</span> <span class="toc-text">8.15 使用select函数的TCP和UDP回射服务器程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-16-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.8.16.</span> <span class="toc-text">8.16 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%90%8D%E5%AD%97%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.9.</span> <span class="toc-text">第11章 名字与地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">11.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">11.2 域名系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-gethostbyname%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">11.3 gethostbyname函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-gethostbyaddr%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">11.4 gethostbyaddr函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-getservbyname%E5%92%8Cgetservbyport%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.5.</span> <span class="toc-text">11.5 getservbyname和getservbyport函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-getaddrinfo-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.6.</span> <span class="toc-text">11.6 getaddrinfo 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-gai-strerror-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.7.</span> <span class="toc-text">11.7 gai_strerror 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-freeaddrinfo-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.8.</span> <span class="toc-text">11.8 freeaddrinfo 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-9-getaddrinfo%E5%87%BD%E6%95%B0-IPV6"><span class="toc-number">1.2.9.9.</span> <span class="toc-text">11.9 getaddrinfo函数: IPV6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-10-getaadrinfo-%E5%87%BD%E6%95%B0-%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.9.10.</span> <span class="toc-text">11.10 getaadrinfo 函数:例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-11-host-serv-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.11.</span> <span class="toc-text">11.11 host_serv 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-12-tcp-connect-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.12.</span> <span class="toc-text">11.12 tcp_connect 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-13-tcp-listen-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.13.</span> <span class="toc-text">11.13 tcp_listen 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-udp-client-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.14.</span> <span class="toc-text">11.4 udp_client 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-15-udp-connect%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.15.</span> <span class="toc-text">11.15 udp_connect函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-16-udp-server%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.16.</span> <span class="toc-text">11.16 udp_server函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-17-getnameinfo-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.17.</span> <span class="toc-text">11.17 getnameinfo 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-18-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.18.</span> <span class="toc-text">11.18 可重入函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-19-gethostbyname-r-%E5%92%8C-gethostbyaddr-r-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.19.</span> <span class="toc-text">11.19 gethostbyname_r 和 gethostbyaddr_r 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-20-%E4%BD%9C%E5%BA%9F%E7%9A%84IPV6%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.20.</span> <span class="toc-text">11.20 作废的IPV6地址解析函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-21-%E5%85%B6%E4%BB%96%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.9.21.</span> <span class="toc-text">11.21 其他网络相关信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-22-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.9.22.</span> <span class="toc-text">11.22 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%AB%98%E7%BA%A7I-x2F-O%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.10.</span> <span class="toc-text">第14章 高级I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">14.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E5%A5%97%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">14.2 套接口超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-recv%E5%92%8Csend%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">14.3 recv和send函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-readv%E5%92%8Cwritev%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.10.4.</span> <span class="toc-text">14.4 readv和writev函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-recvmsg%E5%92%8Csendmsg%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.10.5.</span> <span class="toc-text">14.5 recvmsg和sendmsg函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-%E8%BE%85%E5%8A%A9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.10.6.</span> <span class="toc-text">14.6 辅助数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-%E6%8E%92%E9%98%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F"><span class="toc-number">1.2.10.7.</span> <span class="toc-text">14.7 排队的数据量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-%E5%A5%97%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%A0%87%E5%87%86I-x2F-O"><span class="toc-number">1.2.10.8.</span> <span class="toc-text">14.8 套接口和标准I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-9-%E9%AB%98%E7%BA%A7%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.10.9.</span> <span class="toc-text">14.9 高级轮询技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-10-T-x2F-TCP-%E4%BA%8B%E5%8A%A1%E7%9B%AE%E7%9A%84TCP"><span class="toc-number">1.2.10.10.</span> <span class="toc-text">14.10 T&#x2F;TCP:事务目的TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-11-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.10.11.</span> <span class="toc-text">14.11 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E9%9D%9E%E9%98%BB%E5%A1%9EI-x2F-O"><span class="toc-number">1.2.11.</span> <span class="toc-text">第16章 非阻塞I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.11.1.</span> <span class="toc-text">16.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AF%BB%E5%92%8C%E5%86%99%EF%BC%9Astr-cli%E5%87%BD%E6%95%B0-%E4%BF%AE%E8%AE%A2%E7%89%88"><span class="toc-number">1.2.11.2.</span> <span class="toc-text">16.2 非阻塞读和写：str_cli函数(修订版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-%E9%9D%9E%E9%98%BB%E5%A1%9Econnect"><span class="toc-number">1.2.11.3.</span> <span class="toc-text">16.3 非阻塞connect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-%E9%9D%9E%E9%98%BB%E5%A1%9Econnect-%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.11.4.</span> <span class="toc-text">16.4 非阻塞connect:时间获取客户程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-%E9%9D%9E%E9%98%BB%E5%A1%9Econnect-Web%E5%AE%A2%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.11.5.</span> <span class="toc-text">16.5 非阻塞connect: Web客户程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-6-%E9%9D%9E%E9%98%BB%E5%A1%9Eaccept"><span class="toc-number">1.2.11.6.</span> <span class="toc-text">16.6 非阻塞accept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-7-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.11.7.</span> <span class="toc-text">16.7 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC26%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.12.</span> <span class="toc-text">第26章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#26-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.12.1.</span> <span class="toc-text">26.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-2-%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="toc-number">1.2.12.2.</span> <span class="toc-text">26.2 基本线程函数: 创建和终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-3-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84str-cli%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.12.3.</span> <span class="toc-text">26.3 使用线程的str_cli函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84TCP%E5%9B%9E%E5%B0%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.12.4.</span> <span class="toc-text">26.4 使用线程的TCP回射服务器程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-5-%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.12.5.</span> <span class="toc-text">26.5 线程特定数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-6-Web%E5%AE%A2%E6%88%B7%E4%B8%8E%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.12.6.</span> <span class="toc-text">26.6 Web客户与同时连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-7-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.2.12.7.</span> <span class="toc-text">26.7 互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-8-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.12.8.</span> <span class="toc-text">26.8 条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-9-Web%E5%AE%A2%E6%88%B7%E4%B8%8E%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.12.9.</span> <span class="toc-text">26.9 Web客户与同时连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-10-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.12.10.</span> <span class="toc-text">26.10 小结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/STC89C51/" title="51单片机学习笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="51单片机学习笔记"/></a><div class="content"><a class="title" href="/2023/10/15/STC89C51/" title="51单片机学习笔记">51单片机学习笔记</a><time datetime="2023-10-15T10:00:55.000Z" title="发表于 2023-10-15 18:00:55">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记"><img src="/./img/cat1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器笔记"/></a><div class="content"><a class="title" href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记">Linux高性能服务器笔记</a><time datetime="2023-04-21T10:38:55.000Z" title="发表于 2023-04-21 18:38:55">2023-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记"><img src="/./img/cat8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UNP 学习笔记"/></a><div class="content"><a class="title" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记">UNP 学习笔记</a><time datetime="2023-03-17T09:38:55.000Z" title="发表于 2023-03-17 17:38:55">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="APUE 学习笔记"/></a><div class="content"><a class="title" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记">APUE 学习笔记</a><time datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记note2"/></a><div class="content"><a class="title" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2">算法笔记note2</a><time datetime="2022-05-05T10:48:47.000Z" title="发表于 2022-05-05 18:48:47">2022-05-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: 颜色(white)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By AuroraFish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">饿死了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>