<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux高性能服务器笔记 | Aurora</title><meta name="author" content="AuroraFish"><meta name="copyright" content="AuroraFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频和书籍的一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器笔记">
<meta property="og:url" content="http://example.com/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="视频和书籍的一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cat1.jpg">
<meta property="article:published_time" content="2023-04-21T10:38:55.000Z">
<meta property="article:modified_time" content="2023-05-15T09:50:12.655Z">
<meta property="article:author" content="AuroraFish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cat1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux高性能服务器笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-15 17:50:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/headd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/cat1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aurora</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux高性能服务器笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-21T10:38:55.000Z" title="发表于 2023-04-21 18:38:55">2023-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-15T09:50:12.655Z" title="更新于 2023-05-15 17:50:12">2023-05-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux高性能服务器笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux高性能服务器编程"><a href="#Linux高性能服务器编程" class="headerlink" title="Linux高性能服务器编程"></a>Linux高性能服务器编程</h1><h3 id="第1章-TCP-x2F-IP-协议族"><a href="#第1章-TCP-x2F-IP-协议族" class="headerlink" title="第1章 TCP&#x2F;IP 协议族"></a>第1章 TCP&#x2F;IP 协议族</h3><p>Internet使用的主流协议族是TCP&#x2F;IP协议族，它是一个分层，多协议的通信体系。本章简单介绍其中几个相关协议: ICMP协议，ARP协议和DNS协议。</p>
<h4 id="1-1-TCP-x2F-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-x2F-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP&#x2F;IP协议族体系结构以及主要协议"></a>1.1 TCP&#x2F;IP协议族体系结构以及主要协议</h4><p>四层模型，数据链路层，网络层，传输层和应用层。</p>
<p><img src="/./../pic/image-20230411201351158.png" alt="image-20230411201351158"></p>
<p><strong>a) 数据链路层</strong></p>
<p>实现了网卡接口的网络驱动程序，以处理数据在物理媒介上的传输。隐藏了不同物理网络的细节，为上层协议提供一个统一的接口。</p>
<p>该层的两个常用协议，ARP协议 <strong>(Address Resolve Protocol, 地址解析协议)</strong> 和 RARP协议 <strong>(Reverse Address Resolve Protocol, 逆地址解析协议)</strong> 。实现了IP地址和机器物理地址之间的相互转换。</p>
<p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，网络层需要先将目标机器的IP地址转换成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。</p>
<p><strong>b) 网络层</strong></p>
<p>网络层实现数据包的选路和转发。WAN <strong>(Wide Area Network, 广域网)</strong> 使用众多分级的路由器来连接分散的主机或 LAN**(Local Area Network, 局域网)**。两台主机一般不是直接相连的，而是通过多个中间节点(路由器)连接的。网络层的任务就是选择这些中间节点。网络层对上层细节隐藏这些细节，在上层看来，通信的双方是直接相连的。</p>
<p>网络层最核心的协议，IP协议 **(Internet Protocol, 因特网协议)**。IP协议根据数据包的目的IP地址来决定如何投递他。如果不能直接发送给目标主机，IP协议为它寻找一个合适的下一跳路由器，并将数据包交给路由器来转发，多次重复这一过程。</p>
<p>另一个重要协议，ICMP协议 **(Internet Control Message Protocol, 因特网控制报文协议)**。它是IP协议的重要补充，主要用于检测网络连接。</p>
<p><img src="/./../pic/image-20230411202547785.png" alt="image-20230411202547785"></p>
<p> 8位类型用于区分报文类型。比如目标不可达(类型值为3)，重定向(类型值为5)，目标是否可达(类型值为8)  8位代码进一步细分不同条件。16位检验和字段对整个报文进行循环冗余校验，以检验报文在传输过程中是否损坏。</p>
<p><strong>c) 传输层</strong></p>
<p>传输层位两台主机提供端到端的通信。简单来说不考虑IP协议的中转过程了，这些也在网络层中向上隐藏细节了。下图实线箭头表示协议族各层中之间的实体通信，水平虚线表示逻辑通信线路。</p>
<p><img src="/./../pic/image-20230411203044141.png" alt="image-20230411203044141"></p>
<p>传输层主要有三个协议：TCP协议，UDP协议，SCTP协议。本书不讨论SCTP协议，TCP和UDP协议在UNP中已经比较熟悉了。</p>
<p><strong>d) 应用层</strong></p>
<p>应用层负责处理应用程序的逻辑。前面的三个层处理网络通信细节，这部分稳定高效，因此它们在内核空间中实现。而应用层则在用户空间中实现。</p>
<p>应用层协议很多，图1-1中列举了其中几个：</p>
<ol>
<li>ping是应用程序，不是协议，他利用ICMP报文检测网络连接。</li>
<li>telnet协议是一种远程登陆协议，它使我们能在本地完成远程任务。</li>
<li>OSPF <strong>(Open Shortest Path First, 开放最短路径优先)</strong> 协议是一种动态路由更新协议。</li>
<li>DNS <strong>(Domain Name Service, 域名服务)</strong> 协议提供机器域名到IP地址的转换。</li>
</ol>
<h4 id="1-2-封装"><a href="#1-2-封装" class="headerlink" title="1.2 封装"></a>1.2 封装</h4><p>程序数据在发送到物理网络上之前，将沿着协议栈从上往下传递。每层协议都将在上层数据的基础上加上自己的头部信息，以实现该层的功能呢，这个过程称为封装。</p>
<p><img src="/./../pic/image-20230411203812250.png" alt="image-20230411203812250"></p>
<p>就跟套娃差不多 ( </p>
<p><img src="/./../pic/image-20230411203845768.png" alt="image-20230411203845768"></p>
<p>程序数据到 -&gt; TCP&#x2F;UDP报文段 -&gt; IP数据报 -&gt; 以太网帧</p>
<p>经过数据链路层封装的数据称为帧。传输媒介不同，帧的类型也不同。比如以太网上传输的是以太网帧，而令牌环网络上传输的是令牌环帧。以太网帧的封装格式如下图。类型字段后面讨论，4字节CRC字段对帧的其他部分提供循环冗余校验。</p>
<p><img src="/./../pic/image-20230411204210578.png" alt="image-20230411204210578"></p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h4 id="1-3-分用"><a href="#1-3-分用" class="headerlink" title="1.3 分用"></a>1.3 分用</h4><p>帧到达目的主机后，将沿着协议族自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用。分用时依靠头部信息中的类型字段实现的。</p>
<p><img src="/./../pic/image-20230411204426616.png" alt="image-20230411204426616"></p>
<p>比如拿以太网帧举例说，如果类型字段值为0x800，则帧的数据部分为IP数据报，以太网驱动程序将帧交给IP模块处理；若类型字段值为0X806，则帧的数据部分为ARP请求或应答报文，交给ARP模块来处理；0X835则，RAPA请求或应答，则交给RAPA模块。IP的protocol和TCP&#x2F;UDP的端口号同理。</p>
<h4 id="1-4-测试网络"><a href="#1-4-测试网络" class="headerlink" title="1.4 测试网络"></a>1.4 测试网络</h4><p>本书实验所用的测试网络。作者编写的多个客户端，服务器程序都是使用该网络来调试和测试的。</p>
<p><img src="/./../pic/image-20230411204808044.png" alt="image-20230411204808044"></p>
<h4 id="1-5-ARP协议工作原理"><a href="#1-5-ARP协议工作原理" class="headerlink" title="1.5 ARP协议工作原理"></a>1.5 ARP协议工作原理</h4><p>ARP协议能实现任意网络层地址到任意物理地址的转换。其工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>
<p><strong>a) 以太网ARP请求&#x2F;应答报文详解</strong></p>
<p><img src="/./../pic/image-20230411210424754.png" alt="image-20230411210424754"></p>
<p>每个字段的具体值介绍见p9</p>
<p>ARP请求&#x2F;应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节，则一个携带ARP请求&#x2F;应答报文的以太网帧长度为46字节。</p>
<p><strong>b) ARP高速缓存的查看和修改</strong></p>
<p>通常ARP维护一个高速缓存，其中包含经常访问(比如网关地址)或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。</p>
<p>Linxu下可使用arp命令来查看和修改ARP高速缓存，比如ernest-laptop(作者测试网络中的主机)某一时刻的ARP缓存内容如下(使用arp-a命令):</p>
<p><img src="/./../pic/image-20230411210918667.png" alt="image-20230411210918667"></p>
<p>第一项描述的是另一台测试机器Kongming20，第二项描述的是路由器。下面两条命令分别删除和添加一个ARP缓存项：</p>
<p><img src="/./../pic/image-20230411211041828.png" alt="image-20230411211041828"></p>
<p><strong>c) 使用tcpdump观察ARP通信过程</strong></p>
<p>在ernest-laptop上执行telnet命令登录Kongming20的echo服务，并用tcpdump抓取这个过程中两台测试机器之间交换的以太网帧。具体操作如下:</p>
<p><img src="/./../pic/image-20230411211320139.png" alt="image-20230411211320139"></p>
<p>在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行。ARP通信在TCP连接建立之前就已经完成，我们不关心telnet中的内容，在它建立连接成功后就可以退出。tcpdump中抓取的众多数据包中，只有最靠前的两个和ARP通信有关，将其列出:</p>
<p><img src="/./../pic/image-20230411211535303.png" alt="image-20230411211535303"></p>
<p>第一个数据包，依次看过去，源地址:00:16:d3:5c:b9:e3，目的地址:ff:ff:ff:ff:ff:ff 这是以太网的广播地址，即表示整个LAN，0x0806以太网帧头部类型字段的值 表示ARP模块，长度为42字节；数据部分长度28字节，”Request”表示这是一个ARP请求，”who-has”表示查询对应IP地址。第二个数据包同理</p>
<p> <img src="/./../pic/image-20230411212225324.png" alt="image-20230411212225324"></p>
<p>ARP请求和应答实际是从以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上，所以用虚线表示。路由器也将接到以太网帧1，因为该帧是一个广播帧。</p>
<h4 id="1-6-DNS工作原理"><a href="#1-6-DNS工作原理" class="headerlink" title="1.6 DNS工作原理"></a>1.6 DNS工作原理</h4><p>我们通常使用机器的域名来访问这台机器，而不直接使用IP地址。如何将机器的域名转换成IP地址，这就需要用到域名查询服务。有很多种实现方式，比如NIS **(Network Information Service, 网络信息服务)**，DNS和本地静态文件，本节主要讨论DNS</p>
<p><strong>a) DNS查询和应答报文详解</strong></p>
<p>DNS是一套分布式的域名服务系统。每个DNS服务器上存放着大量的机器名和IP地址的映射，并且动态更新的。众多网络客户端使用DNS协议来向DNS服务器查询目标主机的IP地址。DNS查询和应答报文格式如下</p>
<p><img src="/./../pic/image-20230411220825883.png" alt="image-20230411220825883"></p>
<p>具体字段分析，见p13</p>
<p><strong>b) Linux下访问DNS服务</strong></p>
<p>我们要访问DNS服务，必须先直到DNS服务器的IP地址。Linux使用&#x2F;etc&#x2F;resolvconf文件来存放DNS服务器的IP地址，内容如下</p>
<p><img src="/./../pic/image-20230411221008256.png" alt="image-20230411221008256"></p>
<p>Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器<a href="http://www.baidu.com的IP地址：">www.baidu.com的IP地址：</a></p>
<p><img src="/./../pic/image-20230411221126395.png" alt="image-20230411221126395"></p>
<p><strong>c) 使用tcpdump观察DNS通信过程</strong></p>
<p>下面将在ernest-laptop上运行host命令，查询，并使用tcpdump抓取这一过程中的LAN上传输的以太网帧。</p>
<p><img src="/./../pic/image-20230411221251555.png" alt="image-20230411221251555"></p>
<p>使用port domain来过滤数据包，表示只抓取使用domain服务的数据包，输出如下：</p>
<p><img src="/./../pic/image-20230411221334836.png" alt="image-20230411221334836"></p>
<p>第一个数据包中，数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。”+”表示启用递归查询标志，”A?”表示使用A类型的查询方式。”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;则是dns查询问题中的查询名,括号中的数值31是dns查询报文的长度/">www.baidu.com&quot;则是DNS查询问题中的查询名，括号中的数值31是DNS查询报文的长度</a></p>
<p>第二个数据包中，”3&#x2F;4&#x2F;4”表示该报文中包含3个应答资源记录，4个授权资源记录和4个额外信息记录。”CNAME<a target="_blank" rel="noopener" href="http://www.baidu.com,/">www.baidu.com，</a> A 119.75.218.77, A 119.75.217.56”则表示3个应答资源记录的内容，其中CNAME表示机器别名，A表示的记录是IP地址，长度为226字节</p>
<h4 id="1-7-socket-和-TCP-x2F-IP-协议族的关系"><a href="#1-7-socket-和-TCP-x2F-IP-协议族的关系" class="headerlink" title="1.7 socket 和 TCP&#x2F;IP 协议族的关系"></a>1.7 socket 和 TCP&#x2F;IP 协议族的关系</h4><p>数据链路层，网络层，传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API主要有两套：socket和XTI。本书仅讨论socket。</p>
<h3 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h3><p>IP协议是TCP&#x2F;IP的核心协议，也是socket网络编程的基础之一。本章从IP头部信息和IP数据报的路由和转发两个方向深入探讨IP协议。</p>
<h4 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h4><p>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态，无连接，不可靠的服务。</p>
<p>无状态是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送，传输和接收都是相互独立，没有上下文关系的。这种的服务的最大缺点是无法处理乱序和重复的IP数据报，优点是简单，高效。</p>
<p>无连接是指IP通信双方都不长久地维持对方的任何信息，每次上层协议发送数据时，都必须明确指定对方的IP地址。</p>
<p>不可靠是指IP协议不能保证IP数据报准确地到达接收端。</p>
<h4 id="2-2-IPV4头部结构"><a href="#2-2-IPV4头部结构" class="headerlink" title="2.2 IPV4头部结构"></a>2.2 IPV4头部结构</h4><p><strong>a） IPV4头部结构</strong></p>
<p><img src="/./../pic/image-20230413154701842.png" alt="image-20230413154701842"></p>
<p>4位版本号指定IP协议的版本，对于IPV4来说是4。其他IPV4协议的扩展版本则有不同版本号。</p>
<p>4位头部长度表示IP头部有多少个32bit字 <strong>(4字节)</strong> ，4位最大表示15，所以最长60字节</p>
<p>8位服务类型，包括一个3位优先权字段 **(已被忽略)**，4位的TOS字段和1位的保留字段 **(必须置0)**，4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性，最小费用。</p>
<p>16位总长度是指整个IP数据报的长度，所以最大65535 **(2^16-1)**，但由于MTU的限制，实际上超过MTU的数据报都将被分片传输。</p>
<p>16位标识唯一地表示主机发送的每一个数据报。其初始值由系统随机生成：每发送一个数据报，其值+1。该值在数据报分片时被复制到每个分片中，因此所有分片拥有相同的标识值。</p>
<p>3位表示字段的第一位保留。第二位DF **(Don’t Fragment)**表示”禁止分片” ，第3位表示MF <strong>(More Fragment)</strong> “更多分片”。除了数据报的最后一个分片外，其它都要把它置1</p>
<p>13位分片偏移时分片相对原始IP数据报开始处的偏移。</p>
<p>8位生存时间 **(Time To Live, TTL)**，常见的值时64，每经过一个路由，该值减1。为0时，路由器丢弃数据报</p>
<p>8位协议 **(protocol)**用来区分上层协议，类似于TCP的端口，其中ICMP是1，TCP是6，UDP是17。</p>
<p>16位头部校验和，检验IP数据报头部在传输过程中是否损坏。</p>
<p>32位的源端IP地址和目的端IP地址用来表示数据报的发送端和接收端。</p>
<p>IPV4的最后一个字段是可变长的可选信息。最多包含40字节，因为前面部分已经讨论了20字节固定字节，而IP头部最长是60字节。可用的IP选项包括:</p>
<ol>
<li>记录路由，告诉数据报途径的路由器将IP地址填入头部选项部分，可用来跟踪传递路径。</li>
<li>时间戳，告诉路由器将转发时间填入，测量途径传输的时间。</li>
<li>松散源路由选择，指定一个路由器IP地址列表，数据报必须经过其中的所有路由器。</li>
<li>严格源路由选择，数据报只能经过指定的路由器。</li>
<li></li>
</ol>
<p><strong>b) 使用tcpdump观察IPV4头部结构</strong></p>
<p>使用测试机器ernest-laptop执行talnet命令登陆本机，使用tcpdump抓取这个过程中交换的数据报。</p>
<p><img src="/./../pic/image-20230413160158439.png" alt="image-20230413160158439"></p>
<p>此时观察tcpdump输出的第一个数据包</p>
<p><img src="/./../pic/image-20230413160217849.png" alt="image-20230413160217849"></p>
<p>由于是本机，所以IP地址是127.0.0.1本地回环。flags，seq，win，options位TCP头部信息，第3章讨论</p>
<p>本次抓包开启了tcpdump的-x选项，使之输出数据报的二进制码，此数据包共60字节，前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据 **(length值为0)**分析结果如下。</p>
<p><img src="/./../pic/image-20230413160422533.png" alt="image-20230413160422533"></p>
<h4 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h4><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。</p>
<p>和分片关系比较紧密的三个字段：数据报标识，标志和片偏移。每个分片都具有相同的标识值，具有不同的片偏移，且除了最后一个分片外，其他分片设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU是1500，因此它可携带的IP数据报的数据部分最多是1480字节 **(IP头部占用20字节)**。考虑用IP数据报封装一个1481的ICMP报文(包括8字节的ICMP头部)，分片如下图。</p>
<p>分片为两块，都具有自己的IP头部，且第一个分片设置了MF标志，但ICMP头部只有第一个分片有，因为IP模块重组该ICMP报文的时候只需要一份ICMP头部信息。</p>
<p><img src="/./../pic/image-20230413203130256.png" alt="image-20230413203130256"></p>
<p>ICMP报文的头部长度取决于报文的类型，其变化范围很大。图中8字节原因是后面的例子用到了ping程序，而ping程序使用的ICMP回显和应答报文的头部类型是8字节。</p>
<p>考虑从ernest-laptop来ping机器kongming20，每次发送1473字节来强制引起分片，并使用tcpdump来抓取数据包，操作如下：</p>
<p><img src="/./../pic/image-20230413203406701.png" alt="image-20230413203406701"></p>
<p>tcpdump输出的两个分片，内容如下：</p>
<p><img src="/./../pic/image-20230413203423136.png" alt="image-20230413203423136"></p>
<p>可以看出它们具有相同的标识值 61197，说明是同一个IP数据报的分片。flags [+] 说明设置了MF标志，而第二个分片不设置。片偏移不同。</p>
<h4 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h4><p>IP协议的一个核心任务是数据报的路由，即发送数据报到目标机器的路径。</p>
<p><strong>a) IP模块工作流程</strong></p>
<p><img src="/./../pic/image-20230413203645649.png" alt="image-20230413203645649"></p>
<p>当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误后就<strong>分析其头部的具体信息</strong>。</p>
<p>如果该IP数据报的头部设置了源站选路选项 <strong>(松散源路由选择或严格源路由选择)<strong>，则IP模块调用</strong>数据报转发子模块</strong>来处理该数据报。如果IP数据报的头部中目的IP地址是<strong>本机</strong>的某个IP地址，或者是广播地址，则IP模块根据数据报头部中的协议字段来决定将他<strong>派发给上层应用</strong>。如果不是发送给本机的，也交给<strong>数据报转发子模块</strong>。</p>
<p><strong>数据报转发子模块</strong>首先检测系统是否允许转发，如果不允许，IP模块将数据报丢弃。如果允许，对该数据执行一些操作，然后将他交给<strong>IP数据报输出子模块</strong></p>
<p>IP数据报应该发送至哪一个吓一跳路由，以及经过哪个网卡来发送，就是 <strong>IP路由过程</strong>，即图2-3中的<strong>计算下一条路由子模块</strong>。IP模块实现数据报路由的核心数据结构是路由表。</p>
<p>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据的IP数据报。</p>
<p>图2-3中的虚线箭头显示了路由表更新过程。</p>
<p><strong>b) 路由机制</strong></p>
<p>使用route命令或netstat命令查看路由表，测试机器上执行route内容如下：</p>
<p><img src="/./../pic/image-20230413204536175.png" alt="image-20230413204536175"></p>
<p>路由表如何按照IP地址分类？或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢？这就是IP的路由机制，分为3个步骤：</p>
<ol>
<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用该路由项，没找到则转步骤2</li>
<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(比如代码清单2-2所示的路由表中的第二项)。如果找到，就使用该路由项：没找到则转步骤3</li>
<li>选择默认路由，这通常意味着数据报的吓一跳路由是网关。</li>
</ol>
<p>因此，对于测试机器ernest-laptop而言，所有发送到IP地址为192.168.1.*的机器的IP数据报都可以直接发送到目标机器(匹配路由表第二项)，而所有访问因特网的请求都通过网关来转发(匹配默认路由项)。</p>
<p><strong>c) 路由表更新</strong></p>
<p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能够准确，高效地转发数据报。route命令可以修改路由表，如下：</p>
<p><img src="/./../pic/image-20230413205615908.png" alt="image-20230413205615908"></p>
<p>第1行标识添加主机192.168.1.109(机器Kongming20)对应的路由项。这样设置之后，所有从ernest-laptop发送到Kongming20的IP数据报将通过网卡eth0直接发送到目标机器的接收网卡。第2行标识删除网络192.168.1.0对应的路由项，这样除了机器Kongming20外，测试机器无法访问局域网上的任何其他机器。第3行标识删除默认路由项，这样做的后果是无法访问因特网。第4行标识重新设置默认路由项，不过这次其网关是机器Kongming20，修改后的路由表内容如下：</p>
<p><img src="/./../pic/image-20230413211012367.png" alt="image-20230413211012367"></p>
<p>第一个路由项是主机路由项，所以它被设置了”H”标志。设计该路由表的目的是为后文讨论ICMP重定向提供环境。</p>
<h4 id="2-5-IP转发"><a href="#2-5-IP转发" class="headerlink" title="2.5 IP转发"></a>2.5 IP转发</h4><p>前文提到，不是发送给本机的IP数据报都将由数据报转发子模块来处理。路由器能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward内核参数默认被设置为0。我们可以修改它来使能主机的数据报转发功能:</p>
<p><img src="/./../pic/image-20230413211357717.png" alt="image-20230413211357717"></p>
<p>对于允许IP数据报转发的系统，数据报转发子模块将对期望转发的数据报执行如下操作：</p>
<ol>
<li>检测数据报头部的TTL值，为0则丢弃。</li>
<li>查看数据报头部的严格选路由选择选项。如果设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</li>
<li>如果有必要，则给源端发送一个ICMP重定向报文，以告诉他更合理的吓一跳。</li>
<li>将TTL值减1</li>
<li>处理IP头部选项</li>
<li>如有必要，执行分片</li>
</ol>
<h4 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h4><p>图2-3显示了ICMP重定向报文也能用于更新路由表，简要讨论ICMP重定向</p>
<p><strong>a) ICMP重定向报文</strong></p>
<p><img src="/./../pic/image-20230413211750780.png" alt="image-20230413211750780"></p>
<p>ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本届仅讨论主机重定向，代码值为1</p>
<p>数据部分为接收方提供如下两个信息：</p>
<ol>
<li>引起重定向的IP数据报的源端IP地址</li>
<li>应该使用的路由器IP地址</li>
</ol>
<p>接收主机以此来选择应该使用的路由器，并且更新路由表</p>
<p><strong>b) 主机重定向示例</strong></p>
<p>2.4.3中将机器ernest-laptop的网关设置成了机器Kongming20，2.5节又使能了Kongming20的数据报转发功能，因此机器ernest-laptop将通过Kongming20来访问因特网，如在ernest-laptop上执行ping命令：</p>
<p><img src="/./../pic/image-20230413212310578.png" alt="image-20230413212310578"></p>
<p>Kongming20给ernest-laptop发送了一个ICMP重定向报文，告诉它通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。主机ernest-laptop收到这样的ICMP重定向报文后，更新路由表缓冲，并使用新的路由方式来发送后续数据报</p>
<p><img src="/./../pic/image-20230413212419098.png" alt="image-20230413212419098"></p>
<h4 id="2-7-IPV6头部结构"><a href="#2-7-IPV6头部结构" class="headerlink" title="2.7 IPV6头部结构"></a>2.7 IPV6头部结构</h4><p>简要讨论IPV6头部结构</p>
<p><strong>a) IPV6固定头部结构</strong></p>
<p><img src="/./../pic/image-20230413212545280.png" alt="image-20230413212545280"></p>
<p><img src="/./../pic/image-20230413212607716.png" alt="image-20230413212607716"></p>
<p><strong>b)IPV6扩展头部</strong></p>
<p>可变长的扩展头部使得IPV6可以支持更多选项，并且很便于将来的扩展需求。</p>
<p><img src="/./../pic/image-20230413212705056.png" alt="image-20230413212705056"></p>
<h3 id="第3章-TCP协议详解"><a href="#第3章-TCP协议详解" class="headerlink" title="第3章 TCP协议详解"></a>第3章 TCP协议详解</h3><p>本章主要从四个方面来讨论TCP协议：</p>
<ol>
<li>TCP头部信息</li>
<li>TCP状态转移过程</li>
<li>TCP数据流</li>
<li>TCP数据流的控制</li>
</ol>
<h4 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h4><p>TCP协议相对于UDP协议的特点是：面向连接，字节流和可靠传输。</p>
<p>TCP协议的连接是一对一的，所以基于广播和多播的应用程序，不能使用TCP服务。而无连接协议UDP非常适合广播和多播。</p>
<p>字节流指应用程序执行读操作次数和TCP模块接收到的TCP报文段之间没有固定的数量关系，由接收端&#x2F;发送端，先接收&#x2F;写到TCP发送&#x2F;接收缓冲区，再由应用程序读写；与之不同的UDP则是数据报服务，发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送只。</p>
<p><img src="/./../pic/image-20230418192544531.png" alt="image-20230418192544531"></p>
<p>可靠，TCP协议采用发送应答机制，每个TCP报文段必须得到接收方的应答，才认为这个TCP报文传输成功。且TCP协议采用超时重传机制。以及对收到的可能乱序，重复的IP数据报，重排，整理，再交付应用层。</p>
<h4 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h4><p>TCP头部信息出现在每个TCP报文段中。本节详细介绍</p>
<p><strong>a) TCP固定头部结构</strong></p>
<p><img src="/./../pic/image-20230418192759838.png" alt="image-20230418192759838"></p>
<p>16位端口号：告知该报文段来自哪里以及传给哪个上层协议或应用程序。</p>
<p>32位序号：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号。</p>
<p>32位确认号：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值+1。</p>
<p>4位头部长度：标识该TCP头部有多少个32bit字(4字节)。4位最大表示15，所以TCP头部最长60字节。</p>
<p>6位标志位包含如下几项：</p>
<ol>
<li>URG标志：表示紧急指针是否有效</li>
<li>ACK标志：表示确认号是否有效，携带ACK标志的TCP报文段为确认报文段。</li>
<li>PSH标志：提示接收端应用程序立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。</li>
<li>RST标志：表示要求对方重新建立连接，携带RST为复位报文段</li>
<li>SYN标志：表示请求建立一个连接，携带SYN为同步报文段。</li>
<li>FIN标志：表示通知对方本端要关闭连接了，携带FIN为结束报文段。</li>
</ol>
<p>16位窗口大小：TCP流量控制的一个手段。</p>
<p>16位校验和：接收端执行CRC算法以检验TCP报文段在传输过程中是否损坏。</p>
<p>16位紧急指针：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。</p>
<p><strong>b) TCP头部选项</strong></p>
<p>TCP头部的最后一个选项是可变长的可选信息。这部分最多40字节，因为TCP最长60，前面固定已占了20字节。典型的TCP头部选项结构如下：</p>
<p><img src="/./../pic/image-20230418193622312.png" alt="image-20230418193622312"></p>
<p>kind说明选项的类型，有的TCP选项没有后面的两个值，length指定该选项的长度，包括kind和length占据的2字节，info是选项的具体信息。常见的有7种，如下：</p>
<p><img src="/./../pic/image-20230418193757338.png" alt="image-20230418193757338"></p>
<p>kind0：选项表结束选项。</p>
<p>kind1：空操作(nop)选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind2：最大报文段长度选项。通信双方使用该选项来协商最大报文段长度(MSS)。通常设置为(MTU-40)字节，减掉的包括20字节IP头部和20字节TCP头部，避免IP分片。</p>
<p>kind3：窗口扩大因子选项。TCP头部种，接收通过窗口大小是用6位表示的(即65535)，但TCP模块允许的大小远不止这个数，通过该选项可以扩大该值，如假设TCP头部中的接收通告窗口大小是N，扩大因子是M，即将N左移M位。</p>
<p>kind4：选择性确认选项。若通信时某个TCP报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样会导致原先已经正确传输的TCP报文段被重复发送，从而降低TCP性能。该选项使TCP模块只重新发送丢失的TCP报文段。</p>
<p>kind5：是选择性确认(Selective Acknowledgment, SACK)实际工作的选项。</p>
<p>kind8：时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间(RTT)的方法。</p>
<p><strong>c) 使用tcpdump观察TCP头部信息</strong></p>
<p>抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418194848115.png" alt="image-20230418194848115"></p>
<p>Flags[S]：表示包含SYN标志，因此他是一个同步报文段。</p>
<p>seq：序号值，因为这是该方向上第一个TCP报文段，所以这个序号值也就是本次通信该方向上的ISN(Initial Sequence Number, 初始序号值)。</p>
<p>win：接收通告窗口的大小。</p>
<p>options：tcp选项，mss为最大报文长度。通过ifconfig查看mtu为16436，所以mss为MUT-40，16396。sackOK表示同意使用SACK选项，TSval是发送端的时间戳，ecr是时间戳回显应答。nop是一个空操作，wscale指出发送端的扩大银子为6.</p>
<p>字节码即，TCP头部中对应的消息：</p>
<p><img src="/./../pic/image-20230418195407852.png" alt="image-20230418195407852"></p>
<h4 id="3-3-TCP连接的建立和关闭"><a href="#3-3-TCP连接的建立和关闭" class="headerlink" title="3.3 TCP连接的建立和关闭"></a>3.3 TCP连接的建立和关闭</h4><p><strong>a) 使用tcpdump观察TCP连接的建立和关闭</strong></p>
<p><img src="/./../pic/image-20230418195636159.png" alt="image-20230418195636159"></p>
<p>可以看出是三次握手建立连接，以及四次握手关闭连接</p>
<p><img src="/./../pic/image-20230418195925990.png" alt="image-20230418195925990"></p>
<p><strong>b) 半关闭状态</strong></p>
<p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。也就是允许一端发送结束报文，告诉对端本端已完成数据的发送，但允许继续接收来自对端的数据，直到对方也发送结束报文。</p>
<p><img src="/./../pic/image-20230418200139837.png" alt="image-20230418200139837"></p>
<p><strong>c) 连接超时</strong></p>
<p>这里采用iptable命令过于数据包，丢弃它所接收到的连接请求。随后用tcpdump抓取。</p>
<p><img src="/./../pic/image-20230418200331441.png" alt="image-20230418200331441"></p>
<p>可以看出在5次重连均失败的情况下，TCP模块放弃连接并通知应用程序。</p>
<h4 id="3-4-TCP状态转移"><a href="#3-4-TCP状态转移" class="headerlink" title="3.4 TCP状态转移"></a>3.4 TCP状态转移</h4><p>下图是完整的状态转移图，可以通过netstat命令查看TCP连接处于何种状态。</p>
<p><img src="/./../pic/image-20230418200554092.png" alt="image-20230418200554092"></p>
<p>粗实线表示典型的客户端连接的状态转移，虚线可以看作服务端收到客户端的连接请求后的状态转移，CLOSED为一个假象状态，实际并不存在。</p>
<p><strong>a) TCP状态转移总图</strong></p>
<p>先讨论服务器典型的状态转移。</p>
<p>服务端listen调用进入LISTEN状态，接收到SYN，将连接放入内核等待队列，并向对端发送带SYN标志的ack确认报文段，此时处于SYN_RCVD状态。接收到对端回发的确认报文段后，转移到ESTABLISHED状态。</p>
<p>收到结束报文段，并返回确认报文段后，进入CLOSE_WATI状态，随后等待服务器应用程序关闭连接，发送一个结束报文段后进入LASK_ACK状态，在此等待最后一个确认，一旦确认即彻底关闭。</p>
<p>客户端同意，但注意一个TIME_WATI状态，后续讨论。</p>
<p><img src="/./../pic/image-20230418201413001.png" alt="image-20230418201413001"></p>
<p><strong>b) TIME_WATI状态</strong></p>
<p>客户端在收到服务端的FIN后，没有立即进入CLOSED状态，而要等待一段长为2MSL(报文段最大生存时间)的时间，大概是2分钟，该状态存在的两点原因：</p>
<ol>
<li>可靠地终止TCP连接</li>
<li>保证让迟来的TCP报文段有足够的时间被识别并丢弃</li>
</ol>
<p>通过setsockopt选项SO_REUSEADDR设置端口复用，可以避免TIME_WAIT状态连接占用的端口。</p>
<h4 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h4><p>本节讨论产生复位报文段的三种情况</p>
<p><strong>a) 访问不存在的端口</strong></p>
<p>如以下命令访问一个不存在的54321端口：</p>
<p><img src="/./../pic/image-20230418202122363.png" alt="image-20230418202122363"></p>
<p>抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418202136410.png" alt="image-20230418202136410"></p>
<p>以及对于仍处于TIME_WATI的端口发起连接，客户端程序也将收到复位报文段。</p>
<p><strong>b) 异常终止连接</strong></p>
<p>前面讨论的连接终止方式都是正常的种植方式：数据交换完成后，通过结束报文段。TCP提供了异常终止的一个连接方式，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都被丢弃。通过使用socket选项的SO_LINGER来发送复位报文段，以异常终止一个连接。</p>
<p><strong>c) 处理半打开连接</strong></p>
<p>如下情况，服务器关闭或异常终止了连接，而对方没有收到结束报文段，此时客户端还维持着原来的连接。如果此时客户端向半打开状态的连接写入数据，对方将回应一个结束报文段。</p>
<p>如执行如下命令：</p>
<p><img src="/./../pic/image-20230418202543526.png" alt="image-20230418202543526"></p>
<p>tcpdump抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418202610216.png" alt="image-20230418202610216"></p>
<p>前3个报文段为TCP3次握手的建立，第4个报文段为客户端发送给服务器携带应用程序数据的报文段，length3，为”a”, 回车符\r , 换行符\n。</p>
<h4 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h4><p>TCP报文段锁携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互数据仅包含很少的字节。对实时性要求高的应用程序一般采用该种，如telnet，ssh。成块数据长度通常为TCP报文段允许的最大数据长度，对传输效率高的应用程序采用这种如ftp。</p>
<p>执行如下命令：</p>
<p><img src="/./../pic/image-20230418203103602.png" alt="image-20230418203103602"></p>
<p>tcpdump抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418203122162.png" alt="image-20230418203122162"></p>
<h4 id="3-7-TCP成块数据流"><a href="#3-7-TCP成块数据流" class="headerlink" title="3.7 TCP成块数据流"></a>3.7 TCP成块数据流</h4><p>下面考虑FTP协议传输一个大文件。命令如下：</p>
<p><img src="/./../pic/image-20230418203616713.png" alt="image-20230418203616713"></p>
<p>tcpdump输出如下：</p>
<p><img src="/./../pic/image-20230418203634178.png" alt="image-20230418203634178"></p>
<p>前面16个报文段都为，服务端向客户端发送数据，17，18则是客户端对于TCP报文段2和16的确认。由此可见，当传输大量大块数据的时候，发送方会连续发送多个TCP报文段。</p>
<h4 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h4><p>有些传输层协议具有带外数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据有更高的优先级，它应该总是立即被发送，而不论发送缓冲区种是否有排队等候发送的普通数据。</p>
<p>UDP没有实现带外数据，TCP也米有真正的带外数据。不过TCP利用其头部种的紧急指针标志和紧急指针字段，给应用程序提供了一种紧急方式。</p>
<p>具体过程如下，假设一个进程已经往某个TCP连接的发送缓冲区种写入了N字节的普通数据。在数据被发送前，该进程又向这个连接写入了3字节的带外数据”abc”。此时，待发送的TCP报文段将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节。</p>
<p><img src="/./../pic/image-20230418204844857.png" alt="image-20230418204844857"></p>
<h4 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h4><p>TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维持一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次的重传，就是TCP的重传策略，通过示例来研究。</p>
<p>执行如下命令：</p>
<p><img src="/./../pic/image-20230418205131120.png" alt="image-20230418205131120"></p>
<p>tcpdumo抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418205206146.png" alt="image-20230418205206146"></p>
<p>前3次为三次握手建立连接，4和5为1234数据的发送和应答，后续执行了5次重传，均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。</p>
<p><img src="/./../pic/image-20230418205545198.png" alt="image-20230418205545198"></p>
<p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传。</p>
<h4 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h4><p><strong>a) 拥塞控制概述</strong></p>
<p>TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性，这就是所谓的拥塞控制。</p>
<p>拥塞控制的四个部分：慢启动，拥塞避免，快速重传 和 快速恢复。</p>
<p>拥塞控制的最终受控变量是发送端向网络一次连续写入的数据量，我们称为SWND(Send Window, 发送窗口)。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。</p>
<p>发送端需要合理的选择SWND的大小，如果SWND太小，会引起明显的网络延迟；反之，如果太大，则容易导致网络拥塞。接收方可以通过其接收通过窗口(RWND)来控制发送端的SWND，但这不够，所以发送端引入了一个称为拥塞窗口(Congestion Winod, CWND)的状态变量。实际的值是RWND和CWND种的较小值。</p>
<p><img src="/./../pic/image-20230418210138514.png" alt="image-20230418210138514"></p>
<p><strong>b) 慢启动和拥塞避免</strong></p>
<p>TCP连接建立好后，CWND将被设置成初始值IW(Initial Window)，其大小为2~4个SMSS(Sender Maximum Segment Site，发送者最大段大小)。此时发送端最多能发送IW字节的数据。此后发送端每收到接收端的一个确认，其CWND就按照式(3-1)增加：</p>
<p><img src="/./../pic/image-20230418211442286.png" alt="image-20230418211442286"></p>
<p>其中N是此次确认中包含的之前未被确认的字节数。这样一来，CWND将按照指数形式扩大，这就是所谓的慢启动。该算法的理由是，TCP模块一开始不知道网络的实际情况，通过一个试探的方式平滑的增加CWDN的大小。</p>
<p>但如果不施加其他手段，慢启动必然使得CWND膨胀，导致网络阻塞。因此TCP拥塞控制中定义了另一个重要的状态变量：<strong>慢启动门限（ssthresh）</strong>。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。</p>
<p>拥塞避免算法使得CWND按线性方式增加，从而减缓其扩大。两种实现方式：</p>
<ol>
<li>每个RTT时间内按照(3-1)计算新的CWND，而不论该RTT时间内发送端接收到多少个确认。</li>
<li>没收到一个对新数据报的确认报文段，按(3-2)来更新CWND</li>
</ol>
<p><img src="/./../pic/image-20230418211429983.png" alt="image-20230418211429983"></p>
<p>如果给出一张图示，如下：</p>
<p><img src="/./../pic/image-20230418211523713.png" alt="image-20230418211523713"></p>
<p>以上为发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时拥塞控制行为。首先搞清除发送端如何判断拥塞已经发生，依据有两个：</p>
<ol>
<li>传输超时，或者说TCP重传定时器溢出</li>
<li>接收到重复的确认报文段</li>
</ol>
<p>拥塞控制对这两种情况有不同的处理方式，对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和而快速恢复，这种情况随后讨论。注意如果第二种情况发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</p>
<p>如果发送端检测到拥塞发生是由于传输超时，即第一种情况，将执行重传并做如下调整：</p>
<p><img src="/./../pic/image-20230418212010912.png" alt="image-20230418212010912"></p>
<p>其中FlightSize是已经发送但未接收到确认的字节数，这样调整之后,CWND将一定小于SMSS，那么也必然小于新的慢启动门限ssthresh，故而拥塞控制再次进入慢启动阶段。</p>
<p><strong>c) 快速重传和快速恢复</strong></p>
<p>在很多情况下，发送端都可能收到重复的确认报文段。如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排之等。拥塞控制算法首先需要判断网络是否真的发生了阻塞。具体做法是：如果连续收到3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下：</p>
<p>1.收到3个重复确认报文段时，按式(3-3)计算ssthresh，然后立即重传丢失的报文段，并按照式(3-4)设置CWND</p>
<p><img src="/./../pic/image-20230418224927284.png" alt="image-20230418224927284"></p>
<p>2.每次收到1个重复的确认时，设置CWND &#x3D; CWND + SMSS。此时发送端可以发送新的TCP报文段，如果CWND允许的话。</p>
<p>3.当收到新的数据的确认时，设置CWND &#x3D; ssthresh 该慢启动门限为新的，由第一步设置</p>
<p>快速重传和快速恢复完成后，拥塞控制将恢复到拥塞避免阶段。</p>
<h3 id="第4章-TCP-x2F-IP通信案例：访问Internet上的Web服务器"><a href="#第4章-TCP-x2F-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第4章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器"></a>第4章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器</h3><h4 id="4-1-示例总图"><a href="#4-1-示例总图" class="headerlink" title="4.1 示例总图"></a>4.1 示例总图</h4><p>在Kongming20上运行wget客户端，在ernest-laptop运行squid代理服务器程序。客户端通过代理服务器的中专，获取Internet上的主机<a target="_blank" rel="noopener" href="http://www.baidu.com的首页文档index.html/">www.baidu.com的首页文档index.html</a></p>
<p><img src="/./../pic/image-20230422132253572.png" alt="image-20230422132253572"></p>
<p>为了将ernest-laptop设置为Kongming20的HTTP代理服务器，需要在Kongming20上设置环境变量http_proxy:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export http_proxy=<span class="string">&quot;ernest-laptop:3128&quot;</span></span><br></pre></td></tr></table></figure>

<p>3128为squid服务器默认使用的端口号。</p>
<h4 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h4><p>简单介绍代理服务器的工作原理以及如何部署。</p>
<p><strong>a) HTTP代理服务器的工作原理</strong></p>
<p>HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。代理服务器按照其使用方式和作用，分为正向代理服务器，反向代理服务器和透明代理服务器。</p>
<p>正向代理：要求客户端自己设置代理服务器的地址。客户每次的请求都直接发送到该代理服务器，并由代理服务器来请求目标资源。</p>
<p>反向代理：反向代理被设置在服务器端，因此客户端无须进行任何设置。方向代理用代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得来的结果返回给客户端。</p>
<p>透明代理：只能设置在网关上。透明代理可以看作正向代理的一种特殊情况。</p>
<p><img src="/./../pic/image-20230422133156009.png" alt="image-20230422133156009"></p>
<p><strong>b) 部署squid代理服务器</strong></p>
<p>在ernest-laptop上部署squid代理服务器。只需修改服务器的配置文件&#x2F;etc&#x2F;squid3&#x2F;suiqd.conf，在其加入如下两行代码(需要root权限，应加在合适的为止，详细参考其他类似条目的设置)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acl localnet src <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">http_access allow localnet</span><br></pre></td></tr></table></figure>

<p>192.168.1.0&#x2F;24是CIDR(Classless Inter-Domain Routing，无类域间路由)风格的IP地址表示方法。</p>
<p>接下来在ernest-laptop上执行如下命令，以重启squid服务器:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service squid3 restart</span><br><span class="line">*Restarting Squid HTTP Proxy <span class="number">3.0</span> squid3					[ok]</span><br></pre></td></tr></table></figure>

<p>service是一个脚本程序，为&#x2F;etc&#x2F;init.d&#x2F;目录下的众多服务器程序的启动，停止等动作提供了一个统一的管理。</p>
<h4 id="4-3-使用tcpdump抓取传输的数据包"><a href="#4-3-使用tcpdump抓取传输的数据包" class="headerlink" title="4.3 使用tcpdump抓取传输的数据包"></a>4.3 使用tcpdump抓取传输的数据包</h4><p>执行wget命令前，首先删除ernest-laptop的ARP高速缓存，以便观察TCP&#x2F;IP通信过程中ARP协议何时起作用，完整操作如下:</p>
<p><img src="/./../pic/image-20230422134037893.png" alt="image-20230422134037893"></p>
<p><img src="/./../pic/image-20230422134142198.png" alt="image-20230422134142198"></p>
<p><img src="/./../pic/image-20230422134159265.png" alt="image-20230422134159265"></p>
<p>一共抓取了43个数据包，按照逻辑关系分为如下四部分：</p>
<ol>
<li>代理服务器访问DNS服务器查询域名<a target="_blank" rel="noopener" href="http://www.baidu.com对应的ip地址,数据包8,9./">www.baidu.com对应的IP地址，数据包8，9。</a></li>
<li>代理服务器查询路由器MAC地址的ARP请求和应答，数据包6，7。</li>
<li>wget客户端(192.168.1.109)和代理服务器(192.168.1.108)之间的HTTP通信，数据包1<del>5，23</del>25，32~40，42，43。</li>
<li>代理服务器和Web服务器(119.75.218.77)之间的HTTP通信，数据包10<del>22，26</del>31，41。</li>
</ol>
<h4 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h4><p>数据包8，9表示代理服务器向DNS服务器查询域名<a target="_blank" rel="noopener" href="http://www.baidu.com对应的ip地址,得到回应.回复包括一个主机别名和两个ip地址./">www.baidu.com对应的IP地址，得到回应。回复包括一个主机别名和两个IP地址。</a></p>
<p><img src="/./../pic/image-20230422134810389.png" alt="image-20230422134810389"></p>
<p>完整过程如下图：</p>
<p><img src="/./../pic/image-20230422134825437.png" alt="image-20230422134825437"></p>
<h4 id="4-5-本地名称查询"><a href="#4-5-本地名称查询" class="headerlink" title="4.5 本地名称查询"></a>4.5 本地名称查询</h4><p>通过域名来访问internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。</p>
<p>Linux将目标主机及其对应IP地址存储在&#x2F;etc&#x2F;hosts配置文件中。如Kongming20上&#x2F;etc&#x2F;hosts文件的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>			localhost</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.109</span>		Kongming20</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.108</span>		ernest-laptop</span><br></pre></td></tr></table></figure>

<p>程序在&#x2F;etc&#x2F;hosts文件中未找到目标机器名对应的IP地址，它将求助于DNS服务。</p>
<p>用户可以通过修改&#x2F;etc&#x2F;host.conf文件来自定义系统解析主机名的方法和顺序。</p>
<h4 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h4><p><img src="/./../pic/image-20230422140151624.png" alt="image-20230422140151624"></p>
<p>本例的过程中，客户端仅给服务器发送了一个HTTP请求，即TCP报文段4，请求的长度为136字节。代理用6个TCP报文段(23,24,25,33,35,36)给客户端返回了总长度为8522字节的HTTP应答。客户端使用7个TCP报文段(32,34,37,38,39,40,42)来确定这8552字节的HTTP应答数据。</p>
<p><strong>a) HTTP请求</strong></p>
<p>请求的部分内容如下:</p>
<p><img src="/./../pic/image-20230422141147637.png" alt="image-20230422141147637"></p>
<p>GET为请求方法，一共有如下9种：</p>
<p><img src="/./../pic/image-20230422141339368.png" alt="image-20230422141339368"></p>
<p><a target="_blank" rel="noopener" href="http://www/baidu/com/index.html">http://www/baidu/com/index.html</a> 是目标资源的URL，”http”是所谓的scheme，表示获取目标资源所需使用的应用层协议。<a target="_blank" rel="noopener" href="http://www.baidu.com是目标主机,index.html是指定资源文件名称/">www.baidu.com是目标主机，index.html是指定资源文件名称</a></p>
<p>HTTP&#x2F;1.0表示客户端使用的HTTP版本号是1.0。</p>
<p>User-Agent表示客户端使用的程序。</p>
<p>Host表示目标主机名。</p>
<p>Conection表示如何处理连接方式。</p>
<p><strong>b) HTTP应答</strong></p>
<p><img src="/./../pic/image-20230422141624967.png" alt="image-20230422141624967"></p>
<p>第一行是状态行，HTTP&#x2F;1.0表示服务器使用的协议版本号，通常需要和客户端一致。</p>
<p><img src="/./../pic/image-20230422141713100.png" alt="image-20230422141713100"></p>
<p>往下分别是，服务器程序名，目标内容的长度，目标内容的MIME类型，以及cookie。</p>
<p>via表示HTTP应答在返回过程中经历的所有代理服务器的地址和名称。</p>
<h3 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h3><h4 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h4><p><strong>a) 主机字节序和网络字节序</strong></p>
<p>不同规定导致的字节沿地址增长方向不同，高位存储在低地址为大端字节序，高位存储在高地址，则为小端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断机器字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byteorder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    uninon &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; test;</span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unkonwn...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> in <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> in <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>b) 通用socket地址</strong></p>
<p>socket网络编程中表示socket地址的结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;		<span class="comment">/* 地址族类型 如 AF_INET, AF_INET6 */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230421193648930.png" alt="image-20230421193648930"></p>
<p>由于14字节的sa_data无法容纳众多数的协议族的地址值。下面为新的通用地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__s_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且该结构是内存对齐的</p>
<p><strong>c) 专用socket地址</strong></p>
<p>UNIX本地域协议族使用如下专用socket地址结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; 	<span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];			<span class="comment">/* 文件路径名 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TCP&#x2F;IP，分为IPV4的和IPV6的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;		<span class="comment">/* AF_INET */</span></span><br><span class="line">    <span class="type">u_int16_t</span>	sin_port;		<span class="comment">/* 端口号，网络字节序 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">/* IPV4地址结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;			<span class="comment">/* IPV4地址，网络字节序 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;	<span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;		<span class="comment">/* 端口号，网络字节序 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;	<span class="comment">/* 流信息，应设置为0 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>	<span class="comment">/* IPV6地址结构体 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;	<span class="comment">/* scope ID, 尚处于实验阶段 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];	<span class="comment">/* IPV6地址，网络字节序 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>d) IP地址专函函数</strong></p>
<p>下面3个函数可用于点分十进制字符串到网络字节序整数之间的转换:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * strptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * cp, <span class="keyword">struct</span> in_addr * inp)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inet_ntoa函数内部用一个静态变量存储转化结果，函数的返回值指向静态内存</span></span><br><span class="line"><span class="type">char</span> * szValue1 = inet_ntoa(<span class="string">&quot;1.2.3.4&quot;</span>);</span><br><span class="line"><span class="type">char</span> * szValue2 = inet_ntoa(<span class="string">&quot;10.194.71.60&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 1: %s\n&quot;</span>, szValue1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 2: %s\n&quot;</span>, szValue2);</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">    address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">    address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure>

<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且同时适用于IPV4和IPV6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//socklen_t 的取值一般用如下两个宏，对应IPV4字符串的长度和IPV6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>



<h4 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>domain参数指明使用哪个底层协议，如AF_INET，AF_INET6，AF_UNIX。</p>
<p>type参数指定服务类型。主要为SOCKET_STREAM(流服务)适用于TCP协议，SOCK_DGRAM(数据报服务)适用于UDP协议。</p>
<p>protocol在前两个参数的前提下，指定一个具体的协议。因为前两个参数基本已经完全决定了它的值。在几乎所有情况下，把它设置为0，表示默认协议。</p>
<h4 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h4><p>即将sockaddr绑到socket上去:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>常见的两种errno</p>
<p>EACCES:被保定的地址是受保护的地址，仅超级用户能访问。</p>
<p>EADDRINUSE:被绑定地址正在使用中。比如绑到一个处于TIME_WAIT状态的socket地址。</p>
<h4 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h4><p>创建监听队列存放待处理的客户连接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>backlog参数在内核版本2.2之后，表示完全处于连接状态的socket上线，处于半连接状态的socket上线由        &#x2F;proc&#x2F;sys&#x2F;ipv4&#x2F;tcp_mas_syn_bakclog内核参数定义。</p>
<h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>下面的系统调用从listen监听队列中接受一个连接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>accept成功时返回一个新的连接socket，该socket唯一地标识了被接收的这个连接。</p>
<h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>客户端通过如下系统调用来主动与服务器建立连接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>失败常见的两种errno:</p>
<p>ECONNREFUED:目标端口不存在，连接被拒绝。</p>
<p>ETIMEDOUT:连接超时。</p>
<h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>关闭连接，也就是关闭对应的socket，通过如下系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>close实际上的操作，是将文件描述符fd的引用计数减1，只有引用计数为0时，才真正关闭连接。所以在多进程程序中，一次fork调用会导致父进程中打开的socket引用计数加1，只有父子进程都执行了close，才能将连接关闭。</p>
<p>如果想立即终止连接，可以使用shutdown系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span>;</span><br></pre></td></tr></table></figure>

<p>howto参数决定shutdown的行为:</p>
<p><img src="/./../pic/image-20230421200510032.png" alt="image-20230421200510032"></p>
<h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><p><strong>a) TCP数据读写</strong></p>
<p>socket编程接口提供的几个用于TCP流数读写的系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>flags参数为数据收发提供了额外的控制，具体可选值如下表:</p>
<p><img src="/./../pic/image-20230421200813084.png" alt="image-20230421200813084"></p>
<p>MSG_OBB选项给应用程序提供了发送和接收带外数据方法，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送带外数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename( argv[<span class="number">0</span>]) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_address</span>;</span></span><br><span class="line">    bzero( &amp;serv_address, <span class="keyword">sizeof</span>(serv_address) );</span><br><span class="line">    serv_address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;serv_address.sin_addr );</span><br><span class="line">    serv_address.sin_port = htons(port);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET ,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_address, <span class="keyword">sizeof</span>(serv_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * obb_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">        send(sockfd, obb_data, <span class="built_in">strlen</span>(obb_data), MSG_OBB);</span><br><span class="line">        send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收带外数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt;= <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(...);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_int</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, sizeog(address) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address) );</span><br><span class="line">    assert( ret != <span class="number">1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret != <span class="number">1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clinet_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> buffer[ BUF_SIZE ];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SZIE );</span><br><span class="line">        ret = recv( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SZIE );</span><br><span class="line">        ret = recv( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OBB );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of obb data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SZIE );</span><br><span class="line">        ret = recv( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">        </span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">got <span class="number">5</span> bytes of normal data <span class="string">&#x27;123ab&#x27;</span></span><br><span class="line">got <span class="number">1</span> bytes of obb data <span class="string">&#x27;c&#x27;</span></span><br><span class="line">got <span class="number">3</span> bytes of normal data <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>b) UDP数据读写</strong></p>
<p>socket编程中用于UDP数据报读写的系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr</span></span><br><span class="line"><span class="params">               , <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags</span></span><br><span class="line"><span class="params">               , <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklent_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>UDP没有通信的概念，所以每次读取和发送数据都需要指定目标的socket地址。</p>
<p>该系统调用也可以用于面向连接的socket，只需要把最后两个参数设置为NULL，忽略地址。</p>
<p><strong>c) 通用数据读写函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags )</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags )</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *msg_name;			<span class="comment">/* socket地址 */</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_namelen;	<span class="comment">/* socket地址的长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span>	<span class="comment">/* 分散的内存块 */</span></span><br><span class="line">    <span class="type">int</span> msg_iovlen;			<span class="comment">/* 分散内存块的数量 */</span></span><br><span class="line">    <span class="type">void</span> *msg_contorl;		<span class="comment">/* 指向辅助数据的起始位置 */</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_contorllen;<span class="comment">/* 辅助数据的大小 */</span></span><br><span class="line">    <span class="type">int</span> msg_flags;			<span class="comment">/* 复制函数中的flags参数，并在调用中更新 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base;			<span class="comment">/* 内存起始地址 */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;			<span class="comment">/* 这块内存的长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iovec用于分散读和集中写。</p>
<p>msg_control，辅助数据，13章介绍如何使用它们来实现进程间传递文件描述符。</p>
<h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>前面演示了TCP带外数据的接收方法，但实际应用中，无法预期带外数据何时到来。所以有了如下系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">( <span class="type">int</span> sockfd )</span>;</span><br></pre></td></tr></table></figure>

<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取的数据是否是带外数据。如果是返回1，此时就可以利用带MSG_OBB标志的recv调用来接收带外数据。</p>
<h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><p>用以知道本端的socket地址，以及远端的socket地址:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span> *address_len )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span> *address_len )</span>;</span><br></pre></td></tr></table></figure>

<p>getsockname获取本端的，getpeername获取对端的。</p>
<h4 id="5-11-socket选项"><a href="#5-11-socket选项" class="headerlink" title="5.11 socket选项"></a>5.11 socket选项</h4><p>下面两个系统调用用来读取和设置socket文件描述符属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">( <span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span> *option_value, </span></span><br><span class="line"><span class="params">              <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">( <span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span> *option_value, </span></span><br><span class="line"><span class="params">              <span class="type">socklen_t</span> option_len )</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230421204334261.png" alt="image-20230421204334261"></p>
<p><strong>a) SO_REUSEADDR选项</strong></p>
<p>通过设置该选项，强制使用处于被TIME_WAIT状态的连接占用的socket地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用例</span></span><br><span class="line"><span class="type">int</span> sock = socket( AF_INET ,SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line"><span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeog( reuse ) );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">address.sin_port = htons( port );</span><br><span class="line"><span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br></pre></td></tr></table></figure>



<p><strong>b) SO_RCVBUF和SO_SNDBUF选项</strong></p>
<p>设置接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接收缓冲区的最小值是256，发送缓冲最小值是2048。目的是，确保一个TCP连接拥有足够的空间缓冲区来处理拥塞。通过之间修改内核参数可以强制其没有最小值限制。</p>
<p><img src="/./../pic/image-20230421205007797.png" alt="image-20230421205007797"></p>
<p><img src="/./../pic/image-20230421205106368.png" alt="image-20230421205106368"></p>
<p>执行如下：</p>
<p><img src="/./../pic/image-20230421205204755.png" alt="image-20230421205204755"></p>
<p>可以看出50字节的设置没有成功，系统将其设置为了最小值256，2000成功了，且系统将其实际上加倍</p>
<p><strong>c) SO_RCVLOWAT和SO_SNDLOWAT选项</strong></p>
<p>SO_RCVLOWAT和SO_SNDLOWAT选项分别标识TCP接收缓冲区和发送缓冲区的低水位标记。一般用于I&#x2F;O复用系统调用用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总数大于其低水位标记时，通常读数据；当TCP发送缓冲区的空闲空间大于其低水位标记时，通知写数据。</p>
<p>一般默认值均为1字节。</p>
<p><strong>d) SO_LINGER选项</strong></p>
<p>SO_LINGER选项用来控制close系统调用在关闭TCP连接时的行为。默认情况下，close关闭socket，close立即返回，TCP模块负责把socket对应TCP发送缓冲区中残留的数据发送给对方。</p>
<p>设置该选项，需用传递一个linger类型的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> l_onoff;		<span class="comment">/* 非0开启， 0关闭该选项 */</span></span><br><span class="line">    <span class="type">int</span> l_linger;		<span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据参数的不同有如下三种行为:</p>
<pre><code>    1) l_onoff等于0，此时该选项不起作用，与close默认类似
    1) l_onoff不为0，l_linger等于0，此时close立即返回，丢弃残留的数据，同时发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。
    1) l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件:一是被关闭的socket对应的发送缓冲区是否有残留数据，二是socket是阻塞的还是非阻塞的。对于阻塞的，close等待一段长为l_linger的时间，直到残留数据被发送完并且得到对方的确认。如果没有发送完并得到确认，返回-1并设置errno为EWOULDBLOCK。如果是非阻塞，close立即返回。
</code></pre>
<h4 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h4><p>简单来说避免直接使用IP地址，通过之后的一些函数实现，主机名代替IP地址，服务名代替端口号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>

<p><strong>a) gethostbyname和gethostbyaddr</strong></p>
<p>分别根据主机名获取主机的完整信息和根据IP地址获取主机的完整信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyname</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * name )</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyaddr</span><span class="params">( <span class="type">const</span> <span class="type">void</span> * addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> * h_name;			<span class="comment">/* 主机名 */</span></span><br><span class="line">    <span class="type">char</span> ** h_aliases;		<span class="comment">/* 主机别名列表 */</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;			<span class="comment">/* 地址类型 */</span></span><br><span class="line">    <span class="type">int</span> h_length;			<span class="comment">/* 地址长度 */</span></span><br><span class="line">    <span class="type">char</span> ** h_addr_list;	<span class="comment">/* 网络字节序列出的主机IP地址列表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>b) getservbyname和getservbyport</strong></p>
<p>根据名称获取某个服务的完整信息，和根据端口号获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent * <span class="title function_">getservbyname</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * name, <span class="type">const</span> <span class="type">char</span> * proto )</span>;</span><br><span class="line"><span class="keyword">struct</span> servent * <span class="title function_">getservbyport</span><span class="params">( <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> * proto )</span>;</span><br></pre></td></tr></table></figure>

<p>proto参数指定服务类型，”tcp”标识获取流服务，”udp”标识获取udp服务，NULL标识所有服务类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name;			<span class="comment">/* 服务名称 */</span></span><br><span class="line">    <span class="type">char</span> ** s_aliases;		<span class="comment">/* 服务的别名列表 */</span></span><br><span class="line">    <span class="type">int</span> s_port;				<span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="type">char</span> * s_proto;			<span class="comment">/* 服务类型 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例子:通过主机名和服务名访问目标服务器上的daytime服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    assert( argc == <span class="number">2</span>);</span><br><span class="line">    <span class="type">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取目标主机地址信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostinfo</span> =</span> gethostbyname( host );</span><br><span class="line">    assert( hostinfo );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取daytime服务信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> =</span> getservbyname( <span class="string">&quot;daytime&quot;</span>, <span class="string">&quot;tcp&quot;</span> );</span><br><span class="line">    assert( servinfo );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;daytime port is %d\n&quot;</span>, ntohs( servinfo-&gt;s_port ) );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = servinfo-&gt;s_port;</span><br><span class="line">    address.sin_addr = *( <span class="keyword">struct</span> in_addr* )*hostinfo-&gt;h_addr_list;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sockfd = socket( AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> result = connect( sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( result != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    result = read( sockfd, buffer, <span class="keyword">sizeof</span>( buffer ) );</span><br><span class="line">    assert( result &gt; <span class="number">0</span> );</span><br><span class="line">    buffer[result] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the day time is: %s&quot;</span>, buffer );</span><br><span class="line">    close( sockfd );</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>c) getaddrinfo</strong></p>
<p>getaddrinfo既能通过主机名获取IP地址，也能通过服务名获取端口号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo ** result)</span>;</span><br></pre></td></tr></table></figure>

<p>hitns参数用以给getaddrinfo一个目标期望，resulst参数指向一个链表，用于存储反馈结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;				<span class="comment">/* 见后文 */</span></span><br><span class="line">    <span class="type">int</span> ai_family;				<span class="comment">/* 地址族 */</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;			<span class="comment">/* 服务类型 */</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;			<span class="comment">/* 见后文 */</span></span><br><span class="line">    <span class="type">socklen_t</span> ai_addrlen;		<span class="comment">/* socket地址ai_addr的长度 */</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;			<span class="comment">/* 主机的别名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>	<span class="comment">/* 指向socket的地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>	<span class="comment">/* 指向下一个addrinfo结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230421212321225.png" alt="image-20230421212321225"></p>
<p>当我们使用hints参数时，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，用法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">bzero( &amp;hitns, <span class="keyword">sizeof</span>(hints) );</span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">getaadrinfo( <span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, &amp;hints, &amp;res);</span><br></pre></td></tr></table></figure>

<p>表示只获取主机ernest-laptop上daytime的流服务，也就是TCP服务。</p>
<p>在getaddrinfo调用结束后，使用如下函数释放内存:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaadrinfo</span><span class="params">( <span class="keyword">struct</span> addrinfo *res )</span>;</span><br></pre></td></tr></table></figure>



<p><strong>d) getnameinfo</strong></p>
<p>getnameinfo函数能通过socket地址同时获得以字符串表示的主机名和服务名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">( <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span> *host,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> hostlen, <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>flags参数控制getnameinfo的行为，如下:</p>
<p><img src="/./../pic/image-20230421212738175.png" alt="image-20230421212738175"></p>
<p>失败时返回的错误码表如下:</p>
<p><img src="/./../pic/image-20230421212824151.png" alt="image-20230421212824151"></p>
<h3 id="第6章-高级I-x2F-O函数"><a href="#第6章-高级I-x2F-O函数" class="headerlink" title="第6章 高级I&#x2F;O函数"></a>第6章 高级I&#x2F;O函数</h3><p>诸如pipe，dup&#x2F;dup2等这类函数的介绍</p>
<h4 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h4><p>pipe函数可用于创建一个管道，以实现进程间通信。本章只讨论基本使用方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>fd[0]和fd[1]分别构成管道的两端，fd[1]为写端，fd[0]为读端。并且是单向的，如果要实现双向的数据传输，需要两根管道。如果管道的写端fd[1]的引用计数减少至0，针对该管道的读端fd[0]的read操作将返回0，即读到文件结束标记(EOF)。反之如果读端fd[0]的引用计数减少至0，针对该管道的写端fd[1]的write操作将失败，并引发SIGPIPE信号。</p>
<p>管道本身拥有一个容量限制，大小默认是65535字节。可以使用fcntl来修改。</p>
<p>此外，socket的基础api种有一个socketpari函数。用以方便地创建双向管道:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>前三个参数和socket的参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为仅能在本地使用。</p>
<h4 id="6-2-dup函数和dup2函数"><a href="#6-2-dup函数和dup2函数" class="headerlink" title="6.2 dup函数和dup2函数"></a>6.2 dup函数和dup2函数</h4><p>重定向文件描述符，比如将标准输入重定向到一个文件。可以通过如下用于复制文件描述符的dup&#x2F;dup2函数实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span>;</span><br></pre></td></tr></table></figure>

<p>利用函数实现一个基本GGI服务器例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prot = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        close( STDOUT_FILENO );</span><br><span class="line">        dup( connfd );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;abcd\n&quot;</span> );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先关闭标准输出，此时dup的特性，返回最小可用的文件描述符，即此时标志输出被重定向到connfd，此时的printf将直接发送到connfd连接的socket上。</p>
<h4 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h4><p>集中写和分散读函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>考略之前的Web服务器，当Web服务器解析完一个HTTP请求后，如果目标文档存在且客户具有读权限，那么就要发送一个HTTP应答。这个HTTP应答包含一个状态行，多个头部字段，一个空行和文档的内容，前三部分内容可能存放在一块内存，文档的内容则在另一块单独的内存，此时可以用集中写，将他们一起写出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#icnlude <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SZIE 1024</span></span><br><span class="line"><span class="comment">/* 定义两种HTTP状态码和状态信息 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *status_line[<span class="number">2</span>] = &#123; <span class="string">&quot;200 ok&quot;</span>, <span class="string">&quot;500 Internal server error&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: ... &quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将目标文件作为程序的第三个参数传入 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 用于保存HTTP应答的状态行，头部字段和一个空行的缓存区 */</span></span><br><span class="line">        <span class="type">char</span> header_buf[BUFFER_SIZE];</span><br><span class="line">        <span class="built_in">memset</span>( header_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="comment">/* 用于存放目标文件内容的应用程序缓存 */</span></span><br><span class="line">        <span class="type">char</span> *file_buf;</span><br><span class="line">        <span class="comment">/* 用于获取目标文件的属性，比如是否为目录，文件大小等 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">        <span class="comment">/* 记录目标文件是否是有效文件 */</span></span><br><span class="line">        <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* 缓存区header_buf目前已使用多少字节的空间 */</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( stat( file_name, &amp;file_stat) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 目标文件不存在 */</span></span><br><span class="line">            valid  = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( S_ISDIR( file_stat.st_mode ) ) &#123;<span class="comment">/* 目标文件为目录 */</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( file_stat.st_mode &amp; S_IROTH ) &#123;<span class="comment">/* 当前用户有读取目标文件的权限 */</span></span><br><span class="line">                <span class="comment">/* 动态分配缓存区file_buf，并指定其大小为目标文件的大小 */</span></span><br><span class="line">                <span class="comment">/* size+1 ，然后将目标文件读入file_buf */</span></span><br><span class="line">                <span class="type">int</span> fd = open( file_name, O_RDONLY );</span><br><span class="line">                file_buf = new <span class="type">char</span>[file_stat.st_size + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">memset</span>( file_buf, <span class="string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( read( fd, file_buf, file_stat.st_size ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( valid ) &#123;</span><br><span class="line">            <span class="comment">/* 将状态行，头部字段，空行依次加入header_buf种 */</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">0</span>] );</span><br><span class="line">            len+=ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, </span><br><span class="line">                            file_stat.st_size );</span><br><span class="line">            len+=ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 集中写 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iv</span>[2];</span></span><br><span class="line">            iv[<span class="number">0</span>].iov_base = header_buf;</span><br><span class="line">            iv[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>( header_buf );</span><br><span class="line">            iv[<span class="number">1</span>].iov_base = file_buf;</span><br><span class="line">            iv[<span class="number">1</span>].iov_len = file_stat.st_size;</span><br><span class="line">            ret = writev( connfd, iv, <span class="number">2</span> ); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">/* 如果目标文件无效，通知客户端发生了“内部错误” */</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">1</span>] );</span><br><span class="line">            len+=ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            send( connfd, header_buf, <span class="built_in">strlen</span>( header_buf ), <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        close( connfd );</span><br><span class="line">        delete [] file_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h4><p>sendfile在两个文件描述符之间直接传递数据，完全在内核种操作，避免了内核缓存区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>in_fd是待读出内容的文件描述符，out_fd是待写入内容的文件描述符，offset为读入文件流的偏移位置，count为拷贝字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用sendfile函数将服务器上的一个文件发送给客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#icnlude <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prot = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> filefd = open( file_name, O_RDONLY );</span><br><span class="line">    assert( filefd&gt;<span class="number">0</span> );</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    fstat( filfd, &amp;stat_buf );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sendfile( connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h4 id="6-5-mmap函数和munmap函数"><a href="#6-5-mmap函数和munmap函数" class="headerlink" title="6.5 mmap函数和munmap函数"></a>6.5 mmap函数和munmap函数</h4><p>mmap函数用于申请一段内存空间。可用将这段内存作为进程间通信的共享内存，也可以直接将文件映射到其中。mumap函数则释放mmap创建的这段内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>start参数允许用户使用某个特定的地址作为其实地址，设置为NULL，则系统自动分配一个地址。prot参数用来设置内存段的访问权限，可取以下几个值的按位或：</p>
<ol>
<li>PROT_READ，内存段可读。</li>
<li>PROT_WRITE，内存段可写。</li>
<li>PROT_EXEC，内存段可执行。</li>
<li>PROT_NONE，内存段不能被访问。</li>
</ol>
<p>flags参数控制内存段内容被修改后程序的行为。如下表，其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定:</p>
<p><img src="/./../pic/image-20230422163826042.png" alt="image-20230422163826042"></p>
<h4 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h4><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>fd_in是待输入数据的文件描述符。</p>
<p>flags参数的常用值:</p>
<p><img src="/./../pic/image-20230422164052858.png" alt="image-20230422164052858"></p>
<p>使用splice函数时，fd_in和fd_out必须至少有一个时管道文件描述符。splice函数常见的errno如下：</p>
<p><img src="/./../pic/image-20230422164152069.png" alt="image-20230422164152069"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用splice函数实现的回射服务器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinte/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        ret = pipe( pipefd );		<span class="comment">/* 创建管道 */</span></span><br><span class="line">        <span class="comment">/* 将connfd上流入的客户数据定向到管道 */</span></span><br><span class="line">        ret = splice( connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, </span><br><span class="line">                      SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        <span class="comment">/* 将管道的输出定向到connfd客户连接文件描述符 */</span></span><br><span class="line">        ret = splice( pipifd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>,</span><br><span class="line">                     SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h4><p>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out , <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数和splice一致，但fd_in和fd_out必须都是管道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同时输出数据到终端和文件的程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc !=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> filefd = open( argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span> );</span><br><span class="line">    assert( filefd&gt;<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe( pipefd_stdout );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将标准输入内容输入管道 */</span></span><br><span class="line">    ret = splice( STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>,</span><br><span class="line">                  <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    <span class="comment">/* 将管道的输出复制到pipefd_file的输入端 */</span></span><br><span class="line">    ret = tee( pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    <span class="comment">/* 将管道file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件 */</span></span><br><span class="line">    ret = splice( pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, </span><br><span class="line">                  <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">    assert( ret !=<span class="number">-1</span> );</span><br><span class="line">    <span class="comment">/* 将管道stdout定向到标准输出，将内容写道终端 */</span></span><br><span class="line">    ret = splice( pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>,</span><br><span class="line">                  <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    close( filefd );</span><br><span class="line">    close( pipefd_stdout[<span class="number">0</span>] );</span><br><span class="line">    close( pipefd_stdout[<span class="number">1</span>] );</span><br><span class="line">    close( pipefd_file[<span class="number">0</span>] );</span><br><span class="line">    close( pipefd_file[<span class="number">1</span>] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>支持的常用操作如下表:</p>
<p><img src="/./../pic/image-20230422165821737.png" alt="image-20230422165821737"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用例 将文件描述符设置为非阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl( fd, F_GETFL );		<span class="comment">/* 获取文件描述符旧状态 */</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK; 	<span class="comment">/* 设置非阻塞 */</span></span><br><span class="line">    fcntl( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;							<span class="comment">/* 返回旧状态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h3><p>服务器程序的常见模板:</p>
<p>以守护进程运行，拥有一套日志系统，以某个专门的非root身份运行，通常可配置的也就是拥有配置文件，通常会在启动的时候生成一个PID文件并存入&#x2F;var&#x2F;run目录，通常需要考虑系统资源和限制。</p>
<h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><p><strong>a) Linux系统日志</strong></p>
<p>Linux提供一个守护进程来处理系统日志——syslogd，现在使用的为它的升级版——rsyslogd。</p>
<p>分为内核输出的日志和用户输出的日志。</p>
<p>内核：由printk等函数打印至内核的环状缓存(ring buffer)中。环状缓存的内容直接映射到&#x2F;proc&#x2F; kmsg文件中。</p>
<p>用户：通过调用syslog函数生成系统日志，该函数将日志输出到一个UNIX本地域socket类型的文件&#x2F;dev&#x2F;log中，rsyslogd则监听该文件以获取用户进程的输出。</p>
<p>rsylogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调式信息会保存至&#x2F;var&#x2F;log&#x2F;debug文件，普通信息&#x2F;var&#x2F;log&#x2F;message文件，内核消息&#x2F;var&#x2F;log&#x2F;kern&#x2F;loh文件。日志信息具体如何分发，可在rsyslogd的配置文件中设置。</p>
<p><img src="/./../pic/image-20230424192236582.png" alt="image-20230424192236582"></p>
<p><strong>b) syslog函数</strong></p>
<p>应用程序使用syslog函数与rsylogd守护进程通信:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *message, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>priority参数是所谓的设施值与日志级别的按位或。设施值的默认值是LOG_USER，下面的讨论仅限于该值。日志级别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_EMERG			0	<span class="comment">/* 系统不可用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ALERT			1 	<span class="comment">/* 报警，需要立即采取动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_CRIT			2 	<span class="comment">/* 非常严重的情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERR				3	<span class="comment">/* 错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING 		4	<span class="comment">/* 警告 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_NOTICE 			5	<span class="comment">/* 通知 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO			6	<span class="comment">/* 信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG			7	<span class="comment">/* 调试 */</span></span></span><br></pre></td></tr></table></figure>

<p>下面这个函数可改变syslog的默认输出方式，进一步结构化日志内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure>

<p>ident参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行配置，它可取下列值的按位或:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_PID			0X01	<span class="comment">/* 在日志消息中包含程序PID */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_CONS 		0X02	<span class="comment">/* 如果消息不能记录到日志文件，则打印至终端 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ODELAY		0X04 	<span class="comment">/* 延迟打开日志功能直到第一次调用syslog */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_NDELAY		0X08	<span class="comment">/* 不延迟打开日志功能 */</span></span></span><br></pre></td></tr></table></figure>

<p>facility参数可用来修改syslog函数中的默认值。</p>
<p>下面这个函数用于设置syslog的日志掩码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br></pre></td></tr></table></figure>

<p>如下函数关闭日志功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><p><strong>a) UID, EUID, GID 和 EGID</strong></p>
<p>下面这一组函数可用获取和设置当前进程的真实用户ID(UID)，有效用户ID(EUID)，真实组(GID)和有效组(EGID):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">()</span>;			</span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">seteuid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure>

<p>测试进程的UID和EUID的区别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="type">uid_t</span> euid = geteuid();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effectie userid is %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译该文件，将生成的可执行文件(test_uid)的所有者设置为roort，并设置该文件的set-user-id标志，然后运行该程序查看UID和EUID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root:root test_uid		<span class="comment">//修改目标文件的所有者为root</span></span><br><span class="line">$ sudo chmod +s test_uid 			<span class="comment">//设置目标文件的set-uset-id标志</span></span><br><span class="line">$ ./test_uid 						<span class="comment">//运行程序</span></span><br><span class="line">userid is <span class="number">1000</span>, effective userid is <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可看出进程的UID是启动用户的ID，而EUID则是root账户的ID</p>
<p><strong>b) 切换用户</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何将以root身份启动的进程切换为以一个普通用户身份运行</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">switch_to_user</span><span class="params">(<span class="type">uid_t</span> user_id, <span class="type">gid_t</span> gp_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 确保目标用户不是root */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 确保当前用户是合法用户: root或者目标用户 */</span></span><br><span class="line">    <span class="type">gid_t</span> gid = getgid();</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="keyword">if</span> ( ( (gid != <span class="number">0</span>) || (uid != <span class="number">0</span>) ) &amp;&amp; </span><br><span class="line">          ( (gid != gp_id ) || ( uid != user_id ) ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果不是root，则已是目标用户 */</span></span><br><span class="line">    <span class="keyword">if</span> ( uid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 切换到目标用户 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( setgid( gp_id ) &lt; <span class="number">0</span>) || ( setuid( user_id ) &lt; <span class="number">0</span> ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><p><strong>a) 进程组</strong></p>
<p>每个进程都属于一个进程组，除了它们的PID信息外，还有进程组ID(PGID)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#included <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>

<p>每个进程都有一个首领进程，其PGID和PID相同。进程组将一直存在，直到其中所有进程都退出或加入其他的进程组。</p>
<p>下面的函数用于设置PGID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure>

<p>将PID为pid的进程的PGID设置为pgid，如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领。如果pid为0，则表示设置当前进程的PGID为pgid，如果pgid为0，则使用pid作为目标PGID。</p>
<p><strong>b) 会话</strong></p>
<p>一些有关联的进程组将形成一个会话，下面的函数用于创建一个会话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数不能由进程组的首领进程调用，否则将产生一个错误。对于非组首领的进程，调用函数不仅创建新会话，而且有如下额外效果：</p>
<ol>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li>
<li>新建一个进程组，其GPID就是调用进程的PID，调用进程成为改组的首领。</li>
<li>调用进程将甩开终端。</li>
</ol>
<p>如下函数读取会话ID(SID):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>c) 用ps命令查看进程关系</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -o pid,ppid,pgid,sid,comm | less</span><br><span class="line">PID		PPID	PGID	SID		COMMAND</span><br><span class="line"><span class="number">1943</span>	<span class="number">1942</span>	<span class="number">1943</span>	<span class="number">1943</span>	bash</span><br><span class="line"><span class="number">2298</span>	<span class="number">1943</span>	<span class="number">2298</span>	<span class="number">1943</span>	ps</span><br><span class="line"><span class="number">2299</span>	<span class="number">1942</span>	<span class="number">2298</span>	<span class="number">1943</span>	less</span><br></pre></td></tr></table></figure>

<p>三者关系如下图:</p>
<p><img src="/./../pic/image-20230424195432213.png" alt="image-20230424195432213"></p>
<h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux系统资源限制可用通过如下一对函数来读取和设置:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resuorce.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    rlim_r rlim_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rlim_cur指定资源的软限制，rlim_max指定资源的硬限制。软限制是一个建议性的，最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。硬限制一般是软限制的上限，普通程序可减小硬限制，而只有root身份运行的程序才能增加硬限制。下图列举了部分比较重要的资源限制类型:</p>
<p><img src="/./../pic/image-20230424195811465.png" alt="image-20230424195811465"></p>
<h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有的服务器程序需要改变工作目录。如前面讨论的Web服务器。</p>
<p>获取当前工作目录和改变进程工作目录的函数分别是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>改变进程根目录的函数是chroot，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“&#x2F;“)来将工作目录切换至新的根目录。此外，只有特权进程才能改变根目录。</p>
<h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>讨论在代码中如何让一个进程以守护进程的方式运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">daemonize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建子进程，关闭父进程，这样可使程序在后台运行 */</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置文件权限掩码。当进程创建新文件(使用open(...))时文件的权限将是mode &amp; 0777 */</span></span><br><span class="line">    umask( <span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建新的会话，设置本进程为进程组首领 */</span></span><br><span class="line">    <span class="type">pid_t</span> sid = setsid();</span><br><span class="line">    <span class="keyword">if</span> ( sid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 切换工作目录 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( chdir( <span class="string">&quot;/&quot;</span> ) ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭标准输入，标准输出和标准错误输出 */</span></span><br><span class="line">    close( STDIN_FILENO );</span><br><span class="line">    close( STDOUT_FILENO );</span><br><span class="line">    close( STDERR_FILENO );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭其他已经打开的文件描述符 */</span></span><br><span class="line">    . . . . . .</span><br><span class="line">    <span class="comment">/* 将标准输入，标准输出和标准错误定向到/dev/null */</span></span><br><span class="line">    open( <span class="string">&quot;dev/null&quot;</span>, O_RDONLY );</span><br><span class="line">    open( <span class="string">&quot;dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    open( <span class="string">&quot;dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux提供了完成同样功能的库函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">(<span class="type">int</span> nochdi, <span class="type">int</span> noclose)</span>;</span><br></pre></td></tr></table></figure>

<p>nochdir参数用于指定是否改变工作目录，为0则设置为”&#x2F;“，否则继续使用当前。</p>
<p>nclose参数为0时，标准输入，输出，错误都被重定向到&#x2F;dev&#x2F;null文件，否则依然使用原来的设备。</p>
<h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><p>按照服务器程序的一般原理，将服务器解构成三个模块：</p>
<p>I&#x2F;O处理单元，逻辑单元，存储单元。</p>
<h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><p><strong>a) CS模型</strong></p>
<p>最常见的客户端，服务端模型。</p>
<p><img src="/./../pic/image-20230425194243467.png" alt="image-20230425194243467"></p>
<p><strong>b) P2P模型</strong></p>
<p>摒弃了以服务器为中心的格局，网络上所有主机重新回归对等的地位。</p>
<p><img src="/./../pic/image-20230425194354181.png" alt="image-20230425194354181"></p>
<p>P2P模型使得每台机器在消耗服务的同时也能给别人提供服务，这样资源能够充分，自由地共享。P2P模型存在一个显著的问题，即主机之间很难互相发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，提供查找服务，使每个客户能尽快的找到自己需要的资源。</p>
<p><img src="/./../pic/image-20230425194539047.png" alt="image-20230425194539047"></p>
<h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><p>基本框架如下:</p>
<p><img src="/./../pic/image-20230425194621559.png" alt="image-20230425194621559"></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>单个服务器程序</th>
<th>服务器机群</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O处理单元</td>
<td>处理客户连接，读写网络数据</td>
<td>作为接入服务器，实现负载均衡</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
<td>逻辑服务器</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>本地数据库，文件或缓存</td>
<td>数据库服务器</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
<td>各服务器之间的永久TCP连接</td>
</tr>
</tbody></table>
<p>请求队列是各个单元之间通信方式的抽象，I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。请求队列通常被实现为池的一部分。</p>
<h4 id="8-3-I-x2F-O模型"><a href="#8-3-I-x2F-O模型" class="headerlink" title="8.3 I&#x2F;O模型"></a>8.3 I&#x2F;O模型</h4><p>I&#x2F;O模型对比:</p>
<table>
<thead>
<tr>
<th>I&#x2F;O模型</th>
<th>读写操作和阻塞阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞I&#x2F;O</td>
<td>程序阻塞于读写函数</td>
</tr>
<tr>
<td>I&#x2F;O复用</td>
<td>程序阻塞于I&#x2F;O复用系统调用(如select)，但可同时监听多个I&#x2F;O事件。对I&#x2F;O本身的读写操作是非阻塞的</td>
</tr>
<tr>
<td>SIGIO信号</td>
<td>信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段</td>
</tr>
<tr>
<td>异步I&#x2F;O</td>
<td>内核执行读写操作并触发读写完成事件。程序没有阻塞阶段</td>
</tr>
</tbody></table>
<p>针对非阻塞I&#x2F;O执行的系统调用总是立即返回，而不管事件是否已经发生。如果没有立即发生，返回-1和出错的情况一样。此时需要根据errno来区分这两种情况。</p>
<h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>同步I&#x2F;O常用于实现Reactor模式，异步I&#x2F;O则用于实现Proactor模式。</p>
<p><strong>a) Reactor模式</strong></p>
<p>该模式，要求主线程(I&#x2F;O处理单元)只负责监听文件描述符是否有事件发生，有的话立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程完成。</p>
<p>使用同步I&#x2F;O模型(epoll_wait)实现的的Reactor模型流程如下：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表注册该socket的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程则将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/./../pic/image-20230425200345744.png" alt="image-20230425200345744"></p>
<p><strong>b) Proactor模式</strong></p>
<p>Proactor模式将所有的I&#x2F;O操作交给主线程和内核来处理，工作线程仅负责业务逻辑。因此，该模式更符合前面所描述的服务器编程框架。</p>
<p>使用异步I&#x2F;O模型(以aio_read和aio_write为例)实现的Proactor模式的流程如下:</p>
<ol>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理该客户请求。工作线程处理完客户请求后，调用aio_write函数向内核注册该socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入socket之后，内核向应用程序发送一个信号，通知应用程序数据已发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如是否关闭socket</li>
</ol>
<p><img src="/./../pic/image-20230425200949529.png" alt="image-20230425200949529"></p>
<p><strong>c) 模拟Proactor模式</strong></p>
<p>使用同步I&#x2F;O方式模拟出Proactor模式的一种方法。简单来说将数据读写操作这一工作，从逻辑单元移交给I&#x2F;O处理单元，读写完成后，主线程向工作线程通知这一”完成事件”。</p>
<p>使用同步I&#x2F;O模型(epoll_wait)模拟出的Proactor模式的流程如下：</p>
<ol>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，读完后，将读到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理该客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wati通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/./../pic/image-20230425201451976.png" alt="image-20230425201451976"></p>
<h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发编程的目的简单来说为了提高程序的效率。对于计算密集型来说，并发没有优势，反而因为任务的切换使得效率降低。但对于I&#x2F;O密集型，比如经常读写文件，访问数据库。由于I&#x2F;O操作的速度远没有CPU的计算速度快，让程序阻塞于I&#x2F;O操作将浪费大量的CPU事件。因此，并发可使CPU的利用率显著提升。</p>
<p>并发模式是指I&#x2F;O处理单元和多个逻辑单元之间协调完成任务的方法。服务器主要有两种并发编程模式：半同步&#x2F;半异步(half-sync&#x2F;half-async)模式和领导者&#x2F;追随者(Leader&#x2F;Followers)模式。</p>
<p><strong>a) 半同步&#x2F;半异步模式</strong></p>
<p>此处的同步&#x2F;异步和I&#x2F;O模型中的同步&#x2F;异步是完全不同的概念。</p>
<p>I&#x2F;O模型：同步和异步区分的是内核向应用程序通知的是何种I&#x2F;O事件(就绪事件 or 完成事件)，以及由谁来完成I&#x2F;O读写(应用程序 or 内核)。</p>
<p>并发模式：同步是指程序完全按照代码序列的顺序执行，异步是指程序的执行需要由系统事件来驱动。常见的系统事件包括中断，信号等。</p>
<p>下图a描述了同步的读操作，b描述了异步的读操作：</p>
<p><img src="/./../pic/image-20230425202247401.png" alt="image-20230425202247401"></p>
<p>按同步方式运行的线程称为同步线程，异步方式则称为异步线程。异步效率高，复杂；同步效率低，简单。</p>
<p>同步线程用于处理客户逻辑，即逻辑单元；异步线程处理I&#x2F;O事件，即I&#x2F;O处理单元。</p>
<p>异步线程监听到客户请求后，将其封装成请求对象插入请求队列。请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象。</p>
<p><img src="/./../pic/image-20230425202757521.png" alt="image-20230425202757521"></p>
<p>半同步&#x2F;半异步模式的变体，半同步&#x2F;半反应堆模式：</p>
<p><img src="/./../pic/image-20230425203208587.png" alt="image-20230425203208587"></p>
<p>异步线程只有主线程，主线程插入请求队列的任务是就绪的连接socket。这说明改图采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这也是该模式半反应堆的含义。该模式存在如下缺点：</p>
<ol>
<li>主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而耗费CPU时间。</li>
<li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，工作线程较少，请求队列中任务对象越堆越多，客户端响应速度将越来越慢。</li>
</ol>
<p>下图描述了一种相对高效的半同步&#x2F;半异步模式：</p>
<p><img src="/./../pic/image-20230425203636019.png" alt="image-20230425203636019"></p>
<p>主线程只管监听socket，连接socket由工作线程来管理，此后该新socket上的任何I&#x2F;O操作都由被选中的工作线程来处理，直到客户关闭连接。</p>
<p>可见每个线程都维持自己的事件循环，它们各自独立地监听不同的事件。</p>
<p><strong>b) 领导者&#x2F;追随者模式</strong></p>
<p>该模式是多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件的一种模式。任何时间，程序仅有一个领导者，它负责监听I&#x2F;O事件。当前领导者如果检测到I&#x2F;O事件，首先从线程池中推选出新的领导者线程，然后处理I&#x2F;O事件。此时，新的领导者等待新的I&#x2F;O事件，原先的领导者则处理I&#x2F;O事件。</p>
<p>领导者&#x2F;追随者模式包含如下几个组件：句柄集(HandleSet)，线程集(ThreadSet)，事件处理器(EventHandler)和具体的事件处理器(ConcreteEventHandler)。</p>
<p><img src="/./../pic/image-20230425204250102.png" alt="image-20230425204250102"></p>
<p>​	<em>1.句柄集</em>：</p>
<p>句柄用于表示I&#x2F;O资源，句柄集管理众多句柄，它使用waif_for_event方法来监听句柄上的I&#x2F;O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定在Handle上的事件处理器来处理事件。领导者将Handle和事件处理器绑定是通过调用句柄集中的register_handle方法实现的。</p>
<p>​	<em>2.线程集:</em></p>
<p>所有工作线程的管理者，负责各线程之间的同步，以及新领导者线程的推选，任一线程必处于如下三种状态之一:</p>
<p>​	Leader：线程当前处于领导者线程，负责等待句柄集上的I&#x2F;O事件。</p>
<p>​	Processing：线程正在处理事件。领导者检测到I&#x2F;O之间之后，转移到该状态来处理事件，并调用promote_new_leader方法推选新的领导者；也可以指定其他追随者来处理时间，此时领导者地位不变。当处于Processing状态的线程处理完后，如果没有领导者，它将称为领导者，反之称为追随者。</p>
<p>​	Follower：线程当前处于追随者身份。通过调用join方法等待称为新的领导者，也可能被领导指定处理新任务。</p>
<p><img src="/./../pic/image-20230425205723444.png" alt="image-20230425205723444"></p>
<p>​	<em>3.事件处理器和具体的事件处理器</em></p>
<p>事件处理器通常包含一个或多个回调函数handle_event。这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用之前需要被绑定到某个句柄之上。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的handle_event方法，以处理特定的任务。</p>
<p><img src="/./../pic/image-20230425210007874.png" alt="image-20230425210007874"></p>
<p>由于领导者线程自己监听I&#x2F;O并处理客户请求，因此不需要在线程之间传递任何额外的数据，也无需像半同步&#x2F;半反应堆那样在线程之间同步堆请求队列的访问。</p>
<h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><p>此节介绍逻辑单元内部的一种高效编程方法：有限状态机</p>
<p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE ( Package_pack )</span><br><span class="line">&#123;</span><br><span class="line">    PackageType _type = _pack.GetType();</span><br><span class="line">    <span class="keyword">switch</span> ( _type ) &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">            process_package_A( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">            process_package_B( _pack );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的有限状态机，但每个状态都是相互独立的，之间没有相互转移。状态之间的转移是需要状态机内部驱动的，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE ()</span><br><span class="line">&#123;</span><br><span class="line">    State cur_State  = type_A;</span><br><span class="line">    <span class="keyword">while</span> ( cur_State != type_C) &#123;</span><br><span class="line">        package _pack = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span> ( cur_State ) &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_package_state_A( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_package_state_B( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该状态机包含三种状态：type_A，type_B，type_C，A为开始状态，C为结束状态，通过curState判断以及给他传递状态值实现状态转移。</p>
<p>下面考虑有限状态机应用的一个实例：*<u>HTTP请求的读取和分析</u>*。</p>
<p>很多网络协议，在头部提供长度字段，根据该字段的值可以直到是否接收到一个完整的协议头部。但HTTP协议并未提供这样的头部长度字段，并且头部长度变化很大。根据协议规定，我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回车换行符(<CR><LF>)。</p>
<p>如果一次读操作没有读入HTTP请求的整个头部，即没有遇到空行，那么我们需要等待客户继续写数据并再次读入。因此我们每完成一次读操作，需要分析新读入的数据中是否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP请求头部的分析（空行前面还有请求行和头部域），以提高HTTP请求的效率。</p>
<p>如下代码使用主，从两个有限状态机实现了最简单的HTTP请求的读取和分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 4096    <span class="comment">/* 读缓冲区大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主状态机的两种状态，分别表示：当前正在分析请求行，当前正在分析头部字段  */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>, CHECK_STATE_HEADER &#125;;</span><br><span class="line"><span class="comment">/* 从状态机的三种状态，分别表示：读取到一个完整的行，行出错和行数据尚不完整 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_OPEN &#125;;</span><br><span class="line"><span class="comment">/* 服务器处理HTTP请求的结果：NO_REQUEST表示请求不完整，需要继续读取客户数；</span></span><br><span class="line"><span class="comment">   GET_REQUEST表示获得了一个完整的客户请求；BAD_REQUEST表示客户请求有语法</span></span><br><span class="line"><span class="comment">   错误；FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；INTERNAL_ERROR</span></span><br><span class="line"><span class="comment">   表示服务器内部错误；CLOSED_CONNECTION表示客户端已关闭连接了 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, </span><br><span class="line">    FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;</span><br><span class="line"><span class="comment">/* 简化问题，没有给客户端发送一个完整的HTTP应答报文，只发送处理结果成功还是失败 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *szret[] = &#123; <span class="string">&quot;I get a correct result\n&quot;</span>, <span class="string">&quot;Something wrong\n&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从状态机，用于解析出一行内容 */</span></span><br><span class="line">LINE_STATUS <span class="title function_">parse_line</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">int</span> &amp;checked_index, <span class="type">int</span> &amp;read_index )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="comment">/* checked_index指向Buffer(应用程序读缓冲区)中当前正在分析的字节，read_index</span></span><br><span class="line"><span class="comment">       指向buffer中客户数据尾部的下一字节，buffer中0~checked_index字节都已分析完毕</span></span><br><span class="line"><span class="comment">       第checked_index~(read_index-1)字节由下面的循环挨个分析 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; checked_index &lt; read_index; ++checked_index ) &#123;</span><br><span class="line">        <span class="comment">//获取当前分析字节</span></span><br><span class="line">        temp = buffer[checked_index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前字节是&quot;\r&quot;即回车符，则说明可能读到一个完整的行</span></span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果&quot;\r&quot;字符碰巧是buffer中最后一个被读入数据，那么这次分析没有读到</span></span><br><span class="line">            <span class="comment">//一个完整的行，返回LINE_OPEN表示需要继续读取客户数据才能进一步分析</span></span><br><span class="line">            <span class="keyword">if</span> ( ( checked_index + <span class="number">1</span>) == read_index ) &#123;</span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果下一字符是&quot;\n&quot;，表示成功读取一个完整的行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( buffer[checked_index+<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                buffer[checked_index++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                bffer[checked_index++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//否则说明存在语法问题</span></span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前字节是&quot;\n&quot;，即换行符，也说明可能读到一个完整行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( temp == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (checked_index &gt; <span class="number">1</span>) &amp;&amp; buffer[checked_index<span class="number">-1</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                buffer[checked_index<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                buffer[checked_index++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果分析完毕也没有遇到&quot;\r&quot;字符，返回LINE_OPEN表示还需要更多数据</span></span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析请求行</span></span><br><span class="line">HTTP_CODE <span class="title function_">parse_requestline</span><span class="params">( <span class="type">char</span> *temp, CHECK_STATE &amp;checkstate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *url = <span class="built_in">strpbrk</span>( temp, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="comment">//如果请求行中没有空白字符或\t，则HTTP请求必定有问题</span></span><br><span class="line">    <span class="keyword">if</span> ( !url ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *method = temp;</span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp( method, <span class="string">&quot;GET&quot;</span> ) == <span class="number">0</span>) &#123; <span class="comment">/* 此处仅考虑GET方法 */</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;The requese method is GET\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    url+= <span class="built_in">strspn</span>( url, <span class="string">&quot; \t&quot;</span>) ;</span><br><span class="line">    <span class="type">char</span> *version = <span class="built_in">strpbrk</span>( url, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !version ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125; </span><br><span class="line">    *version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    version += <span class="built_in">strspn</span>( version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp( version, <span class="string">&quot;HTTP/1.1&quot;</span> ) != <span class="number">0</span> ) &#123; <span class="comment">/* 仅考虑HTTP/1.1 */</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查URL是否合法 */</span></span><br><span class="line">    <span class="keyword">if</span> ( strncasecmp( url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span> ) == <span class="number">0</span>) &#123;</span><br><span class="line">        url += <span class="number">7</span>;</span><br><span class="line">        url = <span class="built_in">strchr</span>( url, <span class="string">&#x27;/&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !url || url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;The request URL is : %s\n&quot;</span>, url );</span><br><span class="line">    <span class="comment">//HTTP请求行处理完毕，状态转移到头部字段的分析</span></span><br><span class="line">    checkstate = CHECK_STATE_HEADER;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析头部字段</span></span><br><span class="line">HTTP_CODE <span class="title function_">parse_header</span><span class="params">( <span class="type">char</span> *temp )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遇到一个空行，说明我们得到一个正确的HTTP请求</span></span><br><span class="line">    <span class="keyword">if</span> ( temp[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( temp, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">//处理&quot;host&quot;头部字段</span></span><br><span class="line">        temp += <span class="number">5</span>;</span><br><span class="line">        temp += <span class="built_in">strspn</span>( temp, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;the request host is: %s\n&quot;</span>, temp );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他头部字段不处理</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;I can&#x27;t handle this header\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP_CODE <span class="title function_">parse_content</span><span class="params">( <span class="type">char</span> *buffer, <span class="type">int</span> &amp;checked_index,</span></span><br><span class="line"><span class="params">        CHECK_STATE &amp;checkstate, <span class="type">int</span> &amp;read_index, <span class="type">int</span> &amp;start_line )</span></span><br><span class="line">&#123;</span><br><span class="line">    LINE_STATUS linestatus = LINE_OK;    <span class="comment">//记录当前行的读取状态</span></span><br><span class="line">    HTTP_CODE retcode = NO_REQUEST;      <span class="comment">//记录HTTP请求的处理结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主状态机，用于从buffer中取出所有完整的行</span></span><br><span class="line">    <span class="keyword">while</span> ( (linestatus = parse_line( buffer, checked_index, read_index)) == LINE_OK ) &#123;</span><br><span class="line">        <span class="type">char</span> *temp = buffer + start_line;   <span class="comment">//startline是行在buffer中的起始位置</span></span><br><span class="line">        start_line = checked_index;         <span class="comment">//记录下一行的起始位置</span></span><br><span class="line">        <span class="comment">//checkstate记录当前主状态机的状态</span></span><br><span class="line">        <span class="keyword">switch</span> ( checkstate ) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123; <span class="comment">//第一个状态分析请求行</span></span><br><span class="line">                retcode = parse_requestline( temp, checkstate );</span><br><span class="line">                <span class="keyword">if</span> ( retcode == BAD_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE: &#123; <span class="comment">//第二个状态分析头部字段</span></span><br><span class="line">                retcode = parse_header( temp );</span><br><span class="line">                <span class="keyword">if</span> ( retcode == BAD_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( retcode == GET_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若没有读到一个完整的行，则表示还需要继续读取客户数据才能进一步分析</span></span><br><span class="line">    <span class="keyword">if</span> ( linestatus == LINE_OPEN ) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: ... \n&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="type">int</span> ret = bind( listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line">    ret = listen( listenfd, <span class="number">5</span> );</span><br><span class="line">    assert( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span> ( client );</span><br><span class="line">    <span class="type">int</span> fd = accept( listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len );</span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];   <span class="comment">//读缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="type">int</span> data_read = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> read_index = <span class="number">0</span>;         <span class="comment">//当前已经读取了多少字节的客户数据</span></span><br><span class="line">        <span class="type">int</span> checked_index = <span class="number">0</span>;      <span class="comment">//当前已经分析完了多少字节的客户数据</span></span><br><span class="line">        <span class="type">int</span> start_line = <span class="number">0</span>;         <span class="comment">//行在buffer中的起始位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置主状态机的初始状态</span></span><br><span class="line">        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//循环读取客户数据并分析</span></span><br><span class="line">            data_read = recv( fd, buffer+read_index, BUFFER_SIZE-read_index, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">if</span> ( data_read == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;reading failed\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( data_read == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;remote clinet has closed the connection\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read_index += data_read;</span><br><span class="line">            <span class="comment">//分析目前已经获得的的所有客户数据</span></span><br><span class="line">            HTTP_CODE result = parse_content( buffer, checked_index, checkstate, </span><br><span class="line">                                              read_index, start_line );</span><br><span class="line">            <span class="keyword">if</span> ( reulst == NO_REQUEST ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( result == GET_REQUEST ) &#123;</span><br><span class="line">                send( fd, szret[<span class="number">0</span>], <span class="built_in">strlen</span>( szret[<span class="number">0</span>] ), <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                send( fd, szret[<span class="number">1</span>], <span class="built_in">strlen</span>( szret[<span class="number">1</span>]), <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close( fd );</span><br><span class="line">    &#125;</span><br><span class="line">    close( listenfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该代码中的两个有限状态机分别称为主状态机和从状态机，它们之间的关系：主状态机在内部调用从状态机。从状态机的状态及状态转移过程如下：</p>
<p><img src="/./../pic/image-20230427093244810.png" alt="image-20230427093244810"></p>
<p>简单来说，该状态机的工作流程，recv收到数据后，调用parse_content函数(主状态机)来分析读入的数据，parse函数首先调用parse_line函数(从状态机)来获取一个完整的行。parseline函数的工作流程，如下图所示：</p>
<p><img src="/./../pic/image-20230427093312487.png" alt="image-20230427093312487"></p>
<h4 id="8-7-提高服务器性能的其他建议"><a href="#8-7-提高服务器性能的其他建议" class="headerlink" title="8.7 提高服务器性能的其他建议"></a>8.7 提高服务器性能的其他建议</h4><p>讨论从编程的角度来确保服务器的性能。</p>
<p><strong>a) 池</strong></p>
<p>假设在服务器的硬件资源充分的情况下，提高服务器性能的一个直接的方式即是空间换时间，即”浪费”服务器的硬件资源，以换取其运行效率。这就是池的概念。简单来说，池就是将一些需要用到的资源提前分配创建好，用的时候直接从其中取资源比动态分配资源的速度要快得多，处理完后，将资源放回池中。</p>
<p>根据不同的资源类型，池可分为多种，常见的有内存池，进程池，线程池和连接池。</p>
<p>内存池通常用于socket的接受缓存和发送缓存。预先分配一个大小足够的缓冲区。</p>
<p>线程池和进程池，当我们需要一个工作进程&#x2F;线程来处理客户请求时，可直接从池中取一个实体，而无需调用fork或pthread_create来创建。</p>
<p>连接池通常用于服务器或服务器集群的内部永久连接。</p>
<p><strong>b) 上下文切换和锁</strong></p>
<p>并发程序必须考虑上下文切换问题，即进程切换或线程切换导致的系统开销。即使是I&#x2F;O密集型的服务器，也不应该使用过多的工作线程，否则线程间的切换将占用大量的CPU时间。因此，为每个客户连接都创建一个工作线程的服务器是不可取的。图8-11的模式是一种比较合理的解决方案。</p>
<p>另一个问题是对共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为它引入的代码不处理任何业务逻辑，而且需要访问内核资源。如果服务器必须使用锁，考虑减小锁的粒度，比如使用读写锁。当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加额外的开销，只有当其中一个工作线程需要写这块内存时，才去上锁。</p>
<p><strong>c) 数据复制</strong></p>
<p>高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户和内核之间。比如ftp服务器，无需把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数发送，而是可用”零拷贝”的sendfile函数直接发送。</p>
<p>此外，用户代码内部的数据复制也是应该避免的。比如，两个工作进程之间需要传递大量的数时，我们应该考虑使用共享内存在他们之间直接共享这些数据，而不是使用管道或消息队列来传递。</p>
<h3 id="第9章-I-x2F-O复用"><a href="#第9章-I-x2F-O复用" class="headerlink" title="第9章 I&#x2F;O复用"></a>第9章 I&#x2F;O复用</h3><p>I&#x2F;O复用使得程序能同时监听多个文件描述符，通常网络程序在下列情况下需要使用I&#x2F;O复用功能：</p>
<ol>
<li>客户端程序要同时处理多个socket。比如本章将讨论的非阻塞connect。</li>
<li>客户端程序要同时处理用户输入和网络连接。比如本章讨论的聊天室程序。</li>
<li>TCP服务器要同时处理监听socket和连接socket。</li>
<li>服务器要同时处理TCP请求和UDP请求。比如本章讨论的回射服务器。</li>
<li>服务器要同时监听多个端口，或者处理多种服务器。比如本章讨论的xinetd服务器。</li>
</ol>
<p>Linux下实现I&#x2F;O复用的系统调用主要有select，poll和epoll。</p>
<h4 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h4><p><strong>a) selectAPI</strong></p>
<p>select系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>nfds参数指定被监听的文件描述符总数，通常被设置为select监听的所有描述符中的最大值加以。</p>
<p>readfds，exceptfds，writefds分别指向可读，异常和可写对应的文件描述符集合。fd_set结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typesizes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __fD_SETSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE __FD_SETSIZE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> in __fd_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> __NFDBITS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NFDBITS ( 8 * (int) sizeof (__fd_mask ) )</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">    __fd_mask fds_bits[ __FD_SETSIZE / __NFDBITS ];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __Fd_mask __fds_bits[ __FD_SETSIZE / __NFDBITS ];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>

<p>使用如下一系列宏来访问fd_set结构体中的位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line">FD_ZERO(fd_set *fdset);				<span class="comment">// 清除fdset的所有位</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);		<span class="comment">// 设置fdset的位fd</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);		<span class="comment">// 清除fdset的位fd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;<span class="comment">// 测试fdset的位fd是否被设置</span></span><br></pre></td></tr></table></figure>

<p>timeout参数设置超时时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec; 	<span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">long</span> tv_usec;	<span class="comment">// 微秒数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>select成功时返回就绪文件描述符的总数。</p>
<p><strong>b) 文件描述符就绪条件</strong></p>
<p>在网络编程中，下列情况下socket可读：</p>
<ol>
<li>socket内核接受缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时可以无阻塞地读该socket，且读操作返回的字节数大于0。</li>
<li>socket通信的对方关闭连接。此时读操作返回0。</li>
<li>监听socket上有新的连接请求。</li>
<li>socket上有未处理的错误。此时可以用getsockopt来读取和清除该错误。</li>
</ol>
<p>下列情况下socket可写：</p>
<ol>
<li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时可用无阻塞的写该socket，且写操作的字节数大于0。</li>
<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或者失败之后。</li>
<li>socket上有未处理的错误。此时可以用getsockopt来读取和清除该错误。</li>
</ol>
<p>网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据。下节将详细讨论。</p>
<p><strong>c) 处理带外数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//同时接受普通数据和带外数据</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">    if ( argc &lt;= 2 ) &#123;</span><br><span class="line">        printf( &quot;usage: ... &quot; );</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char *ip = argv[1];</span><br><span class="line">    int port = atoi( argv[2] );</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    bzero( &amp;address, sizeof( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line"></span><br><span class="line">    int listenfd = socket( AF_INET, SOCK_STREAM, 0 );</span><br><span class="line">    assert( listenfd &gt;= 0 );</span><br><span class="line">    ret = bind( listenfd, (struct sockaddr*)&amp;address, sizeof( address ) );</span><br><span class="line">    assert( ret != -1 );</span><br><span class="line">    ret = listen( listenfd, 5 );</span><br><span class="line">    assert( ret != -1 );</span><br><span class="line"></span><br><span class="line">    struct sockaddr client;</span><br><span class="line">    socklen_t client_len = sizeof( client );</span><br><span class="line">    int connfd = accept( listenfd, (struct sockaddr*)&amp;clinet, &amp;client_len );</span><br><span class="line">    if ( connfd &lt; 0 ) &#123;</span><br><span class="line">        printf( &quot;errno is %d\n&quot;, errno );</span><br><span class="line">        close( listenfd );</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    char buf[1024];</span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    fd_set exception_fds;</span><br><span class="line">    FD_ZERO( &amp;read_fds );</span><br><span class="line">    FD_ZERO( &amp;exception_fds );</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        memset( buf, &#x27;\0&#x27;, sizeof(buf) );</span><br><span class="line">        //每次调用select前都需要重新在read_fds和exception_fds中设置文件描述符</span><br><span class="line">        FD_SET( connfd, &amp;read_fds );</span><br><span class="line">        FD_SET( connfd, &amp;exception_fds );</span><br><span class="line">        ret = select( connfd+1, &amp;read_fds, NULL, &amp;exception_fds, NULL );</span><br><span class="line">        if ( ret &lt; 0 ) &#123;</span><br><span class="line">            printf( &quot;selection failure\n&quot; );</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //对于可读事件，采用普通的recv函数读取数据</span><br><span class="line">        if ( FD_ISSET( connfd, &amp;read_fds ) ) &#123;</span><br><span class="line">            ret = recv( connfd, buf, sizeof(buf)-1, 0 );</span><br><span class="line">            if (ret &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            printf( &quot;get %d bytes of normal data: %s\n&quot;, ret, buf );</span><br><span class="line">        &#125;</span><br><span class="line">        //对于异常事件，采用带MSG_OBB标志的recv函数读取带外数据</span><br><span class="line">        else if ( FD_ISSET( connfd, &amp;exception_fds ) ) &#123;</span><br><span class="line">            ret = recv( connfd, buf, sizeof(buf)-1. MSG_OBB );</span><br><span class="line">            if ( ret &lt;= 0 ) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">            printf( &quot;get %d bytes of obb data: %s\n&quot;, ret, buf );</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    close( connfd );</span><br><span class="line">    close( listenfd );</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h4><p>poll系统调用与selec类似，也是指定时间内轮询一定数量的文件描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>pollfd参数即select三种事件集合的综合，采用一个结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;			<span class="comment">//文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;	<span class="comment">//注册的事件</span></span><br><span class="line">    <span class="type">short</span> revents;	<span class="comment">//实际发生的事情，由内核填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>fd指定文件描述符，evets成员告诉poll监听fd上的哪些事件，它是一系列的按位或，revetns由内核修改，通知应用程序fd上实际发生了哪些事件。poll支持的事件类型如下表：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
<th>是否可作为输入</th>
<th>是否可作为输出</th>
</tr>
</thead>
<tbody><tr>
<td>POLLIN</td>
<td>数据(包括普通数据和优先数据)可读</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>普通数据可读</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>优先级带数据可读(Linux不支持)</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>高优先级数据可读，比如TCP带外数据</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>数据(包括普通数据和优先数据)可写</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td>普通数据可写</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>优先级带数据可写</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLRDHUP</td>
<td>TCP连接被对方关闭，或者对方关闭了写操作。他由GUN引入</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POLLER</td>
<td>错误</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>挂起。比如管道的写端被关闭后，读描述上将收到POLLHUP事件</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>文件描述符没有打开</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<p>nfds参数指定被监听事件集合的fds的大小</p>
<p>timeout参数指定超时值</p>
<h4 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h4><p><strong>a) 内核事件表</strong></p>
<p>epoll把用户关心的文件描述符上的事件放在内核的一个事件表中，从而无需像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要一个额外的文件描述符，来唯一标识内核中的这个事件表，该文件描述符使用如下函数创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>size参数现在不起作用，仅作为给内核的一个提示，告诉他事件表需要多大。该函数返回的文件描述符将所用与其他epoll系统调用的第一个参数，以指定要访问的内核事件表。</p>
<p>下面的函数用来操作epoll的内核事件表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *evnet)</span>;</span><br></pre></td></tr></table></figure>

<p>fd参数为操作的描述符，op参数指定操作类型，类型如下三种：</p>
<ol>
<li>EPOLL_CTL_ADD，往事件表中注册fd上的事件。</li>
<li>EPOLL_CTL_MOD，修改fd上的注册事件。</li>
<li>EPOLL_CTL_DEL，删除fd上的注册事件。</li>
</ol>
<p>event参数指定事件，它是epoll_event结构指针类型。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;		<span class="comment">//epoll事件</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;		<span class="comment">//用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>data成员用于存储用户数据，其类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>



<p><strong>b) epoll_wait函数</strong></p>
<p>epoll系列系统调用的主要接口函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *evetns, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表中复制到它的第二个参数events指向的数组中。这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和Poll既用于传入，又用于输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll和poll在使用上的差别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如何索引poll返回的就绪文件描述符 */</span></span><br><span class="line"><span class="type">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/* 必须遍历所有已注册文件描述符，找到其中的就绪者 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i].revents &amp; ) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = fds[i],fd;</span><br><span class="line">        <span class="comment">/* 处理socket */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如何索引epoll返回的就绪文件描述符 */</span></span><br><span class="line"><span class="type">int</span> ret = epoll_wait(epollfd, evetns, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/* 仅便利就绪的ret个文件描述符 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;ret; i++) &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = evetns[i].data.fd;</span><br><span class="line">    <span class="comment">/* socket肯定就绪，直接处理 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>c) LT和ET模式</strong></p>
<p>epoll对文件描述符的操作有两种模式: LT (Level Trigger, 电平触发)模式和 ET(Edge Trigger, 边沿触发)模式。LT模式是默认的工作模式，这种模式相当于一个效率较高的poll。当注册事件EPOLLET时，epoll将以ET模式来操作，ET模式是epoll的高效工作模式。</p>
<p>LT：epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，下次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</p>
<p>ET：应用程序必须立即处理，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> enable_et)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LT模式的工作流程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lt</span><span class="params">(<span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> number, <span class="type">int</span> epollfd, <span class="type">int</span> listenfd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">            <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">            <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, </span><br><span class="line">                                &amp;client_addrlen);</span><br><span class="line">            addfd(epollfd, connfd, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="comment">/* 只要socket读缓存中还有未读出的数据，这段代码就被触发 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="type">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                close(sockfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret ,buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;something else happend\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ET模式的工作流程 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Et</span><span class="params">(<span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epollfd, <span class="type">int</span> listenfd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">            <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">            <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, </span><br><span class="line">                                &amp;client_addrlen);</span><br><span class="line">            addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="comment">/* 这段代码不会被重复触发，所以我们循坏读数据。以确保把socket读缓存</span></span><br><span class="line"><span class="comment">            中所有数据读完*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="type">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* 对于非阻塞I/O，下面的条件成立标识数已全部读完。此后epoll</span></span><br><span class="line"><span class="comment">                    就能再次触发sockfd上的EPOLLIN事件*/</span></span><br><span class="line">                    <span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;something else happend\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ip_address port_number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="type">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">    addfd(epollfd, listenfd, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epolll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Lt(events, ret, epollfd, listenfd);</span></span><br><span class="line">        Et(events, ret, epollfd, listenfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230430142718025.png" alt="image-20230430142718025"></p>
<p><strong>d) EPOLLONESHOT事件</strong></p>
<p>即使我们使用ET模式，一个socket上的某个事件还是可能被多次触发。在并发中这会导致一个问题，比如一个线程读完某个socket上的数据开始处理这些数据，而在数据处理过程中，socket上又有新数据可读，EPOLLIN再次触发，此时另一个线程被唤醒来读取这些数据。导致出现了两个线程同时操作一个socket的局面。使用epoll的EPOLLONESHOT事件解决该情况。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读，可写或异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。</p>
<p>有点像上锁(。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用EPOLLONESHOT事件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> epollfd;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将fd上的EPOLLIN和EPOLLET事件注册。参数oneshot指定是否注册该事件*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> oneshot)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="keyword">if</span> (oneshot) &#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重置fd上的事件。重置EPOLLONESHOT事件*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reset_oneshot</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 工作线程*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = ((fds*)arg)-&gt;sockfd;</span><br><span class="line">    <span class="type">int</span> epollfd = ((fds*)arg)-&gt;epollfd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, sockfd);</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环读取sockefd上的数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = recv(sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;foreinter closed the connection\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                reset_oneshot(epollfd, sockfd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get content: %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="comment">/*休眠5s，模拟数据处理过程*/</span></span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on fd:\n&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    strcut epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    <span class="type">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;ret; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address,</span><br><span class="line">                                    &amp;client_addrlen);</span><br><span class="line">                <span class="comment">/* 对每个非监听文件描述符都注册EPOLLONESHOT*/</span></span><br><span class="line">                addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="type">pthread_t</span> thread;</span><br><span class="line">                fds fds_for_new_worker;</span><br><span class="line">                fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">                fds_for_new_worker.sockfd = sockfd;</span><br><span class="line">                pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, (<span class="type">void</span>*)&amp;fds_for_new_worker);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;something else happend\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-4-三组I-x2F-O复用函数的比较"><a href="#9-4-三组I-x2F-O复用函数的比较" class="headerlink" title="9.4 三组I&#x2F;O复用函数的比较"></a>9.4 三组I&#x2F;O复用函数的比较</h4><p>事件集合不同，select通过三个事件集来监听，并且内核通过对其的修改来反馈结果，所以每次调用都需要重置这3个参数，poll将三个统一为一个，将输入和输出分为event和revent分离，epoll则内核将输出传出，无需反复传入用户需要监听的事件。</p>
<p>工作模式，select和poll只支持LT模式，epoll支持ET和LT。</p>
<p>内核实现和效率，select和poll采用轮询方式检测就绪事件，时间复杂度O(n)；epoll通过回调方式来检测，时间复杂度O(1)。</p>
<p><img src="/./../pic/image-20230430154353430.png" alt="image-20230430154353430"></p>
<h4 id="9-5-I-x2F-O复用的高级应用一-非阻塞connect"><a href="#9-5-I-x2F-O复用的高级应用一-非阻塞connect" class="headerlink" title="9.5 I&#x2F;O复用的高级应用一: 非阻塞connect"></a>9.5 I&#x2F;O复用的高级应用一: 非阻塞connect</h4><p><img src="/./../pic/image-20230430154800776.png" alt="image-20230430154800776"></p>
<p>上述文描述了connect出错时的一种errno值：EINPROGRESS。这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立时。在这种情况下，可以调用select,poll等函数来监听这个连接失败的socket上的可写事件。当select,poll函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码是0表示连接建立成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*超时连接函数，成功时返回已处于连接状态的socket*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unblock_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port, <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> fdopt = setnonblocking(sockfd);</span><br><span class="line">    ret = connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果连接成功，则恢复sockfd的属性，并立即返回 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">        fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line">        <span class="keyword">return</span> sockfd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (errno != EINPROGRESS) &#123;</span><br><span class="line">        <span class="comment">/* 只有errno是EINPROGRESS表示连接还在进行，否则返回出错 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd_set readfds;</span><br><span class="line">    fd_set writefds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(sockfd, &amp;writefds);</span><br><span class="line"></span><br><span class="line">    timeout.tv_sec = time;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = select(sockfd+<span class="number">1</span>, <span class="literal">NULL</span>, &amp;writefds, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* select超时或出错，立即返回 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FD_ISSET(sockfd, &amp;writefds)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no event on sockfd found\n&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line">    <span class="comment">/*调用getsockopt获取并清除sockfd上的错误*/</span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;legnth) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*错误号不为0表示连接出错*/</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed afeter select with the error: %d\n&quot;</span>, error);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*连接成功*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket: %d\n&quot;</span>, sockfd);</span><br><span class="line">    fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = unblock_connect(ip, port, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但该方法存在移植性问题。首先，非阻塞的socket可能导致connect失败。其次select对处于EINPROGRESS状态下的socket可能不起作用。以及，出错的socket，getsockopt返回值不一，有的为-1，有的为0。</p>
<h4 id="9-6-I-x2F-O复用的高级应用二-聊天室程序"><a href="#9-6-I-x2F-O复用的高级应用二-聊天室程序" class="headerlink" title="9.6 I&#x2F;O复用的高级应用二: 聊天室程序"></a>9.6 I&#x2F;O复用的高级应用二: 聊天室程序</h4><p>以poll实现一个简单的聊天室程序。阐述如何使用I&#x2F;O复用技术来同时处理网络连接和用户输入。它分为客户端和服务端两个部分。</p>
<p>客户端：一是从标准输入终端读入用户数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器发送给它的数据。</p>
<p>服务器：接受用户数据，并把客户数据发送给每一个登录到该服务器上的客户端，数据发送者除外。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;=<span class="number">2</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line">    <span class="comment">/* 注册标准输入和socket上的可读事件*/</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">    fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">    fds[<span class="number">1</span>].events = POLLIN;</span><br><span class="line">    fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = poll(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLRDHUP) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server close the connection\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">            recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,read_buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">/* 使用splice将用户输入数据直接写到socket上(零拷贝)*/</span></span><br><span class="line">            ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>,</span><br><span class="line">                        SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">            ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>,</span><br><span class="line">                        SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_LIMIT 5        <span class="comment">//最大用户数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64      <span class="comment">//读缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535      <span class="comment">//文件描述符数量限制</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户数据: 客户端socket地址，待写道socket的数据位置，读入的数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_GETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建users数组，分配FD_LIMIT个client_data对象。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> *<span class="title">users</span> =</span> (<span class="keyword">struct</span> client_data*)<span class="built_in">malloc</span>(FD_LIMIT * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> client_data));</span><br><span class="line">    <span class="comment">//为了提高poll的性能，有必要限制用户的数量</span></span><br><span class="line">    pollfd fds[USER_LIMIT+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;= USER_LIMIT; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">    fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = poll(fds, user_counter++, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line">            breka;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; user_counter+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, </span><br><span class="line">                                    &amp;client_addrlen);</span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*如果请求太多，则关闭新到的连接*/</span></span><br><span class="line">                <span class="keyword">if</span> (user_counter &gt;= USER_LIMIT) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">                    send(connfd, info ,<span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    contniue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*对于新的连接，同时修改fds和users数组*/</span></span><br><span class="line">                user_counter++;</span><br><span class="line">                users[connfd].address = client_address;</span><br><span class="line">                setnonblocking(connfd);</span><br><span class="line">                fds[user_counter].fd = connfd;</span><br><span class="line">                fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;</span><br><span class="line">                fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;comes a new user, now have %d users\n&quot;</span>, user_counter);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get an error from %d\n&quot;</span>, fds[i].fd);</span><br><span class="line">                <span class="type">char</span> errors[<span class="number">100</span>];</span><br><span class="line">                <span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">                <span class="type">socklen_t</span> legnth = <span class="keyword">sizeof</span>(errors);</span><br><span class="line">                <span class="keyword">if</span> (getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors, </span><br><span class="line">                    &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                contniue;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123;</span><br><span class="line">                <span class="comment">/*如果客户端关闭连接，服务器也关闭对应的连接，用户总数减1*/</span></span><br><span class="line">                users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">                close(fds[i].fd);</span><br><span class="line">                fds[i] = fds[user_counter];</span><br><span class="line">                i--;</span><br><span class="line">                user_counter--;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;a client left\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="type">int</span> connfd = fds[i].fd;</span><br><span class="line">                <span class="built_in">memset</span>(user[connfd],buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                ret = recv(connfd, users[connfd].buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, </span><br><span class="line">                        user[connfd].buf, connfd);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*如果读操作出错，关闭连接*/</span></span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        close(connfd);</span><br><span class="line">                        user[fds[i].fd] = user[fds[user_counter].fd];</span><br><span class="line">                        fds[i] = fds[user_counter];</span><br><span class="line">                        i--;</span><br><span class="line">                        user_counter--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*如果接受到客户数据，则通知其他socket连接准备写数据*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=user_counter; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fds[j].fd == connfd) &#123;</span><br><span class="line">                            contniue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fds[j].events |= ~POLLIN;</span><br><span class="line">                        fds[j].events |= POLLOUT;</span><br><span class="line">                        users[fds[j].fd].write_buf = users[connfd].buf;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;</span><br><span class="line">                <span class="type">int</span> connfd = fds[i].fd;</span><br><span class="line">                <span class="keyword">if</span> (!users[connfd],write_buf) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = send(connfd, users[connfd].write_buf, </span><br><span class="line">                            <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line">                users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">/*写完数据重新注册fds[i]上的可读事件*/</span></span><br><span class="line">                fds[i].events |= ~POLLOUT;</span><br><span class="line">                fds[i].events |= POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(users);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-7-I-x2F-O复用的高级应用三-同时处理TCP和UDP服务"><a href="#9-7-I-x2F-O复用的高级应用三-同时处理TCP和UDP服务" class="headerlink" title="9.7 I&#x2F;O复用的高级应用三: 同时处理TCP和UDP服务"></a>9.7 I&#x2F;O复用的高级应用三: 同时处理TCP和UDP服务</h4><p>同时处理多个端口。下示代码所示的回射服务器能够同时处理一个端口上的TCP和UDP请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socekt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*创建TCP socket，并绑定到端口port上*/</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建UDP socket，并绑定到端口port上*/</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    <span class="type">int</span> updfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    assert(udpfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(updfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evnets</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="type">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注册tcp sokcet和upd socket上的可读事件*/</span></span><br><span class="line">    addfd(epollfd, listenfd);</span><br><span class="line">    addfd(epollfd, updfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">                addfd(epollfd, connfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == updfd) &#123;</span><br><span class="line">                <span class="type">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                ret = recvfrom(updfd, buf, UDP_BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>,</span><br><span class="line">                        (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class="line">                <span class="keyword">if</span> (ret &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    sendto(updfd, buf, UDP_BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>, </span><br><span class="line">                        (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="type">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;something else happend\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-8-超级服务xinetd"><a href="#9-8-超级服务xinetd" class="headerlink" title="9.8 超级服务xinetd"></a>9.8 超级服务xinetd</h4><p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版本xinetd。</p>
<p><strong>a) xinetd配置文件</strong></p>
<p>xinetd采用&#x2F;etc&#x2F;xinetd.conf主配置文件和&#x2F;etc&#x2F;xinetd.d目录下的子配置文件来管理所有服务器。主配置文件是通用选项，这些选项将被所有子配置文件继承。但子配置文件可覆盖这些选项。子配置文件用于设置一个自服务的参数，如telnet字符的配置文件典型内容如下:</p>
<p><img src="/./../pic/image-20230430170436220.png" alt="image-20230430170436220"></p>
<p><strong>b) xinetd工作流程</strong></p>
<p>xinetd管理的子服务中的标准服务，如日期服务daytime，回射服务echo直接在内部处理这些事务，有的子服务则需要调用外部服务器来处理，xinetd通过调用fork和exec函数来加载这些服务器程序，如telnet，ftp服务。以telnet服务来探讨xinetd的工作流程。</p>
<p><img src="/./../pic/image-20230430170733016.png" alt="image-20230430170733016"></p>
<p><img src="/./../pic/image-20230430171107014.png" alt="image-20230430171107014"></p>
<h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><h4 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h4><p><strong>a) 发送信号</strong></p>
<p>kill函数，定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>pid参数，取值及含义如下表:</p>
<table>
<thead>
<tr>
<th>pid参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>pid &gt; 0</td>
<td>信号发送给PID为pid的进程</td>
</tr>
<tr>
<td>pid &#x3D; 0</td>
<td>信号发送给本进程组内的其他进程</td>
</tr>
<tr>
<td>pid &#x3D; -1</td>
<td>信号发送给除init进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限</td>
</tr>
<tr>
<td>pid &lt; -1</td>
<td>信号发送给组ID为-pid的进程组中的所有成员</td>
</tr>
</tbody></table>
<p>Linux定义的信号值都大于0，如果sig取值为0，kill函数不发送任何信号。但可以用来检测目标进程或进程组是否存在，因为检查工作在发送之前执行。</p>
<p>失败时返回的errno可能值如下表:</p>
<table>
<thead>
<tr>
<th>errno</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EINVAL</td>
<td>无效的信号</td>
</tr>
<tr>
<td>EPERM</td>
<td>该进程没有权限发送信号给任何一个目标进程</td>
</tr>
<tr>
<td>ESRCH</td>
<td>目标进程或进程组不存在</td>
</tr>
</tbody></table>
<p><strong>b) 信号处理方式</strong></p>
<p>收到信号时，需要定义一个接收函数来处理信号，信号处理函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">__sighandler_t</span>)</span> <span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>int参数用来指示信号类型。除自定义处理函数外，还定义了信号的两种其他处理方式–SIG_IGN和SIG_DEL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/signum.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL ((__sighandler_t)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN ((__sighandler_t)1)</span></span><br></pre></td></tr></table></figure>

<p>SIG_IGN表示忽略目标信号，SIG_DFL表示使用信号的默认处理方式：结束进程(Term)，忽略信号(Ign)，结束进程并生成核心转储文件(Core)，暂停进程(Stop)，以及继续进程(Cont)。</p>
<p><strong>c) Linux信号</strong></p>
<p>Linux可用的信号都定义在bits&#x2F;signum.h头文件中。</p>
<p><img src="/./../pic/image-20230501154830357.png" alt="image-20230501154830357"></p>
<p><img src="/./../pic/image-20230501154844508.png" alt="image-20230501154844508"></p>
<p>后面重点介绍与网络编程关系紧密的几个信号:SIGHUP，SIGPIPE，SIGURG。以及SIGALRM，SIGCHLD。</p>
<p><strong>d) 中断系统调用</strong></p>
<p>如果程序执行处于阻塞状态的系统调用收到信号，默认情况下，系统调用将被中断，并且errno被设置为EINTR。可用使用sigaction函数为信号设置SA_RESTART标志，以自动重启被中断的系统调用。</p>
<h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><p><strong>a) signal系统调用</strong></p>
<p>为信号设置处理函数，signal函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">_sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">_sighandler_t</span> _handler)</span>;</span><br></pre></td></tr></table></figure>

<p>sig参数指出要捕获的信号类型。_handler函数指针，指定信号sig的处理函数。</p>
<p><strong>b) sigaction系统调用</strong></p>
<p>简单来说signal的升级版本系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *ocat)</span>;</span><br></pre></td></tr></table></figure>

<p>sig参数指出要捕获的信号，act参数指定新的信号处理方式，oact参数输出信号先前的处理方式。act的结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_POSIX199309</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">_sighandler_t</span> sa_handler;</span><br><span class="line">        <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span>*, <span class="type">void</span>*);</span><br><span class="line">    &#125;_sigaction_handler;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_handler 		__sigaction_handler.sa_handler;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_sigaction 	__sigaction_handler_sa_sigaction</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">_sighandler_t</span>	sa_handler;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">_sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sa_handler指定处理函数，sa_sigaction好像是特殊处理，详细见APUE。sa_mask设置进程的信号掩码。sa_flags成员用于设置程序收到信号时的行为，可选值如下表：</p>
<p><img src="/./../pic/image-20230501163548220.png" alt="image-20230501163548220"></p>
<p>sa_restorer成员已过时，不使用。</p>
<h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><p><strong>a) 信号集函数</strong></p>
<p>Linux使用sigset_t表示一组信号，定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sigset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof(unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125;<span class="type">__sigset_t</span>;</span><br></pre></td></tr></table></figure>

<p>由此可见，sigset_t实际是一个长整型数组，数组的每个元素的每一位表示一个信号，和fd_set类似。同样，提供了如下一组函数用来设置，修改，删除和查询信号集。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *_set)</span>;					<span class="comment">//清空信号集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *_set)</span>;						<span class="comment">//在信号集中设置所有信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sig_addset</span><span class="params">(<span class="type">sigset_t</span> *_set, <span class="type">int</span> _signo)</span>;			<span class="comment">//将信号signo添加至信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sig_delset</span><span class="params">(<span class="type">sigset_t</span> *_set, <span class="type">int</span> _signo)</span>;			<span class="comment">//将信号signo从信号集中删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismemeber</span><span class="params">(_const <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> _signo)</span>;	<span class="comment">//测试信号signo是否在信号集中</span></span><br></pre></td></tr></table></figure>



<p><strong>b) 进程信号掩码</strong></p>
<p>如下函数用于设置或查看进程的信号掩码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> _how, _const <span class="type">sigset_t</span> *_set, <span class="type">sigset_t</span> *_oset)</span>;</span><br></pre></td></tr></table></figure>

<p>_set指定新的信号掩码，_oset输出原来的信号掩码，how指定设置信号掩码的方式，可选值如下表:</p>
<table>
<thead>
<tr>
<th>_how参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIG_BLOCK</td>
<td>新的进程信号掩码是当前值和_set指定信号集的并集</td>
</tr>
<tr>
<td>SIG_UNBLOCK</td>
<td>新的进程信号掩码是当前值和~_set信号集的交集，因此_set指定的信号不再被屏蔽</td>
</tr>
<tr>
<td>SIG_SETMASK</td>
<td>直接将进程信号的掩码设置为_set</td>
</tr>
</tbody></table>
<p>如果set为NULL，进程信号掩码不变，此时可以利用_oset获取进程当前的信号掩码。</p>
<p><strong>c) 被挂起的信号</strong></p>
<p>设置信号掩码后，被屏蔽的信号将不再被进程接收。如果给进程发送一个被屏蔽的信号，操作系统将其设置为进程的一个被挂起的信号。如果取消对其的屏蔽，则他能被立即接收到，如下函数可获得进程当前被挂起的信号集:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>set参数用于保存被挂起的信号集。</p>
<h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。所以需要尽快的执行完处理函数，以确保信号不被屏蔽太久。</p>
<p>一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它指示简单的通知主循环程序接收信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来讲信号传递给主循环：信号往管道的写端写入信号值，主循环从读端读出信号值。同时主循环通过I&#x2F;O复用技术来监听读端文件描述符上的可读事件。</p>
<p>如此一来，信号事件就能和其他I&#x2F;O事件一样被处理，即统一事件源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统一事件源的简单实现</span></span><br><span class="line"><span class="comment">//统一事件源简单实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(itn epollfd, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN || EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*保留原来的errno, 在函数最后恢复，以确保函数的可重入性*/</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    send(pipefd[<span class="number">1</span>], (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">/*讲信号值写入管道，通知主循环*/</span></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号的处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addsig</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">bind</span><span class="params">(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address))</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evetns</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="type">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">    addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用socketpari创建管道，注册Pipe[0]上的可读事件*/</span></span><br><span class="line">    ret = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">    addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置一些信号的处理函数*/</span></span><br><span class="line">    addsig(SIGHUP);</span><br><span class="line">    addsig(SIGCHLD);</span><br><span class="line">    addsig(SIGTERM);</span><br><span class="line">    addsig(SIGINT);</span><br><span class="line">    <span class="type">bool</span> stpo_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stpo_server) &#123;</span><br><span class="line">        <span class="type">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, </span><br><span class="line">                                    &amp;client_len);</span><br><span class="line">                addfd(epollfd, connfd);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (evnets[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*每个信号占1字节，按字节诸葛接收信号*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;ret; i++) &#123;</span><br><span class="line">                        <span class="keyword">switch</span>(signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">                            <span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">                                stpo_server = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close fds\n&quot;</span>);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h4><p><strong>a) SIGHUP</strong></p>
<p>当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制中断的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重新读取配置文件，一个典型的例子是xinetd超级服务器程序。</p>
<p><strong>b) SIGPIPE</strong></p>
<p>默认情况下，往一个读端关闭的管道或socket连接中写数据讲引发SIGPIPE信号。默认处理为结束进程，所以我们需要捕获并处理该信号，至少忽略他。引起SIGPIPE信号的写操作讲设置errno为EPIPE。</p>
<p>可以使用send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号。这种情况下，通过send函数反馈的errno值来判断管道或socket连接是否已关闭。</p>
<p>此外，可以利用I&#x2F;O复用系统调用来检测管道和socket连接的读端是否已关闭。以poll为例，关闭时，写端文件描述符上的POLLHUP事件将触发。</p>
<p><strong>c) SIGURG</strong></p>
<p>内核通知带外数据到达的两种方法：一是前面介绍的I&#x2F;O复用技术，借由select报告异常事件，二是使用SIGURG信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGURG信号处理函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_urg</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="type">int</span> ret = recv(connfd, buffer, BUFFER_SIZE<span class="number">-1</span>, MSG_OOB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of obb data &#x27;%s&#x27;\n&quot;</span>, ret, buffer);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span> (*sig_handler)(<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    ASSERT(sigaciton(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">bind</span><span class="params">(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address))</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    connfd = accept(listenfd, (sturct sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is %d\n&quot;</span>, ernno);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addsig(SIGURG, sig_urg);</span><br><span class="line">        <span class="comment">/*使用SIGURG信号前，必须设置socket的宿主进程或进程组*/</span></span><br><span class="line">        fcntl(connfd, F_SETOWN, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/*循环接收普通数据*/</span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">            ret = recv(connfd, buffer, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h3><p>本章主要讨论两种高效管理定时器的容器：时间轮和时间堆。在讨论如何组织定时器之前，首先介绍定时的方法。Linux提供了三种定时方法，它们是：</p>
<ol>
<li>socket选项SO_RCMTIMEO和SO_SNDTIMEO。</li>
<li>SIGALRM信号。</li>
<li>I&#x2F;O复用系统调用的超时参数。</li>
</ol>
<h4 id="11-1-socket选项SO-RCVTIMEO和SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO和SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO和SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO和SO_SNDTIMEO</h4><p>这两个选项仅对与数据接收和发送相关的socket专用系统调用有效，包括send，sendmsg，recv，recvmsg，accpet和connect。</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>有效选项</th>
<th>系统调用超时后的行为</th>
</tr>
</thead>
<tbody><tr>
<td>send</td>
<td>SO_SNDTIMEO</td>
<td>返回-1，设置errno为EAGAIN或EWOULDBLOCK</td>
</tr>
<tr>
<td>sendmsg</td>
<td>SO_SNDTIMEO</td>
<td>返回-1，设置errno为EAGAIN或EWOULDBLOCK</td>
</tr>
<tr>
<td>recv</td>
<td>SO_RCVTIMEO</td>
<td>返回-1，设置errno为EAGAIN或EWOULDBLOCK</td>
</tr>
<tr>
<td>recvmsg</td>
<td>SO_RCVTIMEO</td>
<td>返回-1，设置errno为EAGAIN或EWOULDBLOCK</td>
</tr>
<tr>
<td>accept</td>
<td>SO_RCVTIMEO</td>
<td>返回-1，设置errno为EAGAIN或EWOULDBLOCK</td>
</tr>
<tr>
<td>connect</td>
<td>SO_SNDTIMEO</td>
<td>返回-1，设置errno为EINPROGRESS</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置connect超时时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//超时连接函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timeout_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port, <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socekt(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*选项设置的超时时间类型为timeval，和select的参数类型相同*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec = time;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(timeout);</span><br><span class="line">    ret = setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/*超时对应的错误号是EINPROGRESS，如果成立，处理超时任务*/</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGREE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connecting timeout, process timeout logic\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error occur when connecting to server\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = timeout_connect(ip, port, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-2-SIGALRM信号"><a href="#11-2-SIGALRM信号" class="headerlink" title="11.2 SIGALRM信号"></a>11.2 SIGALRM信号</h4><p>由alarm和setitimer函数设hi的实时闹钟一旦超时，将触发SIGALRM信号。</p>
<p>本节通过一个示例–处理非活动连接，来介绍如何使用SIGALRM信号。首先给出一种简单的定时器容器实现–基于升序链表的定时器容器，并把应用到该示例。</p>
<p><strong>a) 基于升序链表的定时器</strong></p>
<p>定时器通常至少需要两个成员：超时时间和任务回调函数。以及可能包含回调函数执行时传入的参数，以及是否重启定时器等信息。</p>
<p>以链表作为容器来串联所有的定时器，则每个定时器还需要一个指向下一个定时器节点的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LST_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span>   <span class="comment">/*前向声明*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用户数据结构：客户端socket地址，socket文件描述符，读缓存和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    util_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    util_timer(): prev(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">time_t</span> expire;                   <span class="comment">/*超时时间，这里使用绝对时间*/</span></span><br><span class="line">    <span class="type">void</span> (*cb_func)(client_data*);   <span class="comment">/*任务回调函数*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*回调函数处理的客户数据，由定时器的执行者传入*/</span></span><br><span class="line">    client_data *user_data;</span><br><span class="line">    util_timer *prev;               <span class="comment">/*指向前一个*/</span></span><br><span class="line">    util_timer *next;               <span class="comment">/*指向下一个*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器链表，升序，双向链表，且带有头尾节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_list</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    sort_timer_list(): head(<span class="literal">NULL</span>), tail(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">/*析构函数*/</span></span><br><span class="line">    ~sort_timer_list() </span><br><span class="line">    &#123;</span><br><span class="line">        util_timer *tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将目标定时timer添加到链表中*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(util_timer *timer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            head = tail = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果目标超时时间小于当前链表中所有的超时时间，插入头部，</span></span><br><span class="line"><span class="comment">        否则调用重载函数找到合适的位置*/</span></span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire) &#123;</span><br><span class="line">            timer-&gt;next = head;</span><br><span class="line">            head-&gt;prev = timer;</span><br><span class="line">            head = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        add_timer(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*当定时任务发生变化时，调整对应的定时器在链表中的位置。只考虑定时器</span></span><br><span class="line"><span class="comment">    事件延长的情况，即往链表尾部移动*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">adjust_timer</span><span class="params">(util_timer *timer)</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        util_timer *tmp = timer-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            add_timer(timer, head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">            timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">            add_timer(timer, head);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将目标定时器timer从list中删除*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">del_timer</span><span class="params">(util_timer *timer)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*下面条件成立表示链表中只有一个定时器，即目标*/</span></span><br><span class="line">        <span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail)) &#123;</span><br><span class="line">            delete timer;</span><br><span class="line">            head = tail = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*目标是头节点*/</span></span><br><span class="line">        <span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            delete timer;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*目标是尾节点*/</span></span><br><span class="line">        <span class="keyword">if</span> (timer == tail) &#123;</span><br><span class="line">            tail = tail-&gt;prev;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            delete timer;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*目标位于其他位置*/</span></span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        delete timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*SIGALRM信号每次被触发一次，就在其信号处理函数中执行一次tick函数，处理任务*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tick</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line">        <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);        <span class="comment">/*获取当前时间*/</span></span><br><span class="line">        util_timer *tmp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从头开始处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器容器的核心逻辑*/</span></span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="comment">/*因为使用的是绝对时间，直接判断即可*/</span></span><br><span class="line">            <span class="keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;</span><br><span class="line">                breka;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*调用回调函数，执行任务*/</span></span><br><span class="line">            tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line">            <span class="comment">/*执行完后，将其从链表删除，重置链表头节点*/</span></span><br><span class="line">            head = tmp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (head) &#123;</span><br><span class="line">                head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            delete tmp;</span><br><span class="line">            tmp = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">/*add_timer的重载函数，将目标定时器按正确的顺序加入节点*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span><br><span class="line">    &#123;</span><br><span class="line">        util_timer *prev = lst_head;</span><br><span class="line">        util_timer *tmp = prev-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*遍历lst_head节点之后的部分链表，找到合适的位置，即超时时间大于目标节点, 然后插入*/</span></span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire) &#123;</span><br><span class="line">                prev-&gt;next = timer;</span><br><span class="line">                timer-&gt;next = tmp;</span><br><span class="line">                tmp -&gt;prev = timer;</span><br><span class="line">                timer-&gt;prev prev;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = tmp;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果没找到则插入队尾*/</span></span><br><span class="line">        <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            tail = timer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    util_timer *head;</span><br><span class="line">    util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>;</span></span><br></pre></td></tr></table></figure>



<p><strong>b) 处理非活动连接</strong></p>
<p>考虑上述代码的实际应用–处理非活动连接。服务器程序通常定期处理非活动连接：给客户端发送一个重连请求，或者关闭连接，或者其他。内核可以通过启动socket选项KEEPALIVE实现该功能，不过管理变的复杂，所以考虑在应用层实现类似的机制。即以下代码，利用alarm函数周期性的触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务–关闭非活动懂连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;apra/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer_list.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMESLOT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> sort_timer_list timer_lst;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN || EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    send(pipefd[<span class="number">1</span>], (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addsig</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    assert(sigaciton(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_handler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*定时处理任务，即调用tick*/</span></span><br><span class="line">    timer_lst.tick();</span><br><span class="line">    <span class="comment">/*一次alarm调用只会引发一次SIGALRM信号，所以需要重新定时，不断触发SIGALRM信号*/</span></span><br><span class="line">    alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器回调函数，删除非活动连接上的注册事件，并关闭*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cb_func</span><span class="params">(client_data *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    assert(user_data);</span><br><span class="line">    close(user_data-&gt;sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close fd %d\n&quot;</span>, user_data-&gt;sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(listenfd, (SA*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(listenfd, <span class="number">6</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="type">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">    addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">    ret = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">    addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">    addsig(SIGALRM);</span><br><span class="line">    addsig(SIGTERM);</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> *<span class="title">users</span> =</span> (<span class="keyword">struct</span> client_data*)<span class="built_in">malloc</span>(FD_LIMIT * <span class="keyword">sizeof</span>(sturct client_data));</span><br><span class="line">    <span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    alarm(TIMESLOT);        <span class="comment">/*定时*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">        <span class="type">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sokcfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*处理新的客户连接*/</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (SA*)&amp;client, &amp;len);</span><br><span class="line">                </span><br><span class="line">                addfd(epollfd, connfd);</span><br><span class="line">                users[connfd].address = client;</span><br><span class="line">                users[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*创建定时器，设置其回调函数与超时事件，然后绑定定时器与用户数据，添加到list中*/</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">util_timer</span> *<span class="title">timer</span> =</span> (<span class="keyword">struct</span> util_timer*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> util_timer));</span><br><span class="line">                timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">                timer-&gt;cb_func = cb_func;</span><br><span class="line">                <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">                timer-&gt;expire = cur + <span class="number">3</span>*TIMESLOT;</span><br><span class="line">                users[connfd].timer = timer;</span><br><span class="line">                timer_lst.add_timer(timer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*处理信号*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">//handle error;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ret; i++) &#123;</span><br><span class="line">                        <span class="keyword">switch</span>(signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGALRM:</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">/*用timeout标记定时任务需要处理，但不立即处理，因为优先级不高*/</span></span><br><span class="line">                                timeout = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            &#123;</span><br><span class="line">                                stop_server = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*处理客户连接上的收到的数据*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of client data %s from %d\n&quot;</span>, ret, users[sockfd].buf, sockfd);</span><br><span class="line"></span><br><span class="line">                util_timer *timer = users[sockfd].timer;</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*如果读错误，关闭连接，移除对应的定时器*/</span></span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGIN) &#123;</span><br><span class="line">                        cb_func(&amp;users[sockfd]);</span><br><span class="line">                        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                            timer_lst.del_timer(timer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*如果对方已经关闭，服务端也关闭*/</span></span><br><span class="line">                    cb_func(&amp;users[sockfd]);</span><br><span class="line">                    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                        timer_lst.del_timer(timer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*有数据可读，调整该连接对应的定时器，延迟被关闭的时间*/</span></span><br><span class="line">                    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">                        <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">                        timer-&gt;expire = cur + <span class="number">3</span>*TIMESLOT;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;adjust timer once\n&quot;</span>);</span><br><span class="line">                        timer_lst.adjust_timer(timer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            timer_handler();</span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(users);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-3-I-x2F-O复用系统调用的超时参数"><a href="#11-3-I-x2F-O复用系统调用的超时参数" class="headerlink" title="11.3 I&#x2F;O复用系统调用的超时参数"></a>11.3 I&#x2F;O复用系统调用的超时参数</h4><p>Linux下3组I&#x2F;O复用系统调用都带有超时参数。但由于I&#x2F;O复用系统可能在超时时间到期之前就返回(有I&#x2F;O事件发生)，所以如果利用它来定时，需要不等更新定时参数剩余的时间，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timeout = TIMEOUT;</span><br><span class="line"><span class="type">time_t</span> start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="type">time_t</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the timeout is now %d mil-seconds\n&quot;</span>, timeout);</span><br><span class="line">    start = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, timeout);</span><br><span class="line">    <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果epoll_wait成功返回，说明超时时间到，此时便可以处理定时任务，重置定时时间*/</span></span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">        timeout = TIMEOUT;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end  = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*如果返回值大于0，则本次调用持续的时间是end-start * 1000 ms*/</span></span><br><span class="line">    <span class="comment">/*需要将定时时间timeout减去这段时间，以获得下次调用的超时参数*/</span></span><br><span class="line">    timeout -= (end-start) *<span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/*重新计算后秒如果等于0，说明本次调用返回时，超时时间刚好到达 */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        timeout = TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//handler connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-4-高性能定时器"><a href="#11-4-高性能定时器" class="headerlink" title="11.4 高性能定时器"></a>11.4 高性能定时器</h4><p><strong>a) 时间轮</strong></p>
<p><img src="/./../pic/image-20230503155530372.png" alt="image-20230503155530372"></p>
<p>哈希的思想，轮子的不同槽对应不同的超时时间，所示时间轮中，实现指针，以恒定的速度顺时针转动，每转动一步就指向下一个槽。</p>
<p>该图只有一个轮子，复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移一槽，像水表一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个较为简单的时间轮的实现。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIME_WHEEL_TIMER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_WHEEL_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    tw_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    tw_timer(<span class="type">int</span> rot, <span class="type">int</span> ts)</span><br><span class="line">    : next(<span class="literal">NULL</span>), prev(<span class="literal">NULL</span>), rotation(rot), time_slot(ts) &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> rotation;       <span class="comment">/*记录定时器在时间轮转多少圈后生效*/</span></span><br><span class="line">    <span class="type">int</span> time_slot;      <span class="comment">/*记录定时器属于轮上哪个槽*/</span></span><br><span class="line">    <span class="type">void</span> (*cb_func)(client_data*);  <span class="comment">/*定时器回调函数*/</span></span><br><span class="line">    client_data *user_data;         <span class="comment">/*客户数据*/</span></span><br><span class="line">    tw_timer *next;     <span class="comment">/*指向下一个*/</span></span><br><span class="line">    tw_timer *prev;     <span class="comment">/*指向前一个*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_wheel</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    time_wheel(): cur_slot(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            slots[i] = <span class="literal">NULL</span>;    <span class="comment">/*初始化每个槽的头结点*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~time_wheel()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*遍历每个槽，销毁其中的定时器*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            tw_timer *tmp = slots[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                slots[i] = tmp-&gt;next;</span><br><span class="line">                delete tmp;</span><br><span class="line">                tmp = slots[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据定时值timeout创建一个定时器，并插入合适的槽中*/</span></span><br><span class="line">    tw_timer *<span class="title function_">add_timer</span><span class="params">(<span class="type">int</span> timeout)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ticks = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*根据超时值计算，它将在多少个tick后被触发，如超时值小于槽间隔SI，</span></span><br><span class="line"><span class="comment">        则向上折合为1，否则向下折合为timeout/SI*/</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; SI) &#123;</span><br><span class="line">            ticks = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ticks = timeout/SI;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*计算待插入的定时器要转动多少圈后被触发*/</span></span><br><span class="line">        <span class="type">int</span> rotation = ticks/N;</span><br><span class="line">        <span class="comment">/*计算插入哪个槽*/</span></span><br><span class="line">        <span class="type">int</span> ts = (cur_slot + (ticks%N)) %N;</span><br><span class="line">        <span class="comment">/*创建新的定时器,它将在转动roation圈后被触发，且位于第ts个槽上*/</span></span><br><span class="line">        tw_timer *timer = (tw_timer*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tw_timer));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果第ts个槽中尚无任何定时器，则插入并设置为头节点*/</span></span><br><span class="line">        <span class="keyword">if</span> (!slots[ts]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;add timer, roatation is %d, ts is %d, cur_slot is %d\n&quot;</span>,</span><br><span class="line">                    roatation, ts, cur_slot);</span><br><span class="line">            slots[ts] = timer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*否则插入第ts个槽中*/</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timer-&gt;next = slots[ts];</span><br><span class="line">            slots[ts]-&gt;prev = timer;</span><br><span class="line">            slots[ts] = timer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">del_timer</span><span class="params">(tw_timer *timer)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ts = timer-&gt;time_slot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer == slots[ts]) &#123;</span><br><span class="line">            slots[ts] = slots[ts]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slots[ts]) &#123;</span><br><span class="line">                slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;next) &#123;</span><br><span class="line">                timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*SI时间到后，调用该函数，时间轮滚动一个槽的间隔*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tick</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        tw_timer *tmp = slots[cur_slot];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current slot is %d\n&quot;</span>, cur_slot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line">            <span class="comment">/*如果定时器的rotation大于0，则这一轮不起作用*/</span></span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;rotation &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmp-&gt;roatation--;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*否则说明定时器稻妻，执行定时任务*/</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line">                <span class="keyword">if</span> (tmp == slots[cur_slot]) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">                    slots[cur_slot] = tmp-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(tmp);</span><br><span class="line">                    <span class="keyword">if</span> (slots[cur_slot]) &#123;</span><br><span class="line">                        slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = slots[cur_slot];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span> (tmp-&gt;next) &#123;</span><br><span class="line">                        tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tw_timer *tmp2 = tmp-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(tmp);</span><br><span class="line">                    tmp = tmp2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_slot == ++cur_slot %N;  <span class="comment">/*更新时间轮当前槽，反映时间轮的滚动*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">/*时间轮上槽的数目*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">/*每1s转动一次*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SI = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*时间轮的槽，每个元素指向一个定时器链表*/</span></span><br><span class="line">    tw_timer *slots[N];</span><br><span class="line">    <span class="comment">/*时间轮的当前槽*/</span></span><br><span class="line">    <span class="type">int</span> cur_slot;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>;</span></span><br></pre></td></tr></table></figure>



<p><strong>b) 时间堆</strong></p>
<p>以最小堆为容器，每次的tick以顶端的计时器对象的timeout为tick间隔。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MIN_HEAP </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">using <span class="built_in">std</span>::exception;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span>;</span>       <span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    heap_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    heap_timer(<span class="type">int</span> delay)</span><br><span class="line">    &#123;</span><br><span class="line">        expire = time(<span class="literal">NULL</span>) + delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="type">time_t</span> expire;      <span class="comment">/*生效的绝对时间*/</span></span><br><span class="line">    <span class="type">void</span> *(cb_func)(client_data*);      <span class="comment">/*回调函数*/</span></span><br><span class="line">    client_data *user_data;             <span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间堆类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_heap</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">/*初始化一个大小为cap的空堆*/</span></span><br><span class="line">    time_heap(<span class="type">int</span> cap) throw(<span class="built_in">std</span>::exception): capacity(cap), cur_size(<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span> = new heap_timer*[capacity];      <span class="comment">/*创建堆数组*/</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;capacity; i++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*用已数组来初始化堆*/</span></span><br><span class="line">    time_heap(heap_timer **init_array, <span class="type">int</span> size, <span class="type">int</span> capacity) throw(<span class="built_in">std</span>::exception)</span><br><span class="line">    : cur_size(size), capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">array</span> = new heap_timer*[capacity];      <span class="comment">/*创建堆数组*/</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;capacity; i++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*初始化堆数组*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                <span class="built_in">array</span>[i] = init_array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=(cur_size<span class="number">-1</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                percolate_down(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*销毁时间堆*/</span></span><br><span class="line">    ~time_heap() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cur_size; i++) &#123;</span><br><span class="line">            delete <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete [] <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">/*添加目标定时器timer*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(heap_timer *timer)</span> <span class="title function_">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*当前数组容量不够，扩容*/</span></span><br><span class="line">        <span class="keyword">if</span> (cur_size &gt;= capacity) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*插入一个元素，当前堆大小加1，hole是新建空穴位置*/</span></span><br><span class="line">        <span class="type">int</span> hole = cur_size++;</span><br><span class="line">        <span class="type">int</span> parent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; hole&gt;<span class="number">0</span>; hoel=parent) &#123;</span><br><span class="line">            parent = (hole<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">array</span>[hole] = <span class="built_in">array</span>[parent];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[hole] = timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除目标定时器*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">del_timer</span><span class="params">(heap_timer *timer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer-&gt;cb_func = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获得堆顶的定时器*/</span></span><br><span class="line">    heap_timer *<span class="title function_">top</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除堆顶定时器*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pop_timer</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">            delete <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[--cur_size];</span><br><span class="line">            percolate_down(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*心搏函数*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tick</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        heap_timer *tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*如果定时器没到期则退出循环*/</span></span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;expire &gt; cur) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*执行堆顶任务*/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func) &#123;</span><br><span class="line">                <span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func(<span class="built_in">array</span>[<span class="number">0</span>]-&gt;user_data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*将堆顶元素删除*/</span></span><br><span class="line">            pop_timer();</span><br><span class="line">            tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> cur_size == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">/*最下对的调整操作*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">percolate_down</span><span class="params">(<span class="type">int</span> hole)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        heap_timer *temp = <span class="built_in">array</span>[hole];</span><br><span class="line">        <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ((hole*<span class="number">2</span>+<span class="number">1</span>) &lt;= (cur_size<span class="number">-1</span>)); hole=child) &#123;</span><br><span class="line">            child = hole*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((child &lt; (cur_size<span class="number">-1</span>)) &amp;&amp; (<span class="built_in">array</span>[child+<span class="number">1</span>]-&gt;expire &lt; <span class="built_in">array</span>[child]-&gt;expire)) &#123;</span><br><span class="line">                ++child;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[child]-&gt;expire &lt; temp-&gt;expire) &#123;</span><br><span class="line">                <span class="built_in">array</span>[hole] = <span class="built_in">array</span>[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[hole] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*数组扩容*/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">resize</span><span class="params">()</span> <span class="title function_">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span></span><br><span class="line">    &#123;</span><br><span class="line">        heap_timer **temp = new heap_timer*[<span class="number">2</span>*capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*capacity; i++) &#123;</span><br><span class="line">            temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        capacity = <span class="number">2</span>*capacity;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cur_size; i++) &#123;</span><br><span class="line">            temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete [] <span class="built_in">array</span>;</span><br><span class="line">        <span class="built_in">array</span> = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    heap_timer **<span class="built_in">array</span>;     <span class="comment">/*堆数组*/</span></span><br><span class="line">    <span class="type">int</span> capacity;           <span class="comment">/*堆容量*/</span></span><br><span class="line">    <span class="type">int</span> cur_size;           <span class="comment">/*对当前包含元素个数*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第12章-高性能I-x2F-O框架库Libevent"><a href="#第12章-高性能I-x2F-O框架库Libevent" class="headerlink" title="第12章 高性能I&#x2F;O框架库Libevent"></a>第12章 高性能I&#x2F;O框架库Libevent</h3><h4 id="12-1-I-x2F-O框架库概述"><a href="#12-1-I-x2F-O框架库概述" class="headerlink" title="12.1 I&#x2F;O框架库概述"></a>12.1 I&#x2F;O框架库概述</h4><p>I&#x2F;O框架库以库函数的形式，封装了较为底层的系统i盗用，给应用程序便于使用的接口。</p>
<p>各种I&#x2F;O框架库的实现原理基本相似，要么基于Reactor模式，要么以Proactor模式，要么同时以两种实现。</p>
<p>以Reactor模式举例，基于该模式的I&#x2F;O框架库包括如下几个组件：句柄，事件多路分发器，事件处理器和具体的事件处理及，Reactor。这些组件的关系，如下图。</p>
<p><img src="/./../pic/image-20230505161810819.png" alt="image-20230505161810819"></p>
<p><u>1.句柄</u></p>
<p>I&#x2F;O框架库要处理的对象，即I&#x2F;O事件，信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。在Linux中，I&#x2F;O事件对应的句柄是文件描述符，信号对应的是信号值。内核检测到就绪事件，通过句柄来通知应用程序。</p>
<p><u>2.事件多路分发器</u></p>
<p>相当于epoll_wait的作用，循环等待并处理事件，也就是事件循环。通常使用I&#x2F;O复用技术来实现，也就是对系统各种I&#x2F;O复用函数封装成统一的接口，称为事件多路分发器。其核心函数demultiplex内部调用的是select, poll, epoll_wati等函数。</p>
<p><u>3.事件处理器和具体事件处理器</u></p>
<p>即执行事件对应的逻辑业务。通常包含一个或多个回调函数在事件循环中被执行，事件处理器为一接口，用户继承它来实现自己的事件处理器，即具体事件处理器。</p>
<p><u>4.Reactor</u></p>
<p>I&#x2F;O框架库的核心。他提供如下几个主要方法：</p>
<ol>
<li>handle_events。执行事件循环，等待事件，依次处理就绪事件对应的事件处理器。</li>
<li>register_handler。调用多路分发器的register_event方法注册一个事件。</li>
<li>remove_handler。调用多路分发器的remove_event方法删除一个事件。</li>
</ol>
<p><img src="/./../pic/image-20230505162651215.png" alt="image-20230505162651215"></p>
<h4 id="12-2-Libevent源码分析"><a href="#12-2-Libevent源码分析" class="headerlink" title="12.2 Libevent源码分析"></a>12.2 Libevent源码分析</h4><p>Libevent为一款轻量级的高性能I&#x2F;O框架库，其特点如下：</p>
<ol>
<li>跨平台支持，支持Linux，UNIX，Windows</li>
<li>统一事件源，对I&#x2F;O事件，信号和定时事件提供统一的处理</li>
<li>线程安全。使用libevent_pthreads库来提供线程安全支持</li>
<li>基于Reactor模式实现。</li>
</ol>
<p>学习它的好处：</p>
<ol>
<li>学习编写一个产品级的函数库需要考虑的细节</li>
</ol>
<p><strong>a) 一个实例</strong></p>
<p>Libevent库实现的一个”Hello World”程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span> *argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> (event_base*)argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> =</span> &#123;<span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal; exiting cleanly in two seconds...\n&quot;</span>);</span><br><span class="line">    event_base_loopexit(base, &amp;delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout_cb</span><span class="params">(<span class="type">int</span> fd, <span class="type">short</span> event, <span class="type">void</span> *argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_init();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">signal_event</span> =</span> evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class="line">    event_add(signal_event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    timeval tv = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">timeout_event</span> =</span> evtimer_new(base, timeout_cb, <span class="literal">NULL</span>);</span><br><span class="line">    event_add(timeout_event, &amp;tv);</span><br><span class="line"></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">    event_free(timeout_event);</span><br><span class="line">    event_free(signal_event);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得出Libevent库的主要逻辑:</p>
<p>1.调用event_init函数创建event_base对象。相当于一个Reactor实例。</p>
<p>2.创建具体的事件处理器，并设置它们丛书的Reactor实例。evsignal_new和evtimer_new分别用于创建信号事件和定时器事件的处理，其定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> evsignal_new(b, x, cb, arg)	\</span></span><br><span class="line"><span class="meta">	event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> evtimer_new(b, cb, arg) event_new((b), -1, 0, (cb), (arg))</span></span><br></pre></td></tr></table></figure>

<p>event_new函数，用于创建通用事件处理，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> event *<span class="title function_">event_new</span><span class="params">(<span class="keyword">struct</span> event_base *base, <span class="type">evutil_socket_t</span> fd, </span></span><br><span class="line"><span class="params">       <span class="type">short</span> evetns, <span class="type">void</span> (*cb)(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span>*), </span></span><br><span class="line"><span class="params">                       <span class="type">void</span>*arg)</span></span><br></pre></td></tr></table></figure>

<p>base指定从属的Reactor，fd指定关联的句柄。I&#x2F;O事件为文件描述符，信号为信号值，定时器为-1。events指定事件类型，cb指定回调函数，arg参数为传递给回调函数的参数。事件类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_TIMEOUT 			0x01	<span class="comment">/*定时事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_READ				0x02	<span class="comment">/*可读事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_WRITE			0x04	<span class="comment">/*可写事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SIGNAL			0x08	<span class="comment">/*信号事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PERSIST			0x10	<span class="comment">/*永久事件*/</span></span></span><br><span class="line"><span class="comment">/*边沿触发事件，需要I/O复用系统调用支持，如epoll*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ET				0x20</span></span><br></pre></td></tr></table></figure>



<p><strong>b) 源码组织结构</strong></p>
<ol>
<li>头文件目录include&#x2F;eventw。该目录头文件是Libevent提供给应用程序使用，如event.h头文件提供核心函数，http.h头文件提供HTTP协议相关服务，rcp.h提供远程过程调用支持。</li>
<li>源码根目录下的头文件。分为两类：一类是对include&#x2F;event2目录下部分头文件的包装，另一类是Livevent内部使用的辅助性头文件，它们的文件名具有*-internal.h的形式</li>
<li>通用数据结构目录compat&#x2F;sys。仅有一个文件queue.h封装了跨平台的基础数据结构</li>
<li>sample目录。提供一些实例程序</li>
<li>test目录。提供一些测试代码</li>
<li>WIN32-Code目录。提供Windows上的一些专用代码</li>
<li>event.c文件，实现Libevent的整体框架</li>
<li>devpoll.c，kqueue.c，qvport.c，select.c，win32select.c，poll.c，epoll.c。分别封装了对应的I&#x2F;O复用机制</li>
<li>minheap-internal.h。实现了一个时间堆</li>
<li>signal.c。提供对信号的支持</li>
<li>evmap.c。维护句柄与事件处理器的映射关系</li>
<li>event_tagging.c。它提供缓冲区中添加标记数据，以及从缓冲区中读出标记数据的函数</li>
<li>event_iocp.c。提供对WindowsIOCP的支持</li>
<li>buffer*.c。提供对网络I&#x2F;O缓存的控制。</li>
<li>evthread*.c。提供多线程支持</li>
<li>listener.c。封装了对监听socket的操作</li>
<li>logs.c。Libevent的日志系统</li>
<li>evutil.c，evutil_rand.c，strlcpy.c和arc4random.c。提供一些基本操作：如生成随机数，获取socket地址信息，读取文件，设置socket属性等</li>
<li>evdns.c，http.c和evrpc.c。对DNS协议，HTTP协议和RPC协议的支持</li>
<li>epoll_sub.c。未使用。</li>
</ol>
<p><strong>c) event结构体</strong></p>
<p>Libevent中的事件处理器的结构类型。封装了句柄，事件类型，回调函数以及其他必要标志。</p>
<p><strong>d) 往注册事件队列中添加事件处理器</strong></p>
<p>event对象创建好后，应用程序需要使用event_add函数将其添加到注册事件队列中，并将对应的事件注册到时间多路分发器上。event_add主要是调用另外一个内部函数event_add_internal。</p>
<p>event_add_inernal内部又调用几个重要函数：</p>
<ol>
<li>evmap_io_add。该函数将I&#x2F;O事件添加到时间多路分发器中，并将对应的事件处理器添加到I&#x2F;O事件队列中，同时建立I&#x2F;O事件和I&#x2F;O事件处理器之间的映射关系。</li>
<li>evmap_signal_add。同上，但是添加到信号事件队列，以及信号和信号事件处理器之间的映射关系。</li>
<li>event_queue_insert。将事件处理器添加到各种事件队列中：将I&#x2F;O事件处理器和信号事件处理器插入注册事件队列；定时器插入定时器队列或时间堆；被激活事件处理添加到活动时间队列。</li>
</ol>
<p><strong>e) 往事件多路分发器中注册事件</strong></p>
<p>其中又调用add函数，注册事件。这里看起来有点复杂，还用哈希建立了文件句柄和事件处理的映射。</p>
<p><strong>f) eventop结构体</strong></p>
<p>封装I&#x2F;O复用机制的一些操作，如注册事件，等待事件等。</p>
<p><img src="/./../pic/image-20230506171636616.png" alt="image-20230506171636616"></p>
<p><strong>g) event_base结构体</strong></p>
<p>即Libevent的Reactor。</p>
<p><img src="/./../pic/image-20230506172134114.png" alt="image-20230506172134114"></p>
<p><img src="/./../pic/image-20230506172142137.png" alt="image-20230506172142137"></p>
<p><strong>h) 事件循环</strong></p>
<p>Libevent中实现事件循环的函数是event_base_loop。该函数首先调用I&#x2F;O事件多路分发器的事件监听函数，以等待事件：当有事件发生时，依次处理。</p>
<p><img src="/./../pic/image-20230506173720527.png" alt="image-20230506173720527"></p>
<p><img src="/./../pic/image-20230506173728868.png" alt="image-20230506173728868"></p>
<p><img src="/./../pic/image-20230506173736141.png" alt="image-20230506173736141"></p>
<p><img src="/./../pic/image-20230506173749422.png" alt="image-20230506173749422"></p>
<p><img src="/./../pic/image-20230506173757896.png" alt="image-20230506173757896"></p>
<h3 id="第13章-多进程编程"><a href="#第13章-多进程编程" class="headerlink" title="第13章 多进程编程"></a>第13章 多进程编程</h3><h4 id="13-1-fork系统调用"><a href="#13-1-fork系统调用" class="headerlink" title="13.1 fork系统调用"></a>13.1 fork系统调用</h4><p>创建新进程的系统调用，定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>大部分属性直接复制，如堆指针，栈指针和标志寄存器的值。</p>
<p>信号位图被清除，PPID被设置成原进程的PID。</p>
<p>写时复制。</p>
<p>父进程打开的文件描述符默认在子进程中也是打开的。</p>
<h4 id="13-2-exec系列系统调用"><a href="#13-2-exec系列系统调用" class="headerlink" title="13.2 exec系列系统调用"></a>13.2 exec系列系统调用</h4><p>在子进程中执行其他程序，即替换当前进程映像：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性。</p>
<h4 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h4><p>父进程调用如下函数，以等待子进程的结束，并获取子进程的返回信息，避免僵尸进程的产生：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *stat_loc)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *stat_loc, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>退出状态信息储存于stat_loc参数，wait.h中定义了几个宏来帮助解释子进程的退出状态信息：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>WIFEXITED(stat_val)</td>
<td>如果子进程正常结束，它就返回一个非0值</td>
</tr>
<tr>
<td>WEXITSTATUS(stat_val)</td>
<td>如果WIFEXITED非0，它返回子进程的退出码</td>
</tr>
<tr>
<td>WIFSIGNALED(stat_val)</td>
<td>如果子进程是因为一个未捕捉的信号而终止，它就返回一个非0值</td>
</tr>
<tr>
<td>WTERMSIG(stat_val)</td>
<td>如果WIFSIGNALED非0，它返回一个信号值</td>
</tr>
<tr>
<td>WIFSTOPPED(stat_val)</td>
<td>如果子进程意外终止，它就返回一个非0值</td>
</tr>
<tr>
<td>WSTOPSIG(stat_val)</td>
<td>如果WIFSTOPPED非0，它返回一个信号值</td>
</tr>
</tbody></table>
<p>wait函数带有阻塞，取而代之的是waitpid。如果pid为-1，它和wait函数相同，等待一个任意的子进程结束，否则等待由pid参数指定的子进程。</p>
<p>options参数可以控制其行为，常用的取值为WNOHANG，即调用为非阻塞。</p>
<p>8.3提过，要在事情已经发生的情况下执行非阻塞调用才能提高效率，所以可以利用SIGCHLD信号，得知某个进程是否已经退出，然后对其处理函数进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_child</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*善后处理*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h4><p>管道也是父子进程之间通信的常用手段。利用的是fork调用之后两个管道文件描述符都保持打开。</p>
<p><img src="/./../pic/image-20230509211125644.png" alt="image-20230509211125644"></p>
<p>普通的管道只能实现单向数据传输，如果要实现父子之间的双向数据传输，必须使用两个管道。或前面介绍过的，socketpari函数，创建全双工管道的系统调用。</p>
<p>管道只能用于有关联的两个进程间的通信，下面讨论3种System V IPC能用于无关联的多个进程之间的通信，因为它们都使用一个全局唯一的键值来标识一条信道。</p>
<h4 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h4><p><strong>a) 信号量原语</strong></p>
<p>用起来感觉和锁差不多的，多进程中，某进程访问一资源的时候，避免其他线程也同时访问，也就是独占式访问。</p>
<p>信号量的操作主要为如下两种，假设信号量SV：</p>
<ol>
<li>P(SV)：如果SV的值大于0，将它减1；如果SV的值为0，挂起进程的执行。</li>
<li>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，将SV加1。</li>
</ol>
<p><img src="/./../pic/image-20230510205642092.png" alt="image-20230510205642092"></p>
<p>如图，在关键代码可用时，假设信号量SV的值为1。AB都有机会进入该段，如果A执行了PSV，将SV值减1，则进程B再次执行PSV则会被挂起。直到A执行VSV操作将SV加1，关键代码段才重新可用。</p>
<p><strong>b) semget系统调用</strong></p>
<p>创建一个新的信号量集，或者获取一个已存在的信号量集。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br></pre></td></tr></table></figure>

<p>key参数是一个键值，标识一个全局唯一的信号量集。</p>
<p>num_sems参数指定要创建&#x2F;获取的信号量集中信号量的数目。</p>
<p>sem_flags参数指定一组标志，权限。和open系统调用的mode参数一样，即0777这种格式的权限。</p>
<p>如果semget用于创建信号量集，则与之关联的内核数据结构体semid_ds将被创建，结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">/*该结构体用于描述IPC对象(信号量，共享内存和消息队列的权限) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span> key;			<span class="comment">//键值</span></span><br><span class="line">    <span class="type">uid_t</span> uid;			<span class="comment">//所有者的有效用户ID</span></span><br><span class="line">    <span class="type">gid_t</span> gid;			<span class="comment">//所有者的有效组ID</span></span><br><span class="line">    <span class="type">uid_t</span> cuid;			<span class="comment">//创建者的有效用户ID</span></span><br><span class="line">    <span class="type">gid_t</span> cgid;			<span class="comment">//创建者的有效组ID</span></span><br><span class="line">    <span class="type">mode_t</span> mode;		<span class="comment">//访问权限</span></span><br><span class="line">    	<span class="comment">/*省略其他填充字段*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>		<span class="comment">//信号量的操作权限</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> sem_nsems;	<span class="comment">//该信号量集中的信号量数目</span></span><br><span class="line">    <span class="type">time_t</span> sem_otime;				<span class="comment">//最后一次调用semop的时间</span></span><br><span class="line">    <span class="type">time_t</span> sem_ctime;				<span class="comment">//最后一次调用semctl的时间</span></span><br><span class="line">    	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>c) semop系统调用</strong></p>
<p>semop改变信号量的值，即执行P，V操作。</p>
<p>每个信号量关联的一些重要的内核变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semval;				<span class="comment">//信号量的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semzcnt;				<span class="comment">//等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semncnt;				<span class="comment">//等待信号量值增加的进程数量</span></span><br><span class="line"><span class="type">pid_t</span> sempid;						<span class="comment">//最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure>

<p>semop定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_ops, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure>

<p>sem_id参数即semget获取&#x2F;创建的信号量集标识符。</p>
<p>sem_ops参数指向一个sembuf的结构体，定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sem_num;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sem_op;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sem_num成员指明信号量集中信号量的编号，0表示第一个。</p>
<p>sem_op指定操作类型，可选值为正整数，0，负整数。其操作的行为又受到sem_flg影响。</p>
<p>sem_flg的可选值为IPC_NOWAIT和SEM_UNDO。IPC_NOWAIT类似于非阻塞操作。SEM_UNDO的含义是进程退出时取消正在进行的semop操作。</p>
<p>sem_flg影响如下：</p>
<ol>
<li>如sem_op大于0，对信号量的值semval增加sem_op，类似V操作。要求调用进程对信号量具有写权限，如果设置了UNDO标志，则系统将更新semadj变量(用以跟踪进程对信号量的修改情况)。</li>
<li>如sem_op等于0，表示这是一个“等待0”操作。要求拥有读权限。如没设置IPC_NOWAIT，信号量的semzcnt值加1，进程睡眠直到以下三个情况发生：a) semval变为0；b) 信号量集被进程移除；c) 调用被信号中断。</li>
<li>如sem_op小于0，灯信号量进行减操作，类似P操作，即期望获得信号量。如设置UNDO标志，系统更新semadj变量。</li>
</ol>
<p>semop的第3个参数num_sem_ops指定要执行的操作个树，即sem_ops数组元素的数量，对数组每个成员按顺序依次执行操作，且该过程为 原子操作。</p>
<p><strong>d) semctl系统调用</strong></p>
<p>该系统调用允许调用者对信号量进行直接控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>id参数指定信号量集的标识符，sem_num指定被操作的信号量在集中的编号，command指定要执行的命令。</p>
<p>有的命令需要第4个参数，第4个参数类型由用户自己定义，推荐格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;				<span class="comment">//用于SETVAL命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>, 	//用于<span class="title">IPC_STAT</span>和<span class="title">IPC_SET</span>命令</span></span><br><span class="line"><span class="class">    <span class="title">unsigned</span> <span class="title">short</span> *<span class="title">array</span>;</span>	<span class="comment">//用于GETALL和SETALL命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span>	<span class="comment">//用于IPC_INFO命令</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> semmap;				<span class="comment">//Linux内核没有使用</span></span><br><span class="line">    <span class="type">int</span> semmni;				<span class="comment">//系统最多可拥有的信号量集数目</span></span><br><span class="line">    <span class="type">int</span> semmns;				<span class="comment">//系统最多可拥有的信号量数目</span></span><br><span class="line">    <span class="type">int</span> semmnu;				<span class="comment">//Linux内核没有使用</span></span><br><span class="line">    <span class="type">int</span> semmsl;				<span class="comment">//一个信号量集组多允许包含的信号量数目</span></span><br><span class="line">    <span class="type">int</span> semopm;				<span class="comment">//semop依次最多能执行的sem_op操作数目</span></span><br><span class="line">    <span class="type">int</span> semume;				<span class="comment">//没有使用</span></span><br><span class="line">    <span class="type">int</span> semusz;				<span class="comment">//sem_undo的结构体大小</span></span><br><span class="line">    <span class="type">int</span> semvmx;				<span class="comment">//最大允许的信号量值</span></span><br><span class="line">    <span class="comment">/*最多允许的UNDO次数(带sem_undo标志的semop操作的次数)*/</span></span><br><span class="line">    <span class="type">int</span> semaem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有支持的命令如下表:</p>
<p><img src="/./../pic/image-20230510213053850.png" alt="image-20230510213053850"></p>
<p><strong>e) 特殊键值IPC_RPIVATE</strong></p>
<p>并非像它的名字是私有的，而是创建一个新的信号量，类似INADDR_ANY。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*op为-1时执行p操作，op为1时执行v操作*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pv</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> op)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = op;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    semop(sem_id, &amp;sem_b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sem_id = semget(IPC_PRIVATE, <span class="number">1</span>, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_un</span>;</span></span><br><span class="line">    sem_un.val = <span class="number">1</span>;</span><br><span class="line">    semctl(sem_id, <span class="number">0</span>, SETVAL, sem_un);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child try to get binary sem\n&quot;</span>);</span><br><span class="line">        pv(sem_id, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child get the sem and would release it after 5s\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        pv(sem_id, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent try to get binary sem\n&quot;</span>);</span><br><span class="line">        pv(sem_id, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent get the sem and would release it after 5s\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        pv(sem_id, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waitpid(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_un);        <span class="comment">/*删除信号量*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出信号量和互斥锁还是很像的，区别在于信号量的lock操作也就是p操作不一定会导致其他线程被挂起。</p>
<h4 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h4><p>共享内存通常和其他进程间通信方式一起使用，以防止产生竞态条件，其包括4个系统调用：shmget，shmat，shmdt和shmctl。</p>
<p><strong>a) shmget系统调用</strong></p>
<p>创建一段新的共享内存，或者获取一段已存在的共享内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<p>key同semget一样，标识符。size指定共享内存的大小。</p>
<p>shmflg同semget一样，类似于open系统调用的mode参数，但支持两个额外参数:</p>
<ol>
<li>SHM_HUGETLB。类似于mmap的MAP_HUGETLB标志，使用“大页面”来分配空间。</li>
<li>SHM_NORESERVE。类似于mmap的MAP_NORESERVE标志，不保留交换分区。这样，当物理内存不足时，将触发SIGSEGV信号。</li>
</ol>
<p>同样，也存在一个与之关联的内核数据结构shmid_ds，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>			<span class="comment">//共享内存的操作权限</span></span><br><span class="line">    <span class="type">size_t</span> shm_segsz;					<span class="comment">//共享内存的大小</span></span><br><span class="line">    <span class="type">__time_t</span> shm_atime;					<span class="comment">//最后一次调用shmat的时间</span></span><br><span class="line">    <span class="type">__time_t</span> shm_dtime;					<span class="comment">//最后一次调用shmdt的时间</span></span><br><span class="line">    <span class="type">__time_t</span> shm_ctime;					<span class="comment">//最后一次调用shmctl的时间</span></span><br><span class="line">    <span class="type">__pid_t</span> shm_cpid;					<span class="comment">//创建者的pid</span></span><br><span class="line">    <span class="type">__pid_t</span> shm_lpid;					<span class="comment">//最后一次执行shmat或shmdt操作的进程的pid</span></span><br><span class="line">    <span class="type">shmatt_t</span> shm_nattach;				<span class="comment">//关联到此共享内存的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>b) shmat和shmdt系统调用</strong></p>
<p>共享内存被创建&#x2F;获取之后，需要将它关联到进程的地址空间中，使用完后也需要将他分离。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shm_addr)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>如shm_addr为NULL，被关联地址由操作系统选择。</li>
<li>如shm_addr非空，SHM_RND标志未设置，则关联到addr指定的地址处</li>
<li>如shm_addr非空，SHM_RND标志已设置，则被关联的地址[shm_addr - (shm_addr % SHMLBA)]。</li>
</ol>
<p>shmflg除SHM_RND参数之外，还支持如下:</p>
<ol>
<li>SHM_RDONLY，仅能读取。</li>
<li>SHM_REMAP，重新关联。</li>
<li>SHM_EXEC，指定执行权限。</li>
</ol>
<p><strong>c) shmctl系统调用</strong></p>
<p>控制共享内存的某些属性，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>支持的命令如下表：</p>
<p><img src="/./../pic/image-20230510221131634.png" alt="image-20230510221131634"></p>
<p><strong>d) 共享内存POSIX方法</strong></p>
<p>即mmap函数。利用它的MAP_ANONYMOUS标志，可以实现父子进程之间的匿名共享内存。通过打开同一个文件，mmap也可以实现无关进程之间的内存共享。Linux提供了另外一种利用mmap在无关进程之间共享内存的方法，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>由shm_open创建的共享内存对象，使用完之后需要被删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>e) 共享内存实例</strong></p>
<p>一个聊天室服务器程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCESS_LIMIT 65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户数据*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="type">int</span> connfd;         <span class="comment">//socket文件描述符</span></span><br><span class="line">    <span class="type">pid_t</span> pid;          <span class="comment">//处理该连接的子进程pid</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];      <span class="comment">//和父进程通信所用管道</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line"><span class="type">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> epollfd;</span><br><span class="line"><span class="type">int</span> listenfd;</span><br><span class="line"><span class="type">int</span> shmfd;</span><br><span class="line"><span class="type">char</span> *share_mem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户连接数组，进程用客户连接的编号来索引这个数组，取得客户连接数据*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> *<span class="title">users</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*子进程和客户连接的映射关系表，利用pid索取这个数组，获取客户连接编号*/</span></span><br><span class="line"><span class="type">int</span> *sub_process = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*当前客户数量*/</span></span><br><span class="line"><span class="type">int</span> user_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> stop_child = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    send(sig_pipefd[<span class="number">1</span>], (<span class="type">char</span>*)*msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span> *(handler)(<span class="type">int</span>), <span class="type">bool</span> restart = <span class="literal">true</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">as</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart) &#123;</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_resource</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    close(epollfd);</span><br><span class="line">    shm_unlink(shm_name);</span><br><span class="line">    delete [] users;</span><br><span class="line">    delete [] sub_process;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*停止一个子进程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_term_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程运行的函数，idx指出子进程处理的客户连接编号，share_mem指出共享内存的起始地址*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">run_child</span><span class="params">(<span class="type">int</span> idx, client_data *users, <span class="type">char</span> *share_mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="comment">/*子进程监听两个文件描述符，客户连接socket和父进程通信的管道*/</span></span><br><span class="line">    <span class="type">int</span> child_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(child_epollfd != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> connfd = users[idx].connfd;</span><br><span class="line">    addfd(child_epollfd, connfd);</span><br><span class="line">    <span class="type">int</span> pipefd = users[idx].pipefd[<span class="number">1</span>];</span><br><span class="line">    addfd(child_epollfd, pipefd);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*子进程需要设置自己的信号处理函数*/</span></span><br><span class="line">    addsig(SIGTERM, child_term_handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_child) &#123;</span><br><span class="line">        <span class="type">int</span> number = epoll_wait(child_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*socket连接有数据到达*/</span></span><br><span class="line">            <span class="keyword">if</span> ((sockfd == connfd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(share_mem+idx*BUFFER_SIZE, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">                ret = recv(connfd, share_mem+idx*BUFFER_SIZE, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">                        stop_child = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    stop_child = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*成功读取后，通知主进程*/</span></span><br><span class="line">                    send(pipefd, (<span class="type">char</span>*)&amp;idx, <span class="keyword">sizeof</span>(idx), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*主进程通知本进程将第client个客户的数据发送到本进程负责的客户端*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="type">int</span> client = <span class="number">0</span>;</span><br><span class="line">                ret = recv(sockfd, (<span class="type">char</span>*)&amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) </span><br><span class="line">                        stop_child = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    stop_child = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    send(connfd, share_mem+client*BUFFER_SIZE, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(connfd);</span><br><span class="line">    close(pipefd);</span><br><span class="line">    close(child_epollfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = port;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    user_count = <span class="number">0</span>;</span><br><span class="line">    users = new clinet_data[USER_LIMIT+<span class="number">1</span>];</span><br><span class="line">    sub_process = new <span class="type">int</span>[PROCESS_LIMIT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;PROCESS_LIMIT; i++)</span><br><span class="line">        sub_process[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">    addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">    ret = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">    setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">    addfd(epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    addsig(SIGCHLD, sig_handler);</span><br><span class="line">    addsig(SIGTERM, sig_handler);</span><br><span class="line">    addsig(SIGINT, sig_handler);</span><br><span class="line">    addsig(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="built_in">terminate</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建共享内存*/</span></span><br><span class="line">    shmfd = shm_open(shm_name, O_CREAT | P_RDWR, <span class="number">0666</span>);</span><br><span class="line">    assert(shmfd != <span class="number">-1</span>);</span><br><span class="line">    ret = ftruncate(shmfd, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    share_mem = (<span class="type">char</span>*)mmap(<span class="literal">NULL</span>, USER_LIMIT*BUFFER_SIZE, PROT_READ | PROT_WRITE, </span><br><span class="line">                            MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">    assert(share_mem != MAP_FAILED);</span><br><span class="line">    close(shmfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">        <span class="type">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;number; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*新的客户连接*/</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="type">socklen_t</span> clientlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, </span><br><span class="line">                                    &amp;clientlen,);</span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;errno is :%d\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (user_count &gt;= USER_LIMIT) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">                    send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*保存第user_count个客户连接的相关数据*/</span></span><br><span class="line">                users[user_count].address = client_address;</span><br><span class="line">                users[user_count].connfd = connfd;</span><br><span class="line">                <span class="comment">/*建立父子进程之间的管道*/</span></span><br><span class="line">                ret = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, users[user_count].pipefd);</span><br><span class="line">                assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span> (pid&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(epollfd);</span><br><span class="line">                    close(listenfd);</span><br><span class="line">                    close(users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">                    close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">                    close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">                    run_child(user_count, users, share_mem);</span><br><span class="line">                    munmap((<span class="type">void</span>*)share_mem, USER_LIMIT*BUFFER_SIZE);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    close(users[user_count].pipefd[<span class="number">1</span>]);</span><br><span class="line">                    addfd(epollfd, user[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">                    users[user_count].pid = pid;</span><br><span class="line">                    sub_process[pid] = user_count;</span><br><span class="line">                    user_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*处理信号事件，统一信号源了属于是，将信号处理交给主线程，并用epoll监听*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == sig_pipefd[<span class="number">0</span>] &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="type">int</span> sig;</span><br><span class="line">                <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ret; i++) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">                            <span class="comment">/*子进程退出，某个客户端关闭了连接*/</span></span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">pid_t</span> pid;</span><br><span class="line">                                <span class="type">int</span> stat;</span><br><span class="line">                                <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="type">int</span> del_user = sub_process[pid];</span><br><span class="line">                                    sub_process[pid] = <span class="number">-1</span>;</span><br><span class="line">                                    <span class="keyword">if</span> ((del_user &lt; <span class="number">0</span>) || (del_user &gt; USER_LIMIT))</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="comment">/*清除del_user客户的数据*/</span></span><br><span class="line">                                    epoll_ctl(epollfd, EPOLL_CTL_DEL, users[del.user].pipefd[<span class="number">0</span>]);</span><br><span class="line">                                    close(user[del_user].pipefd[<span class="number">0</span>]);</span><br><span class="line">                                    users[del_user] = users[--user_count];</span><br><span class="line">                                    sub_process[user[del_user].pid] = del_user;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">terminate</span> &amp;&amp; user_count == <span class="number">0</span>) </span><br><span class="line">                                    stop_server = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT:</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">/*结束服务器程序*/</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;kill all the child now\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">if</span> (user_count == <span class="number">0</span>) &#123;</span><br><span class="line">                                    stop_server = <span class="literal">true</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;user_count; i++) &#123;</span><br><span class="line">                                    <span class="type">int</span> pid = users[i].pid;</span><br><span class="line">                                    kill(pid, SIGTERM);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="built_in">terminate</span> = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*某个子进程像父进程写入数据*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/*读取管道数据*/</span></span><br><span class="line">                ret = recv(sockfd, (<span class="type">char</span>*)&amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read data from child accross pipe\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/*向除负责处理第child个客户连接的子进程之外的进程发送消息*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;user_count; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (users[j].pipefd[<span class="number">0</span>] != sockfd) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;send data to child accross pipe\n&quot;</span>);</span><br><span class="line">                            send(users[j].pipefd[<span class="number">0</span>], (<span class="type">char</span>*)&amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del_resource();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h4><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接受方可以根据类型来有选择地接收数据。</p>
<p>包括4个系统调用：msgget，msgsnd，msgrcv和msgctl。</p>
<p><strong>a) msgget系统调用</strong></p>
<p>创建&#x2F;获取一个消息队列:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p>key键值标识一个全局唯一的消息队列。msfflg类似于open的mode参数。</p>
<p>与之关联的内核数据结构msqid_ds定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>		<span class="comment">//消息队列的操作权限</span></span><br><span class="line">    <span class="type">time_t</span> msg_stime;				<span class="comment">//最后一次调用msgsnd的时间</span></span><br><span class="line">    <span class="type">time_t</span> msg_rtime;				<span class="comment">//最后一次调用msgrcv的时间</span></span><br><span class="line">    <span class="type">time_t</span> msg_ctime;				<span class="comment">//最后一次修改的时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __msg_cbytes;		<span class="comment">//消息队列中已有字节数</span></span><br><span class="line">    <span class="type">msgqnum_t</span> msg_qnum;				<span class="comment">//消息队列中已有的消息数</span></span><br><span class="line">    <span class="type">msgqlen_t</span> msg_qbytes;			<span class="comment">//消息队列允许的最大字节数</span></span><br><span class="line">    <span class="type">pid_t</span> msg_lspid;				<span class="comment">//最后执行msgsnd的进程pid</span></span><br><span class="line">    <span class="type">pid_t</span> msg_lrpid;				<span class="comment">//最后执行msgrcv的进程pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>b) msgsnd系统调用</strong></p>
<p>将一条消息添加到消息队列中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p>msqid指定一个消息队列标识符。</p>
<p>msg_ptr指向一个准备发送的消息，消息必须被定义为如下类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;		<span class="comment">//消息类型</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">512</span>];<span class="comment">//消息数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mtype指定消息的类型，必须为一个正整数。</p>
<p>msgflg控制msgsnd的行为，通常仅支持IPC_NOWAIT。</p>
<p><strong>c) msgrcv系统调用</strong></p>
<p>从消息队列中获取消息，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p>msgtype参数指定接收何种类型的消息，可使用如下几种方式：</p>
<ol>
<li>等于0，读取队列中第一个消息。</li>
<li>大于0，读取队列中第一个类型为msgtype的消息(除非指定了MSG_EXCEPT)。</li>
<li>小于0，读取队列中第一个类型比msgtype的绝对值小的消息。</li>
</ol>
<p>msgflg参数控制msgrcv的行为，如下：</p>
<ol>
<li>IPC_NOWWAIT，非阻塞读。</li>
<li>MSG_EXCEPT，如果msgtype大于0，则接收队列中第一个非msgtype类型的消息。</li>
<li>MSG_NOERROR，如果长度超过了msg_sz，将它截断。</li>
</ol>
<p><strong>d) msgctl系统调用</strong></p>
<p>控制消息队列的某些属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> command, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p>支持的命令如下表：</p>
<p><img src="/./../pic/image-20230511121715343.png" alt="image-20230511121715343"></p>
<p><img src="/./../pic/image-20230511121725671.png" alt="image-20230511121725671"></p>
<h4 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h4><p>ipcs命令，查看当前系统上拥有哪些共享资源实例，如下：</p>
<p><img src="/./../pic/image-20230511121909704.png" alt="image-20230511121909704"></p>
<h4 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h4><p>在Linux下，可以利用UNIX域socket在进程间传递特殊的辅助数据，以实现文件描述符的传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在进程间传递文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> CONTROL_LEN = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送文件描述符，fd参数为UNIX域socket, fd_to_send即待发送的文件描述符*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd_to_send)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> <span class="title">cm</span>;</span></span><br><span class="line">    cm.cmsg_len = CONTROL_LEN;</span><br><span class="line">    cm.cmsg_level = SOL_SOCKET;</span><br><span class="line">    cm.cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *(<span class="type">int</span>*)CMSG_DATA(&amp;cm) = fd_to_send;</span><br><span class="line">    msg.msg_control = &amp;cm;              <span class="comment">//设置辅助数据</span></span><br><span class="line">    msg.msg_controllen = CONTROL_LEN;</span><br><span class="line"></span><br><span class="line">    sendmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*接收目标文件描述符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recv_fd</span><span class="params">(<span class="type">int</span> fd)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> =</span> cm;</span><br><span class="line">    msg.msg_control = &amp;cm;</span><br><span class="line">    msg.msg_controllen = CONTROL_LEN;</span><br><span class="line"></span><br><span class="line">    recvmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> fd_to_read = *(<span class="type">int</span>*)CMSG_DATA(&amp;cm);</span><br><span class="line">    <span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fd_to_pass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*创建父子进程间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket*/</span></span><br><span class="line">    <span class="type">int</span> ret = socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, pipefd);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    assert(pid &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        fd_to_pass = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果打开失败，则将标准输入文件描述符发送到父进程</span></span><br><span class="line">        send_fd(pipefd[<span class="number">1</span>], (fd_to_pass &gt; <span class="number">0</span>) ? fd_to_pass : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        close(fd_to_pass);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    fd_to_pass = recv_fd(pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span>);</span><br><span class="line">    read(fd_to_pass, buf, <span class="number">1024</span>);    <span class="comment">/*读取目标文件，验证有效性*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I got fd %d and data %s\n&quot;</span>, fd_to_pass, buf);</span><br><span class="line">    close(fd_to_pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第14章-多线程编程"><a href="#第14章-多线程编程" class="headerlink" title="第14章 多线程编程"></a>第14章 多线程编程</h3><ol>
<li>创建线程和结束线程</li>
<li>读取和设置线程属性</li>
<li>POSIX线程同步方式：POSIX信号量，互斥锁和条件变量</li>
</ol>
<h4 id="14-1-Linux线程概述"><a href="#14-1-Linux线程概述" class="headerlink" title="14.1 Linux线程概述"></a>14.1 Linux线程概述</h4><p><strong>a) 线程模型</strong></p>
<p>线程分为内核线程和用户线程。它们的关系相当于，内核线程是用户线程的”容器”，当进程的一个内核线程获得CPU的使用权时，它就加载并允许一个用户线程。一个进程可以拥有M个内核线程和N个用户线程，M&lt;&#x3D;N。按照M:N的取值分为三种模式：完全在用户空间实现，完全由内核调度，双层调度。</p>
<p><strong>b) Linux线程库</strong></p>
<p>Linux上两个有名的线程库LinuxThreads和NPTL。现代Linux默认使用的是NPTL。用如下命令查看:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getconf GNU_LIBPTHREAD_VERSION</span><br></pre></td></tr></table></figure>

<p>LinuxThreads的内核线程是用clone系统调用创建的进程模拟的。因为是模拟的，所以导致了很多语义问题。另一个特性是，其引入了所谓的管理线程，专门用于管理其他工作线程的线程。管理线程的引入，增加了额外的系统开销，并且由于它只能运行在一个CPU上，所以LinuxThreads线程库也不能充分利用多处理器系统的优势。</p>
<p>因此Linux内核从2.6版本开始，提供真正的内核线程。新的NPTL线程库应运而生，其优势：</p>
<ol>
<li>内核线程不再是一个进程，避免了很多进程模拟线程的语义问题。</li>
<li>摒弃了管理线程，终止线程丶回收线程堆栈工作由内核完成。</li>
<li>由于不存在管理线程，同一个进程的线程可以运行在不同CPU上。</li>
<li>线程的同步由内核来完成，隶属于不同进程的线程之间也能共享互斥锁。</li>
</ol>
<h4 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h4><p><strong>a) pthread_create</strong></p>
<p>创建一个线程的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>thread参数即线程ID，其类型定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/pthreadtype.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">pthread_t</span>;</span><br></pre></td></tr></table></figure>

<p>attr参数设置线程的属性，NULL标识默认，后面讨论。</p>
<p>start_routine和arg分别指定线程函数和其参数。</p>
<p><strong>b) pthread_exit</strong></p>
<p>线程函数结束时最好调用如下函数，以确保安全，干净地退出:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<p>retval参数向线程的回收者传递其退出信息。该函数永远不会失败。</p>
<p><strong>c) pthread_join</strong></p>
<p>回收线程，类似于wait和waitpid系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<p>retval是目标线程退出返回的退出信息。</p>
<p>可能引发的错误码表如下：</p>
<p><img src="/./../pic/image-20230511150242783.png" alt="image-20230511150242783"></p>
<p><strong>d) pthread_cancel</strong></p>
<p>异常终止一个线程，即取消线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>接收到取消请求的目标线程可以决定似乎否被取消以及如何取消，通过如下两个函数完成:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<p>state的可选值如下：</p>
<ol>
<li>PTHREAD_CANCEL_ENABLE，允许线程被取消。默认状态。</li>
<li>PTHREAD_CANCEL_DISABLE，将取消请求挂起，直到线程允许取消。</li>
</ol>
<p>type的可选值如下:</p>
<ol>
<li>PTHREAD_CANCEL_ASYNCHROUNOUS，线程随时可以被取消。</li>
<li>PTHREAD_CANCEL_DEFERRED，允许目标线程推迟行动，直到它调用了所谓的取消点函数。</li>
</ol>
<p>取消点函数如：pthread_join，pthread_testcancel，pthread_cond_wati，pthread_cond_timewati，sem_wati和sigwait。</p>
<h4 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h4><p>pthread_attr_t结构体定义了一套完整的线程属性，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZEOF_PTHREAD_ATTR_T 36</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<p>线程库定义了一系列函数来操作pthread_attr_t类型的变量，以设置&#x2F;获取线程属性。</p>
<p><img src="/./../pic/image-20230511151041735.png" alt="image-20230511151041735"></p>
<p><img src="/./../pic/image-20230511151048296.png" alt="image-20230511151048296"></p>
<p>含义如下：</p>
<ol>
<li>detachstate，设置线程分离，即手动调用pthread_join回收，还是线程自行释放。</li>
<li>stackaddr和stacksize，手动设置线程堆栈的起始地址和大小。</li>
<li>guardsize，保护区域大小。</li>
<li>schedparam，线程调度参数，表示线程的运行优先级。</li>
<li>schedpolicy，线程调度策略，三个可选值：SCHED_FIFO,SCHED_RR和SCHED_OTHREAD，other默认值，rr表示轮转算法，fifo表示先进先出调度。</li>
<li>inheritsched，是否继承调用线程的调度属性。</li>
<li>scope，线程间竞争CPU的范围，即线程优先级的有效范围，Linux仅支持PTHREAD_SCOPE_SYSTEM，即表示与系统中所有线程竞争CPU。</li>
</ol>
<h4 id="14-4-POSIX信号量"><a href="#14-4-POSIX信号量" class="headerlink" title="14.4 POSIX信号量"></a>14.4 POSIX信号量</h4><p>如下5个:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>seminit用于初始化一个未命名的信号量；pshared指定信号量的类型，如果为0，表示是当前进程的局部信号量，否则可以在多个进程之间共享；value指定初始值。</p>
<p>sem_destroy用于销毁信号量。</p>
<p>sem_wati和sem_trywait对信号量执行减1操作，即p操作。</p>
<p>post将值加1，如果值大于0，唤醒其他等待信号量的线程，即v操作。</p>
<h4 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h4><p>类似于一个二进制信号量，lock相当于p操作，unlock相当于v操作</p>
<p><strong>a) 互斥锁基础API</strong></p>
<p>如下5个:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>mutex指定要操作的目标互斥锁，类型是pthread_mutex_t 结构体。</p>
<p>init初始化互斥锁，mutexattr指定互斥锁属性，后面讨论，NULL表示默认。还可以用如下方式初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITALIZER;</span><br></pre></td></tr></table></figure>

<p>destroy销毁互斥锁。</p>
<p>lock加锁，即p操作。</p>
<p>unlock解锁，即v操作。</p>
<p><strong>b) 互斥锁属性</strong></p>
<p>线程库提供了如下函数，来操作pthread_mutexattr_t 类型的变量，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">/*初始化互斥锁属性对象*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*销毁互斥锁属性对象*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="comment">/*获取和设置互斥锁的pshared属性*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_getshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">/*获取和设置type属性*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>

<p>本书只讨论两种常用属性：pshared和type。</p>
<p>pshared指定是否允许跨进程共享互斥锁，可选值如下：</p>
<ol>
<li>PTHREAD_PROCESS_SHARED，可以被跨进程。</li>
<li>PTHREAD_PROCESS_PRIVATE，不行。</li>
</ol>
<p>type指定互斥锁的类型，如下：</p>
<ol>
<li>PTHREAD_MUTEX_NORMAL，普通锁。问题可能导致死锁。</li>
<li>PTHREAD_MUTEX_ERRORCHECK，检错锁。多次对同一个锁加锁，返回EDEADLK，对一个以及被其他线程加锁的检错所解锁，或者对一个解锁的锁再次解锁，返回EPERM。</li>
<li>PTHREAD_MUTEX_RECURSIVE，嵌套所。允许多次加锁而不死锁，但解锁也需要执行对应次数的解锁操作。对一个其他线程加锁的嵌套锁解锁，或对以解锁的解锁，返回EPERM。</li>
<li>PTHREAD_MUTEX_DEFAULT，默认锁。</li>
</ol>
<p><strong>c) 死锁举例</strong></p>
<p>死锁会导致一个或多个线程被挂起无法继续执行，即一个线程中多次加锁会导致死锁，可能发生于设计不够仔细的递归函数。以及，两个线程按照不同的顺序来申请两个互斥锁，也容易产生死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">another</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, got mutex b, waiting for mutex a\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">    b+=a++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, got mutex a, waiting for mutex b\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    ++a;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">    a+=b++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex_a);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h4><p>条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。</p>
<p>相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *cond_attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>init函数用来初始化，还可以使用如下方式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>



<h4 id="14-7-线程同步机制包装类"><a href="#14-7-线程同步机制包装类" class="headerlink" title="14.7 线程同步机制包装类"></a>14.7 线程同步机制包装类</h4><p>将3个线程同步机制分别封装成3个类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号量*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    sem() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sem_init(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~sem()</span><br><span class="line">    &#123;</span><br><span class="line">        sem_destroy(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">wait</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sem_wait(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">post</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sem_post(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*互斥锁*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    locker()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~locker()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">unlock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*条件变量*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    cond()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pthread_cond_init(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">            throw <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~cond()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">wait</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">        ret = pthread_cond_wait(&amp;m_cond, m_mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">signal</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_signal(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>;</span></span><br></pre></td></tr></table></figure>



<h4 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h4><p><strong>a) 可重入函数</strong></p>
<p>如果一个函数能够被多个线程同时调用且不发生竞态条件，则称之为线程安全的，或者说可重入函数。Linux对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本是在原函数名尾部加上_r。在多线程程序中调用库函数，一定要使用其可重入版本。</p>
<p><strong>b) 线程和进程</strong></p>
<p>一个多线程程序的某个线程调用fork函数，先创建的子进程不会自动创建和父进程相同数量的线程。但他会自动鸡翅父进程中互斥锁的状态，由此可能导致，自己才能不清楚锁的具体状态，从而再次加锁导致死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在多进程程序中调用fork函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程函数，先获得互斥锁，等待5s，释放互斥锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">another</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    pthread_create(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;in the child, want to get the lock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not run to here\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread提供了一个专门的函数pthread_atfork，确保fork调用后父子进程都有一个清除的锁状态，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_atfork</span><span class="params">(<span class="type">void</span> (*prepare)(<span class="type">void</span>), <span class="type">void</span>(*parent)(<span class="type">void</span>), <span class="type">void</span>(*child)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>通过三个句柄来帮助清理互斥锁的状态。prepare句柄在fork调用创建出子进程之前被执行，用来锁住父进程中的互斥锁。parent句柄则是fork调用创建子进程之后，fork返回之前在父进程中执行，释放prepare中锁住的互斥锁。child句柄在fork返回前，在子进程中执行，释放prepare中锁住的互斥锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prepare</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">infork</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_atfork(prepare, infork, infork);</span><br></pre></td></tr></table></figure>

<p>在fork调用前加入如上代码，即可正常工作。</p>
<p><strong>c) 线程和信号</strong></p>
<p>每个线程都可以独立地设置信号掩码，在多线程环境中应该使用如下的pthread版本的sigprocmask函数来设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *newmask, <span class="type">sigset_t</span> *oldmask)</span>;</span><br></pre></td></tr></table></figure>

<p>参数和sigprocmask完全相同。</p>
<p>定义一个专门的线程来处理所有的信号，如下两个步骤:</p>
<ol>
<li><p>主线程创建其他子线程之前就调用pthread_sigmask设置好信号掩码，所有新创建的子线程将自动继承这个信号掩码。这样，所有线程都不会响应被屏蔽的信号了。</p>
</li>
<li><p>在某个线程中调用如下函数来等待信号并处理之。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> *sig)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用一个线程处理所有信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error_en(en, msg) \</span></span><br><span class="line"><span class="meta">    do &#123;errno = en; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sig_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> *<span class="built_in">set</span> = (<span class="type">sigset_t</span>*)arg;</span><br><span class="line">    <span class="type">int</span> s, sig;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//等待信号</span></span><br><span class="line">        s = sigwait(<span class="built_in">set</span>, &amp;sig);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            handle_error_en(s, <span class="string">&quot;sigwait&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;signal handling thread got signal %d\n&quot;</span>, sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置信号掩码</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGUSR1);</span><br><span class="line">    s = pthread_sigmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        handle_error_en(s, <span class="string">&quot;pthread_sigmask&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thread, <span class="literal">NULL</span>, &amp;sig_thread, (<span class="type">void</span>*)&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        handle_error_en(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread还提供了下面的方法，可以明确地将一个信号发送给指定的线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="第17章-系统检测工具"><a href="#第17章-系统检测工具" class="headerlink" title="第17章 系统检测工具"></a>第17章 系统检测工具</h4><p>讨论几个常用工具：tcpdump，nc，strace，lsof，vmstat，ifstat和mpstat</p>
<h4 id="17-1-tcpdump"><a href="#17-1-tcpdump" class="headerlink" title="17.1 tcpdump"></a>17.1 tcpdump</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AuroraFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/">http://example.com/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Aurora</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/cat1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/17/UNP%20note/"><img class="next-cover" src="/./img/cat8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UNP 学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/headd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AuroraFish</div><div class="author-info__description">保持幻想</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AuroraFish"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AuroraFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:205878047@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只是睡着了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux高性能服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-TCP-x2F-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">第1章 TCP&#x2F;IP 协议族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.1 TCP&#x2F;IP协议族体系结构以及主要协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B0%81%E8%A3%85"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">1.2 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%88%86%E7%94%A8"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">1.3 分用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">1.4 测试网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-ARP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">1.5 ARP协议工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-DNS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">1.6 DNS工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-socket-%E5%92%8C-TCP-x2F-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">1.7 socket 和 TCP&#x2F;IP 协议族的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.0.2.</span> <span class="toc-text">第2章 IP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-IP%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">2.1 IP服务的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-IPV4%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2.2 IPV4头部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-IP%E5%88%86%E7%89%87"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">2.3 IP分片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-IP%E8%B7%AF%E7%94%B1"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">2.4 IP路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-IP%E8%BD%AC%E5%8F%91"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">2.5 IP转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">2.6 重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-IPV6%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">2.7 IPV6头部结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.0.3.</span> <span class="toc-text">第3章 TCP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-TCP%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">3.1 TCP服务的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-TCP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">3.2 TCP头部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3.3 TCP连接的建立和关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">3.4 TCP状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%A4%8D%E4%BD%8D%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">3.5 复位报文段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-TCP%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">3.6 TCP交互数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-TCP%E6%88%90%E5%9D%97%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">3.7 TCP成块数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">3.8 带外数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">1.0.3.9.</span> <span class="toc-text">3.9 TCP超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.3.10.</span> <span class="toc-text">3.10 拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-TCP-x2F-IP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%BF%E9%97%AEInternet%E4%B8%8A%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">第4章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%A4%BA%E4%BE%8B%E6%80%BB%E5%9B%BE"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">4.1 示例总图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">4.2 部署代理服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8F%96%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">4.3 使用tcpdump抓取传输的数据包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E8%AE%BF%E9%97%AEDNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">4.4 访问DNS服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E6%9C%AC%E5%9C%B0%E5%90%8D%E7%A7%B0%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">4.5 本地名称查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-HTTP%E9%80%9A%E4%BF%A1"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">4.6 HTTP通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API"><span class="toc-number">1.0.5.</span> <span class="toc-text">第5章 Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-socket%E5%9C%B0%E5%9D%80API"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">5.1 socket地址API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BAsocket"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">5.2 创建socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%91%BD%E5%90%8Dsocket"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">5.3 命名socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E7%9B%91%E5%90%ACsocket"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">5.4 监听socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">5.5 接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">5.6 发起连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">5.7 关闭连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">1.0.5.8.</span> <span class="toc-text">5.8 数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="toc-number">1.0.5.9.</span> <span class="toc-text">5.9 带外标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.5.10.</span> <span class="toc-text">5.10 地址信息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-socket%E9%80%89%E9%A1%B9"><span class="toc-number">1.0.5.11.</span> <span class="toc-text">5.11 socket选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12-%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="toc-number">1.0.5.12.</span> <span class="toc-text">5.12 网络信息API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%AB%98%E7%BA%A7I-x2F-O%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.</span> <span class="toc-text">第6章 高级I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-pipe%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">6.1 pipe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-dup%E5%87%BD%E6%95%B0%E5%92%8Cdup2%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">6.2 dup函数和dup2函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-readv%E5%87%BD%E6%95%B0%E5%92%8Cwritev%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">6.3 readv函数和writev函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-sendfile%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">6.4 sendfile函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-mmap%E5%87%BD%E6%95%B0%E5%92%8Cmunmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">6.5 mmap函数和munmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-splice%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">6.6 splice函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-tee%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.7.</span> <span class="toc-text">6.7 tee函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.8.</span> <span class="toc-text">6.8 fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="toc-number">1.0.7.</span> <span class="toc-text">第7章 Linux服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%97%A5%E5%BF%97"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">7.1 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">7.2 用户信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">7.3 进程间关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">7.4 系统资源限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">7.5 改变工作目录和根目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="toc-number">1.0.7.6.</span> <span class="toc-text">7.6 服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.0.8.</span> <span class="toc-text">第8章 高性能服务器程序框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">8.1 服务器模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">8.2 服务器编程框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">8.3 I&#x2F;O模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">8.4 两种高效的事件处理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">8.5 两种高效的并发模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.0.8.6.</span> <span class="toc-text">8.6 有限状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.0.8.7.</span> <span class="toc-text">8.7 提高服务器性能的其他建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-I-x2F-O%E5%A4%8D%E7%94%A8"><span class="toc-number">1.0.9.</span> <span class="toc-text">第9章 I&#x2F;O复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">9.1 select系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-poll%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">9.2 poll系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-epoll%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">9.3 epoll系列系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E4%B8%89%E7%BB%84I-x2F-O%E5%A4%8D%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.9.4.</span> <span class="toc-text">9.4 三组I&#x2F;O复用函数的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-I-x2F-O%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%80-%E9%9D%9E%E9%98%BB%E5%A1%9Econnect"><span class="toc-number">1.0.9.5.</span> <span class="toc-text">9.5 I&#x2F;O复用的高级应用一: 非阻塞connect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-I-x2F-O%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%BA%8C-%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.9.6.</span> <span class="toc-text">9.6 I&#x2F;O复用的高级应用二: 聊天室程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7-I-x2F-O%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%89-%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86TCP%E5%92%8CUDP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.0.9.7.</span> <span class="toc-text">9.7 I&#x2F;O复用的高级应用三: 同时处理TCP和UDP服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-%E8%B6%85%E7%BA%A7%E6%9C%8D%E5%8A%A1xinetd"><span class="toc-number">1.0.9.8.</span> <span class="toc-text">9.8 超级服务xinetd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.10.</span> <span class="toc-text">第10章 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-Linux%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">10.1 Linux信号概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E4%BF%A1%E5%8F%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.10.2.</span> <span class="toc-text">10.2 信号函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">1.0.10.3.</span> <span class="toc-text">10.3 信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E7%BB%9F%E4%B8%80%E4%BA%8B%E4%BB%B6%E6%BA%90"><span class="toc-number">1.0.10.4.</span> <span class="toc-text">10.4 统一事件源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.10.5.</span> <span class="toc-text">10.5 网络编程相关信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.0.11.</span> <span class="toc-text">第11章 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-socket%E9%80%89%E9%A1%B9SO-RCVTIMEO%E5%92%8CSO-SNDTIMEO"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">11.1 socket选项SO_RCVTIMEO和SO_SNDTIMEO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-SIGALRM%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.11.2.</span> <span class="toc-text">11.2 SIGALRM信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-I-x2F-O%E5%A4%8D%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%B6%85%E6%97%B6%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.11.3.</span> <span class="toc-text">11.3 I&#x2F;O复用系统调用的超时参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.0.11.4.</span> <span class="toc-text">11.4 高性能定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BDI-x2F-O%E6%A1%86%E6%9E%B6%E5%BA%93Libevent"><span class="toc-number">1.0.12.</span> <span class="toc-text">第12章 高性能I&#x2F;O框架库Libevent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-I-x2F-O%E6%A1%86%E6%9E%B6%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">12.1 I&#x2F;O框架库概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">12.2 Libevent源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.0.13.</span> <span class="toc-text">第13章 多进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-fork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.13.1.</span> <span class="toc-text">13.1 fork系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-exec%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.13.2.</span> <span class="toc-text">13.2 exec系列系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.13.3.</span> <span class="toc-text">13.3 处理僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-%E7%AE%A1%E9%81%93"><span class="toc-number">1.0.13.4.</span> <span class="toc-text">13.4 管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.0.13.5.</span> <span class="toc-text">13.5 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">1.0.13.6.</span> <span class="toc-text">13.6 共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.0.13.7.</span> <span class="toc-text">13.7 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-IPC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.13.8.</span> <span class="toc-text">13.8 IPC命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-9-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.0.13.9.</span> <span class="toc-text">13.9 在进程间传递文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.0.14.</span> <span class="toc-text">第14章 多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.14.1.</span> <span class="toc-text">14.1 Linux线程概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.0.14.2.</span> <span class="toc-text">14.2 创建线程和结束线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.0.14.3.</span> <span class="toc-text">14.3 线程属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.0.14.4.</span> <span class="toc-text">14.4 POSIX信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.0.14.5.</span> <span class="toc-text">14.5 互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.14.6.</span> <span class="toc-text">14.6 条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.0.14.7.</span> <span class="toc-text">14.7 线程同步机制包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.0.14.8.</span> <span class="toc-text">14.8 多线程环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.14.9.</span> <span class="toc-text">第17章 系统检测工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-tcpdump"><span class="toc-number">1.0.14.10.</span> <span class="toc-text">17.1 tcpdump</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记"><img src="/./img/cat1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器笔记"/></a><div class="content"><a class="title" href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记">Linux高性能服务器笔记</a><time datetime="2023-04-21T10:38:55.000Z" title="发表于 2023-04-21 18:38:55">2023-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记"><img src="/./img/cat8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UNP 学习笔记"/></a><div class="content"><a class="title" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记">UNP 学习笔记</a><time datetime="2023-03-17T09:38:55.000Z" title="发表于 2023-03-17 17:38:55">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="APUE 学习笔记"/></a><div class="content"><a class="title" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记">APUE 学习笔记</a><time datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记note2"/></a><div class="content"><a class="title" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2">算法笔记note2</a><time datetime="2022-05-05T10:48:47.000Z" title="发表于 2022-05-05 18:48:47">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记题目"/></a><div class="content"><a class="title" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目">算法笔记题目</a><time datetime="2022-04-19T06:35:55.000Z" title="发表于 2022-04-19 14:35:55">2022-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: 颜色(white)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By AuroraFish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">饿死了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>