<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux高性能服务器笔记 | Aurora</title><meta name="author" content="AuroraFish"><meta name="copyright" content="AuroraFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频和书籍的一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器笔记">
<meta property="og:url" content="http://example.com/2022/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="视频和书籍的一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/arch.png">
<meta property="article:published_time" content="2022-11-07T01:38:55.000Z">
<meta property="article:modified_time" content="2023-04-26T12:18:58.938Z">
<meta property="article:author" content="AuroraFish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/arch.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux高性能服务器笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 20:18:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/headd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/arch.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aurora</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux高性能服务器笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-07T01:38:55.000Z" title="发表于 2022-11-07 09:38:55">2022-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-26T12:18:58.938Z" title="更新于 2023-04-26 20:18:58">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux高性能服务器笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux高性能服务器编程"><a href="#Linux高性能服务器编程" class="headerlink" title="Linux高性能服务器编程"></a>Linux高性能服务器编程</h1><h3 id="第1章-TCP-x2F-IP-协议族"><a href="#第1章-TCP-x2F-IP-协议族" class="headerlink" title="第1章 TCP&#x2F;IP 协议族"></a>第1章 TCP&#x2F;IP 协议族</h3><p>Internet使用的主流协议族是TCP&#x2F;IP协议族，它是一个分层，多协议的通信体系。本章简单介绍其中几个相关协议: ICMP协议，ARP协议和DNS协议。</p>
<h4 id="1-1-TCP-x2F-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-x2F-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP&#x2F;IP协议族体系结构以及主要协议"></a>1.1 TCP&#x2F;IP协议族体系结构以及主要协议</h4><p>四层模型，数据链路层，网络层，传输层和应用层。</p>
<p><img src="/./../pic/image-20230411201351158.png" alt="image-20230411201351158"></p>
<p><strong>a) 数据链路层</strong></p>
<p>实现了网卡接口的网络驱动程序，以处理数据在物理媒介上的传输。隐藏了不同物理网络的细节，为上层协议提供一个统一的接口。</p>
<p>该层的两个常用协议，ARP协议 <strong>(Address Resolve Protocol, 地址解析协议)</strong> 和 RARP协议 <strong>(Reverse Address Resolve Protocol, 逆地址解析协议)</strong> 。实现了IP地址和机器物理地址之间的相互转换。</p>
<p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，网络层需要先将目标机器的IP地址转换成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。</p>
<p><strong>b) 网络层</strong></p>
<p>网络层实现数据包的选路和转发。WAN <strong>(Wide Area Network, 广域网)</strong> 使用众多分级的路由器来连接分散的主机或 LAN**(Local Area Network, 局域网)**。两台主机一般不是直接相连的，而是通过多个中间节点(路由器)连接的。网络层的任务就是选择这些中间节点。网络层对上层细节隐藏这些细节，在上层看来，通信的双方是直接相连的。</p>
<p>网络层最核心的协议，IP协议 **(Internet Protocol, 因特网协议)**。IP协议根据数据包的目的IP地址来决定如何投递他。如果不能直接发送给目标主机，IP协议为它寻找一个合适的下一跳路由器，并将数据包交给路由器来转发，多次重复这一过程。</p>
<p>另一个重要协议，ICMP协议 **(Internet Control Message Protocol, 因特网控制报文协议)**。它是IP协议的重要补充，主要用于检测网络连接。</p>
<p><img src="/./../pic/image-20230411202547785.png" alt="image-20230411202547785"></p>
<p> 8位类型用于区分报文类型。比如目标不可达(类型值为3)，重定向(类型值为5)，目标是否可达(类型值为8)  8位代码进一步细分不同条件。16位检验和字段对整个报文进行循环冗余校验，以检验报文在传输过程中是否损坏。</p>
<p><strong>c) 传输层</strong></p>
<p>传输层位两台主机提供端到端的通信。简单来说不考虑IP协议的中转过程了，这些也在网络层中向上隐藏细节了。下图实线箭头表示协议族各层中之间的实体通信，水平虚线表示逻辑通信线路。</p>
<p><img src="/./../pic/image-20230411203044141.png" alt="image-20230411203044141"></p>
<p>传输层主要有三个协议：TCP协议，UDP协议，SCTP协议。本书不讨论SCTP协议，TCP和UDP协议在UNP中已经比较熟悉了。</p>
<p><strong>d) 应用层</strong></p>
<p>应用层负责处理应用程序的逻辑。前面的三个层处理网络通信细节，这部分稳定高效，因此它们在内核空间中实现。而应用层则在用户空间中实现。</p>
<p>应用层协议很多，图1-1中列举了其中几个：</p>
<ol>
<li>ping是应用程序，不是协议，他利用ICMP报文检测网络连接。</li>
<li>telnet协议是一种远程登陆协议，它使我们能在本地完成远程任务。</li>
<li>OSPF <strong>(Open Shortest Path First, 开放最短路径优先)</strong> 协议是一种动态路由更新协议。</li>
<li>DNS <strong>(Domain Name Service, 域名服务)</strong> 协议提供机器域名到IP地址的转换。</li>
</ol>
<h4 id="1-2-封装"><a href="#1-2-封装" class="headerlink" title="1.2 封装"></a>1.2 封装</h4><p>程序数据在发送到物理网络上之前，将沿着协议栈从上往下传递。每层协议都将在上层数据的基础上加上自己的头部信息，以实现该层的功能呢，这个过程称为封装。</p>
<p><img src="/./../pic/image-20230411203812250.png" alt="image-20230411203812250"></p>
<p>就跟套娃差不多 ( </p>
<p><img src="/./../pic/image-20230411203845768.png" alt="image-20230411203845768"></p>
<p>程序数据到 -&gt; TCP&#x2F;UDP报文段 -&gt; IP数据报 -&gt; 以太网帧</p>
<p>经过数据链路层封装的数据称为帧。传输媒介不同，帧的类型也不同。比如以太网上传输的是以太网帧，而令牌环网络上传输的是令牌环帧。以太网帧的封装格式如下图。类型字段后面讨论，4字节CRC字段对帧的其他部分提供循环冗余校验。</p>
<p><img src="/./../pic/image-20230411204210578.png" alt="image-20230411204210578"></p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h4 id="1-3-分用"><a href="#1-3-分用" class="headerlink" title="1.3 分用"></a>1.3 分用</h4><p>帧到达目的主机后，将沿着协议族自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用。分用时依靠头部信息中的类型字段实现的。</p>
<p><img src="/./../pic/image-20230411204426616.png" alt="image-20230411204426616"></p>
<p>比如拿以太网帧举例说，如果类型字段值为0x800，则帧的数据部分为IP数据报，以太网驱动程序将帧交给IP模块处理；若类型字段值为0X806，则帧的数据部分为ARP请求或应答报文，交给ARP模块来处理；0X835则，RAPA请求或应答，则交给RAPA模块。IP的protocol和TCP&#x2F;UDP的端口号同理。</p>
<h4 id="1-4-测试网络"><a href="#1-4-测试网络" class="headerlink" title="1.4 测试网络"></a>1.4 测试网络</h4><p>本书实验所用的测试网络。作者编写的多个客户端，服务器程序都是使用该网络来调试和测试的。</p>
<p><img src="/./../pic/image-20230411204808044.png" alt="image-20230411204808044"></p>
<h4 id="1-5-ARP协议工作原理"><a href="#1-5-ARP协议工作原理" class="headerlink" title="1.5 ARP协议工作原理"></a>1.5 ARP协议工作原理</h4><p>ARP协议能实现任意网络层地址到任意物理地址的转换。其工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>
<p><strong>a) 以太网ARP请求&#x2F;应答报文详解</strong></p>
<p><img src="/./../pic/image-20230411210424754.png" alt="image-20230411210424754"></p>
<p>每个字段的具体值介绍见p9</p>
<p>ARP请求&#x2F;应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节，则一个携带ARP请求&#x2F;应答报文的以太网帧长度为46字节。</p>
<p><strong>b) ARP高速缓存的查看和修改</strong></p>
<p>通常ARP维护一个高速缓存，其中包含经常访问(比如网关地址)或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。</p>
<p>Linxu下可使用arp命令来查看和修改ARP高速缓存，比如ernest-laptop(作者测试网络中的主机)某一时刻的ARP缓存内容如下(使用arp-a命令):</p>
<p><img src="/./../pic/image-20230411210918667.png" alt="image-20230411210918667"></p>
<p>第一项描述的是另一台测试机器Kongming20，第二项描述的是路由器。下面两条命令分别删除和添加一个ARP缓存项：</p>
<p><img src="/./../pic/image-20230411211041828.png" alt="image-20230411211041828"></p>
<p><strong>c) 使用tcpdump观察ARP通信过程</strong></p>
<p>在ernest-laptop上执行telnet命令登录Kongming20的echo服务，并用tcpdump抓取这个过程中两台测试机器之间交换的以太网帧。具体操作如下:</p>
<p><img src="/./../pic/image-20230411211320139.png" alt="image-20230411211320139"></p>
<p>在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行。ARP通信在TCP连接建立之前就已经完成，我们不关心telnet中的内容，在它建立连接成功后就可以退出。tcpdump中抓取的众多数据包中，只有最靠前的两个和ARP通信有关，将其列出:</p>
<p><img src="/./../pic/image-20230411211535303.png" alt="image-20230411211535303"></p>
<p>第一个数据包，依次看过去，源地址:00:16:d3:5c:b9:e3，目的地址:ff:ff:ff:ff:ff:ff 这是以太网的广播地址，即表示整个LAN，0x0806以太网帧头部类型字段的值 表示ARP模块，长度为42字节；数据部分长度28字节，”Request”表示这是一个ARP请求，”who-has”表示查询对应IP地址。第二个数据包同理</p>
<p> <img src="/./../pic/image-20230411212225324.png" alt="image-20230411212225324"></p>
<p>ARP请求和应答实际是从以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上，所以用虚线表示。路由器也将接到以太网帧1，因为该帧是一个广播帧。</p>
<h4 id="1-6-DNS工作原理"><a href="#1-6-DNS工作原理" class="headerlink" title="1.6 DNS工作原理"></a>1.6 DNS工作原理</h4><p>我们通常使用机器的域名来访问这台机器，而不直接使用IP地址。如何将机器的域名转换成IP地址，这就需要用到域名查询服务。有很多种实现方式，比如NIS **(Network Information Service, 网络信息服务)**，DNS和本地静态文件，本节主要讨论DNS</p>
<p><strong>a) DNS查询和应答报文详解</strong></p>
<p>DNS是一套分布式的域名服务系统。每个DNS服务器上存放着大量的机器名和IP地址的映射，并且动态更新的。众多网络客户端使用DNS协议来向DNS服务器查询目标主机的IP地址。DNS查询和应答报文格式如下</p>
<p><img src="/./../pic/image-20230411220825883.png" alt="image-20230411220825883"></p>
<p>具体字段分析，见p13</p>
<p><strong>b) Linux下访问DNS服务</strong></p>
<p>我们要访问DNS服务，必须先直到DNS服务器的IP地址。Linux使用&#x2F;etc&#x2F;resolvconf文件来存放DNS服务器的IP地址，内容如下</p>
<p><img src="/./../pic/image-20230411221008256.png" alt="image-20230411221008256"></p>
<p>Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器<a href="http://www.baidu.com的IP地址：">www.baidu.com的IP地址：</a></p>
<p><img src="/./../pic/image-20230411221126395.png" alt="image-20230411221126395"></p>
<p><strong>c) 使用tcpdump观察DNS通信过程</strong></p>
<p>下面将在ernest-laptop上运行host命令，查询，并使用tcpdump抓取这一过程中的LAN上传输的以太网帧。</p>
<p><img src="/./../pic/image-20230411221251555.png" alt="image-20230411221251555"></p>
<p>使用port domain来过滤数据包，表示只抓取使用domain服务的数据包，输出如下：</p>
<p><img src="/./../pic/image-20230411221334836.png" alt="image-20230411221334836"></p>
<p>第一个数据包中，数值57428是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。”+”表示启用递归查询标志，”A?”表示使用A类型的查询方式。”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;则是dns查询问题中的查询名,括号中的数值31是dns查询报文的长度/">www.baidu.com&quot;则是DNS查询问题中的查询名，括号中的数值31是DNS查询报文的长度</a></p>
<p>第二个数据包中，”3&#x2F;4&#x2F;4”表示该报文中包含3个应答资源记录，4个授权资源记录和4个额外信息记录。”CNAME<a target="_blank" rel="noopener" href="http://www.baidu.com,/">www.baidu.com，</a> A 119.75.218.77, A 119.75.217.56”则表示3个应答资源记录的内容，其中CNAME表示机器别名，A表示的记录是IP地址，长度为226字节</p>
<h4 id="1-7-socket-和-TCP-x2F-IP-协议族的关系"><a href="#1-7-socket-和-TCP-x2F-IP-协议族的关系" class="headerlink" title="1.7 socket 和 TCP&#x2F;IP 协议族的关系"></a>1.7 socket 和 TCP&#x2F;IP 协议族的关系</h4><p>数据链路层，网络层，传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API主要有两套：socket和XTI。本书仅讨论socket。</p>
<h3 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h3><p>IP协议是TCP&#x2F;IP的核心协议，也是socket网络编程的基础之一。本章从IP头部信息和IP数据报的路由和转发两个方向深入探讨IP协议。</p>
<h4 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h4><p>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态，无连接，不可靠的服务。</p>
<p>无状态是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送，传输和接收都是相互独立，没有上下文关系的。这种的服务的最大缺点是无法处理乱序和重复的IP数据报，优点是简单，高效。</p>
<p>无连接是指IP通信双方都不长久地维持对方的任何信息，每次上层协议发送数据时，都必须明确指定对方的IP地址。</p>
<p>不可靠是指IP协议不能保证IP数据报准确地到达接收端。</p>
<h4 id="2-2-IPV4头部结构"><a href="#2-2-IPV4头部结构" class="headerlink" title="2.2 IPV4头部结构"></a>2.2 IPV4头部结构</h4><p><strong>a） IPV4头部结构</strong></p>
<p><img src="/./../pic/image-20230413154701842.png" alt="image-20230413154701842"></p>
<p>4位版本号指定IP协议的版本，对于IPV4来说是4。其他IPV4协议的扩展版本则有不同版本号。</p>
<p>4位头部长度表示IP头部有多少个32bit字 <strong>(4字节)</strong> ，4位最大表示15，所以最长60字节</p>
<p>8位服务类型，包括一个3位优先权字段 **(已被忽略)**，4位的TOS字段和1位的保留字段 **(必须置0)**，4位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性，最小费用。</p>
<p>16位总长度是指整个IP数据报的长度，所以最大65535 **(2^16-1)**，但由于MTU的限制，实际上超过MTU的数据报都将被分片传输。</p>
<p>16位标识唯一地表示主机发送的每一个数据报。其初始值由系统随机生成：每发送一个数据报，其值+1。该值在数据报分片时被复制到每个分片中，因此所有分片拥有相同的标识值。</p>
<p>3位表示字段的第一位保留。第二位DF **(Don’t Fragment)**表示”禁止分片” ，第3位表示MF <strong>(More Fragment)</strong> “更多分片”。除了数据报的最后一个分片外，其它都要把它置1</p>
<p>13位分片偏移时分片相对原始IP数据报开始处的偏移。</p>
<p>8位生存时间 **(Time To Live, TTL)**，常见的值时64，每经过一个路由，该值减1。为0时，路由器丢弃数据报</p>
<p>8位协议 **(protocol)**用来区分上层协议，类似于TCP的端口，其中ICMP是1，TCP是6，UDP是17。</p>
<p>16位头部校验和，检验IP数据报头部在传输过程中是否损坏。</p>
<p>32位的源端IP地址和目的端IP地址用来表示数据报的发送端和接收端。</p>
<p>IPV4的最后一个字段是可变长的可选信息。最多包含40字节，因为前面部分已经讨论了20字节固定字节，而IP头部最长是60字节。可用的IP选项包括:</p>
<ol>
<li>记录路由，告诉数据报途径的路由器将IP地址填入头部选项部分，可用来跟踪传递路径。</li>
<li>时间戳，告诉路由器将转发时间填入，测量途径传输的时间。</li>
<li>松散源路由选择，指定一个路由器IP地址列表，数据报必须经过其中的所有路由器。</li>
<li>严格源路由选择，数据报只能经过指定的路由器。</li>
<li></li>
</ol>
<p><strong>b) 使用tcpdump观察IPV4头部结构</strong></p>
<p>使用测试机器ernest-laptop执行talnet命令登陆本机，使用tcpdump抓取这个过程中交换的数据报。</p>
<p><img src="/./../pic/image-20230413160158439.png" alt="image-20230413160158439"></p>
<p>此时观察tcpdump输出的第一个数据包</p>
<p><img src="/./../pic/image-20230413160217849.png" alt="image-20230413160217849"></p>
<p>由于是本机，所以IP地址是127.0.0.1本地回环。flags，seq，win，options位TCP头部信息，第3章讨论</p>
<p>本次抓包开启了tcpdump的-x选项，使之输出数据报的二进制码，此数据包共60字节，前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据 **(length值为0)**分析结果如下。</p>
<p><img src="/./../pic/image-20230413160422533.png" alt="image-20230413160422533"></p>
<h4 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h4><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。</p>
<p>和分片关系比较紧密的三个字段：数据报标识，标志和片偏移。每个分片都具有相同的标识值，具有不同的片偏移，且除了最后一个分片外，其他分片设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU是1500，因此它可携带的IP数据报的数据部分最多是1480字节 **(IP头部占用20字节)**。考虑用IP数据报封装一个1481的ICMP报文(包括8字节的ICMP头部)，分片如下图。</p>
<p>分片为两块，都具有自己的IP头部，且第一个分片设置了MF标志，但ICMP头部只有第一个分片有，因为IP模块重组该ICMP报文的时候只需要一份ICMP头部信息。</p>
<p><img src="/./../pic/image-20230413203130256.png" alt="image-20230413203130256"></p>
<p>ICMP报文的头部长度取决于报文的类型，其变化范围很大。图中8字节原因是后面的例子用到了ping程序，而ping程序使用的ICMP回显和应答报文的头部类型是8字节。</p>
<p>考虑从ernest-laptop来ping机器kongming20，每次发送1473字节来强制引起分片，并使用tcpdump来抓取数据包，操作如下：</p>
<p><img src="/./../pic/image-20230413203406701.png" alt="image-20230413203406701"></p>
<p>tcpdump输出的两个分片，内容如下：</p>
<p><img src="/./../pic/image-20230413203423136.png" alt="image-20230413203423136"></p>
<p>可以看出它们具有相同的标识值 61197，说明是同一个IP数据报的分片。flags [+] 说明设置了MF标志，而第二个分片不设置。片偏移不同。</p>
<h4 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h4><p>IP协议的一个核心任务是数据报的路由，即发送数据报到目标机器的路径。</p>
<p><strong>a) IP模块工作流程</strong></p>
<p><img src="/./../pic/image-20230413203645649.png" alt="image-20230413203645649"></p>
<p>当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误后就<strong>分析其头部的具体信息</strong>。</p>
<p>如果该IP数据报的头部设置了源站选路选项 <strong>(松散源路由选择或严格源路由选择)<strong>，则IP模块调用</strong>数据报转发子模块</strong>来处理该数据报。如果IP数据报的头部中目的IP地址是<strong>本机</strong>的某个IP地址，或者是广播地址，则IP模块根据数据报头部中的协议字段来决定将他<strong>派发给上层应用</strong>。如果不是发送给本机的，也交给<strong>数据报转发子模块</strong>。</p>
<p><strong>数据报转发子模块</strong>首先检测系统是否允许转发，如果不允许，IP模块将数据报丢弃。如果允许，对该数据执行一些操作，然后将他交给<strong>IP数据报输出子模块</strong></p>
<p>IP数据报应该发送至哪一个吓一跳路由，以及经过哪个网卡来发送，就是 <strong>IP路由过程</strong>，即图2-3中的<strong>计算下一条路由子模块</strong>。IP模块实现数据报路由的核心数据结构是路由表。</p>
<p>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据的IP数据报。</p>
<p>图2-3中的虚线箭头显示了路由表更新过程。</p>
<p><strong>b) 路由机制</strong></p>
<p>使用route命令或netstat命令查看路由表，测试机器上执行route内容如下：</p>
<p><img src="/./../pic/image-20230413204536175.png" alt="image-20230413204536175"></p>
<p>路由表如何按照IP地址分类？或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢？这就是IP的路由机制，分为3个步骤：</p>
<ol>
<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用该路由项，没找到则转步骤2</li>
<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(比如代码清单2-2所示的路由表中的第二项)。如果找到，就使用该路由项：没找到则转步骤3</li>
<li>选择默认路由，这通常意味着数据报的吓一跳路由是网关。</li>
</ol>
<p>因此，对于测试机器ernest-laptop而言，所有发送到IP地址为192.168.1.*的机器的IP数据报都可以直接发送到目标机器(匹配路由表第二项)，而所有访问因特网的请求都通过网关来转发(匹配默认路由项)。</p>
<p><strong>c) 路由表更新</strong></p>
<p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能够准确，高效地转发数据报。route命令可以修改路由表，如下：</p>
<p><img src="/./../pic/image-20230413205615908.png" alt="image-20230413205615908"></p>
<p>第1行标识添加主机192.168.1.109(机器Kongming20)对应的路由项。这样设置之后，所有从ernest-laptop发送到Kongming20的IP数据报将通过网卡eth0直接发送到目标机器的接收网卡。第2行标识删除网络192.168.1.0对应的路由项，这样除了机器Kongming20外，测试机器无法访问局域网上的任何其他机器。第3行标识删除默认路由项，这样做的后果是无法访问因特网。第4行标识重新设置默认路由项，不过这次其网关是机器Kongming20，修改后的路由表内容如下：</p>
<p><img src="/./../pic/image-20230413211012367.png" alt="image-20230413211012367"></p>
<p>第一个路由项是主机路由项，所以它被设置了”H”标志。设计该路由表的目的是为后文讨论ICMP重定向提供环境。</p>
<h4 id="2-5-IP转发"><a href="#2-5-IP转发" class="headerlink" title="2.5 IP转发"></a>2.5 IP转发</h4><p>前文提到，不是发送给本机的IP数据报都将由数据报转发子模块来处理。路由器能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward内核参数默认被设置为0。我们可以修改它来使能主机的数据报转发功能:</p>
<p><img src="/./../pic/image-20230413211357717.png" alt="image-20230413211357717"></p>
<p>对于允许IP数据报转发的系统，数据报转发子模块将对期望转发的数据报执行如下操作：</p>
<ol>
<li>检测数据报头部的TTL值，为0则丢弃。</li>
<li>查看数据报头部的严格选路由选择选项。如果设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</li>
<li>如果有必要，则给源端发送一个ICMP重定向报文，以告诉他更合理的吓一跳。</li>
<li>将TTL值减1</li>
<li>处理IP头部选项</li>
<li>如有必要，执行分片</li>
</ol>
<h4 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h4><p>图2-3显示了ICMP重定向报文也能用于更新路由表，简要讨论ICMP重定向</p>
<p><strong>a) ICMP重定向报文</strong></p>
<p><img src="/./../pic/image-20230413211750780.png" alt="image-20230413211750780"></p>
<p>ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本届仅讨论主机重定向，代码值为1</p>
<p>数据部分为接收方提供如下两个信息：</p>
<ol>
<li>引起重定向的IP数据报的源端IP地址</li>
<li>应该使用的路由器IP地址</li>
</ol>
<p>接收主机以此来选择应该使用的路由器，并且更新路由表</p>
<p><strong>b) 主机重定向示例</strong></p>
<p>2.4.3中将机器ernest-laptop的网关设置成了机器Kongming20，2.5节又使能了Kongming20的数据报转发功能，因此机器ernest-laptop将通过Kongming20来访问因特网，如在ernest-laptop上执行ping命令：</p>
<p><img src="/./../pic/image-20230413212310578.png" alt="image-20230413212310578"></p>
<p>Kongming20给ernest-laptop发送了一个ICMP重定向报文，告诉它通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。主机ernest-laptop收到这样的ICMP重定向报文后，更新路由表缓冲，并使用新的路由方式来发送后续数据报</p>
<p><img src="/./../pic/image-20230413212419098.png" alt="image-20230413212419098"></p>
<h4 id="2-7-IPV6头部结构"><a href="#2-7-IPV6头部结构" class="headerlink" title="2.7 IPV6头部结构"></a>2.7 IPV6头部结构</h4><p>简要讨论IPV6头部结构</p>
<p><strong>a) IPV6固定头部结构</strong></p>
<p><img src="/./../pic/image-20230413212545280.png" alt="image-20230413212545280"></p>
<p><img src="/./../pic/image-20230413212607716.png" alt="image-20230413212607716"></p>
<p><strong>b)IPV6扩展头部</strong></p>
<p>可变长的扩展头部使得IPV6可以支持更多选项，并且很便于将来的扩展需求。</p>
<p><img src="/./../pic/image-20230413212705056.png" alt="image-20230413212705056"></p>
<h3 id="第3章-TCP协议详解"><a href="#第3章-TCP协议详解" class="headerlink" title="第3章 TCP协议详解"></a>第3章 TCP协议详解</h3><p>本章主要从四个方面来讨论TCP协议：</p>
<ol>
<li>TCP头部信息</li>
<li>TCP状态转移过程</li>
<li>TCP数据流</li>
<li>TCP数据流的控制</li>
</ol>
<h4 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h4><p>TCP协议相对于UDP协议的特点是：面向连接，字节流和可靠传输。</p>
<p>TCP协议的连接是一对一的，所以基于广播和多播的应用程序，不能使用TCP服务。而无连接协议UDP非常适合广播和多播。</p>
<p>字节流指应用程序执行读操作次数和TCP模块接收到的TCP报文段之间没有固定的数量关系，由接收端&#x2F;发送端，先接收&#x2F;写到TCP发送&#x2F;接收缓冲区，再由应用程序读写；与之不同的UDP则是数据报服务，发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送只。</p>
<p><img src="/./../pic/image-20230418192544531.png" alt="image-20230418192544531"></p>
<p>可靠，TCP协议采用发送应答机制，每个TCP报文段必须得到接收方的应答，才认为这个TCP报文传输成功。且TCP协议采用超时重传机制。以及对收到的可能乱序，重复的IP数据报，重排，整理，再交付应用层。</p>
<h4 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h4><p>TCP头部信息出现在每个TCP报文段中。本节详细介绍</p>
<p><strong>a) TCP固定头部结构</strong></p>
<p><img src="/./../pic/image-20230418192759838.png" alt="image-20230418192759838"></p>
<p>16位端口号：告知该报文段来自哪里以及传给哪个上层协议或应用程序。</p>
<p>32位序号：一次TCP通信过程中某一个传输方向上的字节流的每个字节的编号。</p>
<p>32位确认号：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值+1。</p>
<p>4位头部长度：标识该TCP头部有多少个32bit字(4字节)。4位最大表示15，所以TCP头部最长60字节。</p>
<p>6位标志位包含如下几项：</p>
<ol>
<li>URG标志：表示紧急指针是否有效</li>
<li>ACK标志：表示确认号是否有效，携带ACK标志的TCP报文段为确认报文段。</li>
<li>PSH标志：提示接收端应用程序立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。</li>
<li>RST标志：表示要求对方重新建立连接，携带RST为复位报文段</li>
<li>SYN标志：表示请求建立一个连接，携带SYN为同步报文段。</li>
<li>FIN标志：表示通知对方本端要关闭连接了，携带FIN为结束报文段。</li>
</ol>
<p>16位窗口大小：TCP流量控制的一个手段。</p>
<p>16位校验和：接收端执行CRC算法以检验TCP报文段在传输过程中是否损坏。</p>
<p>16位紧急指针：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。</p>
<p><strong>b) TCP头部选项</strong></p>
<p>TCP头部的最后一个选项是可变长的可选信息。这部分最多40字节，因为TCP最长60，前面固定已占了20字节。典型的TCP头部选项结构如下：</p>
<p><img src="/./../pic/image-20230418193622312.png" alt="image-20230418193622312"></p>
<p>kind说明选项的类型，有的TCP选项没有后面的两个值，length指定该选项的长度，包括kind和length占据的2字节，info是选项的具体信息。常见的有7种，如下：</p>
<p><img src="/./../pic/image-20230418193757338.png" alt="image-20230418193757338"></p>
<p>kind0：选项表结束选项。</p>
<p>kind1：空操作(nop)选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind2：最大报文段长度选项。通信双方使用该选项来协商最大报文段长度(MSS)。通常设置为(MTU-40)字节，减掉的包括20字节IP头部和20字节TCP头部，避免IP分片。</p>
<p>kind3：窗口扩大因子选项。TCP头部种，接收通过窗口大小是用6位表示的(即65535)，但TCP模块允许的大小远不止这个数，通过该选项可以扩大该值，如假设TCP头部中的接收通告窗口大小是N，扩大因子是M，即将N左移M位。</p>
<p>kind4：选择性确认选项。若通信时某个TCP报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样会导致原先已经正确传输的TCP报文段被重复发送，从而降低TCP性能。该选项使TCP模块只重新发送丢失的TCP报文段。</p>
<p>kind5：是选择性确认(Selective Acknowledgment, SACK)实际工作的选项。</p>
<p>kind8：时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间(RTT)的方法。</p>
<p><strong>c) 使用tcpdump观察TCP头部信息</strong></p>
<p>抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418194848115.png" alt="image-20230418194848115"></p>
<p>Flags[S]：表示包含SYN标志，因此他是一个同步报文段。</p>
<p>seq：序号值，因为这是该方向上第一个TCP报文段，所以这个序号值也就是本次通信该方向上的ISN(Initial Sequence Number, 初始序号值)。</p>
<p>win：接收通告窗口的大小。</p>
<p>options：tcp选项，mss为最大报文长度。通过ifconfig查看mtu为16436，所以mss为MUT-40，16396。sackOK表示同意使用SACK选项，TSval是发送端的时间戳，ecr是时间戳回显应答。nop是一个空操作，wscale指出发送端的扩大银子为6.</p>
<p>字节码即，TCP头部中对应的消息：</p>
<p><img src="/./../pic/image-20230418195407852.png" alt="image-20230418195407852"></p>
<h4 id="3-3-TCP连接的建立和关闭"><a href="#3-3-TCP连接的建立和关闭" class="headerlink" title="3.3 TCP连接的建立和关闭"></a>3.3 TCP连接的建立和关闭</h4><p><strong>a) 使用tcpdump观察TCP连接的建立和关闭</strong></p>
<p><img src="/./../pic/image-20230418195636159.png" alt="image-20230418195636159"></p>
<p>可以看出是三次握手建立连接，以及四次握手关闭连接</p>
<p><img src="/./../pic/image-20230418195925990.png" alt="image-20230418195925990"></p>
<p><strong>b) 半关闭状态</strong></p>
<p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。也就是允许一端发送结束报文，告诉对端本端已完成数据的发送，但允许继续接收来自对端的数据，直到对方也发送结束报文。</p>
<p><img src="/./../pic/image-20230418200139837.png" alt="image-20230418200139837"></p>
<p><strong>c) 连接超时</strong></p>
<p>这里采用iptable命令过于数据包，丢弃它所接收到的连接请求。随后用tcpdump抓取。</p>
<p><img src="/./../pic/image-20230418200331441.png" alt="image-20230418200331441"></p>
<p>可以看出在5次重连均失败的情况下，TCP模块放弃连接并通知应用程序。</p>
<h4 id="3-4-TCP状态转移"><a href="#3-4-TCP状态转移" class="headerlink" title="3.4 TCP状态转移"></a>3.4 TCP状态转移</h4><p>下图是完整的状态转移图，可以通过netstat命令查看TCP连接处于何种状态。</p>
<p><img src="/./../pic/image-20230418200554092.png" alt="image-20230418200554092"></p>
<p>粗实线表示典型的客户端连接的状态转移，虚线可以看作服务端收到客户端的连接请求后的状态转移，CLOSED为一个假象状态，实际并不存在。</p>
<p><strong>a) TCP状态转移总图</strong></p>
<p>先讨论服务器典型的状态转移。</p>
<p>服务端listen调用进入LISTEN状态，接收到SYN，将连接放入内核等待队列，并向对端发送带SYN标志的ack确认报文段，此时处于SYN_RCVD状态。接收到对端回发的确认报文段后，转移到ESTABLISHED状态。</p>
<p>收到结束报文段，并返回确认报文段后，进入CLOSE_WATI状态，随后等待服务器应用程序关闭连接，发送一个结束报文段后进入LASK_ACK状态，在此等待最后一个确认，一旦确认即彻底关闭。</p>
<p>客户端同意，但注意一个TIME_WATI状态，后续讨论。</p>
<p><img src="/./../pic/image-20230418201413001.png" alt="image-20230418201413001"></p>
<p><strong>b) TIME_WATI状态</strong></p>
<p>客户端在收到服务端的FIN后，没有立即进入CLOSED状态，而要等待一段长为2MSL(报文段最大生存时间)的时间，大概是2分钟，该状态存在的两点原因：</p>
<ol>
<li>可靠地终止TCP连接</li>
<li>保证让迟来的TCP报文段有足够的时间被识别并丢弃</li>
</ol>
<p>通过setsockopt选项SO_REUSEADDR设置端口复用，可以避免TIME_WAIT状态连接占用的端口。</p>
<h4 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h4><p>本节讨论产生复位报文段的三种情况</p>
<p><strong>a) 访问不存在的端口</strong></p>
<p>如以下命令访问一个不存在的54321端口：</p>
<p><img src="/./../pic/image-20230418202122363.png" alt="image-20230418202122363"></p>
<p>抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418202136410.png" alt="image-20230418202136410"></p>
<p>以及对于仍处于TIME_WATI的端口发起连接，客户端程序也将收到复位报文段。</p>
<p><strong>b) 异常终止连接</strong></p>
<p>前面讨论的连接终止方式都是正常的种植方式：数据交换完成后，通过结束报文段。TCP提供了异常终止的一个连接方式，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都被丢弃。通过使用socket选项的SO_LINGER来发送复位报文段，以异常终止一个连接。</p>
<p><strong>c) 处理半打开连接</strong></p>
<p>如下情况，服务器关闭或异常终止了连接，而对方没有收到结束报文段，此时客户端还维持着原来的连接。如果此时客户端向半打开状态的连接写入数据，对方将回应一个结束报文段。</p>
<p>如执行如下命令：</p>
<p><img src="/./../pic/image-20230418202543526.png" alt="image-20230418202543526"></p>
<p>tcpdump抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418202610216.png" alt="image-20230418202610216"></p>
<p>前3个报文段为TCP3次握手的建立，第4个报文段为客户端发送给服务器携带应用程序数据的报文段，length3，为”a”, 回车符\r , 换行符\n。</p>
<h4 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h4><p>TCP报文段锁携带的应用程序数据按照长度分为两种：交互数据和成块数据。交互数据仅包含很少的字节。对实时性要求高的应用程序一般采用该种，如telnet，ssh。成块数据长度通常为TCP报文段允许的最大数据长度，对传输效率高的应用程序采用这种如ftp。</p>
<p>执行如下命令：</p>
<p><img src="/./../pic/image-20230418203103602.png" alt="image-20230418203103602"></p>
<p>tcpdump抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418203122162.png" alt="image-20230418203122162"></p>
<h4 id="3-7-TCP成块数据流"><a href="#3-7-TCP成块数据流" class="headerlink" title="3.7 TCP成块数据流"></a>3.7 TCP成块数据流</h4><p>下面考虑FTP协议传输一个大文件。命令如下：</p>
<p><img src="/./../pic/image-20230418203616713.png" alt="image-20230418203616713"></p>
<p>tcpdump输出如下：</p>
<p><img src="/./../pic/image-20230418203634178.png" alt="image-20230418203634178"></p>
<p>前面16个报文段都为，服务端向客户端发送数据，17，18则是客户端对于TCP报文段2和16的确认。由此可见，当传输大量大块数据的时候，发送方会连续发送多个TCP报文段。</p>
<h4 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h4><p>有些传输层协议具有带外数据的概念，用于迅速通告对方本端发生的重要事件。因此，带外数据比普通数据有更高的优先级，它应该总是立即被发送，而不论发送缓冲区种是否有排队等候发送的普通数据。</p>
<p>UDP没有实现带外数据，TCP也米有真正的带外数据。不过TCP利用其头部种的紧急指针标志和紧急指针字段，给应用程序提供了一种紧急方式。</p>
<p>具体过程如下，假设一个进程已经往某个TCP连接的发送缓冲区种写入了N字节的普通数据。在数据被发送前，该进程又向这个连接写入了3字节的带外数据”abc”。此时，待发送的TCP报文段将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节。</p>
<p><img src="/./../pic/image-20230418204844857.png" alt="image-20230418204844857"></p>
<h4 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h4><p>TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维持一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次的重传，就是TCP的重传策略，通过示例来研究。</p>
<p>执行如下命令：</p>
<p><img src="/./../pic/image-20230418205131120.png" alt="image-20230418205131120"></p>
<p>tcpdumo抓取的TCP报文段如下：</p>
<p><img src="/./../pic/image-20230418205206146.png" alt="image-20230418205206146"></p>
<p>前3次为三次握手建立连接，4和5为1234数据的发送和应答，后续执行了5次重传，均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。</p>
<p><img src="/./../pic/image-20230418205545198.png" alt="image-20230418205545198"></p>
<p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传。</p>
<h4 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h4><p><strong>a) 拥塞控制概述</strong></p>
<p>TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性，这就是所谓的拥塞控制。</p>
<p>拥塞控制的四个部分：慢启动，拥塞避免，快速重传 和 快速恢复。</p>
<p>拥塞控制的最终受控变量是发送端向网络一次连续写入的数据量，我们称为SWND(Send Window, 发送窗口)。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。</p>
<p>发送端需要合理的选择SWND的大小，如果SWND太小，会引起明显的网络延迟；反之，如果太大，则容易导致网络拥塞。接收方可以通过其接收通过窗口(RWND)来控制发送端的SWND，但这不够，所以发送端引入了一个称为拥塞窗口(Congestion Winod, CWND)的状态变量。实际的值是RWND和CWND种的较小值。</p>
<p><img src="/./../pic/image-20230418210138514.png" alt="image-20230418210138514"></p>
<p><strong>b) 慢启动和拥塞避免</strong></p>
<p>TCP连接建立好后，CWND将被设置成初始值IW(Initial Window)，其大小为2~4个SMSS(Sender Maximum Segment Site，发送者最大段大小)。此时发送端最多能发送IW字节的数据。此后发送端每收到接收端的一个确认，其CWND就按照式(3-1)增加：</p>
<p><img src="/./../pic/image-20230418211442286.png" alt="image-20230418211442286"></p>
<p>其中N是此次确认中包含的之前未被确认的字节数。这样一来，CWND将按照指数形式扩大，这就是所谓的慢启动。该算法的理由是，TCP模块一开始不知道网络的实际情况，通过一个试探的方式平滑的增加CWDN的大小。</p>
<p>但如果不施加其他手段，慢启动必然使得CWND膨胀，导致网络阻塞。因此TCP拥塞控制中定义了另一个重要的状态变量：<strong>慢启动门限（ssthresh）</strong>。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。</p>
<p>拥塞避免算法使得CWND按线性方式增加，从而减缓其扩大。两种实现方式：</p>
<ol>
<li>每个RTT时间内按照(3-1)计算新的CWND，而不论该RTT时间内发送端接收到多少个确认。</li>
<li>没收到一个对新数据报的确认报文段，按(3-2)来更新CWND</li>
</ol>
<p><img src="/./../pic/image-20230418211429983.png" alt="image-20230418211429983"></p>
<p>如果给出一张图示，如下：</p>
<p><img src="/./../pic/image-20230418211523713.png" alt="image-20230418211523713"></p>
<p>以上为发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时拥塞控制行为。首先搞清除发送端如何判断拥塞已经发生，依据有两个：</p>
<ol>
<li>传输超时，或者说TCP重传定时器溢出</li>
<li>接收到重复的确认报文段</li>
</ol>
<p>拥塞控制对这两种情况有不同的处理方式，对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和而快速恢复，这种情况随后讨论。注意如果第二种情况发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</p>
<p>如果发送端检测到拥塞发生是由于传输超时，即第一种情况，将执行重传并做如下调整：</p>
<p><img src="/./../pic/image-20230418212010912.png" alt="image-20230418212010912"></p>
<p>其中FlightSize是已经发送但未接收到确认的字节数，这样调整之后,CWND将一定小于SMSS，那么也必然小于新的慢启动门限ssthresh，故而拥塞控制再次进入慢启动阶段。</p>
<p><strong>c) 快速重传和快速恢复</strong></p>
<p>在很多情况下，发送端都可能收到重复的确认报文段。如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排之等。拥塞控制算法首先需要判断网络是否真的发生了阻塞。具体做法是：如果连续收到3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下：</p>
<p>1.收到3个重复确认报文段时，按式(3-3)计算ssthresh，然后立即重传丢失的报文段，并按照式(3-4)设置CWND</p>
<p><img src="/./../pic/image-20230418224927284.png" alt="image-20230418224927284"></p>
<p>2.每次收到1个重复的确认时，设置CWND &#x3D; CWND + SMSS。此时发送端可以发送新的TCP报文段，如果CWND允许的话。</p>
<p>3.当收到新的数据的确认时，设置CWND &#x3D; ssthresh 该慢启动门限为新的，由第一步设置</p>
<p>快速重传和快速恢复完成后，拥塞控制将恢复到拥塞避免阶段。</p>
<h3 id="第4章-TCP-x2F-IP通信案例：访问Internet上的Web服务器"><a href="#第4章-TCP-x2F-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第4章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器"></a>第4章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器</h3><h4 id="4-1-示例总图"><a href="#4-1-示例总图" class="headerlink" title="4.1 示例总图"></a>4.1 示例总图</h4><p>在Kongming20上运行wget客户端，在ernest-laptop运行squid代理服务器程序。客户端通过代理服务器的中专，获取Internet上的主机<a target="_blank" rel="noopener" href="http://www.baidu.com的首页文档index.html/">www.baidu.com的首页文档index.html</a></p>
<p><img src="/./../pic/image-20230422132253572.png" alt="image-20230422132253572"></p>
<p>为了将ernest-laptop设置为Kongming20的HTTP代理服务器，需要在Kongming20上设置环境变量http_proxy:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export http_proxy=<span class="string">&quot;ernest-laptop:3128&quot;</span></span><br></pre></td></tr></table></figure>

<p>3128为squid服务器默认使用的端口号。</p>
<h4 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h4><p>简单介绍代理服务器的工作原理以及如何部署。</p>
<p><strong>a) HTTP代理服务器的工作原理</strong></p>
<p>HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。代理服务器按照其使用方式和作用，分为正向代理服务器，反向代理服务器和透明代理服务器。</p>
<p>正向代理：要求客户端自己设置代理服务器的地址。客户每次的请求都直接发送到该代理服务器，并由代理服务器来请求目标资源。</p>
<p>反向代理：反向代理被设置在服务器端，因此客户端无须进行任何设置。方向代理用代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得来的结果返回给客户端。</p>
<p>透明代理：只能设置在网关上。透明代理可以看作正向代理的一种特殊情况。</p>
<p><img src="/./../pic/image-20230422133156009.png" alt="image-20230422133156009"></p>
<p><strong>b) 部署squid代理服务器</strong></p>
<p>在ernest-laptop上部署squid代理服务器。只需修改服务器的配置文件&#x2F;etc&#x2F;squid3&#x2F;suiqd.conf，在其加入如下两行代码(需要root权限，应加在合适的为止，详细参考其他类似条目的设置)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acl localnet src <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">http_access allow localnet</span><br></pre></td></tr></table></figure>

<p>192.168.1.0&#x2F;24是CIDR(Classless Inter-Domain Routing，无类域间路由)风格的IP地址表示方法。</p>
<p>接下来在ernest-laptop上执行如下命令，以重启squid服务器:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service squid3 restart</span><br><span class="line">*Restarting Squid HTTP Proxy <span class="number">3.0</span> squid3					[ok]</span><br></pre></td></tr></table></figure>

<p>service是一个脚本程序，为&#x2F;etc&#x2F;init.d&#x2F;目录下的众多服务器程序的启动，停止等动作提供了一个统一的管理。</p>
<h4 id="4-3-使用tcpdump抓取传输的数据包"><a href="#4-3-使用tcpdump抓取传输的数据包" class="headerlink" title="4.3 使用tcpdump抓取传输的数据包"></a>4.3 使用tcpdump抓取传输的数据包</h4><p>执行wget命令前，首先删除ernest-laptop的ARP高速缓存，以便观察TCP&#x2F;IP通信过程中ARP协议何时起作用，完整操作如下:</p>
<p><img src="/./../pic/image-20230422134037893.png" alt="image-20230422134037893"></p>
<p><img src="/./../pic/image-20230422134142198.png" alt="image-20230422134142198"></p>
<p><img src="/./../pic/image-20230422134159265.png" alt="image-20230422134159265"></p>
<p>一共抓取了43个数据包，按照逻辑关系分为如下四部分：</p>
<ol>
<li>代理服务器访问DNS服务器查询域名<a target="_blank" rel="noopener" href="http://www.baidu.com对应的ip地址,数据包8,9./">www.baidu.com对应的IP地址，数据包8，9。</a></li>
<li>代理服务器查询路由器MAC地址的ARP请求和应答，数据包6，7。</li>
<li>wget客户端(192.168.1.109)和代理服务器(192.168.1.108)之间的HTTP通信，数据包1<del>5，23</del>25，32~40，42，43。</li>
<li>代理服务器和Web服务器(119.75.218.77)之间的HTTP通信，数据包10<del>22，26</del>31，41。</li>
</ol>
<h4 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h4><p>数据包8，9表示代理服务器向DNS服务器查询域名<a target="_blank" rel="noopener" href="http://www.baidu.com对应的ip地址,得到回应.回复包括一个主机别名和两个ip地址./">www.baidu.com对应的IP地址，得到回应。回复包括一个主机别名和两个IP地址。</a></p>
<p><img src="/./../pic/image-20230422134810389.png" alt="image-20230422134810389"></p>
<p>完整过程如下图：</p>
<p><img src="/./../pic/image-20230422134825437.png" alt="image-20230422134825437"></p>
<h4 id="4-5-本地名称查询"><a href="#4-5-本地名称查询" class="headerlink" title="4.5 本地名称查询"></a>4.5 本地名称查询</h4><p>通过域名来访问internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。</p>
<p>Linux将目标主机及其对应IP地址存储在&#x2F;etc&#x2F;hosts配置文件中。如Kongming20上&#x2F;etc&#x2F;hosts文件的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>			localhost</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.109</span>		Kongming20</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.108</span>		ernest-laptop</span><br></pre></td></tr></table></figure>

<p>程序在&#x2F;etc&#x2F;hosts文件中未找到目标机器名对应的IP地址，它将求助于DNS服务。</p>
<p>用户可以通过修改&#x2F;etc&#x2F;host.conf文件来自定义系统解析主机名的方法和顺序。</p>
<h4 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h4><p><img src="/./../pic/image-20230422140151624.png" alt="image-20230422140151624"></p>
<p>本例的过程中，客户端仅给服务器发送了一个HTTP请求，即TCP报文段4，请求的长度为136字节。代理用6个TCP报文段(23,24,25,33,35,36)给客户端返回了总长度为8522字节的HTTP应答。客户端使用7个TCP报文段(32,34,37,38,39,40,42)来确定这8552字节的HTTP应答数据。</p>
<p><strong>a) HTTP请求</strong></p>
<p>请求的部分内容如下:</p>
<p><img src="/./../pic/image-20230422141147637.png" alt="image-20230422141147637"></p>
<p>GET为请求方法，一共有如下9种：</p>
<p><img src="/./../pic/image-20230422141339368.png" alt="image-20230422141339368"></p>
<p><a target="_blank" rel="noopener" href="http://www/baidu/com/index.html">http://www/baidu/com/index.html</a> 是目标资源的URL，”http”是所谓的scheme，表示获取目标资源所需使用的应用层协议。<a target="_blank" rel="noopener" href="http://www.baidu.com是目标主机,index.html是指定资源文件名称/">www.baidu.com是目标主机，index.html是指定资源文件名称</a></p>
<p>HTTP&#x2F;1.0表示客户端使用的HTTP版本号是1.0。</p>
<p>User-Agent表示客户端使用的程序。</p>
<p>Host表示目标主机名。</p>
<p>Conection表示如何处理连接方式。</p>
<p><strong>b) HTTP应答</strong></p>
<p><img src="/./../pic/image-20230422141624967.png" alt="image-20230422141624967"></p>
<p>第一行是状态行，HTTP&#x2F;1.0表示服务器使用的协议版本号，通常需要和客户端一致。</p>
<p><img src="/./../pic/image-20230422141713100.png" alt="image-20230422141713100"></p>
<p>往下分别是，服务器程序名，目标内容的长度，目标内容的MIME类型，以及cookie。</p>
<p>via表示HTTP应答在返回过程中经历的所有代理服务器的地址和名称。</p>
<h3 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h3><h4 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h4><p><strong>a) 主机字节序和网络字节序</strong></p>
<p>不同规定导致的字节沿地址增长方向不同，高位存储在低地址为大端字节序，高位存储在高地址，则为小端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断机器字节序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byteorder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    uninon &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; test;</span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unkonwn...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> in <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> in <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>b) 通用socket地址</strong></p>
<p>socket网络编程中表示socket地址的结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;		<span class="comment">/* 地址族类型 如 AF_INET, AF_INET6 */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230421193648930.png" alt="image-20230421193648930"></p>
<p>由于14字节的sa_data无法容纳众多数的协议族的地址值。下面为新的通用地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__s_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且该结构是内存对齐的</p>
<p><strong>c) 专用socket地址</strong></p>
<p>UNIX本地域协议族使用如下专用socket地址结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; 	<span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];			<span class="comment">/* 文件路径名 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TCP&#x2F;IP，分为IPV4的和IPV6的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;		<span class="comment">/* AF_INET */</span></span><br><span class="line">    <span class="type">u_int16_t</span>	sin_port;		<span class="comment">/* 端口号，网络字节序 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">/* IPV4地址结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;			<span class="comment">/* IPV4地址，网络字节序 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;	<span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;		<span class="comment">/* 端口号，网络字节序 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;	<span class="comment">/* 流信息，应设置为0 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>	<span class="comment">/* IPV6地址结构体 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;	<span class="comment">/* scope ID, 尚处于实验阶段 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];	<span class="comment">/* IPV6地址，网络字节序 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>d) IP地址专函函数</strong></p>
<p>下面3个函数可用于点分十进制字符串到网络字节序整数之间的转换:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * strptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * cp, <span class="keyword">struct</span> in_addr * inp)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inet_ntoa函数内部用一个静态变量存储转化结果，函数的返回值指向静态内存</span></span><br><span class="line"><span class="type">char</span> * szValue1 = inet_ntoa(<span class="string">&quot;1.2.3.4&quot;</span>);</span><br><span class="line"><span class="type">char</span> * szValue2 = inet_ntoa(<span class="string">&quot;10.194.71.60&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 1: %s\n&quot;</span>, szValue1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 2: %s\n&quot;</span>, szValue2);</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">    address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">    address1: <span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure>

<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且同时适用于IPV4和IPV6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//socklen_t 的取值一般用如下两个宏，对应IPV4字符串的长度和IPV6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>



<h4 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>domain参数指明使用哪个底层协议，如AF_INET，AF_INET6，AF_UNIX。</p>
<p>type参数指定服务类型。主要为SOCKET_STREAM(流服务)适用于TCP协议，SOCK_DGRAM(数据报服务)适用于UDP协议。</p>
<p>protocol在前两个参数的前提下，指定一个具体的协议。因为前两个参数基本已经完全决定了它的值。在几乎所有情况下，把它设置为0，表示默认协议。</p>
<h4 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h4><p>即将sockaddr绑到socket上去:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>常见的两种errno</p>
<p>EACCES:被保定的地址是受保护的地址，仅超级用户能访问。</p>
<p>EADDRINUSE:被绑定地址正在使用中。比如绑到一个处于TIME_WAIT状态的socket地址。</p>
<h4 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h4><p>创建监听队列存放待处理的客户连接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>backlog参数在内核版本2.2之后，表示完全处于连接状态的socket上线，处于半连接状态的socket上线由        &#x2F;proc&#x2F;sys&#x2F;ipv4&#x2F;tcp_mas_syn_bakclog内核参数定义。</p>
<h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>下面的系统调用从listen监听队列中接受一个连接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>accept成功时返回一个新的连接socket，该socket唯一地标识了被接收的这个连接。</p>
<h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>客户端通过如下系统调用来主动与服务器建立连接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>失败常见的两种errno:</p>
<p>ECONNREFUED:目标端口不存在，连接被拒绝。</p>
<p>ETIMEDOUT:连接超时。</p>
<h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>关闭连接，也就是关闭对应的socket，通过如下系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>close实际上的操作，是将文件描述符fd的引用计数减1，只有引用计数为0时，才真正关闭连接。所以在多进程程序中，一次fork调用会导致父进程中打开的socket引用计数加1，只有父子进程都执行了close，才能将连接关闭。</p>
<p>如果想立即终止连接，可以使用shutdown系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span>;</span><br></pre></td></tr></table></figure>

<p>howto参数决定shutdown的行为:</p>
<p><img src="/./../pic/image-20230421200510032.png" alt="image-20230421200510032"></p>
<h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><p><strong>a) TCP数据读写</strong></p>
<p>socket编程接口提供的几个用于TCP流数读写的系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>flags参数为数据收发提供了额外的控制，具体可选值如下表:</p>
<p><img src="/./../pic/image-20230421200813084.png" alt="image-20230421200813084"></p>
<p>MSG_OBB选项给应用程序提供了发送和接收带外数据方法，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送带外数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, basename( argv[<span class="number">0</span>]) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_address</span>;</span></span><br><span class="line">    bzero( &amp;serv_address, <span class="keyword">sizeof</span>(serv_address) );</span><br><span class="line">    serv_address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;serv_address.sin_addr );</span><br><span class="line">    serv_address.sin_port = htons(port);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET ,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_address, <span class="keyword">sizeof</span>(serv_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * obb_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">        send(sockfd, obb_data, <span class="built_in">strlen</span>(obb_data), MSG_OBB);</span><br><span class="line">        send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收带外数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt;= <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(...);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_int</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, sizeog(address) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> ret = bind(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address) );</span><br><span class="line">    assert( ret != <span class="number">1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret != <span class="number">1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clinet_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> buffer[ BUF_SIZE ];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SZIE );</span><br><span class="line">        ret = recv( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SZIE );</span><br><span class="line">        ret = recv( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OBB );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of obb data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SZIE );</span><br><span class="line">        ret = recv( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line">        </span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">got <span class="number">5</span> bytes of normal data <span class="string">&#x27;123ab&#x27;</span></span><br><span class="line">got <span class="number">1</span> bytes of obb data <span class="string">&#x27;c&#x27;</span></span><br><span class="line">got <span class="number">3</span> bytes of normal data <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>b) UDP数据读写</strong></p>
<p>socket编程中用于UDP数据报读写的系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr</span></span><br><span class="line"><span class="params">               , <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags</span></span><br><span class="line"><span class="params">               , <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklent_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>UDP没有通信的概念，所以每次读取和发送数据都需要指定目标的socket地址。</p>
<p>该系统调用也可以用于面向连接的socket，只需要把最后两个参数设置为NULL，忽略地址。</p>
<p><strong>c) 通用数据读写函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags )</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags )</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *msg_name;			<span class="comment">/* socket地址 */</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_namelen;	<span class="comment">/* socket地址的长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span>	<span class="comment">/* 分散的内存块 */</span></span><br><span class="line">    <span class="type">int</span> msg_iovlen;			<span class="comment">/* 分散内存块的数量 */</span></span><br><span class="line">    <span class="type">void</span> *msg_contorl;		<span class="comment">/* 指向辅助数据的起始位置 */</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_contorllen;<span class="comment">/* 辅助数据的大小 */</span></span><br><span class="line">    <span class="type">int</span> msg_flags;			<span class="comment">/* 复制函数中的flags参数，并在调用中更新 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base;			<span class="comment">/* 内存起始地址 */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;			<span class="comment">/* 这块内存的长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iovec用于分散读和集中写。</p>
<p>msg_control，辅助数据，13章介绍如何使用它们来实现进程间传递文件描述符。</p>
<h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>前面演示了TCP带外数据的接收方法，但实际应用中，无法预期带外数据何时到来。所以有了如下系统调用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">( <span class="type">int</span> sockfd )</span>;</span><br></pre></td></tr></table></figure>

<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取的数据是否是带外数据。如果是返回1，此时就可以利用带MSG_OBB标志的recv调用来接收带外数据。</p>
<h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><p>用以知道本端的socket地址，以及远端的socket地址:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span> *address_len )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">( <span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span> *address_len )</span>;</span><br></pre></td></tr></table></figure>

<p>getsockname获取本端的，getpeername获取对端的。</p>
<h4 id="5-11-socket选项"><a href="#5-11-socket选项" class="headerlink" title="5.11 socket选项"></a>5.11 socket选项</h4><p>下面两个系统调用用来读取和设置socket文件描述符属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">( <span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span> *option_value, </span></span><br><span class="line"><span class="params">              <span class="type">socklen_t</span> *<span class="keyword">restrict</span> option_len )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">( <span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span> *option_value, </span></span><br><span class="line"><span class="params">              <span class="type">socklen_t</span> option_len )</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230421204334261.png" alt="image-20230421204334261"></p>
<p><strong>a) SO_REUSEADDR选项</strong></p>
<p>通过设置该选项，强制使用处于被TIME_WAIT状态的连接占用的socket地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用例</span></span><br><span class="line"><span class="type">int</span> sock = socket( AF_INET ,SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">assert( sock &gt;= <span class="number">0</span> );</span><br><span class="line"><span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeog( reuse ) );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">address.sin_port = htons( port );</span><br><span class="line"><span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br></pre></td></tr></table></figure>



<p><strong>b) SO_RCVBUF和SO_SNDBUF选项</strong></p>
<p>设置接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。TCP接收缓冲区的最小值是256，发送缓冲最小值是2048。目的是，确保一个TCP连接拥有足够的空间缓冲区来处理拥塞。通过之间修改内核参数可以强制其没有最小值限制。</p>
<p><img src="/./../pic/image-20230421205007797.png" alt="image-20230421205007797"></p>
<p><img src="/./../pic/image-20230421205106368.png" alt="image-20230421205106368"></p>
<p>执行如下：</p>
<p><img src="/./../pic/image-20230421205204755.png" alt="image-20230421205204755"></p>
<p>可以看出50字节的设置没有成功，系统将其设置为了最小值256，2000成功了，且系统将其实际上加倍</p>
<p><strong>c) SO_RCVLOWAT和SO_SNDLOWAT选项</strong></p>
<p>SO_RCVLOWAT和SO_SNDLOWAT选项分别标识TCP接收缓冲区和发送缓冲区的低水位标记。一般用于I&#x2F;O复用系统调用用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总数大于其低水位标记时，通常读数据；当TCP发送缓冲区的空闲空间大于其低水位标记时，通知写数据。</p>
<p>一般默认值均为1字节。</p>
<p><strong>d) SO_LINGER选项</strong></p>
<p>SO_LINGER选项用来控制close系统调用在关闭TCP连接时的行为。默认情况下，close关闭socket，close立即返回，TCP模块负责把socket对应TCP发送缓冲区中残留的数据发送给对方。</p>
<p>设置该选项，需用传递一个linger类型的结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> l_onoff;		<span class="comment">/* 非0开启， 0关闭该选项 */</span></span><br><span class="line">    <span class="type">int</span> l_linger;		<span class="comment">/* 滞留时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据参数的不同有如下三种行为:</p>
<pre><code>    1) l_onoff等于0，此时该选项不起作用，与close默认类似
    1) l_onoff不为0，l_linger等于0，此时close立即返回，丢弃残留的数据，同时发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。
    1) l_onoff不为0，l_linger大于0。此时close的行为取决于两个条件:一是被关闭的socket对应的发送缓冲区是否有残留数据，二是socket是阻塞的还是非阻塞的。对于阻塞的，close等待一段长为l_linger的时间，直到残留数据被发送完并且得到对方的确认。如果没有发送完并得到确认，返回-1并设置errno为EWOULDBLOCK。如果是非阻塞，close立即返回。
</code></pre>
<h4 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h4><p>简单来说避免直接使用IP地址，通过之后的一些函数实现，主机名代替IP地址，服务名代替端口号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80</span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>

<p><strong>a) gethostbyname和gethostbyaddr</strong></p>
<p>分别根据主机名获取主机的完整信息和根据IP地址获取主机的完整信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyname</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * name )</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent * <span class="title function_">gethostbyaddr</span><span class="params">( <span class="type">const</span> <span class="type">void</span> * addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> * h_name;			<span class="comment">/* 主机名 */</span></span><br><span class="line">    <span class="type">char</span> ** h_aliases;		<span class="comment">/* 主机别名列表 */</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;			<span class="comment">/* 地址类型 */</span></span><br><span class="line">    <span class="type">int</span> h_length;			<span class="comment">/* 地址长度 */</span></span><br><span class="line">    <span class="type">char</span> ** h_addr_list;	<span class="comment">/* 网络字节序列出的主机IP地址列表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>b) getservbyname和getservbyport</strong></p>
<p>根据名称获取某个服务的完整信息，和根据端口号获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent * <span class="title function_">getservbyname</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * name, <span class="type">const</span> <span class="type">char</span> * proto )</span>;</span><br><span class="line"><span class="keyword">struct</span> servent * <span class="title function_">getservbyport</span><span class="params">( <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> * proto )</span>;</span><br></pre></td></tr></table></figure>

<p>proto参数指定服务类型，”tcp”标识获取流服务，”udp”标识获取udp服务，NULL标识所有服务类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name;			<span class="comment">/* 服务名称 */</span></span><br><span class="line">    <span class="type">char</span> ** s_aliases;		<span class="comment">/* 服务的别名列表 */</span></span><br><span class="line">    <span class="type">int</span> s_port;				<span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="type">char</span> * s_proto;			<span class="comment">/* 服务类型 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例子:通过主机名和服务名访问目标服务器上的daytime服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    assert( argc == <span class="number">2</span>);</span><br><span class="line">    <span class="type">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取目标主机地址信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostinfo</span> =</span> gethostbyname( host );</span><br><span class="line">    assert( hostinfo );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取daytime服务信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span> *<span class="title">servinfo</span> =</span> getservbyname( <span class="string">&quot;daytime&quot;</span>, <span class="string">&quot;tcp&quot;</span> );</span><br><span class="line">    assert( servinfo );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;daytime port is %d\n&quot;</span>, ntohs( servinfo-&gt;s_port ) );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = servinfo-&gt;s_port;</span><br><span class="line">    address.sin_addr = *( <span class="keyword">struct</span> in_addr* )*hostinfo-&gt;h_addr_list;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sockfd = socket( AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> result = connect( sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( result != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    result = read( sockfd, buffer, <span class="keyword">sizeof</span>( buffer ) );</span><br><span class="line">    assert( result &gt; <span class="number">0</span> );</span><br><span class="line">    buffer[result] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the day time is: %s&quot;</span>, buffer );</span><br><span class="line">    close( sockfd );</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>c) getaddrinfo</strong></p>
<p>getaddrinfo既能通过主机名获取IP地址，也能通过服务名获取端口号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo ** result)</span>;</span><br></pre></td></tr></table></figure>

<p>hitns参数用以给getaddrinfo一个目标期望，resulst参数指向一个链表，用于存储反馈结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;				<span class="comment">/* 见后文 */</span></span><br><span class="line">    <span class="type">int</span> ai_family;				<span class="comment">/* 地址族 */</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;			<span class="comment">/* 服务类型 */</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;			<span class="comment">/* 见后文 */</span></span><br><span class="line">    <span class="type">socklen_t</span> ai_addrlen;		<span class="comment">/* socket地址ai_addr的长度 */</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;			<span class="comment">/* 主机的别名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>	<span class="comment">/* 指向socket的地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>	<span class="comment">/* 指向下一个addrinfo结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20230421212321225.png" alt="image-20230421212321225"></p>
<p>当我们使用hints参数时，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，用法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">bzero( &amp;hitns, <span class="keyword">sizeof</span>(hints) );</span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">getaadrinfo( <span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, &amp;hints, &amp;res);</span><br></pre></td></tr></table></figure>

<p>表示只获取主机ernest-laptop上daytime的流服务，也就是TCP服务。</p>
<p>在getaddrinfo调用结束后，使用如下函数释放内存:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaadrinfo</span><span class="params">( <span class="keyword">struct</span> addrinfo *res )</span>;</span><br></pre></td></tr></table></figure>



<p><strong>d) getnameinfo</strong></p>
<p>getnameinfo函数能通过socket地址同时获得以字符串表示的主机名和服务名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">( <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span> *host,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> hostlen, <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>flags参数控制getnameinfo的行为，如下:</p>
<p><img src="/./../pic/image-20230421212738175.png" alt="image-20230421212738175"></p>
<p>失败时返回的错误码表如下:</p>
<p><img src="/./../pic/image-20230421212824151.png" alt="image-20230421212824151"></p>
<h3 id="第6章-高级I-x2F-O函数"><a href="#第6章-高级I-x2F-O函数" class="headerlink" title="第6章 高级I&#x2F;O函数"></a>第6章 高级I&#x2F;O函数</h3><p>诸如pipe，dup&#x2F;dup2等这类函数的介绍</p>
<h4 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h4><p>pipe函数可用于创建一个管道，以实现进程间通信。本章只讨论基本使用方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>fd[0]和fd[1]分别构成管道的两端，fd[1]为写端，fd[0]为读端。并且是单向的，如果要实现双向的数据传输，需要两根管道。如果管道的写端fd[1]的引用计数减少至0，针对该管道的读端fd[0]的read操作将返回0，即读到文件结束标记(EOF)。反之如果读端fd[0]的引用计数减少至0，针对该管道的写端fd[1]的write操作将失败，并引发SIGPIPE信号。</p>
<p>管道本身拥有一个容量限制，大小默认是65535字节。可以使用fcntl来修改。</p>
<p>此外，socket的基础api种有一个socketpari函数。用以方便地创建双向管道:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>前三个参数和socket的参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为仅能在本地使用。</p>
<h4 id="6-2-dup函数和dup2函数"><a href="#6-2-dup函数和dup2函数" class="headerlink" title="6.2 dup函数和dup2函数"></a>6.2 dup函数和dup2函数</h4><p>重定向文件描述符，比如将标准输入重定向到一个文件。可以通过如下用于复制文件描述符的dup&#x2F;dup2函数实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span>;</span><br></pre></td></tr></table></figure>

<p>利用函数实现一个基本GGI服务器例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prot = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        close( STDOUT_FILENO );</span><br><span class="line">        dup( connfd );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;abcd\n&quot;</span> );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先关闭标准输出，此时dup的特性，返回最小可用的文件描述符，即此时标志输出被重定向到connfd，此时的printf将直接发送到connfd连接的socket上。</p>
<h4 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h4><p>集中写和分散读函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>考略之前的Web服务器，当Web服务器解析完一个HTTP请求后，如果目标文档存在且客户具有读权限，那么就要发送一个HTTP应答。这个HTTP应答包含一个状态行，多个头部字段，一个空行和文档的内容，前三部分内容可能存放在一块内存，文档的内容则在另一块单独的内存，此时可以用集中写，将他们一起写出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#icnlude <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SZIE 1024</span></span><br><span class="line"><span class="comment">/* 定义两种HTTP状态码和状态信息 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *status_line[<span class="number">2</span>] = &#123; <span class="string">&quot;200 ok&quot;</span>, <span class="string">&quot;500 Internal server error&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: ... &quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将目标文件作为程序的第三个参数传入 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 用于保存HTTP应答的状态行，头部字段和一个空行的缓存区 */</span></span><br><span class="line">        <span class="type">char</span> header_buf[BUFFER_SIZE];</span><br><span class="line">        <span class="built_in">memset</span>( header_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="comment">/* 用于存放目标文件内容的应用程序缓存 */</span></span><br><span class="line">        <span class="type">char</span> *file_buf;</span><br><span class="line">        <span class="comment">/* 用于获取目标文件的属性，比如是否为目录，文件大小等 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">        <span class="comment">/* 记录目标文件是否是有效文件 */</span></span><br><span class="line">        <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* 缓存区header_buf目前已使用多少字节的空间 */</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( stat( file_name, &amp;file_stat) &lt; <span class="number">0</span> ) &#123; <span class="comment">/* 目标文件不存在 */</span></span><br><span class="line">            valid  = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( S_ISDIR( file_stat.st_mode ) ) &#123;<span class="comment">/* 目标文件为目录 */</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( file_stat.st_mode &amp; S_IROTH ) &#123;<span class="comment">/* 当前用户有读取目标文件的权限 */</span></span><br><span class="line">                <span class="comment">/* 动态分配缓存区file_buf，并指定其大小为目标文件的大小 */</span></span><br><span class="line">                <span class="comment">/* size+1 ，然后将目标文件读入file_buf */</span></span><br><span class="line">                <span class="type">int</span> fd = open( file_name, O_RDONLY );</span><br><span class="line">                file_buf = new <span class="type">char</span>[file_stat.st_size + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">memset</span>( file_buf, <span class="string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( read( fd, file_buf, file_stat.st_size ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( valid ) &#123;</span><br><span class="line">            <span class="comment">/* 将状态行，头部字段，空行依次加入header_buf种 */</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">0</span>] );</span><br><span class="line">            len+=ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, </span><br><span class="line">                            file_stat.st_size );</span><br><span class="line">            len+=ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 集中写 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iv</span>[2];</span></span><br><span class="line">            iv[<span class="number">0</span>].iov_base = header_buf;</span><br><span class="line">            iv[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>( header_buf );</span><br><span class="line">            iv[<span class="number">1</span>].iov_base = file_buf;</span><br><span class="line">            iv[<span class="number">1</span>].iov_len = file_stat.st_size;</span><br><span class="line">            ret = writev( connfd, iv, <span class="number">2</span> ); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">/* 如果目标文件无效，通知客户端发生了“内部错误” */</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">1</span>] );</span><br><span class="line">            len+=ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf+len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            send( connfd, header_buf, <span class="built_in">strlen</span>( header_buf ), <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        close( connfd );</span><br><span class="line">        delete [] file_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h4><p>sendfile在两个文件描述符之间直接传递数据，完全在内核种操作，避免了内核缓存区和用户缓冲区之间的数据拷贝，效率很高，被称为零拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>in_fd是待读出内容的文件描述符，out_fd是待写入内容的文件描述符，offset为读入文件流的偏移位置，count为拷贝字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用sendfile函数将服务器上的一个文件发送给客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#icnlude <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prot = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file_name = argv[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> filefd = open( file_name, O_RDONLY );</span><br><span class="line">    assert( filefd&gt;<span class="number">0</span> );</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    fstat( filfd, &amp;stat_buf );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sendfile( connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>



<h4 id="6-5-mmap函数和munmap函数"><a href="#6-5-mmap函数和munmap函数" class="headerlink" title="6.5 mmap函数和munmap函数"></a>6.5 mmap函数和munmap函数</h4><p>mmap函数用于申请一段内存空间。可用将这段内存作为进程间通信的共享内存，也可以直接将文件映射到其中。mumap函数则释放mmap创建的这段内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>start参数允许用户使用某个特定的地址作为其实地址，设置为NULL，则系统自动分配一个地址。prot参数用来设置内存段的访问权限，可取以下几个值的按位或：</p>
<ol>
<li>PROT_READ，内存段可读。</li>
<li>PROT_WRITE，内存段可写。</li>
<li>PROT_EXEC，内存段可执行。</li>
<li>PROT_NONE，内存段不能被访问。</li>
</ol>
<p>flags参数控制内存段内容被修改后程序的行为。如下表，其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定:</p>
<p><img src="/./../pic/image-20230422163826042.png" alt="image-20230422163826042"></p>
<h4 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h4><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>fd_in是待输入数据的文件描述符。</p>
<p>flags参数的常用值:</p>
<p><img src="/./../pic/image-20230422164052858.png" alt="image-20230422164052858"></p>
<p>使用splice函数时，fd_in和fd_out必须至少有一个时管道文件描述符。splice函数常见的errno如下：</p>
<p><img src="/./../pic/image-20230422164152069.png" alt="image-20230422164152069"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用splice函数实现的回射服务器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinte/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc&lt;=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi( argv[<span class="number">2</span>] );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero( &amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sock = socket( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    assert( sock&gt;=<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = bind( sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    ret = listen( sock, <span class="number">5</span> );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> cli_len = <span class="keyword">sizeof</span>( client );</span><br><span class="line">    <span class="type">int</span> connfd = accept( sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;cli_len );</span><br><span class="line">    <span class="keyword">if</span> ( connfd&lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        ret = pipe( pipefd );		<span class="comment">/* 创建管道 */</span></span><br><span class="line">        <span class="comment">/* 将connfd上流入的客户数据定向到管道 */</span></span><br><span class="line">        ret = splice( connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, </span><br><span class="line">                      SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        <span class="comment">/* 将管道的输出定向到connfd客户连接文件描述符 */</span></span><br><span class="line">        ret = splice( pipifd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>,</span><br><span class="line">                     SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        assert( ret != <span class="number">-1</span> );</span><br><span class="line">        close( connfd );</span><br><span class="line">    &#125;</span><br><span class="line">    close( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h4><p>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out , <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数和splice一致，但fd_in和fd_out必须都是管道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同时输出数据到终端和文件的程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( argc !=<span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> filefd = open( argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span> );</span><br><span class="line">    assert( filefd&gt;<span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe( pipefd_stdout );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将标准输入内容输入管道 */</span></span><br><span class="line">    ret = splice( STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>,</span><br><span class="line">                  <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    <span class="comment">/* 将管道的输出复制到pipefd_file的输入端 */</span></span><br><span class="line">    ret = tee( pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    <span class="comment">/* 将管道file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件 */</span></span><br><span class="line">    ret = splice( pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, </span><br><span class="line">                  <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">    assert( ret !=<span class="number">-1</span> );</span><br><span class="line">    <span class="comment">/* 将管道stdout定向到标准输出，将内容写道终端 */</span></span><br><span class="line">    ret = splice( pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>,</span><br><span class="line">                  <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">    assert( ret!=<span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    close( filefd );</span><br><span class="line">    close( pipefd_stdout[<span class="number">0</span>] );</span><br><span class="line">    close( pipefd_stdout[<span class="number">1</span>] );</span><br><span class="line">    close( pipefd_file[<span class="number">0</span>] );</span><br><span class="line">    close( pipefd_file[<span class="number">1</span>] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>支持的常用操作如下表:</p>
<p><img src="/./../pic/image-20230422165821737.png" alt="image-20230422165821737"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用例 将文件描述符设置为非阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old_option = fcntl( fd, F_GETFL );		<span class="comment">/* 获取文件描述符旧状态 */</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK; 	<span class="comment">/* 设置非阻塞 */</span></span><br><span class="line">    fcntl( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;							<span class="comment">/* 返回旧状态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h3><p>服务器程序的常见模板:</p>
<p>以守护进程运行，拥有一套日志系统，以某个专门的非root身份运行，通常可配置的也就是拥有配置文件，通常会在启动的时候生成一个PID文件并存入&#x2F;var&#x2F;run目录，通常需要考虑系统资源和限制。</p>
<h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><p><strong>a) Linux系统日志</strong></p>
<p>Linux提供一个守护进程来处理系统日志——syslogd，现在使用的为它的升级版——rsyslogd。</p>
<p>分为内核输出的日志和用户输出的日志。</p>
<p>内核：由printk等函数打印至内核的环状缓存(ring buffer)中。环状缓存的内容直接映射到&#x2F;proc&#x2F; kmsg文件中。</p>
<p>用户：通过调用syslog函数生成系统日志，该函数将日志输出到一个UNIX本地域socket类型的文件&#x2F;dev&#x2F;log中，rsyslogd则监听该文件以获取用户进程的输出。</p>
<p>rsylogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调式信息会保存至&#x2F;var&#x2F;log&#x2F;debug文件，普通信息&#x2F;var&#x2F;log&#x2F;message文件，内核消息&#x2F;var&#x2F;log&#x2F;kern&#x2F;loh文件。日志信息具体如何分发，可在rsyslogd的配置文件中设置。</p>
<p><img src="/./../pic/image-20230424192236582.png" alt="image-20230424192236582"></p>
<p><strong>b) syslog函数</strong></p>
<p>应用程序使用syslog函数与rsylogd守护进程通信:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *message, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>priority参数是所谓的设施值与日志级别的按位或。设施值的默认值是LOG_USER，下面的讨论仅限于该值。日志级别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_EMERG			0	<span class="comment">/* 系统不可用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ALERT			1 	<span class="comment">/* 报警，需要立即采取动作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_CRIT			2 	<span class="comment">/* 非常严重的情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERR				3	<span class="comment">/* 错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING 		4	<span class="comment">/* 警告 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_NOTICE 			5	<span class="comment">/* 通知 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO			6	<span class="comment">/* 信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG			7	<span class="comment">/* 调试 */</span></span></span><br></pre></td></tr></table></figure>

<p>下面这个函数可改变syslog的默认输出方式，进一步结构化日志内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure>

<p>ident参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行配置，它可取下列值的按位或:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_PID			0X01	<span class="comment">/* 在日志消息中包含程序PID */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_CONS 		0X02	<span class="comment">/* 如果消息不能记录到日志文件，则打印至终端 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ODELAY		0X04 	<span class="comment">/* 延迟打开日志功能直到第一次调用syslog */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_NDELAY		0X08	<span class="comment">/* 不延迟打开日志功能 */</span></span></span><br></pre></td></tr></table></figure>

<p>facility参数可用来修改syslog函数中的默认值。</p>
<p>下面这个函数用于设置syslog的日志掩码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br></pre></td></tr></table></figure>

<p>如下函数关闭日志功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><p><strong>a) UID, EUID, GID 和 EGID</strong></p>
<p>下面这一组函数可用获取和设置当前进程的真实用户ID(UID)，有效用户ID(EUID)，真实组(GID)和有效组(EGID):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">()</span>;			</span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">seteuid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure>

<p>测试进程的UID和EUID的区别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="type">uid_t</span> euid = geteuid();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effectie userid is %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译该文件，将生成的可执行文件(test_uid)的所有者设置为roort，并设置该文件的set-user-id标志，然后运行该程序查看UID和EUID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root:root test_uid		<span class="comment">//修改目标文件的所有者为root</span></span><br><span class="line">$ sudo chmod +s test_uid 			<span class="comment">//设置目标文件的set-uset-id标志</span></span><br><span class="line">$ ./test_uid 						<span class="comment">//运行程序</span></span><br><span class="line">userid is <span class="number">1000</span>, effective userid is <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可看出进程的UID是启动用户的ID，而EUID则是root账户的ID</p>
<p><strong>b) 切换用户</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何将以root身份启动的进程切换为以一个普通用户身份运行</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">switch_to_user</span><span class="params">(<span class="type">uid_t</span> user_id, <span class="type">gid_t</span> gp_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 确保目标用户不是root */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 确保当前用户是合法用户: root或者目标用户 */</span></span><br><span class="line">    <span class="type">gid_t</span> gid = getgid();</span><br><span class="line">    <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="keyword">if</span> ( ( (gid != <span class="number">0</span>) || (uid != <span class="number">0</span>) ) &amp;&amp; </span><br><span class="line">          ( (gid != gp_id ) || ( uid != user_id ) ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果不是root，则已是目标用户 */</span></span><br><span class="line">    <span class="keyword">if</span> ( uid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 切换到目标用户 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( setgid( gp_id ) &lt; <span class="number">0</span>) || ( setuid( user_id ) &lt; <span class="number">0</span> ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><p><strong>a) 进程组</strong></p>
<p>每个进程都属于一个进程组，除了它们的PID信息外，还有进程组ID(PGID)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#included <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>

<p>每个进程都有一个首领进程，其PGID和PID相同。进程组将一直存在，直到其中所有进程都退出或加入其他的进程组。</p>
<p>下面的函数用于设置PGID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br></pre></td></tr></table></figure>

<p>将PID为pid的进程的PGID设置为pgid，如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领。如果pid为0，则表示设置当前进程的PGID为pgid，如果pgid为0，则使用pid作为目标PGID。</p>
<p><strong>b) 会话</strong></p>
<p>一些有关联的进程组将形成一个会话，下面的函数用于创建一个会话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数不能由进程组的首领进程调用，否则将产生一个错误。对于非组首领的进程，调用函数不仅创建新会话，而且有如下额外效果：</p>
<ol>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li>
<li>新建一个进程组，其GPID就是调用进程的PID，调用进程成为改组的首领。</li>
<li>调用进程将甩开终端。</li>
</ol>
<p>如下函数读取会话ID(SID):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>c) 用ps命令查看进程关系</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -o pid,ppid,pgid,sid,comm | less</span><br><span class="line">PID		PPID	PGID	SID		COMMAND</span><br><span class="line"><span class="number">1943</span>	<span class="number">1942</span>	<span class="number">1943</span>	<span class="number">1943</span>	bash</span><br><span class="line"><span class="number">2298</span>	<span class="number">1943</span>	<span class="number">2298</span>	<span class="number">1943</span>	ps</span><br><span class="line"><span class="number">2299</span>	<span class="number">1942</span>	<span class="number">2298</span>	<span class="number">1943</span>	less</span><br></pre></td></tr></table></figure>

<p>三者关系如下图:</p>
<p><img src="/./../pic/image-20230424195432213.png" alt="image-20230424195432213"></p>
<h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux系统资源限制可用通过如下一对函数来读取和设置:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resuorce.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    rlim_r rlim_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rlim_cur指定资源的软限制，rlim_max指定资源的硬限制。软限制是一个建议性的，最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。硬限制一般是软限制的上限，普通程序可减小硬限制，而只有root身份运行的程序才能增加硬限制。下图列举了部分比较重要的资源限制类型:</p>
<p><img src="/./../pic/image-20230424195811465.png" alt="image-20230424195811465"></p>
<h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有的服务器程序需要改变工作目录。如前面讨论的Web服务器。</p>
<p>获取当前工作目录和改变进程工作目录的函数分别是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>改变进程根目录的函数是chroot，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“&#x2F;“)来将工作目录切换至新的根目录。此外，只有特权进程才能改变根目录。</p>
<h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>讨论在代码中如何让一个进程以守护进程的方式运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">daemonize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建子进程，关闭父进程，这样可使程序在后台运行 */</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置文件权限掩码。当进程创建新文件(使用open(...))时文件的权限将是mode &amp; 0777 */</span></span><br><span class="line">    umask( <span class="number">0</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建新的会话，设置本进程为进程组首领 */</span></span><br><span class="line">    <span class="type">pid_t</span> sid = setsid();</span><br><span class="line">    <span class="keyword">if</span> ( sid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 切换工作目录 */</span></span><br><span class="line">    <span class="keyword">if</span> ( ( chdir( <span class="string">&quot;/&quot;</span> ) ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭标准输入，标准输出和标准错误输出 */</span></span><br><span class="line">    close( STDIN_FILENO );</span><br><span class="line">    close( STDOUT_FILENO );</span><br><span class="line">    close( STDERR_FILENO );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭其他已经打开的文件描述符 */</span></span><br><span class="line">    . . . . . .</span><br><span class="line">    <span class="comment">/* 将标准输入，标准输出和标准错误定向到/dev/null */</span></span><br><span class="line">    open( <span class="string">&quot;dev/null&quot;</span>, O_RDONLY );</span><br><span class="line">    open( <span class="string">&quot;dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    open( <span class="string">&quot;dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux提供了完成同样功能的库函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">daemon</span><span class="params">(<span class="type">int</span> nochdi, <span class="type">int</span> noclose)</span>;</span><br></pre></td></tr></table></figure>

<p>nochdir参数用于指定是否改变工作目录，为0则设置为”&#x2F;“，否则继续使用当前。</p>
<p>nclose参数为0时，标准输入，输出，错误都被重定向到&#x2F;dev&#x2F;null文件，否则依然使用原来的设备。</p>
<h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><p>按照服务器程序的一般原理，将服务器解构成三个模块：</p>
<p>I&#x2F;O处理单元，逻辑单元，存储单元。</p>
<h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><p><strong>a) CS模型</strong></p>
<p>最常见的客户端，服务端模型。</p>
<p><img src="/./../pic/image-20230425194243467.png" alt="image-20230425194243467"></p>
<p><strong>b) P2P模型</strong></p>
<p>摒弃了以服务器为中心的格局，网络上所有主机重新回归对等的地位。</p>
<p><img src="/./../pic/image-20230425194354181.png" alt="image-20230425194354181"></p>
<p>P2P模型使得每台机器在消耗服务的同时也能给别人提供服务，这样资源能够充分，自由地共享。P2P模型存在一个显著的问题，即主机之间很难互相发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，提供查找服务，使每个客户能尽快的找到自己需要的资源。</p>
<p><img src="/./../pic/image-20230425194539047.png" alt="image-20230425194539047"></p>
<h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><p>基本框架如下:</p>
<p><img src="/./../pic/image-20230425194621559.png" alt="image-20230425194621559"></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>单个服务器程序</th>
<th>服务器机群</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O处理单元</td>
<td>处理客户连接，读写网络数据</td>
<td>作为接入服务器，实现负载均衡</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
<td>逻辑服务器</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>本地数据库，文件或缓存</td>
<td>数据库服务器</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
<td>各服务器之间的永久TCP连接</td>
</tr>
</tbody></table>
<p>请求队列是各个单元之间通信方式的抽象，I&#x2F;O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。请求队列通常被实现为池的一部分。</p>
<h4 id="8-3-I-x2F-O模型"><a href="#8-3-I-x2F-O模型" class="headerlink" title="8.3 I&#x2F;O模型"></a>8.3 I&#x2F;O模型</h4><p>I&#x2F;O模型对比:</p>
<table>
<thead>
<tr>
<th>I&#x2F;O模型</th>
<th>读写操作和阻塞阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞I&#x2F;O</td>
<td>程序阻塞于读写函数</td>
</tr>
<tr>
<td>I&#x2F;O复用</td>
<td>程序阻塞于I&#x2F;O复用系统调用(如select)，但可同时监听多个I&#x2F;O事件。对I&#x2F;O本身的读写操作是非阻塞的</td>
</tr>
<tr>
<td>SIGIO信号</td>
<td>信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段</td>
</tr>
<tr>
<td>异步I&#x2F;O</td>
<td>内核执行读写操作并触发读写完成事件。程序没有阻塞阶段</td>
</tr>
</tbody></table>
<p>针对非阻塞I&#x2F;O执行的系统调用总是立即返回，而不管事件是否已经发生。如果没有立即发生，返回-1和出错的情况一样。此时需要根据errno来区分这两种情况。</p>
<h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>同步I&#x2F;O常用于实现Reactor模式，异步I&#x2F;O则用于实现Proactor模式。</p>
<p><strong>a) Reactor模式</strong></p>
<p>该模式，要求主线程(I&#x2F;O处理单元)只负责监听文件描述符是否有事件发生，有的话立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程完成。</p>
<p>使用同步I&#x2F;O模型(epoll_wait)实现的的Reactor模型流程如下：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表注册该socket的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程则将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/./../pic/image-20230425200345744.png" alt="image-20230425200345744"></p>
<p><strong>b) Proactor模式</strong></p>
<p>Proactor模式将所有的I&#x2F;O操作交给主线程和内核来处理，工作线程仅负责业务逻辑。因此，该模式更符合前面所描述的服务器编程框架。</p>
<p>使用异步I&#x2F;O模型(以aio_read和aio_write为例)实现的Proactor模式的流程如下:</p>
<ol>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理该客户请求。工作线程处理完客户请求后，调用aio_write函数向内核注册该socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入socket之后，内核向应用程序发送一个信号，通知应用程序数据已发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如是否关闭socket</li>
</ol>
<p><img src="/./../pic/image-20230425200949529.png" alt="image-20230425200949529"></p>
<p><strong>c) 模拟Proactor模式</strong></p>
<p>使用同步I&#x2F;O方式模拟出Proactor模式的一种方法。简单来说将数据读写操作这一工作，从逻辑单元移交给I&#x2F;O处理单元，读写完成后，主线程向工作线程通知这一”完成事件”。</p>
<p>使用同步I&#x2F;O模型(epoll_wait)模拟出的Proactor模式的流程如下：</p>
<ol>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，读完后，将读到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理该客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wati通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img src="/./../pic/image-20230425201451976.png" alt="image-20230425201451976"></p>
<h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发编程的目的简单来说为了提高程序的效率。对于计算密集型来说，并发没有优势，反而因为任务的切换使得效率降低。但对于I&#x2F;O密集型，比如经常读写文件，访问数据库。由于I&#x2F;O操作的速度远没有CPU的计算速度快，让程序阻塞于I&#x2F;O操作将浪费大量的CPU事件。因此，并发可使CPU的利用率显著提升。</p>
<p>并发模式是指I&#x2F;O处理单元和多个逻辑单元之间协调完成任务的方法。服务器主要有两种并发编程模式：半同步&#x2F;半异步(half-sync&#x2F;half-async)模式和领导者&#x2F;追随者(Leader&#x2F;Followers)模式。</p>
<p><strong>a) 半同步&#x2F;半异步模式</strong></p>
<p>此处的同步&#x2F;异步和I&#x2F;O模型中的同步&#x2F;异步是完全不同的概念。</p>
<p>I&#x2F;O模型：同步和异步区分的是内核向应用程序通知的是何种I&#x2F;O事件(就绪事件 or 完成事件)，以及由谁来完成I&#x2F;O读写(应用程序 or 内核)。</p>
<p>并发模式：同步是指程序完全按照代码序列的顺序执行，异步是指程序的执行需要由系统事件来驱动。常见的系统事件包括中断，信号等。</p>
<p>下图a描述了同步的读操作，b描述了异步的读操作：</p>
<p><img src="/./../pic/image-20230425202247401.png" alt="image-20230425202247401"></p>
<p>按同步方式运行的线程称为同步线程，异步方式则称为异步线程。异步效率高，复杂；同步效率低，简单。</p>
<p>同步线程用于处理客户逻辑，即逻辑单元；异步线程处理I&#x2F;O事件，即I&#x2F;O处理单元。</p>
<p>异步线程监听到客户请求后，将其封装成请求对象插入请求队列。请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象。</p>
<p><img src="/./../pic/image-20230425202757521.png" alt="image-20230425202757521"></p>
<p>半同步&#x2F;半异步模式的变体，半同步&#x2F;半反应堆模式：</p>
<p><img src="/./../pic/image-20230425203208587.png" alt="image-20230425203208587"></p>
<p>异步线程只有主线程，主线程插入请求队列的任务是就绪的连接socket。这说明改图采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这也是该模式半反应堆的含义。该模式存在如下缺点：</p>
<ol>
<li>主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而耗费CPU时间。</li>
<li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，工作线程较少，请求队列中任务对象越堆越多，客户端响应速度将越来越慢。</li>
</ol>
<p>下图描述了一种相对高效的半同步&#x2F;半异步模式：</p>
<p><img src="/./../pic/image-20230425203636019.png" alt="image-20230425203636019"></p>
<p>主线程只管监听socket，连接socket由工作线程来管理，此后该新socket上的任何I&#x2F;O操作都由被选中的工作线程来处理，直到客户关闭连接。</p>
<p>可见每个线程都维持自己的事件循环，它们各自独立地监听不同的事件。</p>
<p><strong>b) 领导者&#x2F;追随者模式</strong></p>
<p>该模式是多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件的一种模式。任何时间，程序仅有一个领导者，它负责监听I&#x2F;O事件。当前领导者如果检测到I&#x2F;O事件，首先从线程池中推选出新的领导者线程，然后处理I&#x2F;O事件。此时，新的领导者等待新的I&#x2F;O事件，原先的领导者则处理I&#x2F;O事件。</p>
<p>领导者&#x2F;追随者模式包含如下几个组件：句柄集(HandleSet)，线程集(ThreadSet)，事件处理器(EventHandler)和具体的事件处理器(ConcreteEventHandler)。</p>
<p><img src="/./../pic/image-20230425204250102.png" alt="image-20230425204250102"></p>
<p>​	<em>1.句柄集</em>：</p>
<p>句柄用于表示I&#x2F;O资源，句柄集管理众多句柄，它使用waif_for_event方法来监听句柄上的I&#x2F;O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定在Handle上的事件处理器来处理事件。领导者将Handle和事件处理器绑定是通过调用句柄集中的register_handle方法实现的。</p>
<p>​	<em>2.线程集:</em></p>
<p>所有工作线程的管理者，负责各线程之间的同步，以及新领导者线程的推选，任一线程必处于如下三种状态之一:</p>
<p>​	Leader：线程当前处于领导者线程，负责等待句柄集上的I&#x2F;O事件。</p>
<p>​	Processing：线程正在处理事件。领导者检测到I&#x2F;O之间之后，转移到该状态来处理事件，并调用promote_new_leader方法推选新的领导者；也可以指定其他追随者来处理时间，此时领导者地位不变。当处于Processing状态的线程处理完后，如果没有领导者，它将称为领导者，反之称为追随者。</p>
<p>​	Follower：线程当前处于追随者身份。通过调用join方法等待称为新的领导者，也可能被领导指定处理新任务。</p>
<p><img src="/./../pic/image-20230425205723444.png" alt="image-20230425205723444"></p>
<p>​	<em>3.事件处理器和具体的事件处理器</em></p>
<p>事件处理器通常包含一个或多个回调函数handle_event。这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用之前需要被绑定到某个句柄之上。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的handle_event方法，以处理特定的任务。</p>
<p><img src="/./../pic/image-20230425210007874.png" alt="image-20230425210007874"></p>
<p>由于领导者线程自己监听I&#x2F;O并处理客户请求，因此不需要在线程之间传递任何额外的数据，也无需像半同步&#x2F;半反应堆那样在线程之间同步堆请求队列的访问。</p>
<h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><h4 id="8-7-提高服务器性能的其他建议"><a href="#8-7-提高服务器性能的其他建议" class="headerlink" title="8.7 提高服务器性能的其他建议"></a>8.7 提高服务器性能的其他建议</h4><p>讨论从编程的角度来确保服务器的性能。</p>
<p><strong>a) 池</strong></p>
<p>假设在服务器的硬件资源充分的情况下，提高服务器性能的一个直接的方式即是空间换时间，即”浪费”服务器的硬件资源，以换取其运行效率。这就是池的概念。简单来说，池就是将一些需要用到的资源提前分配创建好，用的时候直接从其中取资源比动态分配资源的速度要快得多，处理完后，将资源放回池中。</p>
<p>根据不同的资源类型，池可分为多种，常见的有内存池，进程池，线程池和连接池。</p>
<p>内存池通常用于socket的接受缓存和发送缓存。预先分配一个大小足够的缓冲区。</p>
<p>线程池和进程池，当我们需要一个工作进程&#x2F;线程来处理客户请求时，可直接从池中取一个实体，而无需调用fork或pthread_create来创建。</p>
<p>连接池通常用于服务器或服务器集群的内部永久连接。</p>
<p><strong>b) 上下文切换和锁</strong></p>
<p>并发程序必须考虑上下文切换问题，即进程切换或线程切换导致的系统开销。即使是I&#x2F;O密集型的服务器，也不应该使用过多的工作线程，否则线程间的切换将占用大量的CPU时间。因此，为每个客户连接都创建一个工作线程的服务器是不可取的。图8-11的模式是一种比较合理的解决方案。</p>
<p>另一个问题是对共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为它引入的代码不处理任何业务逻辑，而且需要访问内核资源。如果服务器必须使用锁，考虑减小锁的粒度，比如使用读写锁。当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加额外的开销，只有当其中一个工作线程需要写这块内存时，才去上锁。</p>
<p><strong>c) 数据复制</strong></p>
<p>高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户和内核之间。比如ftp服务器，无需把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数发送，而是可用”零拷贝”的sendfile函数直接发送。</p>
<p>此外，用户代码内部的数据复制也是应该避免的。比如，两个工作进程之间需要传递大量的数时，我们应该考虑使用共享内存在他们之间直接共享这些数据，而不是使用管道或消息队列来传递。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AuroraFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/">http://example.com/2022/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Aurora</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/arch.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/17/UNP%20note/"><img class="prev-cover" src="/./img/cat8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UNP 学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/16/APUE%20note/"><img class="next-cover" src="/./img/background.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">APUE 学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/headd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AuroraFish</div><div class="author-info__description">保持幻想</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AuroraFish"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AuroraFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:205878047@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只是睡着了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux高性能服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-TCP-x2F-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">第1章 TCP&#x2F;IP 协议族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%97%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.1 TCP&#x2F;IP协议族体系结构以及主要协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B0%81%E8%A3%85"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">1.2 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%88%86%E7%94%A8"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">1.3 分用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">1.4 测试网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-ARP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">1.5 ARP协议工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-DNS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">1.6 DNS工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-socket-%E5%92%8C-TCP-x2F-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">1.7 socket 和 TCP&#x2F;IP 协议族的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.0.2.</span> <span class="toc-text">第2章 IP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-IP%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">2.1 IP服务的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-IPV4%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">2.2 IPV4头部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-IP%E5%88%86%E7%89%87"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">2.3 IP分片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-IP%E8%B7%AF%E7%94%B1"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">2.4 IP路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-IP%E8%BD%AC%E5%8F%91"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">2.5 IP转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">2.6 重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-IPV6%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">2.7 IPV6头部结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.0.3.</span> <span class="toc-text">第3章 TCP协议详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-TCP%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">3.1 TCP服务的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-TCP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">3.2 TCP头部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3.3 TCP连接的建立和关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">3.4 TCP状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%A4%8D%E4%BD%8D%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">3.5 复位报文段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-TCP%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">3.6 TCP交互数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-TCP%E6%88%90%E5%9D%97%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">3.7 TCP成块数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">3.8 带外数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">1.0.3.9.</span> <span class="toc-text">3.9 TCP超时重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.3.10.</span> <span class="toc-text">3.10 拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-TCP-x2F-IP%E9%80%9A%E4%BF%A1%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%AE%BF%E9%97%AEInternet%E4%B8%8A%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">第4章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%A4%BA%E4%BE%8B%E6%80%BB%E5%9B%BE"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">4.1 示例总图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">4.2 部署代理服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8F%96%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">4.3 使用tcpdump抓取传输的数据包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E8%AE%BF%E9%97%AEDNS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">4.4 访问DNS服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E6%9C%AC%E5%9C%B0%E5%90%8D%E7%A7%B0%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">4.5 本地名称查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-HTTP%E9%80%9A%E4%BF%A1"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">4.6 HTTP通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API"><span class="toc-number">1.0.5.</span> <span class="toc-text">第5章 Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-socket%E5%9C%B0%E5%9D%80API"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">5.1 socket地址API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BAsocket"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">5.2 创建socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%91%BD%E5%90%8Dsocket"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">5.3 命名socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E7%9B%91%E5%90%ACsocket"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">5.4 监听socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">5.5 接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">5.6 发起连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">5.7 关闭连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">1.0.5.8.</span> <span class="toc-text">5.8 数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="toc-number">1.0.5.9.</span> <span class="toc-text">5.9 带外标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.5.10.</span> <span class="toc-text">5.10 地址信息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-socket%E9%80%89%E9%A1%B9"><span class="toc-number">1.0.5.11.</span> <span class="toc-text">5.11 socket选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12-%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="toc-number">1.0.5.12.</span> <span class="toc-text">5.12 网络信息API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%AB%98%E7%BA%A7I-x2F-O%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.</span> <span class="toc-text">第6章 高级I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-pipe%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">6.1 pipe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-dup%E5%87%BD%E6%95%B0%E5%92%8Cdup2%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">6.2 dup函数和dup2函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-readv%E5%87%BD%E6%95%B0%E5%92%8Cwritev%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">6.3 readv函数和writev函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-sendfile%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">6.4 sendfile函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-mmap%E5%87%BD%E6%95%B0%E5%92%8Cmunmap%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">6.5 mmap函数和munmap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-splice%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.6.</span> <span class="toc-text">6.6 splice函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-tee%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.7.</span> <span class="toc-text">6.7 tee函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.8.</span> <span class="toc-text">6.8 fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="toc-number">1.0.7.</span> <span class="toc-text">第7章 Linux服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%97%A5%E5%BF%97"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">7.1 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">7.2 用户信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">7.3 进程间关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">7.4 系统资源限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">7.5 改变工作目录和根目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="toc-number">1.0.7.6.</span> <span class="toc-text">7.6 服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.0.8.</span> <span class="toc-text">第8章 高性能服务器程序框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">8.1 服务器模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">8.2 服务器编程框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">8.3 I&#x2F;O模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">8.4 两种高效的事件处理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">8.5 两种高效的并发模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.0.8.6.</span> <span class="toc-text">8.6 有限状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.0.8.7.</span> <span class="toc-text">8.7 提高服务器性能的其他建议</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记"><img src="/./img/cat8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UNP 学习笔记"/></a><div class="content"><a class="title" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记">UNP 学习笔记</a><time datetime="2023-03-17T09:38:55.000Z" title="发表于 2023-03-17 17:38:55">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记"><img src="/./img/arch.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器笔记"/></a><div class="content"><a class="title" href="/2022/11/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记">Linux高性能服务器笔记</a><time datetime="2022-11-07T01:38:55.000Z" title="发表于 2022-11-07 09:38:55">2022-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="APUE 学习笔记"/></a><div class="content"><a class="title" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记">APUE 学习笔记</a><time datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记note2"/></a><div class="content"><a class="title" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2">算法笔记note2</a><time datetime="2022-05-05T10:48:47.000Z" title="发表于 2022-05-05 18:48:47">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记题目"/></a><div class="content"><a class="title" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目">算法笔记题目</a><time datetime="2022-04-19T06:35:55.000Z" title="发表于 2022-04-19 14:35:55">2022-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: 颜色(white)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By AuroraFish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">饿死了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>