<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Effective C++ 笔记 | Aurora</title><meta name="author" content="AuroraFish"><meta name="copyright" content="AuroraFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++中你需要注意的一些条款">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ 笔记">
<meta property="og:url" content="http://example.com/2022/04/17/Effective%20note/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="C++中你需要注意的一些条款">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/background.png">
<meta property="article:published_time" content="2022-04-17T10:10:55.000Z">
<meta property="article:modified_time" content="2022-04-17T13:08:47.232Z">
<meta property="article:author" content="AuroraFish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/background.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/17/Effective%20note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++ 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-17 21:08:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/headd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/background.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aurora</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++ 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-17T10:10:55.000Z" title="发表于 2022-04-17 18:10:55">2022-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-17T13:08:47.232Z" title="更新于 2022-04-17 21:08:47">2022-04-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective C++ 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TR1-和-Boost"><a href="#TR1-和-Boost" class="headerlink" title="TR1 和 Boost"></a>TR1 和 Boost</h1><h3 id="条款-54-Tr1"><a href="#条款-54-Tr1" class="headerlink" title="条款 54 Tr1"></a>条款 54 Tr1</h3><h5 id="“Technical-Report-1”-是一份规范，描述加入C-标准程序库的诸多新机能"><a href="#“Technical-Report-1”-是一份规范，描述加入C-标准程序库的诸多新机能" class="headerlink" title="“Technical Report 1”, 是一份规范，描述加入C++标准程序库的诸多新机能."></a><u>“Technical Report 1”,</u> 是一份规范，描述加入C++标准程序库的诸多新机能.</h5><h3 id="条款-55-Boost"><a href="#条款-55-Boost" class="headerlink" title="条款 55 Boost"></a>条款 55 Boost</h3><h5 id="Boost-是个组织-x2F-网站-提供开源的C-程序库"><a href="#Boost-是个组织-x2F-网站-提供开源的C-程序库" class="headerlink" title="Boost 是个组织&#x2F;网站, 提供开源的C++程序库"></a><u>Boost 是个组织&#x2F;网站</u>, 提供开源的C++程序库</h5><h1 id="条款-01"><a href="#条款-01" class="headerlink" title="条款 01 :"></a>条款 01 :</h1><h4 id="1-C"><a href="#1-C" class="headerlink" title="1.C"></a>1.C</h4><h4 id="2-Object-Oriented-C-oop"><a href="#2-Object-Oriented-C-oop" class="headerlink" title="2.Object-Oriented C++ (oop)"></a>2.Object-Oriented C++ (oop)</h4><h4 id="3-Template-C"><a href="#3-Template-C" class="headerlink" title="3.Template C++"></a>3.Template C++</h4><h4 id="4-STL"><a href="#4-STL" class="headerlink" title="4.STL"></a>4.STL</h4><h1 id="条款-02-使用const-enum-inline替换-define"><a href="#条款-02-使用const-enum-inline替换-define" class="headerlink" title="条款 02 : 使用const,enum,inline替换#define"></a>条款 02 : 使用const,enum,inline替换#define</h1><h4 id="1-const"><a href="#1-const" class="headerlink" title="1.const"></a>1.const</h4><h4 id="2-enum-类内使用相当于常量"><a href="#2-enum-类内使用相当于常量" class="headerlink" title="2.enum 类内使用相当于常量"></a>2.enum 类内使用相当于常量</h4><h4 id="3-inline-替换-define-定义的函数"><a href="#3-inline-替换-define-定义的函数" class="headerlink" title="3.inline 替换 #define 定义的函数"></a>3.inline 替换 #define 定义的函数</h4><h1 id="条款-03-尽可能使用const"><a href="#条款-03-尽可能使用const" class="headerlink" title="条款 03 : 尽可能使用const"></a>条款 03 : 尽可能使用const</h1><h4 id="1-对于不做更改打算的-尽量使用const-防止出现-a-b-x3D-x3D-c写成赋值的错误"><a href="#1-对于不做更改打算的-尽量使用const-防止出现-a-b-x3D-x3D-c写成赋值的错误" class="headerlink" title="1.对于不做更改打算的,尽量使用const,防止出现 a*b &#x3D;&#x3D; c写成赋值的错误"></a>1.对于不做更改打算的,尽量使用const,防止出现 <u>a*b &#x3D;&#x3D; c</u>写成赋值的错误</h4><h4 id="2-mutabel-释放掉const的约束"><a href="#2-mutabel-释放掉const的约束" class="headerlink" title="2.mutabel 释放掉const的约束"></a>2.<u>mutabel</u> 释放掉<u>const</u>的约束</h4><h4 id="3-const-与-non-const-一个op-的例子-说明可以籍由non-const-调用const-但绝对不能反向操作-籍由const-调用non-const"><a href="#3-const-与-non-const-一个op-的例子-说明可以籍由non-const-调用const-但绝对不能反向操作-籍由const-调用non-const" class="headerlink" title="3.const 与 non-const 一个op[] 的例子,说明可以籍由non-const 调用const,但绝对不能反向操作,籍由const 调用non-const,"></a>3.<u>const</u> 与 <u>non-const</u> 一个op[] 的例子,说明可以籍由<u>non-const</u> 调用<u>const</u>,但绝对不能反向操作,籍由const 调用<u>non-const</u>,</h4><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-声明为const有助于编译器侦察错误用法"><a href="#1-声明为const有助于编译器侦察错误用法" class="headerlink" title="1.声明为const有助于编译器侦察错误用法"></a>1.声明为const有助于编译器侦察错误用法</h4><h4 id="2-编译器强制实施bitwise-constness-const一切都不能更改-用户应该使用”概念上的常量性”-用mutable实现"><a href="#2-编译器强制实施bitwise-constness-const一切都不能更改-用户应该使用”概念上的常量性”-用mutable实现" class="headerlink" title="2.编译器强制实施bitwise constness(const一切都不能更改),用户应该使用”概念上的常量性”,用mutable实现"></a>2.编译器强制实施<u>bitwise constness</u>(const一切都不能更改),用户应该使用”概念上的常量性”,用mutable实现</h4><h4 id="3-用const-来避免代码复用-通过non-const-调用-const"><a href="#3-用const-来避免代码复用-通过non-const-调用-const" class="headerlink" title="3.用const 来避免代码复用,通过non-const 调用 const"></a>3.用<u>const</u> 来避免代码复用,通过<u>non-const</u> 调用 <u>const</u></h4><h1 id="条款-04-确定对象被使用前已初始化"><a href="#条款-04-确定对象被使用前已初始化" class="headerlink" title="条款 04 : 确定对象被使用前已初始化"></a>条款 04 : 确定对象被使用前已初始化</h1><h4 id="1-对于C-part-of-C-和-non-C-parts-of-C-初始化规则有点不同-最好的办法是对于所有的对象都初始化"><a href="#1-对于C-part-of-C-和-non-C-parts-of-C-初始化规则有点不同-最好的办法是对于所有的对象都初始化" class="headerlink" title="1.对于C part of C++ 和 non-C parts of C++ 初始化规则有点不同,最好的办法是对于所有的对象都初始化"></a>1.对于<u>C part of C++</u> 和 <u>non-C parts of C++</u> 初始化规则有点不同,最好的办法是对于所有的对象都初始化</h4><h4 id="2-对于构造函数可以使用初始化列表技术-对于部分构造可以选择性的在构造函数体中使用赋值来替换初始化"><a href="#2-对于构造函数可以使用初始化列表技术-对于部分构造可以选择性的在构造函数体中使用赋值来替换初始化" class="headerlink" title="2.对于构造函数可以使用初始化列表技术,对于部分构造可以选择性的在构造函数体中使用赋值来替换初始化"></a>2.对于构造函数可以使用初始化列表技术,对于部分构造可以选择性的在构造函数体中使用赋值来替换初始化</h4><h4 id="3-“成员初始化次序”-base-classes更早于其他derived-classes-而class的成员变量总以其声明次序被初始化"><a href="#3-“成员初始化次序”-base-classes更早于其他derived-classes-而class的成员变量总以其声明次序被初始化" class="headerlink" title="3.“成员初始化次序” ,base classes更早于其他derived classes,而class的成员变量总以其声明次序被初始化"></a>3.<u>“成员初始化次序”</u> ,<u>base classes</u>更早于其他<u>derived classes</u>,而class的成员变量总以其声明次序被初始化</h4><h4 id="4-“不同编译单元内定义non-local-static对象”"><a href="#4-“不同编译单元内定义non-local-static对象”" class="headerlink" title="4.“不同编译单元内定义non-local static对象”"></a>4.<u>“不同编译单元内定义non-local static对象”</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>h</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;                  <span class="comment">// 另一翻译单元中的non-local static 对象</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span>cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>( params );</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>( params )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = tfs.<span class="built_in">numDisks</span>(); <span class="comment">// 使用 tfs 对象  </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果想调用Directory的构造-则-tfs-的初始必须在之前-但C-对“定义于不同的编译单元内的non-local-static对象”的初始化相对次序无明确定义"><a href="#如果想调用Directory的构造-则-tfs-的初始必须在之前-但C-对“定义于不同的编译单元内的non-local-static对象”的初始化相对次序无明确定义" class="headerlink" title="如果想调用Directory的构造 则 tfs 的初始必须在之前,但C++对“定义于不同的编译单元内的non-local static对象”的初始化相对次序无明确定义."></a>如果想调用Directory的构造 则 tfs 的初始必须在之前,但C++对<u>“定义于不同的编译单元内的non-local static对象”</u>的初始化相对次序无明确定义.</h4><h4 id="一个小小的设计-将每个non-local-static对象搬到自己的专属函数内-这些函数返回一个reference指向它所含的对象-用户调用这些函数-而不直接涉猎这些对象"><a href="#一个小小的设计-将每个non-local-static对象搬到自己的专属函数内-这些函数返回一个reference指向它所含的对象-用户调用这些函数-而不直接涉猎这些对象" class="headerlink" title="一个小小的设计:将每个non-local static对象搬到自己的专属函数内,这些函数返回一个reference指向它所含的对象,用户调用这些函数,而不直接涉猎这些对象"></a>一个小小的设计:将每个non-local static对象搬到自己的专属函数内,这些函数返回一个reference指向它所含的对象,用户调用这些函数,而不直接涉猎这些对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>h</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123; ... &#125;;</span><br><span class="line"><span class="function">FileSystem &amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line">#<span class="number">2.</span>cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> &#123; ... &#125;;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory &amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-为内置对象手动初始化-C-不保证初始化他们"><a href="#1-为内置对象手动初始化-C-不保证初始化他们" class="headerlink" title="1.为内置对象手动初始化,C++不保证初始化他们"></a>1.为内置对象手动初始化,C++不保证初始化他们</h4><h4 id="2-对构造函数使用初始化列表技术"><a href="#2-对构造函数使用初始化列表技术" class="headerlink" title="2.对构造函数使用初始化列表技术"></a>2.对构造函数使用初始化列表技术</h4><h4 id="3-对于跨编译单元的non-local-static-对象的处理"><a href="#3-对于跨编译单元的non-local-static-对象的处理" class="headerlink" title="3.对于跨编译单元的non-local static 对象的处理"></a>3.对于跨编译单元的non-local static 对象的处理</h4><h1 id="条款-05-了解C-默认编写并调用哪些函数"><a href="#条款-05-了解C-默认编写并调用哪些函数" class="headerlink" title="条款 05 : 了解C++默认编写并调用哪些函数"></a>条款 05 : 了解C++默认编写并调用哪些函数</h1><h4 id="1-default构造-copy构造-copy-assignment赋值-析构"><a href="#1-default构造-copy构造-copy-assignment赋值-析构" class="headerlink" title="1.default构造,copy构造,copy assignment赋值,析构"></a>1.default构造,copy构造,<u>copy assignment</u>赋值,析构</h4><h4 id="2-编译器提供的copy为浅拷贝"><a href="#2-编译器提供的copy为浅拷贝" class="headerlink" title="2.编译器提供的copy为浅拷贝"></a>2.编译器提供的copy为浅拷贝</h4><h4 id="3-编译器产出的析构为non-vitrual析构"><a href="#3-编译器产出的析构为non-vitrual析构" class="headerlink" title="3.编译器产出的析构为non-vitrual析构"></a>3.编译器产出的析构为<u>non-vitrual</u>析构</h4><h4 id="4-如果已声明构造-编译器不会再提供default构造"><a href="#4-如果已声明构造-编译器不会再提供default构造" class="headerlink" title="4.如果已声明构造,编译器不会再提供default构造"></a>4.如果已声明构造,编译器不会再提供default构造</h4><h4 id="5-对于内含reference成员的类-应提供自定义copy-assignment"><a href="#5-对于内含reference成员的类-应提供自定义copy-assignment" class="headerlink" title="5.对于内含reference成员的类,应提供自定义copy assignment"></a>5.对于内含<u>reference</u>成员的类,应提供自定义<u>copy assignment</u></h4><h4 id="6-如果将base-class-的-copy-assignment-声明为-private，则-derived-class-编译器不会提供copy-assignment"><a href="#6-如果将base-class-的-copy-assignment-声明为-private，则-derived-class-编译器不会提供copy-assignment" class="headerlink" title="6.如果将base class 的 copy assignment 声明为 private，则 derived class 编译器不会提供copy assignment"></a>6.如果将<u>base class</u> 的 <u>copy assignment</u> 声明为 <u>private</u>，则 derived class 编译器不会提供<u>copy assignment</u></h4><h1 id="条款-06-若不想使用编译器自动生成的函数-应该明确拒绝"><a href="#条款-06-若不想使用编译器自动生成的函数-应该明确拒绝" class="headerlink" title="条款 06 : 若不想使用编译器自动生成的函数,应该明确拒绝"></a>条款 06 : 若不想使用编译器自动生成的函数,应该明确拒绝</h1><h4 id="1-如何拒绝使用编译器提供的copy构造和copy-assignment"><a href="#1-如何拒绝使用编译器提供的copy构造和copy-assignment" class="headerlink" title="1.如何拒绝使用编译器提供的copy构造和copy assignment"></a>1.如何拒绝使用编译器提供的<u>copy</u>构造和<u>copy assignment</u></h4><h4 id="2-将其声明为private-但不定义-对其进行copy行为时会给出编译错误或连接性错误-编译错误源自private类外不能访问-链接性错误源自member-或-friend-函数链接不到其定义"><a href="#2-将其声明为private-但不定义-对其进行copy行为时会给出编译错误或连接性错误-编译错误源自private类外不能访问-链接性错误源自member-或-friend-函数链接不到其定义" class="headerlink" title="2.将其声明为private(但不定义),对其进行copy行为时会给出编译错误或连接性错误,编译错误源自private类外不能访问,链接性错误源自member 或 friend 函数链接不到其定义"></a>2.将其声明为<u>private</u>(但不定义),对其进行<u>copy</u>行为时会给出编译错误或连接性错误,编译错误源自<u>private</u>类外不能访问,链接性错误源自member 或 <u>friend</u> 函数链接不到其定义</h4><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-为驳回编译器自动提供的机能-可将其对应的成员函数声明为private-并且不予定义-或使用像-Uncopyable-这样的-base-class"><a href="#1-为驳回编译器自动提供的机能-可将其对应的成员函数声明为private-并且不予定义-或使用像-Uncopyable-这样的-base-class" class="headerlink" title="1.为驳回编译器自动提供的机能,可将其对应的成员函数声明为private 并且不予定义,或使用像 Uncopyable 这样的 base class"></a>1.为驳回编译器自动提供的机能,可将其对应的成员函数声明为<u>private</u> 并且不予定义,或使用像 Uncopyable 这样的 <u>base class</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#第一种方式</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">HomeForSale</span>(<span class="type">const</span> HomeForSale&amp;);                <span class="comment">//只有声明</span></span><br><span class="line">    HomeforSale &amp; <span class="keyword">operator</span>=(<span class="type">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">#第二种方式</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;                                  <span class="comment">//允许derived 对象构造和析构</span></span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);      <span class="comment">// 组织 copy</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//为防止HomeForSale对象被拷贝,只需继承Uncopyable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeForSale</span>:<span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>



<h1 id="条款-07-为多态基类声明virtual析构函数"><a href="#条款-07-为多态基类声明virtual析构函数" class="headerlink" title="条款 07 : 为多态基类声明virtual析构函数"></a>条款 07 : 为多态基类声明virtual析构函数</h1><h4 id="1-如果base-class-析构不是vitrual-当derived-class-对象经由一个base-class-指针删除，通常发生derived-成分没销毁-导致”局部销毁”-内存泄露-应给base-class-一个virtual析构函数-这样就能正常销毁整个对象-包括derived-class-成分"><a href="#1-如果base-class-析构不是vitrual-当derived-class-对象经由一个base-class-指针删除，通常发生derived-成分没销毁-导致”局部销毁”-内存泄露-应给base-class-一个virtual析构函数-这样就能正常销毁整个对象-包括derived-class-成分" class="headerlink" title="1.如果base class 析构不是vitrual,当derived class 对象经由一个base class 指针删除，通常发生derived 成分没销毁,导致”局部销毁”,内存泄露,应给base class 一个virtual析构函数,这样就能正常销毁整个对象,包括derived class 成分"></a>1.如果<u>base class</u> 析构不是<u>vitrual</u>,当<u>derived class</u> 对象经由一个base class 指针删除，通常发生derived 成分没销毁,导致”局部销毁”,内存泄露,应给<u>base class 一个virtual析构函数,这样就能正常销毁整个对象,包括derived class 成分</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#例子</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeKeeper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TimeKeeper</span>();</span><br><span class="line">    ...;</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper * ptk = <span class="built_in">getTimeKeeper</span>();   <span class="comment">//getTimeKeeper 返回一个指向derived 对象的base 指针</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;                           <span class="comment">//现在行为正确</span></span><br></pre></td></tr></table></figure>

<h4 id="2-如果没有意图用于base-class-则不应该令其析构为virtual，virtual声明会导致类创建vptr-虚表指针-会导致不必要的内存开支-只有当class内至少含有一个virtual函数，才为它声明virtual析构函数"><a href="#2-如果没有意图用于base-class-则不应该令其析构为virtual，virtual声明会导致类创建vptr-虚表指针-会导致不必要的内存开支-只有当class内至少含有一个virtual函数，才为它声明virtual析构函数" class="headerlink" title="2.如果没有意图用于base class 则不应该令其析构为virtual，virtual声明会导致类创建vptr(虚表指针),会导致不必要的内存开支,只有当class内至少含有一个virtual函数，才为它声明virtual析构函数"></a>2.如果没有意图用于<u>base class</u> 则不应该令其析构为virtual，<u>virtual</u>声明会导致类创建vptr(虚表指针),会导致不必要的内存开支,只有当<u>class</u>内至少含有一个virtual函数，才为它声明<u>virtual</u>析构函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#例子</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord);</span><br><span class="line">    ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果int占32位,则point对象刚好可塞入64-bit缓存器，此时如果声明位virtual,多余的开支导致其不能恰好塞入</span></span><br></pre></td></tr></table></figure>

<h4 id="3-pure-virtual-纯虚-gt-abstract-抽象-classes-—-不能被实例化的class"><a href="#3-pure-virtual-纯虚-gt-abstract-抽象-classes-—-不能被实例化的class" class="headerlink" title="3.pure virtual (纯虚)-&gt;abstract(抽象) classes — 不能被实例化的class"></a>3.<u>pure virtual</u> (纯虚)-&gt;<u>abstract</u>(抽象) classes — 不能被实例化的class</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMOV</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AMOV</span>()=<span class="number">0</span>;   <span class="comment">//声明位 pure virtual 析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line">AMOV::~<span class="built_in">AMOV</span>()&#123;&#125;          <span class="comment">//pure virtual 析构函数的定义</span></span><br></pre></td></tr></table></figure>

<h4 id="只要class含有一个pure-virtual-函数-则这个类为抽象类-注意事项-你必须为这个pure-virtual-析构函数提供一份定义"><a href="#只要class含有一个pure-virtual-函数-则这个类为抽象类-注意事项-你必须为这个pure-virtual-析构函数提供一份定义" class="headerlink" title="只要class含有一个pure virtual 函数,则这个类为抽象类,注意事项:你必须为这个pure virtual 析构函数提供一份定义"></a>只要class含有一个pure virtual 函数,则这个类为抽象类,注意事项:你必须为这个<u>pure virtual</u> 析构函数提供一份定义</h4><h4 id="4-析构函数的运作规则-由最外层的-derived-class-开始析构-然后是其每一个-base-class的析构函数被调用-编译器会在AMOV的-derived-classes-的析构函数中创建一个对-AMOV的调用动作-所以你必须为这个函数提供一份定义-第3点-否则连接器会报错"><a href="#4-析构函数的运作规则-由最外层的-derived-class-开始析构-然后是其每一个-base-class的析构函数被调用-编译器会在AMOV的-derived-classes-的析构函数中创建一个对-AMOV的调用动作-所以你必须为这个函数提供一份定义-第3点-否则连接器会报错" class="headerlink" title="4.析构函数的运作规则,由最外层的 derived class 开始析构,然后是其每一个 base class的析构函数被调用.编译器会在AMOV的 derived classes 的析构函数中创建一个对~AMOV的调用动作,所以你必须为这个函数提供一份定义(第3点),否则连接器会报错"></a>4.析构函数的运作规则,由最外层的 derived class 开始析构,然后是其每一个 <u>base class</u>的析构函数被调用.<u>编译器会在AMOV的 derived classes 的析构函数中创建一个对~AMOV的调用动作,所以你必须为这个函数提供一份定义(第3点),否则连接器会报错</u></h4><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-对于具有多态性质的base-classes-应该声明一个virtual-析构函数-或者class带有任何virtual函数，它也应该拥有virtual-析构"><a href="#1-对于具有多态性质的base-classes-应该声明一个virtual-析构函数-或者class带有任何virtual函数，它也应该拥有virtual-析构" class="headerlink" title="1.对于具有多态性质的base classes 应该声明一个virtual 析构函数,或者class带有任何virtual函数，它也应该拥有virtual 析构"></a>1.对于具有多态性质的<u>base classes</u> 应该声明一个<u>virtual</u> 析构函数,或者class带有任何<u>virtua</u>l函数，它也应该拥有virtual 析构</h4><h4 id="2-如果class的目的不是作为base-class-则不应该声明virtual析构函数"><a href="#2-如果class的目的不是作为base-class-则不应该声明virtual析构函数" class="headerlink" title="2.如果class的目的不是作为base class 则不应该声明virtual析构函数"></a>2.如果class的目的不是作为<u>base class</u> 则不应该声明<u>virtual</u>析构函数</h4><h1 id="条款-08-别让异常逃离析构函数"><a href="#条款-08-别让异常逃离析构函数" class="headerlink" title="条款 08 : 别让异常逃离析构函数"></a>条款 08 : 别让异常逃离析构函数</h1><h4 id="1-如果析构吐出异常，则会导致程序提前结束或出现不明确的行为"><a href="#1-如果析构吐出异常，则会导致程序提前结束或出现不明确的行为" class="headerlink" title="1.如果析构吐出异常，则会导致程序提前结束或出现不明确的行为"></a>1.如果析构吐出异常，则会导致程序提前结束或出现不明确的行为</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#例子:<span class="keyword">class</span> 负责数据库连接</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> DBConnection <span class="title">creat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;                 <span class="comment">//关闭联机,失败则抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line">#为防止客户忘记调用<span class="built_in">close</span>(),一个合理的想法是创建一个<span class="keyword">class</span>用来管理</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">DBConn</span>()                     <span class="comment">//析构函数确保数据库连接总是会被关闭</span></span><br><span class="line">    &#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::creat())</span></span>; </span><br><span class="line">    <span class="comment">//建立一个 DBConnection 对象并交给DBConn对象管理</span></span><br><span class="line">    <span class="comment">//通过DBConn的接口使用DBConnection对象</span></span><br><span class="line">    <span class="comment">//在区块结束时,DBConn对象销毁调用析构函数,自动为DBConnection对象调用close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-如果调用失败则会抛出异常，导致问题-两种解决方法"><a href="#2-如果调用失败则会抛出异常，导致问题-两种解决方法" class="headerlink" title="2.如果调用失败则会抛出异常，导致问题,两种解决方法"></a>2.如果调用失败则会抛出异常，导致问题,两种解决方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>如果close抛出异常就结束程序，通过调用abort完成</span><br><span class="line">DBConn::~<span class="built_in">DBConn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        制作运转记录,记下对close的调用失败;</span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在导致&quot;不明确行为&quot;前，强迫结束程序</span></span><br><span class="line">#<span class="number">2.</span>吞下close导致的异常</span><br><span class="line">DBConn::~<span class="built_in">DBConn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        制作转运记录,记下对close的调用失败;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-上述方法用处不大，一个更好的解决方法为为客户提供一个处理发生异常的机会"><a href="#3-上述方法用处不大，一个更好的解决方法为为客户提供一个处理发生异常的机会" class="headerlink" title="3.上述方法用处不大，一个更好的解决方法为为客户提供一个处理发生异常的机会"></a>3.上述方法用处不大，一个更好的解决方法为为客户提供一个处理发生异常的机会</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span>                               <span class="comment">//为客户提供的处理接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">            <span class="built_in">catch</span> (...)&#123;                        <span class="comment">//如果抛出异常</span></span><br><span class="line">                制作运转记录,记下对close的调用失败; <span class="comment">//记录下来并结束程序或吞下异常</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那这个异常必须来自析构函数以外的某个函数，因为析构函数抛出异常很危险，会导致提前结束程序的风险，或发生不明确行为"><a href="#如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那这个异常必须来自析构函数以外的某个函数，因为析构函数抛出异常很危险，会导致提前结束程序的风险，或发生不明确行为" class="headerlink" title="如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那这个异常必须来自析构函数以外的某个函数，因为析构函数抛出异常很危险，会导致提前结束程序的风险，或发生不明确行为"></a><u>如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那这个异常必须来自析构函数以外的某个函数，因为析构函数抛出异常很危险，会导致提前结束程序的风险，或发生不明确行为</u></h4><h2 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-析构函数不应抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下它或提前结束程序"><a href="#1-析构函数不应抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下它或提前结束程序" class="headerlink" title="1.析构函数不应抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下它或提前结束程序"></a>1.析构函数不应抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下它或提前结束程序</h4><h4 id="2-可以给客户提供一个处理程序中异常的接口，一个普通函数"><a href="#2-可以给客户提供一个处理程序中异常的接口，一个普通函数" class="headerlink" title="2.可以给客户提供一个处理程序中异常的接口，一个普通函数"></a>2.可以给客户提供一个处理程序中异常的接口，一个普通函数</h4><h1 id="条款-09-绝不在构造和析构过程中调用virtual函数"><a href="#条款-09-绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款 09 : 绝不在构造和析构过程中调用virtual函数"></a>条款 09 : 绝不在构造和析构过程中调用virtual函数</h1><h4 id="1-在base-class-构造期间-virtual-函数不是-virtual-函数"><a href="#1-在base-class-构造期间-virtual-函数不是-virtual-函数" class="headerlink" title="1.在base class 构造期间,virtual 函数不是 virtual 函数"></a>1.在base class 构造期间,virtual 函数不是 virtual 函数</h4><h4 id="2-在derived-class-对象的base-class-构造期间-对象类型是base-class-不是derived-class"><a href="#2-在derived-class-对象的base-class-构造期间-对象类型是base-class-不是derived-class" class="headerlink" title="2.在derived class 对象的base class 构造期间,对象类型是base class,不是derived class"></a>2.在derived class 对象的base class 构造期间,对象类型是base class,不是derived class</h4><h4 id="3-确定你的构造函数都没有-在对象被创建和被销毁期间-调用virtual函数-而它们调用的函数也都服从同一约束"><a href="#3-确定你的构造函数都没有-在对象被创建和被销毁期间-调用virtual函数-而它们调用的函数也都服从同一约束" class="headerlink" title="3.确定你的构造函数都没有(在对象被创建和被销毁期间)调用virtual函数,而它们调用的函数也都服从同一约束,"></a>3.确定你的构造函数都没有(在对象被创建和被销毁期间)调用virtual函数,而它们调用的函数也都服从同一约束,</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#错误示例<span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();                              <span class="comment">//调用 non-virtual</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">logTransaction</span>();                    <span class="comment">//调用virtual!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#正确示例<span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string &amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std::string &amp; logInfo)</span><span class="type">const</span></span>; <span class="comment">//现为non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string &amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>:<span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>( parameters )</span><br><span class="line">        :<span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>( parameters ))        <span class="comment">//将log信息向上传给base class构造</span></span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">creatLogString</span><span class="params">( parameters )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="注意本例中比起-初始化列表内直接给予数据-利用辅助函数创建一个值传给构造函数更方便-更可读-声明为static-防止出现-“那些成员变量处于为定义状态”"><a href="#注意本例中比起-初始化列表内直接给予数据-利用辅助函数创建一个值传给构造函数更方便-更可读-声明为static-防止出现-“那些成员变量处于为定义状态”" class="headerlink" title="注意本例中比起 初始化列表内直接给予数据 利用辅助函数创建一个值传给构造函数更方便(更可读),声明为static 防止出现 “那些成员变量处于为定义状态”"></a><u>注意本例中比起 初始化列表内直接给予数据 利用辅助函数创建一个值传给构造函数更方便(更可读),声明为static 防止出现 “那些成员变量处于为定义状态”</u></h4><h2 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-在构造和析构期间不要调用virtual函数，因为这类调用不会下降至derived-class-换句话说在base-class-构造期间-virtua函数调用属于base的那个"><a href="#1-在构造和析构期间不要调用virtual函数，因为这类调用不会下降至derived-class-换句话说在base-class-构造期间-virtua函数调用属于base的那个" class="headerlink" title="1.在构造和析构期间不要调用virtual函数，因为这类调用不会下降至derived class,换句话说在base class 构造期间,virtua函数调用属于base的那个"></a>1.在构造和析构期间不要调用virtual函数，因为这类调用不会下降至derived class,换句话说在base class 构造期间,virtua函数调用属于base的那个</h4><h1 id="条款-10-令operator-x3D-返回一个reference-to-this"><a href="#条款-10-令operator-x3D-返回一个reference-to-this" class="headerlink" title="条款 10 : 令operator&#x3D;返回一个reference to *this"></a>条款 10 : 令operator&#x3D;返回一个reference to *this</h1><h4 id="1-不仅仅适用于-x3D-也适用于-x3D-x3D-x3D-等等"><a href="#1-不仅仅适用于-x3D-也适用于-x3D-x3D-x3D-等等" class="headerlink" title="1.不仅仅适用于&#x3D;,也适用于+&#x3D;,-&#x3D;,*&#x3D;等等"></a>1.不仅仅适用于&#x3D;,也适用于+&#x3D;,-&#x3D;,*&#x3D;等等</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//理由 为了实现连锁赋值,实现和内置数据类型一样的功能</span></span><br><span class="line"><span class="comment">//int x,y,z; x = y = z = 15;</span></span><br><span class="line">#示例<span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">#适用于其他赋值相关运算</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//此函数也适用,即使此一操作符的参数类型不符协定</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-这仅仅是个协议，无强制性，如果你有自己的实现需求，可以不遵守它"><a href="#2-这仅仅是个协议，无强制性，如果你有自己的实现需求，可以不遵守它" class="headerlink" title="2.这仅仅是个协议，无强制性，如果你有自己的实现需求，可以不遵守它"></a>2.这仅仅是个协议，无强制性，如果你有自己的实现需求，可以不遵守它</h4><h2 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-令assignment-赋值-操作符返回一个-reference-to-this"><a href="#1-令assignment-赋值-操作符返回一个-reference-to-this" class="headerlink" title="1.令assignment(赋值)操作符返回一个 reference to * this"></a>1.令assignment(赋值)操作符返回一个 reference to * this</h4><h1 id="条款-11-在operator-x3D-中处理”自我赋值”"><a href="#条款-11-在operator-x3D-中处理”自我赋值”" class="headerlink" title="条款 11 : 在operator&#x3D;中处理”自我赋值”"></a>条款 11 : 在operator&#x3D;中处理”自我赋值”</h1><h4 id="1-不处理自我赋值的后果-在“停止使用资源前意外释放了它”"><a href="#1-不处理自我赋值的后果-在“停止使用资源前意外释放了它”" class="headerlink" title="1.不处理自我赋值的后果,在“停止使用资源前意外释放了它”"></a>1.不处理自我赋值的后果,在<u>“停止使用资源前意外释放了它”</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#示例</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Bitmap * pb;         <span class="comment">//指向一个从heap分配而得的对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget &amp; rhs)   <span class="comment">//一份未防止自我赋值的 assignment copy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;                                  <span class="comment">//释放当前的内存</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);                   <span class="comment">//使用rhs的副本</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有处理&quot;自我赋值&quot; *this 和 rhs 可能为同一对象,</span></span><br></pre></td></tr></table></figure>

<h4 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2.解决方式"></a>2.解决方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#证同测试</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺陷:不具备&quot;异常安全性&quot;,如果&quot;new Bitmap&quot;导致异常,Widget最终会持有一个被删除的Bitmap</span></span><br><span class="line"><span class="comment">//#恰当的语句顺序 另外让operator= 具备&quot;异常安全性&quot;往往自动获得&quot;自我赋值安全&quot;</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap * pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺陷:不是效率最高的方法,但行得通</span></span><br><span class="line"><span class="comment">//#copy and swap 技术</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget &amp; rhs)</span></span>;         <span class="comment">//交换*this 和 rhs 的数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);                <span class="comment">//为 rhs 数据制作一份副本</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);                      <span class="comment">//将*this 和 temp 交换</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法的另一版本,copy assignment &quot;以 by value 方式接受实参&quot; ,该方式传递会早成一份副本</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);                       <span class="comment">//pass by value</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺陷:牺牲了代码的清晰性,但更高效</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-确保处理”自我赋值”，包括上述三种方式的技术可以处理"><a href="#1-确保处理”自我赋值”，包括上述三种方式的技术可以处理" class="headerlink" title="1.确保处理”自我赋值”，包括上述三种方式的技术可以处理"></a>1.确保处理”<u>自我赋值”</u>，包括上述三种方式的技术可以处理</h4><h4 id="2-确定任何函数如果操作一个以上的对象-而其中多个对象是同一个对象时-其行为任然正确-就像第一个示例中-赋值-和-被赋值-的对象是同一个"><a href="#2-确定任何函数如果操作一个以上的对象-而其中多个对象是同一个对象时-其行为任然正确-就像第一个示例中-赋值-和-被赋值-的对象是同一个" class="headerlink" title="2.确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为任然正确,就像第一个示例中 赋值 和 被赋值 的对象是同一个"></a>2.确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为任然正确,就像第一个示例中 赋值 和 被赋值 的对象是同一个</h4><h1 id="条款-12-复制对象时勿忘其每一个成分"><a href="#条款-12-复制对象时勿忘其每一个成分" class="headerlink" title="条款 12 : 复制对象时勿忘其每一个成分"></a>条款 12 : 复制对象时勿忘其每一个成分</h1><h4 id="1-往类中新添成员-同时也需要修改copying函数-编译器不会提醒-导致可能局部拷贝"><a href="#1-往类中新添成员-同时也需要修改copying函数-编译器不会提醒-导致可能局部拷贝" class="headerlink" title="1.往类中新添成员,同时也需要修改copying函数,编译器不会提醒,导致可能局部拷贝"></a>1.往类中<u>新添成员</u>,同时也需要修改copying函数,<u>编译器不会提醒</u>,导致可能局部拷贝</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logCall</span><span class="params">(<span class="type">const</span> std::string &amp; funcName)</span></span>;  <span class="comment">//制作一个log entry</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Customer</span>(<span class="type">const</span> Customer &amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer &amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line">Customer::<span class="built_in">Customer</span>(<span class="type">const</span> Customer &amp; rhs):<span class="built_in">name</span>(rhs.name)  <span class="comment">//复制</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="type">const</span> Customer &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy assignment operator&quot;</span>);</span><br><span class="line">    name = rhs.name;                                     <span class="comment">//复制</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#2           往类中新添成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123; ... &#125;;          <span class="comment">//日期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...                      <span class="comment">//同前</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#3       如果发生继承，可能导致严重的潜藏危机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>:<span class="keyword">public</span> Customer               <span class="comment">//derived class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer &amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer &amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//没有指定实参传给 base class 的构造函数，base class 将调用不带参数的构造(default构造)</span></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer &amp; rhs)</span><br><span class="line"> :<span class="built_in">Priority</span>(rhs.Priority)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Priority = rhs.Priority;</span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#4</span></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer &amp; rhs)</span><br><span class="line"> :<span class="built_in">Customer</span>(rhs),<span class="built_in">Priority</span>(rhs.Priority) <span class="comment">//调用base class 的 copy构造函数</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);          <span class="comment">//对base class 成分进行复制动作</span></span><br><span class="line">    Priority = rhs.Priority;</span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-当你编写一个copying函数，确保复制所有local成员变量，调用所有base-class内适当的copying函数"><a href="#2-当你编写一个copying函数，确保复制所有local成员变量，调用所有base-class内适当的copying函数" class="headerlink" title="2.当你编写一个copying函数，确保复制所有local成员变量，调用所有base class内适当的copying函数"></a>2.<u>当你编写一个copying函数，确保复制所有local成员变量，调用所有base class内适当的copying函数</u></h4><h4 id="3-你不该令copy-assignment操作符-调用-copy构造函数-反过来也不能令copy构造函数调用copy-assignment操作符"><a href="#3-你不该令copy-assignment操作符-调用-copy构造函数-反过来也不能令copy构造函数调用copy-assignment操作符" class="headerlink" title="3.你不该令copy assignment操作符 调用 copy构造函数,反过来也不能令copy构造函数调用copy assignment操作符"></a>3.你不该令copy assignment操作符 调用 copy构造函数,反过来也不能令copy构造函数调用copy assignment操作符</h4><h2 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-copying函数应确保复制”对象内的所有成员变量”及”所有base-class-成分”"><a href="#1-copying函数应确保复制”对象内的所有成员变量”及”所有base-class-成分”" class="headerlink" title="1.copying函数应确保复制”对象内的所有成员变量”及”所有base class 成分”"></a>1.copying函数应确保复制”对象内的所有成员变量”及”所有base class 成分”</h4><h4 id="2-不要尝试以某个copying函数实现另一个copying函数，应将共同机能放进第三个函数，并由两个copying函数共同调用"><a href="#2-不要尝试以某个copying函数实现另一个copying函数，应将共同机能放进第三个函数，并由两个copying函数共同调用" class="headerlink" title="2.不要尝试以某个copying函数实现另一个copying函数，应将共同机能放进第三个函数，并由两个copying函数共同调用"></a>2.不要尝试以某个copying函数实现另一个copying函数，应将共同机能放进第三个函数，并由两个copying函数共同调用</h4><h1 id="条款-13-以对象管理资源"><a href="#条款-13-以对象管理资源" class="headerlink" title="条款 13 : 以对象管理资源"></a>条款 13 : 以对象管理资源</h1><h4 id="1-为何需要以对象管理资源"><a href="#1-为何需要以对象管理资源" class="headerlink" title="1.为何需要以对象管理资源"></a>1.为何需要以对象管理资源</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; ... &#125;;                     <span class="comment">//继承体系中的base class</span></span><br><span class="line"><span class="comment">//进一步假设，通过一个 factory function (条款7) 提供特定的 Investment 对象</span></span><br><span class="line"><span class="function">Investment * <span class="title">createInvestment</span><span class="params">()</span></span>;              <span class="comment">//返回指针,指向继承体系中的动态分配对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Investment * pInv = <span class="built_in">createInvestment</span>();   <span class="comment">//调用 factory function</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;                              <span class="comment">//释放pInv所指对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的风险在于,如果...因为一些原因提前结束,像是return,或者continue or goto导致跳过了delete，导致内存泄漏,谨慎编写程序可以防止这类错误,但更好的做法是将资源放入对象,以析构函数来自动释放这些资源</span></span><br></pre></td></tr></table></figure>

<h4 id="2-利用auto-ptr-pointer-like-也就是智能指针-其析构函数会自动调用delete"><a href="#2-利用auto-ptr-pointer-like-也就是智能指针-其析构函数会自动调用delete" class="headerlink" title="2.利用auto_ptr(pointer-like),也就是智能指针,其析构函数会自动调用delete"></a>2.利用<u>auto_ptr(pointer-like)</u>,也就是智能指针,其析构函数会自动调用delete</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...                                       <span class="comment">//经由auto_ptr析构函数自动释放pInv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="“以对象管理资源”的两个关键想法"><a href="#“以对象管理资源”的两个关键想法" class="headerlink" title="“以对象管理资源”的两个关键想法"></a>“以对象管理资源”的两个关键想法</h4><h5 id="a-获得资源后立刻放进管理对象-该观念被称为“资源取得时机便是初始化时机”-RAII"><a href="#a-获得资源后立刻放进管理对象-该观念被称为“资源取得时机便是初始化时机”-RAII" class="headerlink" title="a.获得资源后立刻放进管理对象,该观念被称为“资源取得时机便是初始化时机”(RAII)"></a>a.获得资源后立刻放进管理对象,该观念被称为<u>“资源取得时机便是初始化时机”(RAII)</u></h5><h5 id="b-管理对象运用析构函数确保资源被释放"><a href="#b-管理对象运用析构函数确保资源被释放" class="headerlink" title="b.管理对象运用析构函数确保资源被释放"></a>b.管理对象运用析构函数确保资源被释放</h5><h4 id="3-由于其自动销毁-注意别让多个auto-ptr指向同一对象-否则会导致”未定义行为”-对于这个问题-auto-ptr有一个不寻常的性质-若通过copy构造或copy-assignment-复制它们-它们会变成null-复制所得指针获取资源的唯一拥有权"><a href="#3-由于其自动销毁-注意别让多个auto-ptr指向同一对象-否则会导致”未定义行为”-对于这个问题-auto-ptr有一个不寻常的性质-若通过copy构造或copy-assignment-复制它们-它们会变成null-复制所得指针获取资源的唯一拥有权" class="headerlink" title="3.由于其自动销毁,注意别让多个auto_ptr指向同一对象,否则会导致”未定义行为”,对于这个问题,auto_ptr有一个不寻常的性质: 若通过copy构造或copy assignment 复制它们,它们会变成null,复制所得指针获取资源的唯一拥有权"></a>3.由于其自动销毁,注意别让多个auto_ptr指向同一对象,否则会导致”未定义行为”,对于这个问题,auto_ptr有一个不寻常的性质: 若通过copy构造或copy assignment 复制它们,它们会变成null,复制所得指针获取资源的唯一拥有权</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv1</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//pInv1指向对象</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv2</span><span class="params">(pInv1)</span></span>;               <span class="comment">//pInv2指向对象,pInv1被设为null</span></span><br><span class="line">pInv1 = pInv2;                                        <span class="comment">//pInv1指向对象,pInv2被设为null</span></span><br></pre></td></tr></table></figure>

<h4 id="“受auto-ptr管理的资源必须绝对没有一个以上的auto-ptr同时指向它”"><a href="#“受auto-ptr管理的资源必须绝对没有一个以上的auto-ptr同时指向它”" class="headerlink" title="“受auto_ptr管理的资源必须绝对没有一个以上的auto_ptr同时指向它”"></a>“受auto_ptr管理的资源<u>必须绝对没有一个以上</u>的auto_ptr同时指向它”</h4><h4 id="4-另一替代方案“引用计数型智能指针”-RCSP-RCSP持续追踪共有多少对象指向某资源-并在无人指向它时自动删除该资源"><a href="#4-另一替代方案“引用计数型智能指针”-RCSP-RCSP持续追踪共有多少对象指向某资源-并在无人指向它时自动删除该资源" class="headerlink" title="4.另一替代方案“引用计数型智能指针”(RCSP).RCSP持续追踪共有多少对象指向某资源,并在无人指向它时自动删除该资源"></a>4.另一替代方案<u>“引用计数型智能指针”(RCSP)</u>.RCSP持续追踪共有多少对象指向某资源,并在无人指向它时自动删除该资源</h4><h4 id="Tr1的tr1-shared-ptr-就是个RCSP"><a href="#Tr1的tr1-shared-ptr-就是个RCSP" class="headerlink" title="Tr1的tr1::shared_ptr 就是个RCSP"></a>Tr1的<u>tr1::shared_ptr</u> 就是个RCSP</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用与auto_ptr基本一致,区别在于不同于auto_ptrd的复制行为</span></span><br><span class="line"><span class="comment">//#2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv1</span><span class="params">(createInvestment())</span></span>; <span class="comment">//pInv1指向对象</span></span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv2</span><span class="params">(pInv1)</span></span>;              <span class="comment">//pInv1,pInv2指向同一对象</span></span><br><span class="line">    pInv1 = pInv2;                                              <span class="comment">//同上</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-auto-ptr和shared-ptr都在析构函数内做delete而不是delete-这意味着动态分配的array不能在auto-ptr或shared-ptr上使用-如有需求见条款55"><a href="#5-auto-ptr和shared-ptr都在析构函数内做delete而不是delete-这意味着动态分配的array不能在auto-ptr或shared-ptr上使用-如有需求见条款55" class="headerlink" title="5.auto_ptr和shared_ptr都在析构函数内做delete而不是delete[],这意味着动态分配的array不能在auto_ptr或shared_ptr上使用(如有需求见条款55)"></a>5.auto_ptr和shared_ptr都在析构函数内做delete而不是delete[],<u>这意味着动态分配的array不能在auto_ptr或shared_ptr上使用</u>(如有需求见条款55)</h4><h2 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-为防止资源泄漏-应使用RAII对象-它们在构造时获取资源-析构时释放资源"><a href="#1-为防止资源泄漏-应使用RAII对象-它们在构造时获取资源-析构时释放资源" class="headerlink" title="1.为防止资源泄漏,应使用RAII对象,它们在构造时获取资源,析构时释放资源"></a>1.为防止资源泄漏,应使用RAII对象,它们在构造时获取资源,析构时释放资源</h4><h4 id="2-两个常用的RAII对象-tr1-shared-ptr-和-auto-ptr-两只区别在于复制行为的不同"><a href="#2-两个常用的RAII对象-tr1-shared-ptr-和-auto-ptr-两只区别在于复制行为的不同" class="headerlink" title="2.两个常用的RAII对象,tr1::shared_ptr 和 auto_ptr,两只区别在于复制行为的不同"></a>2.两个常用的RAII对象,tr1::shared_ptr 和 auto_ptr,两只区别在于复制行为的不同</h4><h1 id="条款-14-在资源管理类中小心copying行为"><a href="#条款-14-在资源管理类中小心copying行为" class="headerlink" title="条款 14 : 在资源管理类中小心copying行为"></a>条款 14 : 在资源管理类中小心copying行为</h1><h4 id="1-对于并非heap-based的资源-auto-pt-或-tr1-shared-ptr-往往不适合-因此你需要建立自己的资源管理类"><a href="#1-对于并非heap-based的资源-auto-pt-或-tr1-shared-ptr-往往不适合-因此你需要建立自己的资源管理类" class="headerlink" title="1.对于并非heap_based的资源,auto_pt 或 tr1::shared_ptr 往往不适合,因此你需要建立自己的资源管理类"></a>1.对于<u>并非heap_based的资源</u>,auto_pt 或 tr1::shared_ptr 往往不适合,因此你需要<u>建立自己的资源管理类</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如,假设 有一个 类型为 Mutex的互斥器对象,共有lock 和 unlock 两函数可用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(Mutex * pm)</span></span>;           <span class="comment">//锁定pm所指的互斥器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(Mutex * pm)</span></span>;         <span class="comment">//将互斥器解除锁定</span></span><br><span class="line"><span class="comment">//建立一个class用来管理机锁,由RAII守则支配,&quot;资源在构造期间获得,在析构期间释放&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex * pm)</span></span></span><br><span class="line"><span class="function">    :mutexPtr(pm)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutePtr);            <span class="comment">//获得资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>()&#123; <span class="built_in">unlock</span>(mutexPtr); &#125;  <span class="comment">//释放资源</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Mutex * mutexPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//客户对lock的用法符号RAII方式:</span></span><br><span class="line">Mutex m;                          <span class="comment">//定义你所需要的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;                  <span class="comment">//以Lock来管理Mutex m ,锁定互斥器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;                                 <span class="comment">//在区块末尾自动解除互斥器锁定</span></span><br></pre></td></tr></table></figure>

<h4 id="2-考虑如果Lock对象被复制-会发生什么"><a href="#2-考虑如果Lock对象被复制-会发生什么" class="headerlink" title="2.考虑如果Lock对象被复制,会发生什么"></a>2.考虑如果Lock对象被复制,会发生什么</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">m11</span><span class="params">(&amp;m)</span></span>;                     <span class="comment">//锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">m12</span><span class="params">(m11)</span></span>;                    <span class="comment">//将m11 复制到 m12 上</span></span><br></pre></td></tr></table></figure>

<h5 id="a-禁止复制-许多时候允许RAII对象被复制并不合理-如果复制动作对RAII-class-并不合理-应该将其禁止-通过将copying操作声明为private-条款6"><a href="#a-禁止复制-许多时候允许RAII对象被复制并不合理-如果复制动作对RAII-class-并不合理-应该将其禁止-通过将copying操作声明为private-条款6" class="headerlink" title="a.禁止复制,许多时候允许RAII对象被复制并不合理.如果复制动作对RAII class 并不合理,应该将其禁止,通过将copying操作声明为private(条款6)"></a>a.禁止复制,许多时候允许RAII对象被复制并不合理.<u>如果复制动作对RAII class 并不合理,</u>应该将其禁止,通过将copying操作声明为private<u>(条款6)</u></h5><h5 id="b-对底层资源祭出“引用计数法”-如-tr1-shared-ptr"><a href="#b-对底层资源祭出“引用计数法”-如-tr1-shared-ptr" class="headerlink" title="b.对底层资源祭出“引用计数法”,如 tr1::shared_ptr."></a>b.对底层资源祭出<u>“引用计数法”</u>,如 tr1::shared_ptr.</h5><h5 id="通常内含一个tr1-shared-ptr成员变量-RAII-class-便可实现-reference-counting-copying-行为-如-若前述的Lock打算使用reference-couting-，它可以改变mutexPtr的类型-改为-tr1-shared-ptr-lt-Mutex-gt-，tr1-shared-ptr-的默认行为为“当引用次数为0时删除其所指物”-这不是Lock想要的行为-但tr1-shared-ptr允许指定所谓的”删除器”-那是一个函数或函数对象-当引用次数为0的时候调用"><a href="#通常内含一个tr1-shared-ptr成员变量-RAII-class-便可实现-reference-counting-copying-行为-如-若前述的Lock打算使用reference-couting-，它可以改变mutexPtr的类型-改为-tr1-shared-ptr-lt-Mutex-gt-，tr1-shared-ptr-的默认行为为“当引用次数为0时删除其所指物”-这不是Lock想要的行为-但tr1-shared-ptr允许指定所谓的”删除器”-那是一个函数或函数对象-当引用次数为0的时候调用" class="headerlink" title="通常内含一个tr1::shared_ptr成员变量,RAII class 便可实现 reference-counting copying 行为,如 若前述的Lock打算使用reference couting ，它可以改变mutexPtr的类型,改为 tr1::shared_ptr&lt;Mutex.&gt;，tr1::shared_ptr 的默认行为为“当引用次数为0时删除其所指物”,这不是Lock想要的行为,但tr1::shared_ptr允许指定所谓的”删除器”,那是一个函数或函数对象,当引用次数为0的时候调用"></a>通常<u>内含一个tr1::shared_ptr</u>成员变量,RAII class 便可实现 <u>reference-counting copying</u> 行为,如 若前述的Lock打算使用reference couting ，<u>它可以改变mutexPtr的类型,改为 tr1::shared_ptr&lt;Mutex.&gt;</u>，tr1::shared_ptr 的默认行为为<u>“当引用次数为0时删除其所指物”</u>,这不是Lock想要的行为,但tr1::shared_ptr允许指定所谓的”<u>删除器”</u>,那是一个函数或函数对象,当引用次数为0的时候调用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex * pm)</span></span></span><br><span class="line"><span class="function">     :mutexPtr(pm,unlock)                    //将unlock 函数 作为删除器</span></span><br><span class="line"><span class="function">     &#123;</span></span><br><span class="line">         <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());               <span class="comment">//条款 15 谈到&quot;get&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;    <span class="comment">//使用shared_ptr 替换 raw pointer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处没有声明析构,条款5 说过,class的析构(无论是编译器生成的,或是用户自定义的)会自动调用其non-static成员变量的析构函数(本例为mutexPtr)</span></span><br></pre></td></tr></table></figure>

<h5 id="c-复制底层资源-，复制资源管理类对象时-进行的应是-“深度拷贝”"><a href="#c-复制底层资源-，复制资源管理类对象时-进行的应是-“深度拷贝”" class="headerlink" title="c.复制底层资源 ，复制资源管理类对象时,进行的应是 “深度拷贝”"></a>c.复制底层资源 ，复制资源管理类对象时,进行的应是 <u>“深度拷贝”</u></h5><h5 id="d-转移底部资源的拥有权，如条款13-这是auto-ptr的复制意义"><a href="#d-转移底部资源的拥有权，如条款13-这是auto-ptr的复制意义" class="headerlink" title="d.转移底部资源的拥有权，如条款13 ,这是auto_ptr的复制意义"></a>d.转移底部资源的拥有权，如<u>条款13</u> ,这是auto_ptr的复制意义</h5><h2 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-复制RAII对象必须一并复制它所管理的资源-所以资源的copying行为决定RAII对象的copying行为"><a href="#1-复制RAII对象必须一并复制它所管理的资源-所以资源的copying行为决定RAII对象的copying行为" class="headerlink" title="1.复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为"></a>1.复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为</h4><h4 id="2-常见的的RAII-class-copying-行为为：抑制copying-禁止复制-reference-counting"><a href="#2-常见的的RAII-class-copying-行为为：抑制copying-禁止复制-reference-counting" class="headerlink" title="2.常见的的RAII class copying 行为为：抑制copying(禁止复制) , reference counting"></a>2.常见的的RAII class copying 行为为：抑制copying(禁止复制) , reference counting</h4><h4 id="引用计数法-其他行为也可能被实现如-c-d"><a href="#引用计数法-其他行为也可能被实现如-c-d" class="headerlink" title="(引用计数法), 其他行为也可能被实现如 c,d."></a>(引用计数法), 其他行为也可能被实现如 c,d.</h4><h1 id="条款-15-在资源管理类中提供对原始资源的访问"><a href="#条款-15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15 : 在资源管理类中提供对原始资源的访问"></a>条款 15 : 在资源管理类中提供对原始资源的访问</h1><h4 id="1-为什么引入对原始资源的直接访问"><a href="#1-为什么引入对原始资源的直接访问" class="headerlink" title="1.为什么引入对原始资源的直接访问:"></a>1.为什么<u>引入对原始资源的直接访问</u>:</h4><h4 id="下述例子想返回一个int型的天数却通不过编译-因为daysHeld需要的是-Investment-指针"><a href="#下述例子想返回一个int型的天数却通不过编译-因为daysHeld需要的是-Investment-指针" class="headerlink" title="下述例子想返回一个int型的天数却通不过编译,因为daysHeld需要的是 Investment*指针"></a>下述例子想<u>返回一个int型的天数</u>却通不过编译,因为daysHeld需要的是 Investment*指针</h4><h4 id="但传给它的却是个类型为tr1-shared-ptr-lt-Investment-gt-的对象"><a href="#但传给它的却是个类型为tr1-shared-ptr-lt-Investment-gt-的对象" class="headerlink" title="但传给它的却是个类型为tr1::shared_ptr&lt;.Investment&gt;的对象"></a>但传给它的却是个类型为tr1::shared_ptr&lt;.Investment&gt;的对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例</span></span><br><span class="line"><span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;    <span class="comment">//智能指针管理对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dayHeld</span><span class="params">(<span class="type">const</span> Investment * pi)</span></span>;                      <span class="comment">//返回天数</span></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">dayHeld</span>(pInv);                                <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h4 id="2-两种做法可以达成目的-显示转换和隐式转换-tr1-shared-ptr和auto-ptr都提供一个get函数-用来执行显示转换-也就是它会返回智能指针内部的原始指针-的复件"><a href="#2-两种做法可以达成目的-显示转换和隐式转换-tr1-shared-ptr和auto-ptr都提供一个get函数-用来执行显示转换-也就是它会返回智能指针内部的原始指针-的复件" class="headerlink" title="2.两种做法可以达成目的,显示转换和隐式转换. tr1::shared_ptr和auto_ptr都提供一个get函数,用来执行显示转换,也就是它会返回智能指针内部的原始指针(的复件)."></a>2.两种做法可以达成目的,显示转换和隐式转换. tr1::shared_ptr和auto_ptr都提供一个get函数,用来执行显示转换,也就是它会返回智能指针内部的原始指针(的复件).</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#显示转换的例子</span></span><br><span class="line"><span class="type">int</span> days = <span class="built_in">dayHeld</span>(pInv.<span class="built_in">get</span>());                          <span class="comment">//利用get返回原始指针</span></span><br><span class="line"><span class="comment">//#tr1::shared_ptr auto_ptr 重载了-&gt;和* ,它们允许隐式转换至底部原始指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;                          <span class="comment">//factory函数</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pil</span><span class="params">(createInvestment())</span></span>;<span class="comment">//令pi1管理一笔资源</span></span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>());                     <span class="comment">//经由operator-&gt;访问资源</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>;       <span class="comment">//令pi2管理一笔资源</span></span><br><span class="line"><span class="type">bool</span> taxable2 = !((*pi2).<span class="built_in">isTaxFree</span>());                   <span class="comment">//经由operator*访问资源</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="3-显示转换和隐式转换"><a href="#3-显示转换和隐式转换" class="headerlink" title="3.显示转换和隐式转换"></a>3.显示转换和隐式转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例</span></span><br><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>                                <span class="comment">//RAII class</span></span><br><span class="line">&#123;          </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh           <span class="comment">//获得资源  pass-by-value</span></span></span></span><br><span class="line"><span class="params"><span class="function">     :f(fh)</span></span></span><br><span class="line"><span class="params"><span class="function">     &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">     &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    ~Font()&#123; releaseFont(f); &#125;            <span class="comment">//释放资源</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">    FontHandle f;                         <span class="comment">//raw(原始) 资源</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//#假设将Font转换为FontHandle 很频繁则需要提供一个显示转换函数       </span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">class</span> Font</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">    FontHandle get()cosnt&#123; <span class="keyword">return</span> f; &#125;   <span class="comment">//显示转换函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> changeFontSize(FontHandle f,<span class="type">int</span> newSize);</span></span></span><br><span class="line"><span class="params"><span class="function">Font f(getFont());</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> newFontSize;</span></span></span><br><span class="line"><span class="params"><span class="function">...</span></span></span><br><span class="line"><span class="params"><span class="function">changeFontSize(f.get(), newFontSize)     <span class="comment">//显示的将Font转换为FontHandle</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//#或者提供隐式转换</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">class</span> Font</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">operator</span> FontHandle()<span class="type">const</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123; <span class="keyword">return</span> f; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    ...</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">Font f(getFont());</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> newFontSize;</span></span></span><br><span class="line"><span class="params"><span class="function">...</span></span></span><br><span class="line"><span class="params"><span class="function">changeFontSize(f,newFontSize)            <span class="comment">//隐式转换</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//#缺陷:增加错误发生的机会</span></span></span></span><br><span class="line"><span class="params"><span class="function">Font f1(getFont());                    </span></span></span><br><span class="line"><span class="params"><span class="function">...                                      <span class="comment">//原意是拷贝一个Font对象,却将其隐式转换后才复制</span></span></span></span><br><span class="line"><span class="params"><span class="function">FontHandle f2 = f1;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="4-通常显示转换用的更多-隐式转换会增加错误的发生-RAII-class-并不是为了封装而存在"><a href="#4-通常显示转换用的更多-隐式转换会增加错误的发生-RAII-class-并不是为了封装而存在" class="headerlink" title="4.通常显示转换用的更多,隐式转换会增加错误的发生.RAII class 并不是为了封装而存在:"></a>4.通常显示转换用的更多,隐式转换会增加错误的发生.<u>RAII class 并不是为了封装而存在:</u></h4><h4 id="其目的为”确保一个特殊行为–资源释放–会发生”-所以RAII-class中返回原始资源的函数并非设计灾难"><a href="#其目的为”确保一个特殊行为–资源释放–会发生”-所以RAII-class中返回原始资源的函数并非设计灾难" class="headerlink" title="其目的为”确保一个特殊行为–资源释放–会发生”,所以RAII class中返回原始资源的函数并非设计灾难"></a><u>其目的为”确保一个特殊行为–资源释放–会发生”</u>,所以RAII class中返回原始资源的函数并非设计灾难</h4><h2 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-APIs往往要求访问原始资源-所以每一个RAII-class-应该提供一个”获取原始资源”的方法"><a href="#1-APIs往往要求访问原始资源-所以每一个RAII-class-应该提供一个”获取原始资源”的方法" class="headerlink" title="1.APIs往往要求访问原始资源,所以每一个RAII class 应该提供一个”获取原始资源”的方法"></a>1.APIs往往要求访问原始资源,所以每一个RAII class 应该提供一个”获取原始资源”的方法</h4><h4 id="2-通过显示转换或隐式转换都可以访问-但显示更安全-隐式增加了错误的发生但更方便"><a href="#2-通过显示转换或隐式转换都可以访问-但显示更安全-隐式增加了错误的发生但更方便" class="headerlink" title="2.通过显示转换或隐式转换都可以访问,但显示更安全,隐式增加了错误的发生但更方便"></a>2.通过<u>显示转换或隐式转换</u>都可以访问,但显示更安全,隐式增加了错误的发生但更方便</h4><h1 id="条款-16-成对使用new和delete时采用相同形式"><a href="#条款-16-成对使用new和delete时采用相同形式" class="headerlink" title="条款 16 : 成对使用new和delete时采用相同形式"></a>条款 16 : 成对使用new和delete时采用相同形式</h1><h4 id="1-new-与-delete-应该成对配套出现-new-与-delete-new-与-delete"><a href="#1-new-与-delete-应该成对配套出现-new-与-delete-new-与-delete" class="headerlink" title="1.new 与 delete 应该成对配套出现 , new 与 delete , new [] 与 delete[]"></a>1.new 与 delete <u>应该成对配套出现</u> , new 与 delete , new [] 与 delete[]</h4><h4 id="2-原因-数组所有内存通常还包括”数组大小”的记录-以便delete知道调用多少次析构-单一内存则没有这笔记录"><a href="#2-原因-数组所有内存通常还包括”数组大小”的记录-以便delete知道调用多少次析构-单一内存则没有这笔记录" class="headerlink" title="2.原因,数组所有内存通常还包括”数组大小”的记录,以便delete知道调用多少次析构,单一内存则没有这笔记录"></a>2.原因,数组所有内存通常还包括”数组大小”的记录,以便delete知道调用多少次析构,单一内存则没有这笔记录</h4><table>
<thead>
<tr>
<th><strong>单一对象</strong></th>
<th><strong>Object</strong></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>对象数组</strong></td>
<td><strong>n</strong></td>
<td><strong>Object</strong></td>
<td><strong>Object</strong></td>
<td><strong>Object</strong></td>
</tr>
</tbody></table>
<h4 id="上述大概描述了编译器中的实现-但并非所有编译都是如此-但足够解释为什么配套使用"><a href="#上述大概描述了编译器中的实现-但并非所有编译都是如此-但足够解释为什么配套使用" class="headerlink" title="上述大概描述了编译器中的实现,但并非所有编译都是如此,但足够解释为什么配套使用"></a>上述大概描述了编译器中的实现,但并非所有编译都是如此,但足够解释为什么配套使用</h4><h4 id="3-对typedef也是如此-考虑下述例子"><a href="#3-对typedef也是如此-考虑下述例子" class="headerlink" title="3.对typedef也是如此,考虑下述例子"></a>3.对typedef也是如此,考虑下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//typedef 定义 数组  AddressLines a; 相当于  string a[4];</span></span><br><span class="line">std::string* pal = <span class="keyword">new</span> AddressLines;    <span class="comment">//所以是以new [] 创建的,需以delete [] 释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;                 <span class="comment">//行为为定义</span></span><br><span class="line"><span class="keyword">delete</span> [] pal;              <span class="comment">//很好</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-new-和-delete-，new-和-delete-需成对配套出现使用"><a href="#1-new-和-delete-，new-和-delete-需成对配套出现使用" class="headerlink" title="1.new 和 delete ，new [] 和 delete [] 需成对配套出现使用"></a>1.new 和 delete ，new [] 和 delete [] <u>需成对配套出现使用</u></h4><h1 id="条款-17-以独立语句将newd对象置入智能指针"><a href="#条款-17-以独立语句将newd对象置入智能指针" class="headerlink" title="条款 17 : 以独立语句将newd对象置入智能指针"></a>条款 17 : 以独立语句将newd对象置入智能指针</h1><h4 id="1-对于下述例子"><a href="#1-对于下述例子" class="headerlink" title="1.对于下述例子"></a>1.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"><span class="comment">//由于谨记&quot;以对象管理资源&quot;(条款13),processWidget决定以智能指针处理其动态分配而来的Widget</span></span><br><span class="line"><span class="comment">//现在考虑调用processWidget</span></span><br><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget, <span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">//该形式无法通过编译,由于tr1::shared_ptr需要一个原始指针,但该构造是explicit构造,无法进行隐式转换</span></span><br><span class="line"><span class="comment">//将&quot;new Widget“转换为tr1::shared_ptr</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),<span class="built_in">priority</span>());</span><br><span class="line"><span class="comment">//这样即可通过编译,但出现了另一个问题,即使运用了 RAII 对象,仍存在泄漏资源的可能</span></span><br></pre></td></tr></table></figure>

<h4 id="2-原因在于调用processWidget之前-必须先核算被传递的实参-上述第二实参有一个priority函数调用-但第一实参由两部分组成-“执行new-Widget-表达式”-”调用tr1-shared构造函数”"><a href="#2-原因在于调用processWidget之前-必须先核算被传递的实参-上述第二实参有一个priority函数调用-但第一实参由两部分组成-“执行new-Widget-表达式”-”调用tr1-shared构造函数”" class="headerlink" title="2.原因在于调用processWidget之前,必须先核算被传递的实参,上述第二实参有一个priority函数调用,但第一实参由两部分组成,“执行new Widget 表达式”,”调用tr1::shared构造函数”"></a>2.原因在于调用processWidget之前,必须先核算被传递的实参,上述第二实参有一个priority函数调用,但第一实参由两部分组成,“执行new Widget 表达式”,”调用tr1::shared构造函数”</h4><h4 id="所以再调用processWidget之前有三件事"><a href="#所以再调用processWidget之前有三件事" class="headerlink" title="所以再调用processWidget之前有三件事"></a>所以再调用processWidget之前有三件事</h4><h5 id="a-调用priority"><a href="#a-调用priority" class="headerlink" title="a.调用priority"></a>a.调用priority</h5><h5 id="b-执行”new-Widget”"><a href="#b-执行”new-Widget”" class="headerlink" title="b.执行”new Widget”"></a>b.执行”new Widget”</h5><h5 id="c-调用tr1-shared-ptr-构造函数"><a href="#c-调用tr1-shared-ptr-构造函数" class="headerlink" title="c.调用tr1::shared_ptr 构造函数"></a>c.调用tr1::shared_ptr 构造函数</h5><h4 id="编译完成这些事情的次序具有弹性-如果最终获得这样的操作序列"><a href="#编译完成这些事情的次序具有弹性-如果最终获得这样的操作序列" class="headerlink" title="编译完成这些事情的次序具有弹性,如果最终获得这样的操作序列"></a>编译完成这些事情的<u>次序具有弹性</u>,如果最终获得这样的操作序列</h4><h5 id="a-执行”new-Widget”"><a href="#a-执行”new-Widget”" class="headerlink" title="a.执行”new Widget”"></a>a.执行”new Widget”</h5><h5 id="b-调用priority"><a href="#b-调用priority" class="headerlink" title="b.调用priority"></a>b.调用priority</h5><h5 id="c-调用tr1-shared-ptr-构造函数-1"><a href="#c-调用tr1-shared-ptr-构造函数-1" class="headerlink" title="c.调用tr1::shared_ptr 构造函数"></a>c.调用tr1::shared_ptr 构造函数</h5><h4 id="如果priority的调用抛出异常-则会导致-“new-Widget”-返回的指针遗失-引发资源泄漏"><a href="#如果priority的调用抛出异常-则会导致-“new-Widget”-返回的指针遗失-引发资源泄漏" class="headerlink" title="如果priority的调用抛出异常,则会导致 “new Widget” 返回的指针遗失,引发资源泄漏"></a>如果<u>priority的调用抛出异常,则会导致 “new Widget” 返回的指针遗失</u>,引发资源泄漏</h4><h4 id="3-如何处理"><a href="#3-如何处理" class="headerlink" title="3.如何处理:"></a>3.如何处理:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span>     <span class="comment">//分出单独语句</span></span></span><br><span class="line"><span class="function"><span class="title">processWidget</span><span class="params">(pw,priority())</span></span>;                   <span class="comment">//这个动作不会导致泄漏</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-以独立语句将newd对象存储于智能指针-如果不这么做-一旦抛出异常-则可能导致难以察觉的资源泄漏"><a href="#1-以独立语句将newd对象存储于智能指针-如果不这么做-一旦抛出异常-则可能导致难以察觉的资源泄漏" class="headerlink" title="1.以独立语句将newd对象存储于智能指针,如果不这么做,一旦抛出异常,则可能导致难以察觉的资源泄漏"></a>1.<u>以独立语句将newd对象存储于智能指针</u>,如果不这么做,一旦抛出异常,则可能导致难以察觉的资源泄漏</h4><h1 id="条款-18-让接口容易被正确使用-不易被误用"><a href="#条款-18-让接口容易被正确使用-不易被误用" class="headerlink" title="条款 18 : 让接口容易被正确使用,不易被误用"></a>条款 18 : 让接口容易被正确使用,不易被误用</h1><h4 id="1-导入简单的外覆类型"><a href="#1-导入简单的外覆类型" class="headerlink" title="1.导入简单的外覆类型"></a>1.导入简单的外覆类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> month,<span class="type">int</span> day,<span class="type">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>,<span class="number">3</span>,<span class="number">1995</span>)</span>            <span class="comment">//应该为 3,30 而不是 30,3</span></span></span><br><span class="line"><span class="function"><span class="comment">//外覆类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> Day</span>&#123;                        </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">        :val(d)&#123;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span>&#123;                        </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">        :val(d)&#123;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span>&#123;                        </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">        :val(d)&#123;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>,<span class="number">3</span>,<span class="number">1995</span>)</span></span>;                             <span class="comment">//error！</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">30</span>),Month(<span class="number">3</span>),Year(<span class="number">1995</span>))</span></span>;           <span class="comment">//error!</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>),Day(<span class="number">30</span>),Year(<span class="number">1995</span>))</span></span>;           <span class="comment">//right</span></span><br></pre></td></tr></table></figure>

<h4 id="2-提供行为一致的接口-如果STL容器每个都有一个size成员函数-告诉调用者容器内有多少个对象"><a href="#2-提供行为一致的接口-如果STL容器每个都有一个size成员函数-告诉调用者容器内有多少个对象" class="headerlink" title="2.提供行为一致的接口,如果STL容器每个都有一个size成员函数,告诉调用者容器内有多少个对象"></a>2.<u>提供行为一致的接口</u>,如果STL容器每个都有一个size成员函数,告诉调用者容器内有多少个对象</h4><h4 id="3-对于下述例子"><a href="#3-对于下述例子" class="headerlink" title="3.对于下述例子"></a>3.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回的指针可能导致两种错误:1.没有删除指针 2.删除多次</span></span><br><span class="line"><span class="comment">//条款13 表面可以用智能指针来更好的管理指针的销毁 , 本例可令其返回一个智能指针</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-假设调用者期许将指针传给一个特定的函数来执行特定的销毁而不是delete可以尝试将其绑定一个删除器"><a href="#4-假设调用者期许将指针传给一个特定的函数来执行特定的销毁而不是delete可以尝试将其绑定一个删除器" class="headerlink" title="4.假设调用者期许将指针传给一个特定的函数来执行特定的销毁而不是delete可以尝试将其绑定一个删除器"></a>4.假设调用者期许将<u>指针传给一个特定的函数来执行特定的销毁而不是delete</u>可以尝试将其绑定一个删除器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shared_ptr 接受两个实参:1.被管理的指针 2.引用次数为0时调用的&quot;删除器&quot;</span></span><br><span class="line"><span class="comment">//如果像下述一样创建一个 null tr1::shared_ptr </span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="number">0</span>,getRidOfInvestment)</span></span>;    <span class="comment">//无法通过编译</span></span><br><span class="line"><span class="comment">//第一参数必须为指针,而0是个int , 虽然可以被转换但不够好  tr1::shared_ptr 需要一个完全的指针</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),getOfInvestment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在可以将createinvestment 函数 实现成我们想要的,即返回一个传给特点函数删除的指针</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvesment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                                            getRidOfInvestment)</span></span>;</span><br><span class="line">    reVal = ...;</span><br><span class="line">    <span class="keyword">return</span> reVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-防范“cross-DLL-problem”-不清楚DLL是什么-似乎与多线程有关"><a href="#5-防范“cross-DLL-problem”-不清楚DLL是什么-似乎与多线程有关" class="headerlink" title="5.防范“cross-DLL-problem”   (不清楚DLL是什么,似乎与多线程有关)"></a>5.防范<u>“cross-DLL-problem”</u>   (不清楚DLL是什么,似乎与多线程有关)</h4><h1 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项:"></a>注意事项:</h1><h4 id="1-应尽量在接口中实现-不容易误用的性质"><a href="#1-应尽量在接口中实现-不容易误用的性质" class="headerlink" title="1.应尽量在接口中实现,不容易误用的性质"></a>1.应尽量在接口中实现,不容易误用的性质</h4><h4 id="2-实现接口的一致性-以及与内置类型的行为兼容"><a href="#2-实现接口的一致性-以及与内置类型的行为兼容" class="headerlink" title="2.实现接口的一致性,以及与内置类型的行为兼容"></a>2.实现接口的一致性,以及与内置类型的行为兼容</h4><h4 id="3-”阻止误用”-a-建立新类型-b-限制类型上的操作-c-束缚对象值-d-消除客户的资源管理自认"><a href="#3-”阻止误用”-a-建立新类型-b-限制类型上的操作-c-束缚对象值-d-消除客户的资源管理自认" class="headerlink" title="3.”阻止误用” a.建立新类型 b.限制类型上的操作 c.束缚对象值 d.消除客户的资源管理自认"></a>3.”阻止误用” a.建立新类型 b.限制类型上的操作 c.束缚对象值 d.消除客户的资源管理自认</h4><h4 id="4-tr1-shared-ptr-可以自定义删除器-这可防范DLL-问题"><a href="#4-tr1-shared-ptr-可以自定义删除器-这可防范DLL-问题" class="headerlink" title="4.tr1::shared_ptr 可以自定义删除器 , 这可防范DLL 问题"></a>4.tr1::shared_ptr 可以自定义删除器 , 这可防范DLL 问题</h4><h1 id="条款-19-设计class犹如type"><a href="#条款-19-设计class犹如type" class="headerlink" title="条款 19 : 设计class犹如type"></a>条款 19 : 设计class犹如type</h1><h4 id="1-新type的对象该如何创建和销毁"><a href="#1-新type的对象该如何创建和销毁" class="headerlink" title="1.新type的对象该如何创建和销毁?"></a>1.新type的对象该如何创建和销毁?</h4><h6 id="考虑构造和析构-以及new-和-delete-重载的设计"><a href="#考虑构造和析构-以及new-和-delete-重载的设计" class="headerlink" title="考虑构造和析构,以及new 和 delete 重载的设计"></a>考虑构造和析构,以及new 和 delete 重载的设计</h6><h4 id="2-初始化和对象的赋值该有什么差别"><a href="#2-初始化和对象的赋值该有什么差别" class="headerlink" title="2.初始化和对象的赋值该有什么差别?"></a>2.初始化和对象的赋值该有什么差别?</h4><h6 id="不要混淆对象的构造函数和operator-x3D"><a href="#不要混淆对象的构造函数和operator-x3D" class="headerlink" title="不要混淆对象的构造函数和operator&#x3D;"></a>不要混淆对象的构造函数和operator&#x3D;</h6><h4 id="3-新type对象如果-pass-by-value-意味着什么"><a href="#3-新type对象如果-pass-by-value-意味着什么" class="headerlink" title="3.新type对象如果 pass-by-value 意味着什么?"></a>3.新type对象如果 pass-by-value 意味着什么?</h4><h6 id="通常用copy构造函数来实现pass-by-value"><a href="#通常用copy构造函数来实现pass-by-value" class="headerlink" title="通常用copy构造函数来实现pass by value"></a>通常用copy构造函数来实现pass by value</h6><h4 id="4-新type的合法值"><a href="#4-新type的合法值" class="headerlink" title="4.新type的合法值?"></a>4.新type的合法值?</h4><h6 id="对class范围的约束-对成员函数需要进行的错误检测工作"><a href="#对class范围的约束-对成员函数需要进行的错误检测工作" class="headerlink" title="对class范围的约束,对成员函数需要进行的错误检测工作"></a>对class范围的约束,对成员函数需要进行的错误检测工作</h6><h4 id="5-你的新type需要配合某个继承图系吗"><a href="#5-你的新type需要配合某个继承图系吗" class="headerlink" title="5.你的新type需要配合某个继承图系吗?"></a>5.你的新type需要配合某个继承图系吗?</h4><h6 id="对于继承中non-virtual-和-virtual-声明的考虑-尤其是析构函数是否为virtual-条款-34-36"><a href="#对于继承中non-virtual-和-virtual-声明的考虑-尤其是析构函数是否为virtual-条款-34-36" class="headerlink" title="对于继承中non-virtual 和 virtual 声明的考虑,尤其是析构函数是否为virtual   (条款 34,36)"></a>对于继承中non-virtual 和 virtual 声明的考虑,尤其是析构函数是否为virtual   (条款 34,36)</h6><h4 id="6-你的新type需要声明样的转换？"><a href="#6-你的新type需要声明样的转换？" class="headerlink" title="6.你的新type需要声明样的转换？"></a>6.你的新type需要声明样的转换？</h4><h6 id="types之间的转换考虑-隐式转换-或-i按时转换函数的设计"><a href="#types之间的转换考虑-隐式转换-或-i按时转换函数的设计" class="headerlink" title="types之间的转换考虑, 隐式转换 或 i按时转换函数的设计"></a>types之间的转换考虑, 隐式转换 或 i按时转换函数的设计</h6><h4 id="7-什么样的操作符和函数对此新type是合理的"><a href="#7-什么样的操作符和函数对此新type是合理的" class="headerlink" title="7.什么样的操作符和函数对此新type是合理的?"></a>7.什么样的操作符和函数对此新type是合理的?</h4><h6 id="考虑该type需要什么函数和操作符-如list需要insert-条款-23-24-46"><a href="#考虑该type需要什么函数和操作符-如list需要insert-条款-23-24-46" class="headerlink" title="考虑该type需要什么函数和操作符,如list需要insert  (条款 23,24,46)"></a>考虑该type需要什么函数和操作符,如list需要insert  (条款 23,24,46)</h6><h4 id="8-什么样的标准函数该驳回"><a href="#8-什么样的标准函数该驳回" class="headerlink" title="8.什么样的标准函数该驳回?"></a>8.什么样的标准函数该驳回?</h4><h6 id="如你不需要编译器默认提供的copying-函数-即应该将其声明为private-条款-6"><a href="#如你不需要编译器默认提供的copying-函数-即应该将其声明为private-条款-6" class="headerlink" title="如你不需要编译器默认提供的copying 函数,即应该将其声明为private (条款 6)"></a>如你不需要编译器默认提供的copying 函数,即应该将其声明为private (条款 6)</h6><h4 id="9-谁该取用type的成员"><a href="#9-谁该取用type的成员" class="headerlink" title="9.谁该取用type的成员?"></a>9.谁该取用type的成员?</h4><h6 id="考虑成员的访问权-是声明为private-public-还剩-protected"><a href="#考虑成员的访问权-是声明为private-public-还剩-protected" class="headerlink" title="考虑成员的访问权,是声明为private , public, 还剩 protected"></a>考虑成员的访问权,是声明为private , public, 还剩 protected</h6><h4 id="10-什么是新type的”未声明接口”"><a href="#10-什么是新type的”未声明接口”" class="headerlink" title="10.什么是新type的”未声明接口”?"></a>10.什么是新type的”未声明接口”?</h4><h6 id="不理解-见条款29"><a href="#不理解-见条款29" class="headerlink" title="不理解(见条款29)"></a>不理解(见条款29)</h6><h4 id="11-你的新type有多么一般化"><a href="#11-你的新type有多么一般化" class="headerlink" title="11.你的新type有多么一般化?"></a>11.你的新type有多么一般化?</h4><h6 id="考虑是否需要使用-template-class"><a href="#考虑是否需要使用-template-class" class="headerlink" title="考虑是否需要使用 template class"></a>考虑是否需要使用 template class</h6><h4 id="12-你真的需要一个新的type吗？"><a href="#12-你真的需要一个新的type吗？" class="headerlink" title="12.你真的需要一个新的type吗？"></a>12.你真的需要一个新的type吗？</h4><h6 id="考虑继承-自-base-class-即在-derived-class-上添加新机能"><a href="#考虑继承-自-base-class-即在-derived-class-上添加新机能" class="headerlink" title="考虑继承 自 base class 即在 derived class 上添加新机能"></a>考虑继承 自 base class 即在 derived class 上添加新机能</h6><h1 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项:"></a>注意事项:</h1><h4 id="1-再设计class-之前确定你已经考虑过本条款所有讨论主题"><a href="#1-再设计class-之前确定你已经考虑过本条款所有讨论主题" class="headerlink" title="1.再设计class 之前确定你已经考虑过本条款所有讨论主题"></a>1.再设计class 之前确定你已经考虑过本条款所有讨论主题</h4><h1 id="条款-20-以pass-by-reference-to-const替换pass-by-value"><a href="#条款-20-以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款 20 : 以pass-by-reference-to-const替换pass-by-value"></a>条款 20 : 以pass-by-reference-to-const替换pass-by-value</h1><h4 id="1-考虑下述继承体系"><a href="#1-考虑下述继承体系" class="headerlink" title="1.考虑下述继承体系"></a>1.考虑下述继承体系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();                               <span class="comment">//为求简化,省略参数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();                      <span class="comment">//声明为virtual (条款7)</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">    std::string schoolAddress;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;            <span class="comment">//pass-by-value</span></span><br><span class="line">Student plato;                                </span><br><span class="line"><span class="type">bool</span> platoIsOK = <span class="built_in">validateStudent</span>(plato);    <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<h4 id="上述函数实现上没有问题-但-pass-by-value-时构造一个临时的Student-Student内又包含两个string-同时继承自Perosn-Base-Class-又要构建Person-Person又包含两个string-总体上进行了六次构造和六次析构-效率极低"><a href="#上述函数实现上没有问题-但-pass-by-value-时构造一个临时的Student-Student内又包含两个string-同时继承自Perosn-Base-Class-又要构建Person-Person又包含两个string-总体上进行了六次构造和六次析构-效率极低" class="headerlink" title="上述函数实现上没有问题,但 pass-by-value 时构造一个临时的Student,Student内又包含两个string,同时继承自Perosn Base-Class 又要构建Person ,Person又包含两个string,总体上进行了六次构造和六次析构,效率极低"></a>上述函数<u>实现上没有问题</u>,但 pass-by-value 时构造一个临时的Student,Student内又包含两个string,同时继承自Perosn Base-Class 又要构建Person ,Person又包含两个string,总体上进行了六次构造和六次析构,<u>效率极低</u></h4><h4 id="2-对此的解决方式即为pass-by-reference"><a href="#2-对此的解决方式即为pass-by-reference" class="headerlink" title="2.对此的解决方式即为pass-by-reference"></a>2.对此的解决方式即为pass-by-reference</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-by-reference可以避免slicing-对象切割-此问题产生于将derived-class-以-by-value的方式传递给形参为base-class-的函数-考虑下述例子"><a href="#3-by-reference可以避免slicing-对象切割-此问题产生于将derived-class-以-by-value的方式传递给形参为base-class-的函数-考虑下述例子" class="headerlink" title="3.by-reference可以避免slicing(对象切割),此问题产生于将derived class 以 by-value的方式传递给形参为base-class 的函数,考虑下述例子"></a>3.by-reference可以避免<u>slicing(对象切割)</u>,此问题产生于将derived class 以 by-value的方式传递给形参为base-class 的函数,考虑下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span><span class="type">const</span></span>;                 <span class="comment">//返回窗口名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;             <span class="comment">//显示窗口及其内容</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span>:<span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span>           <span class="comment">//不正确,参数可能被切割</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br><span class="line"><span class="comment">//wwsb中的windowWithScrollBars部分将被切割,只剩下Window</span></span><br><span class="line"><span class="comment">//正确示例 pass-by-reference</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="type">const</span> Window&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-pass-by-refernce-往往比-pass-by-value-更高效"><a href="#4-pass-by-refernce-往往比-pass-by-value-更高效" class="headerlink" title="4.pass-by-refernce 往往比 pass-by-value 更高效"></a>4.pass-by-refernce 往往比 pass-by-value 更高效</h4><h4 id="5-对于大部分类型应该选用by-reference-但对于内置类型-及STL迭代器和函数对象选择pass-by-value并非没有道理"><a href="#5-对于大部分类型应该选用by-reference-但对于内置类型-及STL迭代器和函数对象选择pass-by-value并非没有道理" class="headerlink" title="5.对于大部分类型应该选用by-reference 但对于内置类型,及STL迭代器和函数对象选择pass-by-value并非没有道理"></a>5.对于大部分类型应该选用by-reference 但对于内置类型,及STL迭代器和函数对象选择pass-by-value并非没有道理</h4><h2 id="注意事项-15"><a href="#注意事项-15" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-尽量以pass-by-reference-替换-pass-by-value-，高效且避免切割问题"><a href="#1-尽量以pass-by-reference-替换-pass-by-value-，高效且避免切割问题" class="headerlink" title="1.尽量以pass-by-reference 替换 pass-by-value ，高效且避免切割问题"></a>1.尽量以pass-by-reference 替换 pass-by-value ，高效且避免切割问题</h4><h4 id="2-以上规则不适用于内置类型-以及STL迭代器和函数对象"><a href="#2-以上规则不适用于内置类型-以及STL迭代器和函数对象" class="headerlink" title="2.以上规则不适用于内置类型,以及STL迭代器和函数对象"></a>2.<u>以上规则不适用于内置类型</u>,以及STL迭代器和函数对象</h4><h1 id="条款-21-必须返回对象时-别妄想返回reference"><a href="#条款-21-必须返回对象时-别妄想返回reference" class="headerlink" title="条款 21 : 必须返回对象时,别妄想返回reference"></a>条款 21 : 必须返回对象时,别妄想返回reference</h1><h4 id="1-返回-reference"><a href="#1-返回-reference" class="headerlink" title="1.返回 reference"></a>1.返回 reference</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, </span><br><span class="line">             <span class="type">int</span> denominator = <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n,d;                              <span class="comment">//分子 numerator , 分母 denominator</span></span><br><span class="line">    <span class="keyword">friend</span> Rational</span><br><span class="line">        <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当前版本返回一个计算结果的对象 pass-by-value</span></span><br><span class="line"><span class="comment">//如果改为 byr-reference</span></span><br><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;         <span class="comment">//a = 1/2</span></span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;         <span class="comment">//b = 3/5</span></span><br><span class="line">Rational c = a * b;      <span class="comment">//c = 3/10</span></span><br><span class="line"><span class="comment">//期望&quot;原本就存在一个其值为3/10的Rational&quot;不合理,它必须自己创建那个Rational对象</span></span><br></pre></td></tr></table></figure>

<h4 id="2-在stack-或-heap-空间创建并返回"><a href="#2-在stack-或-heap-空间创建并返回" class="headerlink" title="2.在stack 或 heap 空间创建并返回"></a>2.在stack 或 heap 空间创建并返回</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n , lhs.d * rhs.d)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result 为 local 对象,函数退出前被销毁了,导致&quot;无定义行为&quot;,然后函数如果返回一个reference指向某个local对象,都将一败涂地</span></span><br><span class="line"><span class="comment">//如果在heap 内呢？考虑如下</span></span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n , lhs.d * rhs.d);</span><br><span class="line">    <span class="keyword">return</span> * result;</span><br><span class="line">    <span class="comment">//这将导致: 谁该对着被你 new 出来的对象 实施 delete</span></span><br><span class="line">&#125;</span><br><span class="line">Rational w,x,y,z;</span><br><span class="line">w = x * y * z;</span><br><span class="line"><span class="comment">//这里两次new 就需要 两次 delete,但没有合理的办法让他们获得operator*返回的reference背后隐藏的指针,导致资源泄漏</span></span><br></pre></td></tr></table></figure>

<h4 id="3-如果使用static-呢"><a href="#3-如果使用static-呢" class="headerlink" title="3.如果使用static 呢"></a>3.如果使用static 呢</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result;</span><br><span class="line">    result = ...;</span><br><span class="line">    retur retsult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">Rational a,b,c,d;</span><br><span class="line"><span class="keyword">if</span> ((a*b)==(c*d))</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这将导致 (a*b)==(c*d) 永远被判别为TRUE , 因为返回的引用都指向static同一个值,同一个值当然和自己相等</span></span><br></pre></td></tr></table></figure>

<h4 id="4-综上，一个”必须返回新对象”的函数正确写法是：return-一个新对象-而不是refernce"><a href="#4-综上，一个”必须返回新对象”的函数正确写法是：return-一个新对象-而不是refernce" class="headerlink" title="4.综上，一个”必须返回新对象”的函数正确写法是：return 一个新对象 而不是refernce"></a>4.综上，一个”必须返回新对象”的函数正确写法是：return 一个新对象 而不是refernce</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Ratioanl</span>(lhs.n*rhs.n,lhs.d*rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项-16"><a href="#注意事项-16" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-绝不要返回pointer或reference指向local-stack-对象-或返回reference-指向-heap-allocated-对象-或返回-reference-指向local-static-对象-条款4-为”在单线程环境中合理返回reference指向一个local-statci对象”提供了一份设计实例"><a href="#1-绝不要返回pointer或reference指向local-stack-对象-或返回reference-指向-heap-allocated-对象-或返回-reference-指向local-static-对象-条款4-为”在单线程环境中合理返回reference指向一个local-statci对象”提供了一份设计实例" class="headerlink" title="1.绝不要返回pointer或reference指向local stack 对象 ,或返回reference 指向 heap-allocated 对象, 或返回 reference 指向local-static 对象.(条款4)为”在单线程环境中合理返回reference指向一个local statci对象”提供了一份设计实例"></a>1.绝不要返回pointer或reference指向local stack 对象 ,或返回reference 指向 heap-allocated 对象, 或返回 reference 指向local-static 对象.(条款4)为”在单线程环境中合理返回reference指向一个local statci对象”提供了一份设计实例</h4><h1 id="条款-22-将成员变量声明为private"><a href="#条款-22-将成员变量声明为private" class="headerlink" title="条款 22 : 将成员变量声明为private"></a>条款 22 : 将成员变量声明为private</h1><h4 id="1-保证语法一致性"><a href="#1-保证语法一致性" class="headerlink" title="1.保证语法一致性"></a>1.保证语法一致性</h4><h4 id="2-对成员变量进行更精确的控制"><a href="#2-对成员变量进行更精确的控制" class="headerlink" title="2.对成员变量进行更精确的控制"></a>2.对成员变量进行更精确的控制</h4><h4 id="3-保证封装性-从封装的角度出发-其实只有两种访问权限-private-和-其他"><a href="#3-保证封装性-从封装的角度出发-其实只有两种访问权限-private-和-其他" class="headerlink" title="3.保证封装性,从封装的角度出发,其实只有两种访问权限:private 和 其他"></a>3.保证封装性,从封装的角度出发,其实只有两种访问权限:private 和 其他</h4><h4 id="4-条款23：某些东西的封装性于”当其内容改变时造成的代码破坏量”成反比"><a href="#4-条款23：某些东西的封装性于”当其内容改变时造成的代码破坏量”成反比" class="headerlink" title="4.条款23：某些东西的封装性于”当其内容改变时造成的代码破坏量”成反比"></a>4.条款23：某些东西的封装性于”当其内容改变时造成的代码破坏量”成反比</h4><h2 id="注意事项-17"><a href="#注意事项-17" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-切记将成员变量声明为private-赋予客户访问数据的一致性-即通过Public方法来访问-可细微划分访问控制-允诺约束条件获得保证-提供class-作者充分的实现弹性"><a href="#1-切记将成员变量声明为private-赋予客户访问数据的一致性-即通过Public方法来访问-可细微划分访问控制-允诺约束条件获得保证-提供class-作者充分的实现弹性" class="headerlink" title="1.切记将成员变量声明为private,赋予客户访问数据的一致性(即通过Public方法来访问),可细微划分访问控制,允诺约束条件获得保证,提供class 作者充分的实现弹性"></a>1.切记将成员变量声明为private,赋予客户访问数据的一致性(即通过Public方法来访问),可细微划分访问控制,允诺约束条件获得保证,提供class 作者充分的实现弹性</h4><h4 id="2-proteced-并不比-public-更具封装性"><a href="#2-proteced-并不比-public-更具封装性" class="headerlink" title="2.proteced 并不比 public 更具封装性"></a>2.proteced 并不比 public 更具封装性</h4><h1 id="条款-23-宁以non-member-non-friend替换member函数"><a href="#条款-23-宁以non-member-non-friend替换member函数" class="headerlink" title="条款 23 : 宁以non-member-non-friend替换member函数"></a>条款 23 : 宁以non-member-non-friend替换member函数</h1><h4 id="1-对于下述例子-1"><a href="#1-对于下述例子-1" class="headerlink" title="1.对于下述例子"></a>1.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果想统一执行这些动作,可以改写成下述</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;          <span class="comment">//调用clearCache,clearHistory,removeCookies</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//同样也可以改写为non-member</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clearBrowser具有更大的封装性"><a href="#clearBrowser具有更大的封装性" class="headerlink" title="clearBrowser具有更大的封装性"></a>clearBrowser具有更大的封装性</h4><h4 id="2-C-中更自然的做法是让clearBrowser-作为一个non-member-且与其在同一namespace"><a href="#2-C-中更自然的做法是让clearBrowser-作为一个non-member-且与其在同一namespace" class="headerlink" title="2.C++中更自然的做法是让clearBrowser 作为一个non-member 且与其在同一namespace"></a>2.C++中更自然的做法是让clearBrowser 作为一个non-member 且与其在同一namespace</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-namespcae-的好处-a-可跨越多个源码文件-而后者不能-b-将所有便利函数放在多个头文件但隶属于同一个namespace-意味着可以更轻松的扩展-class-对于客户是不能扩展的"><a href="#3-namespcae-的好处-a-可跨越多个源码文件-而后者不能-b-将所有便利函数放在多个头文件但隶属于同一个namespace-意味着可以更轻松的扩展-class-对于客户是不能扩展的" class="headerlink" title="3.namespcae 的好处: a.可跨越多个源码文件,而后者不能 b.将所有便利函数放在多个头文件但隶属于同一个namespace 意味着可以更轻松的扩展 ,class 对于客户是不能扩展的"></a>3.namespcae 的好处: a.可跨越多个源码文件,而后者不能 b.将所有便利函数放在多个头文件但隶属于同一个namespace 意味着可以更轻松的扩展 ,class 对于客户是不能扩展的</h4><h2 id="注意事项-18"><a href="#注意事项-18" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-以non-member-non-friend-替换-member-函数-依次增加封装性-包裹弹性-和机能扩充性"><a href="#1-以non-member-non-friend-替换-member-函数-依次增加封装性-包裹弹性-和机能扩充性" class="headerlink" title="1.以non-member-non-friend 替换 member 函数,依次增加封装性,包裹弹性?和机能扩充性"></a>1.以non-member-non-friend 替换 member 函数,依次增加<u>封装性</u>,<u>包裹弹性?</u>和<u>机能扩充性</u></h4><h1 id="条款-24-若所有参数皆需类型转换-为此采用non-member-函数"><a href="#条款-24-若所有参数皆需类型转换-为此采用non-member-函数" class="headerlink" title="条款 24 : 若所有参数皆需类型转换,为此采用non-member 函数"></a>条款 24 : 若所有参数皆需类型转换,为此采用non-member 函数</h1><h4 id="1-对于下述例子-2"><a href="#1-对于下述例子-2" class="headerlink" title="1.对于下述例子"></a>1.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>   <span class="comment">//有理数类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator=<span class="number">0</span>, <span class="type">int</span> denominator=<span class="number">1</span>);     <span class="comment">//non-explicit 允许隐式转换</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span><span class="type">const</span></span>;                             <span class="comment">//分子和分母的访问函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//假设想实现 operator*</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; rhs)<span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//return by-value 但接受一个 pass-by-reference-to-const (条款3,20,21)</span></span><br><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEighth;</span><br><span class="line">result = result * oneEighth;</span><br><span class="line"><span class="comment">//但如果想实现混合算数呢?</span></span><br><span class="line"><span class="number">1.</span>result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);        <span class="comment">//valid</span></span><br><span class="line"><span class="number">2.</span>result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);        <span class="comment">//invalid</span></span><br><span class="line"><span class="number">3.</span>result = <span class="keyword">operator</span>*(<span class="number">2</span>,oneHalf);        <span class="comment">//invalid</span></span><br><span class="line"><span class="comment">//对于成功的 1  2传给operator*时发生了隐式转换 , 类似于下述的行为</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * temp;</span><br><span class="line"><span class="comment">//对于下述例子</span></span><br><span class="line">result = oneHalf * <span class="number">2</span>;                   <span class="comment">//valid (在non-explicit构造下)</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;                   <span class="comment">//invalid(甚至在non-explicit构造下)</span></span><br><span class="line"><span class="comment">//结论:只有参数被列于参数列内,这个参数才是隐式转换的合格参与者</span></span><br></pre></td></tr></table></figure>

<h4 id="2-对此可以以non-member函数实现"><a href="#2-对此可以以non-member函数实现" class="headerlink" title="2.对此可以以non-member函数实现"></a>2.对此可以以non-member函数实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raional</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                    lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;                 <span class="comment">//valid</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth;                 <span class="comment">//invalid</span></span><br></pre></td></tr></table></figure>

<h4 id="3-member函数的反面是non-member函数-不是friend函数"><a href="#3-member函数的反面是non-member函数-不是friend函数" class="headerlink" title="3.member函数的反面是non-member函数,不是friend函数"></a>3.member函数的反面是non-member函数,不是friend函数</h4><h2 id="注意事项-19"><a href="#注意事项-19" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-如果你需要为某个函数的所有参数-进行类型转换-那么这个函数必须是个non-member"><a href="#1-如果你需要为某个函数的所有参数-进行类型转换-那么这个函数必须是个non-member" class="headerlink" title="1.如果你需要为某个函数的所有参数 进行类型转换,那么这个函数必须是个non-member"></a>1.如果你需要为某个函数的所有参数 进行类型转换,那么这个函数必须是个non-member</h4><h1 id="条款-25-考虑写出一个不抛出异常的swap函数"><a href="#条款-25-考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款 25 : 考虑写出一个不抛出异常的swap函数"></a>条款 25 : 考虑写出一个不抛出异常的swap函数</h1><h4 id="1-考虑下述例子"><a href="#1-考虑下述例子" class="headerlink" title="1.考虑下述例子"></a>1.考虑下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span>      <span class="comment">//std::swap</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只要类型支持copying函数,即可使用默认的swap代码</span></span><br><span class="line"><span class="comment">//&quot;pimpl手法&quot;  &quot;以指针指向一个对象,内含真正数据&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span>               </span><br><span class="line">&#123;                              <span class="comment">//针对Widget数据设计的class</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a,b,c;                 <span class="comment">//可能有许多数据,意味着赋值时间很长</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;       </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>                   <span class="comment">//使用 pimpl 手法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Wdiget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...                    <span class="comment">//省略实现细节 见(条款10,11,12)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl * pImpl;        <span class="comment">//指针,所指对象内含Widget数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-一旦要置换两个Widget对象值-需要做的是置换pImpl指针-但默认的swap算法不知道这点-默认的会赋值三个Widgets-和-三个WidgetImpl-效率极低-对此可以对std-swap提供针对Widget的特化"><a href="#2-一旦要置换两个Widget对象值-需要做的是置换pImpl指针-但默认的swap算法不知道这点-默认的会赋值三个Widgets-和-三个WidgetImpl-效率极低-对此可以对std-swap提供针对Widget的特化" class="headerlink" title="2.一旦要置换两个Widget对象值,需要做的是置换pImpl指针,但默认的swap算法不知道这点,默认的会赋值三个Widgets 和 三个WidgetImpl 效率极低,对此可以对std::swap提供针对Widget的特化"></a>2.一旦要置换两个Widget对象值,需要做的是置换pImpl指针,但默认的swap算法不知道这点,默认的会赋值三个Widgets 和 三个WidgetImpl 效率极低,对此可以对std::swap提供针对Widget的特化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;                    <span class="comment">//针对Widget的特化,但目前无法通过编译</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);   <span class="comment">//置换Wdigets时只需要置换它们的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//template&lt;&gt;表面它是一个std::swap的全特化</span></span><br><span class="line"><span class="comment">//无法编译的原因:该函数无法访问private变量,解决将其声明为friend 或 member</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);                          <span class="comment">//调用a的swap成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-假设Widget和WidgetImpl-都是class-templates-而不是-classes"><a href="#3-假设Widget和WidgetImpl-都是class-templates-而不是-classes" class="headerlink" title="3.假设Widget和WidgetImpl 都是class templates 而不是 classes"></a>3.假设Widget和WidgetImpl 都是class templates 而不是 classes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"><span class="comment">//如果尝试像 2 中一样的实现对std::swap 的特化</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;          <span class="comment">//错误 不合法</span></span><br><span class="line">    <span class="type">void</span> swap&lt; Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的错误是企图 偏特化 一个function template , 而C++只允许对class template 偏特化</span></span><br><span class="line"><span class="comment">//对此的解决办法是,为它添加一个重载版本</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;          <span class="comment">//std::swap的一个重载版本</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);                <span class="comment">//稍后为告诉你,这任然不合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-一般而言重载function-template-没有问题-但std是个特殊的namespace-其管理规则比较特殊-客户可以全特化-其中的templates-但不可以添加新的templates-即为此处为什么重载std-swap不合法的原因-所以请不要添加新的东西到std里头"><a href="#4-一般而言重载function-template-没有问题-但std是个特殊的namespace-其管理规则比较特殊-客户可以全特化-其中的templates-但不可以添加新的templates-即为此处为什么重载std-swap不合法的原因-所以请不要添加新的东西到std里头" class="headerlink" title="4.一般而言重载function template 没有问题,但std是个特殊的namespace ,其管理规则比较特殊, 客户可以全特化 其中的templates 但不可以添加新的templates,即为此处为什么重载std::swap不合法的原因,所以请不要添加新的东西到std里头"></a>4.一般而言重载function template 没有问题,但std是个特殊的namespace ,其管理规则比较特殊, 客户可以全特化 其中的templates 但不可以添加新的templates,即为此处为什么重载std::swap不合法的原因,所以请不要添加新的东西到std里头</h4><h4 id="5-所以对-3-中的解决办法为-声明一个non-member-swap-让他调用member-swap，但不再将这个swap声明为std-swap的特化或重载版本"><a href="#5-所以对-3-中的解决办法为-声明一个non-member-swap-让他调用member-swap，但不再将这个swap声明为std-swap的特化或重载版本" class="headerlink" title="5.所以对 3 中的解决办法为 声明一个non-member-swap,让他调用member-swap，但不再将这个swap声明为std::swap的特化或重载版本"></a>5.所以对 3 中的解决办法为 声明一个non-member-swap,让他调用member-swap，但不再将这个swap声明为std::swap的特化或重载版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff</span><br><span class="line">&#123;</span><br><span class="line">    ...                                     <span class="comment">//模板化的WidgetImpl 等等 用...省略</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;                   <span class="comment">//同前,省略细节,参考前述例子</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在任何地点的任何代码如果打算置换两个Widget对象,因而调用 name lookup rules: 所谓的&quot;argument-dependent lookup 或 Koenig lookup&quot;法则,找到WidgetStuff内的Widget专属版本</span></span><br></pre></td></tr></table></figure>

<h4 id="6-应该调用哪个swap-std-swap的一般化-还是可能存在的特化版本-栖身于某个命名空间的T专属版本"><a href="#6-应该调用哪个swap-std-swap的一般化-还是可能存在的特化版本-栖身于某个命名空间的T专属版本" class="headerlink" title="6.应该调用哪个swap? std::swap的一般化,还是可能存在的特化版本,栖身于某个命名空间的T专属版本?"></a>6.应该调用哪个swap? std::swap的一般化,还是可能存在的特化版本,栖身于某个命名空间的T专属版本?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;    <span class="comment">//令std::swap 在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1,obj2);    <span class="comment">//为T 调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器优先std::swap的T专属版本,而非一般的template,所以如果你已针对T将std::swap特化，特化版会被编译器挑中</span></span><br></pre></td></tr></table></figure>

<h4 id="7-此处已经讨论过-default-swap-member-swap-non-member-swap-std-swap-特化版本-以及对swap的调用-如果swap默认版本效率不够-尝试做以下事"><a href="#7-此处已经讨论过-default-swap-member-swap-non-member-swap-std-swap-特化版本-以及对swap的调用-如果swap默认版本效率不够-尝试做以下事" class="headerlink" title="7.此处已经讨论过 default swap,member swap,non-member swap,std::swap 特化版本,以及对swap的调用,如果swap默认版本效率不够,尝试做以下事"></a>7.此处已经讨论过 <u>default swap</u>,<u>member swap</u>,<u>non-member swap</u>,<u>std::swap</u> 特化版本,以及对swap的调用,如果swap默认版本效率不够,尝试做以下事</h4><h5 id="a-提供一个public-swap-成员函数-此函数绝不该抛出异常"><a href="#a-提供一个public-swap-成员函数-此函数绝不该抛出异常" class="headerlink" title="a.提供一个public swap 成员函数,此函数绝不该抛出异常"></a>a.提供一个public swap 成员函数,此函数绝不该抛出异常</h5><h5 id="b-在你的class-或-template-所在的命名空间内提供一个non-member-swap"><a href="#b-在你的class-或-template-所在的命名空间内提供一个non-member-swap" class="headerlink" title="b.在你的class 或 template 所在的命名空间内提供一个non-member swap"></a>b.在你的class 或 template 所在的命名空间内提供一个non-member swap</h5><h5 id="c-如果你在编写一个class-，为你的class-特化std-swap"><a href="#c-如果你在编写一个class-，为你的class-特化std-swap" class="headerlink" title="c.如果你在编写一个class ，为你的class 特化std::swap"></a>c.如果你在编写一个class ，为你的class 特化std::swap</h5><h5 id="d-调用时确定包含一个using-声明式-使std-swap在函数内曝光"><a href="#d-调用时确定包含一个using-声明式-使std-swap在函数内曝光" class="headerlink" title="d.调用时确定包含一个using 声明式,使std::swap在函数内曝光"></a>d.调用时确定包含一个using 声明式,使std::swap在函数内曝光</h5><h2 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-当std-swap-效率不高时-提供一个绝不抛出异常的swap成员函数"><a href="#1-当std-swap-效率不高时-提供一个绝不抛出异常的swap成员函数" class="headerlink" title="1.当std::swap 效率不高时,提供一个绝不抛出异常的swap成员函数"></a>1.当std::swap 效率不高时,提供一个绝不抛出异常的swap成员函数</h4><h4 id="2-如果你提供一个member-swap，也该提供一个non-member-swap来调用函数-队与classes-而非templates-请特化std-swap"><a href="#2-如果你提供一个member-swap，也该提供一个non-member-swap来调用函数-队与classes-而非templates-请特化std-swap" class="headerlink" title="2.如果你提供一个member swap，也该提供一个non-member swap来调用函数,队与classes(而非templates) 请特化std::swap"></a>2.如果你提供一个member swap，也该提供一个non-member swap来调用函数,队与classes(而非templates) 请特化std::swap</h4><h4 id="3-调用swap时应该针对std-swap使用using-声明"><a href="#3-调用swap时应该针对std-swap使用using-声明" class="headerlink" title="3.调用swap时应该针对std::swap使用using 声明"></a>3.调用swap时应该针对std::swap使用using 声明</h4><h4 id="4-不要在std-namespcae-中添加新的东西-但可以提供template的特化"><a href="#4-不要在std-namespcae-中添加新的东西-但可以提供template的特化" class="headerlink" title="4.不要在std namespcae 中添加新的东西,但可以提供template的特化"></a>4.不要在std namespcae 中添加新的东西,但可以提供template的特化</h4><h1 id="条款-26-尽可能延后变量定义式的出现时间"><a href="#条款-26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26 : 尽可能延后变量定义式的出现时间"></a>条款 26 : 尽可能延后变量定义式的出现时间</h1><h4 id="1-对于下述例子-3"><a href="#1-对于下述例子-3" class="headerlink" title="1.对于下述例子"></a>1.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下述函数计算通行密码的加密版本并返回,前提是密码够长,若太短则抛出异常,类型为logic_error</span></span><br><span class="line"><span class="comment">//这个函数过早定义变量&quot;encrypted&quot;</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinmumPasswordLength)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...                    <span class="comment">//必要动作,加密密码,并置入变量encrypted内</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//encrypted并没有被完全使用,如果抛出异常,则白白承担了encrypted的构造和析构成本</span></span><br><span class="line"><span class="comment">//下述函数延后&quot;encrypted&quot;的定义,直到需要它</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinmumPasswordLength)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    ...                    <span class="comment">//必要动作,加密密码,并置入变量encrypted内</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仍然不够秾纤合度,条款4曾解释为什么&quot;通过default构造函数构造出一个对象然后赋值&quot;比&quot;直接在构造时指定初值&quot;效率差</span></span><br><span class="line"><span class="comment">//假设加密部分在以下函数中进行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encrypt</span><span class="params">(std::string&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::string encrypted;</span><br><span class="line">    encrypted = password;</span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更受欢迎的做法是以password直接作为encrypted的初值,跳过无意义的default构造</span></span><br><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="type">const</span> std::string&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">encrypted</span><span class="params">(password)</span></span>;</span><br><span class="line">    <span class="built_in">encrypt</span>(encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-对于循环来说呢"><a href="#2-对于循环来说呢" class="headerlink" title="2.对于循环来说呢?"></a>2.对于循环来说呢?</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#示例A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    w = i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//#示例B</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两种写法成本如下</span></span><br><span class="line"><span class="comment">//A : 1个构造函数 + 1个析构函数 + n个赋值操作</span></span><br><span class="line"><span class="comment">//B : n个构造函数 + n个析构函数</span></span><br></pre></td></tr></table></figure>

<h4 id="大体上A更高效-尤其当n很大的时候-否则做法B或许比较好-A造成名称w的作用域比B大-可能对程序的可理解性和易维护性造成冲突-因此除非你知道"><a href="#大体上A更高效-尤其当n很大的时候-否则做法B或许比较好-A造成名称w的作用域比B大-可能对程序的可理解性和易维护性造成冲突-因此除非你知道" class="headerlink" title="大体上A更高效,尤其当n很大的时候,否则做法B或许比较好.A造成名称w的作用域比B大,可能对程序的可理解性和易维护性造成冲突,因此除非你知道:"></a>大体上A更高效,尤其当n很大的时候,否则做法B或许比较好.A造成名称w的作用域比B大,可能对程序的可理解性和易维护性造成冲突,因此除非你知道:</h4><h5 id="a-赋值成本比”析构-构造“低"><a href="#a-赋值成本比”析构-构造“低" class="headerlink" title="a.赋值成本比”析构+构造“低"></a>a.赋值成本比”析构+构造“低</h5><h5 id="b-你正在处理代码中效率高度敏感的部分"><a href="#b-你正在处理代码中效率高度敏感的部分" class="headerlink" title="b.你正在处理代码中效率高度敏感的部分"></a>b.你正在处理代码中效率高度敏感的部分</h5><h2 id="注意事项-20"><a href="#注意事项-20" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-尽可能延后变量定义式的出现-以增加程序清晰度-并改善效率"><a href="#1-尽可能延后变量定义式的出现-以增加程序清晰度-并改善效率" class="headerlink" title="1.尽可能延后变量定义式的出现,以增加程序清晰度,并改善效率"></a>1.尽可能延后变量定义式的出现,以增加程序清晰度,并改善效率</h4><h1 id="条款-27-尽量少做转型动作"><a href="#条款-27-尽量少做转型动作" class="headerlink" title="条款 27 : 尽量少做转型动作"></a>条款 27 : 尽量少做转型动作</h1><h4 id="1-”旧式转换”-T-expression-和-T-expression-C-提供四种新式类型转换"><a href="#1-”旧式转换”-T-expression-和-T-expression-C-提供四种新式类型转换" class="headerlink" title="1.”旧式转换”: (T)expression 和 T(expression) , C++提供四种新式类型转换"></a>1.”旧式转换”: (T)expression 和 T(expression) , C++提供<u>四种新式类型转换</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="comment">//各有不同的目的</span></span><br></pre></td></tr></table></figure>

<h5 id="a-const-cast-通常用来将对象的常量性转除-cast-away-the-constness-也是唯一有次能力的C-style操作符"><a href="#a-const-cast-通常用来将对象的常量性转除-cast-away-the-constness-也是唯一有次能力的C-style操作符" class="headerlink" title="a. const_cast 通常用来将对象的常量性转除 (cast away the constness),也是唯一有次能力的C++-style操作符"></a>a. const_cast 通常用来将对象的常量性转除 (cast away the constness),也是唯一有次能力的C++-style操作符</h5><h5 id="b-dynamic-cast-用来执行”安全向下转型”-safe-downcasting-也就是来决定某对象是否归属继承体系中的某个类型-唯一无法由旧语法执行的动作-而且开销巨大"><a href="#b-dynamic-cast-用来执行”安全向下转型”-safe-downcasting-也就是来决定某对象是否归属继承体系中的某个类型-唯一无法由旧语法执行的动作-而且开销巨大" class="headerlink" title="b. dynamic_cast 用来执行”安全向下转型” (safe downcasting) ,也就是来决定某对象是否归属继承体系中的某个类型,唯一无法由旧语法执行的动作,而且开销巨大"></a>b. dynamic_cast 用来执行”安全向下转型” (safe downcasting) ,也就是来决定某对象是否归属继承体系中的某个类型,唯一无法由旧语法执行的动作,而且开销巨大</h5><h5 id="c-reinterpret-cast-意图执行低级转型"><a href="#c-reinterpret-cast-意图执行低级转型" class="headerlink" title="c. reinterpret_cast 意图执行低级转型"></a>c. reinterpret_cast 意图执行低级转型</h5><h5 id="d-static-cast-用来强迫隐式转换-例如将non-const-转换为-const对象-条款3-或像int-转为-double-但他无法做到const转为non-const"><a href="#d-static-cast-用来强迫隐式转换-例如将non-const-转换为-const对象-条款3-或像int-转为-double-但他无法做到const转为non-const" class="headerlink" title="d. static_cast 用来强迫隐式转换,例如将non-const 转换为 const对象(条款3),或像int 转为 double,但他无法做到const转为non-const"></a>d. static_cast 用来强迫隐式转换,例如将non-const 转换为 const对象(条款3),或像int 转为 double,但他无法做到const转为non-const</h5><h4 id="2-C-新式转换很受欢迎-但旧式转换仍然有更适合的使用时机-参考下述例子"><a href="#2-C-新式转换很受欢迎-但旧式转换仍然有更适合的使用时机-参考下述例子" class="headerlink" title="2.C++新式转换很受欢迎,但旧式转换仍然有更适合的使用时机 ,参考下述例子"></a>2.C++新式转换很受欢迎,但旧式转换仍然有更适合的使用时机 ,参考下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">Widget</span>(<span class="number">15</span>));              <span class="comment">//旧式函数风格</span></span><br><span class="line"><span class="built_in">doSomeWork</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>)); <span class="comment">//C++-style</span></span><br></pre></td></tr></table></figure>

<h4 id="对此蓄意的”对象生成”-动作上不像”类型转换”-所以使用旧式转换可能更恰当-但始终使用新式转换也是好的习惯"><a href="#对此蓄意的”对象生成”-动作上不像”类型转换”-所以使用旧式转换可能更恰当-但始终使用新式转换也是好的习惯" class="headerlink" title="对此蓄意的”对象生成”,动作上不像”类型转换”,所以使用旧式转换可能更恰当,但始终使用新式转换也是好的习惯"></a>对此<u>蓄意的”对象生成”,动作上不像”类型转换”,所以使用旧式转换可能更恰当</u>,但始终使用新式转换也是好的习惯</h4><h4 id="3-对于类型转换-编译器什么都没做吗？参考下述例子"><a href="#3-对于类型转换-编译器什么都没做吗？参考下述例子" class="headerlink" title="3.对于类型转换,编译器什么都没做吗？参考下述例子"></a>3.对于类型转换,编译器什么都没做吗？参考下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base * pb = &amp;d;                     <span class="comment">//隐喻的将Derived* 转换为 Base*</span></span><br><span class="line"><span class="comment">//这里建立一个 base class 指针指向一个 derived class 对象,但有时候上述的两个指针值并不相同,这种情况下会有个偏移量(offset)在运行期被施行于Derived* 指针上,用以获取正确的Base* 指针值</span></span><br><span class="line"><span class="comment">//这个例子表面,但一对象可能拥有一个以上的地址(C,JAVA,C# 都不可能发生这种事),但C++可能</span></span><br></pre></td></tr></table></figure>

<h4 id="4-参考下述例子-一个base-class-和-derived-class-两者都定义了virtual-函数-要求先在derived-class-的virtual-中-调用-base-class-的virtua"><a href="#4-参考下述例子-一个base-class-和-derived-class-两者都定义了virtual-函数-要求先在derived-class-的virtual-中-调用-base-class-的virtua" class="headerlink" title="4.参考下述例子,一个base class 和 derived class ,两者都定义了virtual 函数,要求先在derived class 的virtual 中 调用 base class 的virtua"></a>4.参考下述例子,一个base class 和 derived class ,两者都定义了virtual 函数,要求先在derived class 的virtual 中 调用 base class 的virtua</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>:<span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();<span class="comment">// 将*this转为Window 调用其onResize这不可行</span></span><br><span class="line">        ...                  <span class="comment">//执行SpecialWindow的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此处将*this转为 Window ，对函数的调用因此调用了 Window::onResize ，但他调用的不是当前对象上的函数, </span></span><br><span class="line"><span class="comment">//&quot; 而是稍早转型动作所建立的一个 ‘*this 对象的base class 成分’ 的暂时副本身上的onResize &quot;</span></span><br><span class="line"><span class="comment">//换句话说就是 转型动作导致生成了一个副本,此处的调用是对副本执行的,使当前对象进入一种&quot;伤残&quot;状态:</span></span><br><span class="line"><span class="comment">//其base class 成分的更改没有执行(执行到一个副本上去了),而derived class 成分的更改落实了</span></span><br></pre></td></tr></table></figure>

<h4 id="5-解决的办法应该是拿掉转型动作-采用下述例子的方法"><a href="#5-解决的办法应该是拿掉转型动作-采用下述例子的方法" class="headerlink" title="5.解决的办法应该是拿掉转型动作,采用下述例子的方法"></a>5.解决的办法应该是拿掉转型动作,采用下述例子的方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>:<span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Window::<span class="built_in">onResize</span>();   <span class="comment">//调用Window::onResize 作用于当前对象身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6-对于dynamic-cast-应该注重他对效率的影响-之所以需要使用-dynamic-cast-，通常是因为你想要在一个你认定为derived-class-对象身上执行derived-class操作-但你的手上只有一个”指向base”的pointer或reference-一般两种做法可以解决"><a href="#6-对于dynamic-cast-应该注重他对效率的影响-之所以需要使用-dynamic-cast-，通常是因为你想要在一个你认定为derived-class-对象身上执行derived-class操作-但你的手上只有一个”指向base”的pointer或reference-一般两种做法可以解决" class="headerlink" title="6.对于dynamic_cast 应该注重他对效率的影响,之所以需要使用:dynamic_cast ，通常是因为你想要在一个你认定为derived class 对象身上执行derived class操作,但你的手上只有一个”指向base”的pointer或reference,一般两种做法可以解决:"></a>6.对于dynamic_cast 应该注重他对效率的影响,之所以需要使用:<u>dynamic_cast ，通常是因为你想要在一个你认定为derived class 对象身上执行derived class操作,但你的手上只有一个”指向base”的pointer或reference</u>,一般两种做法可以解决:</h4><h6 id="第一-使用容器并在其中存储指向-derived-class-对象的指针-通常是智能指针-条款13"><a href="#第一-使用容器并在其中存储指向-derived-class-对象的指针-通常是智能指针-条款13" class="headerlink" title="第一,使用容器并在其中存储指向 derived class 对象的指针(通常是智能指针,条款13)"></a>第一,使用容器并在其中存储指向 derived class 对象的指针(通常是智能指针,条款13)</h6><h6 id="假设先前的Window-x2F-SpecialWindow-继承中-只有SpecialWindow-支持闪烁"><a href="#假设先前的Window-x2F-SpecialWindow-继承中-只有SpecialWindow-支持闪烁" class="headerlink" title="假设先前的Window &#x2F; SpecialWindow 继承中,只有SpecialWindow 支持闪烁"></a>假设先前的Window &#x2F; SpecialWindow 继承中,只有SpecialWindow 支持闪烁</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试着不要这么做</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>:<span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">blink</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;                                               <span class="comment">//关于tr1::shared_ptr 见条款13</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPM;</span><br><span class="line">VPM winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPM::iterator iter = winPtrs.<span class="built_in">begin</span>();iter != winPtrs.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">&#123;                                                <span class="comment">//不希望使用</span></span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow *psw = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;( iter-&gt;<span class="built_in">get</span>() ) )</span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//应该改成这样做   1.</span></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...                                              <span class="comment">//不使用dynamic_cast</span></span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();iter != winPtrs.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种做法的弊端:无法在同一个容器内存储指针&quot;指向所有可能的Window派生类&quot;</span></span><br><span class="line"><span class="comment">//另一种做法可以通过base class 接口处理所有可能</span></span><br><span class="line"><span class="comment">//               2.</span></span><br><span class="line"><span class="comment">//那就是在base class 中提供virtual函数.举个例子 在不需要闪烁的派生中提供一份什么也不做的闪烁函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:              <span class="comment">//默认实现代码什么也不做,条款34告诉你为什么默认实现代码可能是个馊主意</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>:<span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;                           <span class="comment">//Window 指向所有可能</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPM::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>

<h4 id="无论哪种写法-1-使用类型安全容器-2-将virtual函数往继承体系上方移动-—-都并非完美的方案-但在许多情况下提供了一个可行的dynamic-cast替代方案"><a href="#无论哪种写法-1-使用类型安全容器-2-将virtual函数往继承体系上方移动-—-都并非完美的方案-但在许多情况下提供了一个可行的dynamic-cast替代方案" class="headerlink" title="无论哪种写法 1.使用类型安全容器 2.将virtual函数往继承体系上方移动 —-都并非完美的方案,但在许多情况下提供了一个可行的dynamic_cast替代方案"></a>无论哪种写法 <u>1.使用类型安全容器 2.将virtual函数往继承体系上方移动</u> —-都并非完美的方案,但在许多情况下提供了一个<u>可行的dynamic_cast替代方案</u></h4><h4 id="7-绝对需要避免的是所谓的-“连串-dynamic-cast”"><a href="#7-绝对需要避免的是所谓的-“连串-dynamic-cast”" class="headerlink" title="7.绝对需要避免的是所谓的 “连串 dynamic-cast”"></a>7.绝对需要避免的是所谓的 <u>“连串 dynamic-cast”</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123; ... &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPM;</span><br><span class="line">VPM winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPM::iterator iter = winPtrs.<span class="built_in">begin</span>();iter != winPtrs.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow1 * psw1 = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow1&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (SpecialWindow2 * psw2 = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow2&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (SpecialWindow3 * psw3 = <span class="built_in">dynamic_cast</span>&lt;SpecialWindow3&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这样的代码又大又慢-且一旦base-class-发生改变-需要花费大量的时间检查是否需要修改-应当采用上述替代方案-将其替换"><a href="#这样的代码又大又慢-且一旦base-class-发生改变-需要花费大量的时间检查是否需要修改-应当采用上述替代方案-将其替换" class="headerlink" title="这样的代码又大又慢,且一旦base class 发生改变,需要花费大量的时间检查是否需要修改,应当采用上述替代方案,将其替换"></a>这样的代码又大又慢,且一旦base class 发生改变,需要花费大量的时间检查是否需要修改,应当采用上述替代方案,将其替换</h4><h2 id="注意事项-21"><a href="#注意事项-21" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-尽量避免转型动作-尤其是在效率敏感的代码中执行-dynamic-cast"><a href="#1-尽量避免转型动作-尤其是在效率敏感的代码中执行-dynamic-cast" class="headerlink" title="1.尽量避免转型动作,尤其是在效率敏感的代码中执行 dynamic_cast"></a>1.尽量避免转型动作,尤其是在<u>效率敏感</u>的代码中执行 dynamic_cast</h4><h4 id="2-如果转型是必要的-试着将它隐藏于某个函数背后-客户通过调用该函数达到目的-而不是直接将他放入代码"><a href="#2-如果转型是必要的-试着将它隐藏于某个函数背后-客户通过调用该函数达到目的-而不是直接将他放入代码" class="headerlink" title="2.如果转型是必要的,试着将它隐藏于某个函数背后,客户通过调用该函数达到目的,而不是直接将他放入代码"></a>2.如果转型是必要的,试着将它隐藏于某个函数背后,客户通过调用该函数达到目的,而不是直接将他放入代码</h4><h4 id="3-使用新式而不用旧式-新式方便辨认目的"><a href="#3-使用新式而不用旧式-新式方便辨认目的" class="headerlink" title="3.使用新式而不用旧式,新式方便辨认目的"></a>3.使用新式而不用旧式,新式方便辨认目的</h4><h1 id="条款28-避免返回handles指向对象内部成分"><a href="#条款28-避免返回handles指向对象内部成分" class="headerlink" title="条款28 : 避免返回handles指向对象内部成分"></a>条款28 : 避免返回handles指向对象内部成分</h1><h4 id="1-成员变量的封装性最多只等于”返回其reference”的函数的访问级别-如返回一个pirvate变量的引用-将导致该变量的访问权限降到public"><a href="#1-成员变量的封装性最多只等于”返回其reference”的函数的访问级别-如返回一个pirvate变量的引用-将导致该变量的访问权限降到public" class="headerlink" title="1.成员变量的封装性最多只等于”返回其reference”的函数的访问级别,如返回一个pirvate变量的引用,将导致该变量的访问权限降到public"></a>1.成员变量的封装性最多只等于”返回其reference”的函数的访问级别,如返回一个pirvate变量的引用,将导致该变量的访问权限降到public</h4><h4 id="2-如果const成员函数传出一个reference-，后者所指数据与对象自身有关联-而它又被存储于对象之外-那么这个函数的调用者可以修改那笔数据-这正式bitwise-constness-的附带结果-见条款3"><a href="#2-如果const成员函数传出一个reference-，后者所指数据与对象自身有关联-而它又被存储于对象之外-那么这个函数的调用者可以修改那笔数据-这正式bitwise-constness-的附带结果-见条款3" class="headerlink" title="2.如果const成员函数传出一个reference ，后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个函数的调用者可以修改那笔数据, 这正式bitwise constness 的附带结果(见条款3)"></a>2.如果<u>const成员函数传出一个reference</u> ，后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个<u>函数的调用者可以修改那笔数据</u>, 这正式bitwise constness 的附带结果(见条款3)</h4><h4 id="3-上述事情都是发生于”函数返回reference”-如果它们返回的式指针或迭代器-同样如此"><a href="#3-上述事情都是发生于”函数返回reference”-如果它们返回的式指针或迭代器-同样如此" class="headerlink" title="3.上述事情都是发生于”函数返回reference”.如果它们返回的式指针或迭代器,同样如此."></a>3.上述事情都是发生于”函数返回reference”.如果它们返回的式指针或迭代器,同样如此.</h4><h4 id="reference-指针-迭代器-都是所谓的-handles-，返回它们将导致”降低对象封装性"><a href="#reference-指针-迭代器-都是所谓的-handles-，返回它们将导致”降低对象封装性" class="headerlink" title="reference,指针,迭代器 都是所谓的 handles ，返回它们将导致”降低对象封装性"></a>reference,指针,迭代器 都是所谓的 handles ，返回它们将导致”降低对象封装性</h4><h4 id="4-对于成员内部-变量或函数-绝不应该令public-中的成员函数返回一个指针指向它们-这样会导致后者的访问级别提高"><a href="#4-对于成员内部-变量或函数-绝不应该令public-中的成员函数返回一个指针指向它们-这样会导致后者的访问级别提高" class="headerlink" title="4.对于成员内部,变量或函数,绝不应该令public 中的成员函数返回一个指针指向它们,这样会导致后者的访问级别提高"></a>4.对于成员内部,变量或函数,绝不应该令public 中的成员函数返回一个指针指向它们,这样会导致后者的访问级别提高</h4><h4 id="5-返回handles-易导致-指向一个不存在的对象-即该指针变为-空悬-虚掉的"><a href="#5-返回handles-易导致-指向一个不存在的对象-即该指针变为-空悬-虚掉的" class="headerlink" title="5.返回handles 易导致 指向一个不存在的对象,即该指针变为 空悬,虚掉的"></a>5.<u>返回handles 易导致 指向一个不存在的对象,即该指针变为 空悬,虚掉的</u></h4><h4 id="6-这并不意味着绝对不可以让函数返回handle-operator-就是一个允许返回引用的例子-但这是例外-并不是常态"><a href="#6-这并不意味着绝对不可以让函数返回handle-operator-就是一个允许返回引用的例子-但这是例外-并不是常态" class="headerlink" title="6.这并不意味着绝对不可以让函数返回handle, operator[] 就是一个允许返回引用的例子,但这是例外,并不是常态"></a>6.这并不意味着绝对不可以让函数返回handle, operator[] 就是一个允许返回引用的例子,但这是例外,并不是常态</h4><h2 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-避免返回handles-reference-pointer-iterator-指向内部-将发生指针悬吊的可能性降到最低"><a href="#1-避免返回handles-reference-pointer-iterator-指向内部-将发生指针悬吊的可能性降到最低" class="headerlink" title="1.避免返回handles(reference,pointer,iterator)指向内部,将发生指针悬吊的可能性降到最低"></a>1.避免返回handles(<u>reference,pointer,iterator</u>)指向内部,将发生指针悬吊的可能性降到最低</h4><h1 id="条款-29-为”异常安全”而努力是值得的"><a href="#条款-29-为”异常安全”而努力是值得的" class="headerlink" title="条款 29 : 为”异常安全”而努力是值得的"></a>条款 29 : 为”异常安全”而努力是值得的</h1><h4 id="1-基本承诺：如果抛出异常-程序内的任何事物仍然保存在有效状态-没有任何对象或数据结构会因此损坏-例如-对于changeBackground-一旦对象被抛出-对象可能继续拥有原背景图像-也可能拥有一个缺省背景图像-但客户无法预期哪一种情况-如果想知道-他们恐怕必须调用某个成员函数以得知当时的背景图像是什么"><a href="#1-基本承诺：如果抛出异常-程序内的任何事物仍然保存在有效状态-没有任何对象或数据结构会因此损坏-例如-对于changeBackground-一旦对象被抛出-对象可能继续拥有原背景图像-也可能拥有一个缺省背景图像-但客户无法预期哪一种情况-如果想知道-他们恐怕必须调用某个成员函数以得知当时的背景图像是什么" class="headerlink" title="1.基本承诺：如果抛出异常,程序内的任何事物仍然保存在有效状态,没有任何对象或数据结构会因此损坏,例如 对于changeBackground 一旦对象被抛出, 对象可能继续拥有原背景图像,也可能拥有一个缺省背景图像,但客户无法预期哪一种情况,如果想知道,他们恐怕必须调用某个成员函数以得知当时的背景图像是什么"></a>1.<u>基本承诺</u>：如果抛出异常,程序内的任何事物仍然保存在有效状态,没有任何对象或数据结构会因此损坏,例如 对于changeBackground 一旦对象被抛出, 对象可能继续拥有原背景图像,也可能拥有一个缺省背景图像,但客户无法预期哪一种情况,如果想知道,他们恐怕必须调用某个成员函数以得知当时的背景图像是什么</h4><h4 id="2-强烈保证：如果异常被抛出-程序状态不改变-即如果成功-就是完全成功-如果失败-则会回复到”调用函数前的状态”"><a href="#2-强烈保证：如果异常被抛出-程序状态不改变-即如果成功-就是完全成功-如果失败-则会回复到”调用函数前的状态”" class="headerlink" title="2.强烈保证：如果异常被抛出,程序状态不改变,即如果成功,就是完全成功,如果失败,则会回复到”调用函数前的状态”"></a>2.<u>强烈保证</u>：如果异常被抛出,程序状态不改变,即如果成功,就是完全成功,如果失败,则会回复到”调用函数前的状态”</h4><h4 id="3-不抛掷保证-承诺绝不抛出异常-总是能完成它们承诺的功能"><a href="#3-不抛掷保证-承诺绝不抛出异常-总是能完成它们承诺的功能" class="headerlink" title="3.不抛掷保证,承诺绝不抛出异常,总是能完成它们承诺的功能"></a>3.<u>不抛掷保证</u>,承诺绝不抛出异常,总是能完成它们承诺的功能</h4><h4 id="4-对于强烈保证的一个一般化设计策略：copy-and-swap"><a href="#4-对于强烈保证的一个一般化设计策略：copy-and-swap" class="headerlink" title="4.对于强烈保证的一个一般化设计策略：copy and swap"></a>4.对于<u>强烈保证的一个一般化设计策略：copy and swap</u></h4><h5 id="实现上通常是将所有”隶属于对象的数据”从原对象放进另一个对象内-然后赋予原对象一个指针-指向那个所谓的实现对象-这种手法通常被称为-pimpl-idiom-条款31-详细描述了它"><a href="#实现上通常是将所有”隶属于对象的数据”从原对象放进另一个对象内-然后赋予原对象一个指针-指向那个所谓的实现对象-这种手法通常被称为-pimpl-idiom-条款31-详细描述了它" class="headerlink" title="实现上通常是将所有”隶属于对象的数据”从原对象放进另一个对象内,然后赋予原对象一个指针,指向那个所谓的实现对象,这种手法通常被称为 pimpl idiom 条款31 详细描述了它"></a>实现上通常是将所有”隶属于对象的数据”从原对象放进另一个对象内,然后赋予原对象一个指针,指向那个所谓的实现对象,这种手法通常被称为 pimpl idiom 条款31 详细描述了它</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMImpl</span>                                     <span class="comment">//声明为struct 后面解释</span></span><br><span class="line">&#123;</span><br><span class="line">    std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="type">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    pNew-&gt;bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));     <span class="comment">//修改副本</span></span><br><span class="line">    pNew-&gt;imageChanges++;</span><br><span class="line">    <span class="built_in">swap</span>(pImpl,pNew);                           <span class="comment">//置换swap,释放mutex</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让PMImpl成为一个struct 而不是一个 class,因为PrettyMenu 的数据封装性,已经将其声明为private</span></span><br><span class="line"><span class="comment">//&quot;copy-and-swap&quot; 策略是对象状态做出&quot;全有或全无&quot;改变的一个很好办法</span></span><br></pre></td></tr></table></figure>

<h4 id="5-但一般而言它并不保证整个函数有强烈的异常安全性"><a href="#5-但一般而言它并不保证整个函数有强烈的异常安全性" class="headerlink" title="5.但一般而言它并不保证整个函数有强烈的异常安全性"></a>5.<u>但一般而言它并不保证整个函数有强烈的异常安全性</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...      <span class="comment">//对local状态做一份副本</span></span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">    ...      <span class="comment">//将修改后的的状态置换过来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//很显然如果f1, f2 的异常安全性比&quot;强烈保证低&quot;，就很难让somefunc成为&quot;强烈异常安全&quot;</span></span><br><span class="line"><span class="comment">//如果f1,f2都是&quot;强烈异常安全&quot;，情况并不就此好转,假设f1圆满执行,但f2抛出异常,此时f1发生变化,f2不变,程序状态与被调用前并不相同,所以不属于&quot;强烈异常安全&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-问题出在“连带影响”-只操作局部性状态很容易提供强烈保证-但是当函数对非局部性数据有连带影响时，提供强烈保证就困难的多"><a href="#6-问题出在“连带影响”-只操作局部性状态很容易提供强烈保证-但是当函数对非局部性数据有连带影响时，提供强烈保证就困难的多" class="headerlink" title="6.问题出在“连带影响”,只操作局部性状态很容易提供强烈保证,但是当函数对非局部性数据有连带影响时，提供强烈保证就困难的多"></a>6.问题出在<u>“连带影响”</u>,只操作局部性状态很容易提供强烈保证,但是当函数对非局部性数据有连带影响时，提供强烈保证就困难的多</h4><h4 id="7-上述议题会组织你为函数提供强烈保证-即使你想这么做-另一个原因是效率-copy-and-swap的关键在于”修改对象数据的副本”-然后再不抛出异常的前提下置换-因此必须为每一个将被改动的对象做一个副本"><a href="#7-上述议题会组织你为函数提供强烈保证-即使你想这么做-另一个原因是效率-copy-and-swap的关键在于”修改对象数据的副本”-然后再不抛出异常的前提下置换-因此必须为每一个将被改动的对象做一个副本" class="headerlink" title="7.上述议题会组织你为函数提供强烈保证,即使你想这么做.另一个原因是效率,copy-and-swap的关键在于”修改对象数据的副本”,然后再不抛出异常的前提下置换,因此必须为每一个将被改动的对象做一个副本"></a>7.上述议题会组织你为函数提供强烈保证,即使你想这么做.另一个原因是效率,copy-and-swap的关键在于”修改对象数据的副本”,然后再不抛出异常的前提下置换,因此必须为每一个将被改动的对象做一个副本</h4><h4 id="8-当”强烈保证”不切实际时-应当提供”基本保证"><a href="#8-当”强烈保证”不切实际时-应当提供”基本保证" class="headerlink" title="8.当”强烈保证”不切实际时,应当提供”基本保证"></a>8.当”强烈保证”不切实际时,应当提供”基本保证</h4><h2 id="注意事项-22"><a href="#注意事项-22" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-异常安全函数-即使发生异常也不会泄漏资源或允许任何数据结构败坏-这样的函数分为三种级别：基本型-强烈型-不抛异常型"><a href="#1-异常安全函数-即使发生异常也不会泄漏资源或允许任何数据结构败坏-这样的函数分为三种级别：基本型-强烈型-不抛异常型" class="headerlink" title="1.异常安全函数(即使发生异常也不会泄漏资源或允许任何数据结构败坏):这样的函数分为三种级别：基本型,强烈型,不抛异常型"></a>1.异常安全函数(即使发生异常也不会泄漏资源或允许任何数据结构败坏):这样的函数分为三种级别：基本型,强烈型,不抛异常型</h4><h4 id="2-”强烈保证”通常的实现策略为copy-and-swap-，但并非所有函数都可以实现或具备实现意义"><a href="#2-”强烈保证”通常的实现策略为copy-and-swap-，但并非所有函数都可以实现或具备实现意义" class="headerlink" title="2.”强烈保证”通常的实现策略为copy-and-swap ，但并非所有函数都可以实现或具备实现意义"></a>2.”强烈保证”通常的实现策略为copy-and-swap ，但并非所有函数都可以实现或具备实现意义</h4><h4 id="3-函数提供的”异常安全保证”，通常只等于其调用各个函数的”异常安全保证”中的最弱者，短板效应"><a href="#3-函数提供的”异常安全保证”，通常只等于其调用各个函数的”异常安全保证”中的最弱者，短板效应" class="headerlink" title="3.函数提供的”异常安全保证”，通常只等于其调用各个函数的”异常安全保证”中的最弱者，短板效应?"></a>3.函数提供的”异常安全保证”，通常只等于其调用各个函数的”异常安全保证”中的最弱者，短板效应?</h4><h1 id="条款-30-透彻了解inlining的里里外外"><a href="#条款-30-透彻了解inlining的里里外外" class="headerlink" title="条款 30 : 透彻了解inlining的里里外外"></a>条款 30 : 透彻了解inlining的里里外外</h1><h4 id="1-inline-虽然“免除函数调用成本”-但导致程序体积增大-适用于本体很小的函数"><a href="#1-inline-虽然“免除函数调用成本”-但导致程序体积增大-适用于本体很小的函数" class="headerlink" title="1.inline  虽然“免除函数调用成本”,但导致程序体积增大,适用于本体很小的函数"></a>1.inline  虽然<u>“免除函数调用成本”</u>,但导致程序体积增大,适用于本体很小的函数</h4><h4 id="2-inline-是对编译器提出的一个申请-而不是强制命令-可以隐喻提出-也可以明确提出"><a href="#2-inline-是对编译器提出的一个申请-而不是强制命令-可以隐喻提出-也可以明确提出" class="headerlink" title="2.inline 是对编译器提出的一个申请,而不是强制命令.可以隐喻提出,也可以明确提出"></a>2.inline 是对编译器提出的<u>一个申请,而不是强制命令</u>.可以隐喻提出,也可以明确提出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐喻方式是将函数定义于class定义式内</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125;           <span class="comment">//一个隐喻的inline申请</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-inlining在大多数C-程序中是编译期行为"><a href="#3-inlining在大多数C-程序中是编译期行为" class="headerlink" title="3.inlining在大多数C++程序中是编译期行为"></a>3.inlining在大多数C++程序中是编译期行为</h4><h4 id="4-有时候即使inline但还是会生成函数本体-是否意味着inline代表着没有函数本体-如下述例子"><a href="#4-有时候即使inline但还是会生成函数本体-是否意味着inline代表着没有函数本体-如下述例子" class="headerlink" title="4.有时候即使inline但还是会生成函数本体(是否意味着inline代表着没有函数本体?),如下述例子"></a>4.有时候即使inline但还是会生成函数本体(是否意味着inline代表着没有函数本体?),如下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码要取某个inline的地址,编译器通常必须为此函数生成一个Outline的函数本体</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125;     </span><br><span class="line"><span class="built_in">void</span> (*pf) () = f;        <span class="comment">//pf 指向 f</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">f</span>();                      <span class="comment">//这个调用inlined</span></span><br><span class="line"><span class="built_in">pf</span>();                     <span class="comment">//这个调用 或许 不被inlined,因为它通过函数指针达成</span></span><br></pre></td></tr></table></figure>

<h4 id="5-构造和析构函数不适用于inline"><a href="#5-构造和析构函数不适用于inline" class="headerlink" title="5.构造和析构函数不适用于inline"></a>5.构造和析构函数不适用于inline</h4><h4 id="6-inline-不适用于-virtual-virtual-运行时确定-inline编译时确定-互相冲突"><a href="#6-inline-不适用于-virtual-virtual-运行时确定-inline编译时确定-互相冲突" class="headerlink" title="6.inline 不适用于 virtual ,virtual 运行时确定, inline编译时确定,互相冲突"></a>6.inline 不适用于 <u>virtual ,virtual 运行时确定, inline编译时确定</u>,互相冲突</h4><h4 id="7-inline-函数难以调试-不知道现在的编译器解决这个问题没"><a href="#7-inline-函数难以调试-不知道现在的编译器解决这个问题没" class="headerlink" title="7.inline 函数难以调试(不知道现在的编译器解决这个问题没)"></a>7.inline 函数难以调试(不知道现在的编译器解决这个问题没)</h4><h2 id="注意事项-23"><a href="#注意事项-23" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-将inline-限制在小型-调用频繁的函数身上"><a href="#1-将inline-限制在小型-调用频繁的函数身上" class="headerlink" title="1.将inline 限制在小型,调用频繁的函数身上"></a>1.将inline 限制在小型,调用频繁的函数身上</h4><h4 id="2-不要只因为function-template-出现在头文件-就将它们声明为-inline"><a href="#2-不要只因为function-template-出现在头文件-就将它们声明为-inline" class="headerlink" title="2.不要只因为function template 出现在头文件,就将它们声明为 inline"></a>2.不要只因为function template 出现在头文件,就将它们声明为 inline</h4><h4 id="3-重点-inline-是个申请-最终是否为inlined函数取决于编译器-自己的理解"><a href="#3-重点-inline-是个申请-最终是否为inlined函数取决于编译器-自己的理解" class="headerlink" title="3.重点 inline 是个申请,最终是否为inlined函数取决于编译器(自己的理解)"></a>3.重点 inline 是个申请,最终是否为inlined函数取决于编译器(自己的理解)</h4><h1 id="条款-31-将文件间的编译依存关系降至最低"><a href="#条款-31-将文件间的编译依存关系降至最低" class="headerlink" title="条款 31 : 将文件间的编译依存关系降至最低"></a>条款 31 : 将文件间的编译依存关系降至最低</h1><h4 id="1-编译时定义-往往会包含其他文件中的定义式-如果其他文件中的定义被更改-那么则该文件需要重新编译-这既是-“编译依存关系”-不过通常包含标准头文件不会造成问题"><a href="#1-编译时定义-往往会包含其他文件中的定义式-如果其他文件中的定义被更改-那么则该文件需要重新编译-这既是-“编译依存关系”-不过通常包含标准头文件不会造成问题" class="headerlink" title="1.编译时定义,往往会包含其他文件中的定义式,如果其他文件中的定义被更改,那么则该文件需要重新编译,这既是 “编译依存关系” , 不过通常包含标准头文件不会造成问题"></a>1.编译时定义,往往会包含其他文件中的定义式,如果其他文件中的定义被更改,那么则该文件需要重新编译,这既是 “编译依存关系” , 不过通常包含标准头文件不会造成问题</h4><h4 id="2-采用pimpl-idiom-设计"><a href="#2-采用pimpl-idiom-设计" class="headerlink" title="2.采用pimpl idiom 设计"></a>2.采用<u>pimpl idiom</u> 设计</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;       <span class="comment">//Person实现类的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;             <span class="comment">//Person接口用到的classes的前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl;   <span class="comment">//指针,指向实现物,且采用shared_ptr (条款13)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="这样的设计下-Person的客户完全与Dates-Addresses以及Person的实现细节分离-”接口与实现分离”"><a href="#这样的设计下-Person的客户完全与Dates-Addresses以及Person的实现细节分离-”接口与实现分离”" class="headerlink" title="这样的设计下,Person的客户完全与Dates,Addresses以及Person的实现细节分离,”接口与实现分离”"></a>这样的设计下,Person的客户完全与Dates,Addresses以及Person的实现细节分离,”接口与实现分离”</h4><h6 id="这个分离关键在于-”声明的依存性”-替换-“定义的依存性”-那正是编译依存最小化的本质-这个简单的设计策略"><a href="#这个分离关键在于-”声明的依存性”-替换-“定义的依存性”-那正是编译依存最小化的本质-这个简单的设计策略" class="headerlink" title="这个分离关键在于,”声明的依存性” 替换 “定义的依存性”, 那正是编译依存最小化的本质,这个简单的设计策略:"></a>这个分离关键在于,”声明的依存性” 替换 “定义的依存性”, 那正是编译依存最小化的本质,这个简单的设计策略:</h6><h6 id="a-如果使用-object-references-或-object-pointers-可以完成任务-则不用使用objects"><a href="#a-如果使用-object-references-或-object-pointers-可以完成任务-则不用使用objects" class="headerlink" title="a.如果使用 object references 或 object pointers 可以完成任务,则不用使用objects"></a>a.如果使用 object references 或 object pointers 可以完成任务,则不用使用objects</h6><h6 id="b-如果能够-尽量以class-声明式替换class-定义式"><a href="#b-如果能够-尽量以class-声明式替换class-定义式" class="headerlink" title="b.如果能够,尽量以class 声明式替换class 定义式"></a>b.如果能够,尽量以class 声明式替换class 定义式</h6><h6 id="c-为声明式和定义式提供不同的头文件-类似于我自己写的？将声明与定义分文件编写-声明包含定义头文件"><a href="#c-为声明式和定义式提供不同的头文件-类似于我自己写的？将声明与定义分文件编写-声明包含定义头文件" class="headerlink" title="c.为声明式和定义式提供不同的头文件 (类似于我自己写的？将声明与定义分文件编写,声明包含定义头文件)"></a>c.为声明式和定义式提供不同的头文件 (类似于我自己写的？将声明与定义分文件编写,声明包含定义头文件)</h6><h4 id="3-这样的pimpl设计-使classes-往往被称为Handle-classes-这种做法不会改变它要做的事情-只会改变它做事的方式-另一种制作Handle-class-的方法是-令Person-class-成为abstract-class-，称为interface-class"><a href="#3-这样的pimpl设计-使classes-往往被称为Handle-classes-这种做法不会改变它要做的事情-只会改变它做事的方式-另一种制作Handle-class-的方法是-令Person-class-成为abstract-class-，称为interface-class" class="headerlink" title="3.这样的pimpl设计,使classes 往往被称为Handle classes ,这种做法不会改变它要做的事情,只会改变它做事的方式.另一种制作Handle class 的方法是,令Person class 成为abstract class ，称为interface class"></a>3.这样的pimpl设计,使classes 往往被称为Handle classes ,这种做法不会改变它要做的事情,只会改变它做事的方式.另一种制作Handle class 的方法是,令Person class 成为abstract class ，称为<u>interface class</u></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">address</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通常这种class的目的是详细描述derived 的接口，为了有办法为这种class创建新对象,往往采用facrtory函数</span></span><br><span class="line"><span class="comment">//(条款13)或virtual构造函数.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> std::tr1::shared_ptr&lt;Person&gt;<span class="built_in">create</span>(<span class="type">const</span> std::string&amp; name,</span><br><span class="line">                                              <span class="type">const</span> Date&amp; birthday,</span><br><span class="line">                                              <span class="type">const</span> Address&amp; addr);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用ing</span></span><br><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//创意一个对象,支持Person接口</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name,dateOfBith,address))</span></span>;</span><br><span class="line">...</span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; was born on &quot;</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">birthDate</span>()</span><br><span class="line">          &lt;&lt;<span class="string">&quot; and now lives at&quot;</span></span><br><span class="line">          &lt;&lt; pp-&gt;<span class="built_in">address</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="当然支持interface-class-接口的具象类必须被定义出来-p147"><a href="#当然支持interface-class-接口的具象类必须被定义出来-p147" class="headerlink" title="当然支持interface class 接口的具象类必须被定义出来(p147)"></a>当然支持interface class 接口的具象类必须被定义出来(p147)</h4><h4 id="4-Handle-classes-和-Interface-classes-解除了接口和实现之间的耦合关系-从而降低文件间的编译依存性"><a href="#4-Handle-classes-和-Interface-classes-解除了接口和实现之间的耦合关系-从而降低文件间的编译依存性" class="headerlink" title="4.Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系,从而降低文件间的编译依存性"></a>4.Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系,从而降低文件间的编译依存性</h4><h2 id="注意事项-24"><a href="#注意事项-24" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-支持”编译依存性最小化”的一般构想是-相依于声明式-不要相依于定义式"><a href="#1-支持”编译依存性最小化”的一般构想是-相依于声明式-不要相依于定义式" class="headerlink" title="1.支持”编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式"></a>1.支持”编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式</h4><h4 id="2-程序库头文件-应该以”完全且仅有声明式”-类似于main-gt-声明-h-gt-实现-cpp"><a href="#2-程序库头文件-应该以”完全且仅有声明式”-类似于main-gt-声明-h-gt-实现-cpp" class="headerlink" title="2.程序库头文件,应该以”完全且仅有声明式”,(类似于main-&gt;声明.h-&gt;实现.cpp ?)"></a>2.程序库头文件,应该以”完全且仅有声明式”,(类似于main-&gt;声明.h-&gt;实现.cpp ?)</h4><h1 id="条款-32-确定你的public-继承塑模出-is-a-关系"><a href="#条款-32-确定你的public-继承塑模出-is-a-关系" class="headerlink" title="条款 32 : 确定你的public 继承塑模出 is-a 关系"></a>条款 32 : 确定你的public 继承塑模出 is-a 关系</h1><h2 id="注意事项-25"><a href="#注意事项-25" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-”public”继承-意味着-is-a-关系-适用于base-class-身上的每一件事情也一定适用于derived-class-身上"><a href="#1-”public”继承-意味着-is-a-关系-适用于base-class-身上的每一件事情也一定适用于derived-class-身上" class="headerlink" title="1.”public”继承,意味着 is-a 关系,适用于base class 身上的每一件事情也一定适用于derived class 身上"></a>1.”public”继承,意味着 is-a 关系,适用于base class 身上的每一件事情也一定适用于derived class 身上</h4><h1 id="条款-33-避免遮掩继承而来的名称"><a href="#条款-33-避免遮掩继承而来的名称" class="headerlink" title="条款 33 : 避免遮掩继承而来的名称"></a>条款 33 : 避免遮掩继承而来的名称</h1><h4 id="1-同名的函数会导致隐藏"><a href="#1-同名的函数会导致隐藏" class="headerlink" title="1.同名的函数会导致隐藏"></a>1.同名的函数会导致隐藏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.<span class="built_in">mf1</span>();                  <span class="comment">//Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);                 <span class="comment">//invalid Derived::mf1 隐藏了 Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();                  <span class="comment">//Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();                  <span class="comment">//Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);                 <span class="comment">//invalid Derived::mf3 隐藏了 Base::mf3</span></span><br></pre></td></tr></table></figure>

<h4 id="2-覆盖-x2F-隐藏"><a href="#2-覆盖-x2F-隐藏" class="headerlink" title="2.覆盖    &#x2F;    隐藏"></a>2.覆盖    &#x2F;    隐藏</h4><h4 id="3-通过using-声明取消隐藏"><a href="#3-通过using-声明取消隐藏" class="headerlink" title="3.通过using 声明取消隐藏"></a>3.通过using 声明取消隐藏</h4><h4 id="4-转交函数-forwarding-funciton"><a href="#4-转交函数-forwarding-funciton" class="headerlink" title="4.转交函数 forwarding funciton"></a>4.转交函数 forwarding funciton</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; Base::<span class="built_in">mf1</span>(); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x; </span><br><span class="line">d.<span class="built_in">mf1</span>();                   <span class="comment">// Base::mf1()</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);                  <span class="comment">//Base::mf1(int) 被隐藏了</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-26"><a href="#注意事项-26" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-deirved-class-内的名称会隐藏base-class-内的名称"><a href="#1-deirved-class-内的名称会隐藏base-class-内的名称" class="headerlink" title="1.deirved class 内的名称会隐藏base class 内的名称"></a>1.deirved class 内的名称会隐藏base class 内的名称</h4><h4 id="2-可用using-声明或转交函数来让被隐藏的名称再见天日"><a href="#2-可用using-声明或转交函数来让被隐藏的名称再见天日" class="headerlink" title="2.可用using 声明或转交函数来让被隐藏的名称再见天日"></a>2.可用using 声明或转交函数来让被隐藏的名称再见天日</h4><h1 id="条款-34-区分接口继承和实现继承"><a href="#条款-34-区分接口继承和实现继承" class="headerlink" title="条款 34 : 区分接口继承和实现继承"></a>条款 34 : 区分接口继承和实现继承</h1><h4 id="1-继承时可能出现三种我们希望的情况-”只继承接口”-”同时继承接口和实现-但希望能override”-”继承接口和实现-但不允许override”"><a href="#1-继承时可能出现三种我们希望的情况-”只继承接口”-”同时继承接口和实现-但希望能override”-”继承接口和实现-但不允许override”" class="headerlink" title="1.继承时可能出现三种我们希望的情况,”只继承接口”,”同时继承接口和实现,但希望能override”,”继承接口和实现,但不允许override”."></a>1.继承时可能出现三种我们希望的情况,”只继承接口”,”同时继承接口和实现,但希望能override”,”继承接口和实现,但不允许override”.</h4><h4 id="2-成员函数的接口总会被继承"><a href="#2-成员函数的接口总会被继承" class="headerlink" title="2.成员函数的接口总会被继承"></a>2.成员函数的接口总会被继承</h4><h4 id="3-pure-virtual函数的目的是为了第一种情况-只继承函数接口-Interface-class-类似条款31"><a href="#3-pure-virtual函数的目的是为了第一种情况-只继承函数接口-Interface-class-类似条款31" class="headerlink" title="3.pure virtual函数的目的是为了第一种情况,只继承函数接口(Interface class 类似条款31?)"></a>3.pure virtual函数的目的是为了第一种情况,只继承函数接口(Interface class 类似条款31?)</h4><h4 id="4-impure-virtua函数目的是为了第二种情况-继承函数的接口和默认实现"><a href="#4-impure-virtua函数目的是为了第二种情况-继承函数的接口和默认实现" class="headerlink" title="4.impure virtua函数目的是为了第二种情况,继承函数的接口和默认实现"></a>4.impure virtua函数目的是为了第二种情况,继承函数的接口和默认实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//该接口表示每个derived class 都必须支持&quot;遇上错误时可调用&quot;,若某个class不打算针对错误做出任何特殊行为,它可以退回到Shape class 的默认错误处理</span></span><br></pre></td></tr></table></figure>

<h4 id="但这种情况可能出现危险"><a href="#但这种情况可能出现危险" class="headerlink" title="但这种情况可能出现危险"></a>但这种情况可能出现危险</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airport</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">default</span> 实现</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>::<span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>::<span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br><span class="line"><span class="comment">//由A B 继承 Airplane 并 override 默认实现  , 但如果出现下述情况呢</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelC</span>::<span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    ...                        <span class="comment">//未声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Airport <span class="title">PDX</span> <span class="params">(...)</span></span>;                  <span class="comment">//目的地</span></span><br><span class="line">Airplane* pa = <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line">pa-&gt;<span class="built_in">fly</span>(PDX)                        <span class="comment">//调用 Airplane::fly</span></span><br></pre></td></tr></table></figure>

<h4 id="如果忘记override-则采用默认实现-可能导致错误-问题不在于采用了默认实现-关键在于ModelC在没有override的时候-继承了fly-获得了一个它没有的行为-切断virtual接口和其默认实现之间的联系-可以解决这种问题"><a href="#如果忘记override-则采用默认实现-可能导致错误-问题不在于采用了默认实现-关键在于ModelC在没有override的时候-继承了fly-获得了一个它没有的行为-切断virtual接口和其默认实现之间的联系-可以解决这种问题" class="headerlink" title="如果忘记override,则采用默认实现,可能导致错误,问题不在于采用了默认实现,关键在于ModelC在没有override的时候,继承了fly,获得了一个它没有的行为,切断virtual接口和其默认实现之间的联系,可以解决这种问题"></a>如果忘记override,则采用默认实现,可能导致错误,问题不在于采用了默认实现,关键在于ModelC在没有override的时候,继承了fly,获得了一个它没有的行为,切断<u>virtual接口</u>和其<u>默认实现之间</u>的联系,可以解决这种问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; dstination)</span> </span>=<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defalutFly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="type">const</span> Airplane&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">default</span> 实现</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在fly 被改为 pure-virtual 函数,只提供接口,即接口于实现分离!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>::<span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airplane&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">defaultFly</span>(destination); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>::<span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airplane&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">defaultFly</span>(destination); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在不可能意外继承不正确的实现了,因为pure-virtual函数只提供了接口,ModelC必须override提供自己的版本</span></span><br></pre></td></tr></table></figure>

<h4 id="由于pure-virtual函数一定要被override-则可以采用另一种方式"><a href="#由于pure-virtual函数一定要被override-则可以采用另一种方式" class="headerlink" title="由于pure-virtual函数一定要被override,则可以采用另一种方式"></a>由于pure-virtual函数一定要被override,则可以采用另一种方式</h4><h4 id="（如果不覆盖-则派生类也会由于继承了纯虚函数变为抽象类–个人理解"><a href="#（如果不覆盖-则派生类也会由于继承了纯虚函数变为抽象类–个人理解" class="headerlink" title="（如果不覆盖,则派生类也会由于继承了纯虚函数变为抽象类–个人理解)"></a>（如果不覆盖,则派生类也会由于继承了纯虚函数变为抽象类–个人理解)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>=<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span>     <span class="comment">//pure-virtual函数实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">default</span> 实现</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>::<span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123; Airplane::<span class="built_in">fly</span>(destination); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelC</span>:<span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-non-virtual函数用于令derived-classes-继承函数的接口以及一份强制性实现"><a href="#5-non-virtual函数用于令derived-classes-继承函数的接口以及一份强制性实现" class="headerlink" title="5.non-virtual函数用于令derived classes 继承函数的接口以及一份强制性实现"></a>5.non-virtual函数用于令derived classes 继承函数的接口以及一份强制性实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//就如上述例子,所有shape都采用统一的方式计算ID</span></span><br></pre></td></tr></table></figure>

<h4 id="6-pure-virtual-simple-impure-virtual-non-virtual-”只继承接口”-“继承接口和一份默认实现”-”继承接口和一份强制实现”"><a href="#6-pure-virtual-simple-impure-virtual-non-virtual-”只继承接口”-“继承接口和一份默认实现”-”继承接口和一份强制实现”" class="headerlink" title="6.pure-virtual , simple(impure)virtual , non-virtual :”只继承接口”, “继承接口和一份默认实现” ,”继承接口和一份强制实现”"></a>6.pure-virtual , simple(impure)virtual , non-virtual :”只继承接口”, “继承接口和一份默认实现” ,”继承接口和一份强制实现”</h4><h2 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-接口继承和实现继承的区别-在public继承下-derived-class-总是继承base-class的接口"><a href="#1-接口继承和实现继承的区别-在public继承下-derived-class-总是继承base-class的接口" class="headerlink" title="1.接口继承和实现继承的区别,在public继承下,derived class 总是继承base class的接口"></a>1.接口继承和实现继承的区别,在public继承下,derived class 总是继承base class的接口</h4><h4 id="2-pure-virtual-只继承接口"><a href="#2-pure-virtual-只继承接口" class="headerlink" title="2.pure-virtual 只继承接口"></a>2.pure-virtual 只继承接口</h4><h4 id="3-impure-virutal-继承接口和默认实现"><a href="#3-impure-virutal-继承接口和默认实现" class="headerlink" title="3.impure-virutal 继承接口和默认实现"></a>3.impure-virutal 继承接口和默认实现</h4><h4 id="4-non-virtual-继承接口和强制实现"><a href="#4-non-virtual-继承接口和强制实现" class="headerlink" title="4.non-virtual 继承接口和强制实现"></a>4.non-virtual 继承接口和强制实现</h4><h1 id="条款-35-考虑virtual函数以外的选择"><a href="#条款-35-考虑virtual函数以外的选择" class="headerlink" title="条款 35 : 考虑virtual函数以外的选择"></a>条款 35 : 考虑virtual函数以外的选择</h1><h4 id="对于下述例子-通常会用virtual-来overred它-不妨考虑其他设计"><a href="#对于下述例子-通常会用virtual-来overred它-不妨考虑其他设计" class="headerlink" title="对于下述例子 , 通常会用virtual 来overred它,不妨考虑其他设计"></a>对于下述例子 , 通常会用virtual 来overred它,不妨考虑其他设计</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span><span class="type">const</span></span>;     <span class="comment">//返回人物的健康值,derived class 可以override它</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-籍由non-virtual-Interface-实现-Template-Method"><a href="#1-籍由non-virtual-Interface-实现-Template-Method" class="headerlink" title="1.籍由non-virtual-Interface 实现 Template Method"></a>1.籍由non-virtual-Interface 实现 Template Method</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span><span class="type">const</span>                 <span class="comment">//derived classes不重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;                                      <span class="comment">//见条款36</span></span><br><span class="line">        ...                                <span class="comment">//做一些事前工作</span></span><br><span class="line">        <span class="type">int</span> reVal = <span class="built_in">doHealthValue</span>();       <span class="comment">//真正的工作</span></span><br><span class="line">        ...                                <span class="comment">//做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> reVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span><span class="type">const</span>       <span class="comment">//derived classes可重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...                                <span class="comment">//默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="这一设计”令客户通过public-non-virtual成员函数间接调用-private-virtual-函数”-称为non-virtual-interface-NVI-手法-它是所谓Template-Method-设计模式-与c-templa"><a href="#这一设计”令客户通过public-non-virtual成员函数间接调用-private-virtual-函数”-称为non-virtual-interface-NVI-手法-它是所谓Template-Method-设计模式-与c-templa" class="headerlink" title="这一设计”令客户通过public non-virtual成员函数间接调用 private virtual 函数”,称为non-virtual interface (NVI)手法.  它是所谓Template Method 设计模式(与c++templa"></a>这一设计”令客户通过public non-virtual成员函数间接调用 private virtual 函数”,称为non-virtual interface (NVI)手法.  它是所谓Template Method 设计模式(与c++templa</h4><h4 id="es并无关联-的一个独特表现形式-这个non-virtual-被称为-virtual-的外覆器"><a href="#es并无关联-的一个独特表现形式-这个non-virtual-被称为-virtual-的外覆器" class="headerlink" title="es并无关联),的一个独特表现形式,这个non-virtual 被称为 virtual 的外覆器"></a>es并无关联),的一个独特表现形式,这个non-virtual 被称为 virtual 的外覆器</h4><h6 id="此手法优点：-“做一些事前工作”和”做一些事后工作”-gt-确保得以在一个virtual函数被调用前设定好适当场景-并在调用结束之后清理场景"><a href="#此手法优点：-“做一些事前工作”和”做一些事后工作”-gt-确保得以在一个virtual函数被调用前设定好适当场景-并在调用结束之后清理场景" class="headerlink" title="此手法优点： “做一些事前工作”和”做一些事后工作”, -&gt; 确保得以在一个virtual函数被调用前设定好适当场景,并在调用结束之后清理场景"></a>此手法优点： “做一些事前工作”和”做一些事后工作”, -&gt; 确保得以在一个virtual函数被调用前设定好适当场景,并在调用结束之后清理场景</h6><h4 id="2-籍由Function-Pointer-实现-Strategy模式"><a href="#2-籍由Function-Pointer-实现-Strategy模式" class="headerlink" title="2.籍由Function Pointer 实现 Strategy模式"></a>2.籍由Function Pointer 实现 Strategy模式</h4><h5 id="例如我们可能会要求每个人物的构造函数接受一个指针-指向一个健康计算函数"><a href="#例如我们可能会要求每个人物的构造函数接受一个指针-指向一个健康计算函数" class="headerlink" title="例如我们可能会要求每个人物的构造函数接受一个指针,指向一个健康计算函数"></a>例如我们可能会要求每个人物的构造函数接受一个指针,指向一个健康计算函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;         <span class="comment">//前置声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        :healthFunc(hcf)</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="与virtual-做法相比-它提供了弹性"><a href="#与virtual-做法相比-它提供了弹性" class="headerlink" title="与virtual 做法相比,它提供了弹性"></a>与virtual 做法相比,它提供了弹性</h4><h5 id="a-同一类型不同实体-可以有不同的计算函数"><a href="#a-同一类型不同实体-可以有不同的计算函数" class="headerlink" title="a.同一类型不同实体,可以有不同的计算函数"></a>a.同一类型不同实体,可以有不同的计算函数</h5><h5 id="b-已知类型的计算函数可以在运行期变更-例如提供一个成员函数setHealthCalculator-替换当前计算函数"><a href="#b-已知类型的计算函数可以在运行期变更-例如提供一个成员函数setHealthCalculator-替换当前计算函数" class="headerlink" title="b.已知类型的计算函数可以在运行期变更,例如提供一个成员函数setHealthCalculator,替换当前计算函数"></a>b.已知类型的计算函数可以在运行期变更,例如提供一个成员函数setHealthCalculator,替换当前计算函数</h5><h4 id="3-籍由tr1-function-完成Strategy模式"><a href="#3-籍由tr1-function-完成Strategy模式" class="headerlink" title="3.籍由tr1::function 完成Strategy模式"></a>3.籍由tr1::function 完成Strategy模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//HealthCalcFunc可以是任何&quot;可调用物&quot;,可被调用并接受任何兼容于</span></span><br><span class="line">    <span class="comment">//GameCharacter之物,返回任何兼容于int 的东西</span></span><br><span class="line">    <span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span> (<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthClacFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">    :healthFunc(hcf)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和前一个设计相比-几乎相同-但如果需要更惊人的弹性"><a href="#和前一个设计相比-几乎相同-但如果需要更惊人的弹性" class="headerlink" title="和前一个设计相比,几乎相同.但如果需要更惊人的弹性"></a>和前一个设计相比,几乎相同.但如果需要更惊人的弹性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;    <span class="comment">//健康计算函数  其返回类型为 non-int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span>                    <span class="comment">//为计算健康而设计的函数对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter*)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span><span class="type">const</span></span>; <span class="comment">//成员函数用以计算健康</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span>:<span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span>:<span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">EvilBadGuye <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;                       <span class="comment">//人物 1 使用&quot;函数&quot;计算</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;         <span class="comment">//人物 2 使用&quot;函数对象&quot;计算</span></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(                                    <span class="comment">//人物 3 使用&quot;成员函数&quot;计算</span></span></span></span><br><span class="line"><span class="params"><span class="function">           std::tr1::band(&amp;Game::health,</span></span></span><br><span class="line"><span class="params"><span class="function">                          currentLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">                          _1)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="前两个都很好理解-对于第三个的理解因为此处的构造只接受一个参数，但此处有两个参数，所以用tr1-bind-将currentLevel绑定为GameLevel对象-让它在”每次GameLevel被调用计算ebg2的健康”时被使用-那正是tr1-bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象"><a href="#前两个都很好理解-对于第三个的理解因为此处的构造只接受一个参数，但此处有两个参数，所以用tr1-bind-将currentLevel绑定为GameLevel对象-让它在”每次GameLevel被调用计算ebg2的健康”时被使用-那正是tr1-bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象" class="headerlink" title="前两个都很好理解,对于第三个的理解因为此处的构造只接受一个参数，但此处有两个参数，所以用tr1::bind 将currentLevel绑定为GameLevel对象,让它在”每次GameLevel被调用计算ebg2的健康”时被使用,那正是tr1::bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象"></a>前两个都很好理解,对于第三个的理解因为此处的构造只接受一个参数，但此处有两个参数，所以用tr1::bind 将currentLevel绑定为GameLevel对象,让它在”每次GameLevel被调用计算ebg2的健康”时被使用,那正是tr1::bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象</h4><h4 id="4-古典的Strategy"><a href="#4-古典的Strategy" class="headerlink" title="4.古典的Strategy"></a>4.古典的Strategy</h4><h5 id="将健康计算函数做成一个分离的继承体系中的virtual函数-对于上述例子-GameCharacter-是某个继承体系的根类-体系中的EvilBadGuy-和-EyeCandyCharacter-都是derived-class-HealthCalcFunc是另一个继承体系的根类-体系中的SlowHealthLoser-和-FastHealthLoser-都是derived-class-每一个GameCharacter对象都内含一个指针-指向一个来自HealthCalcFunc继承体系的对象-参考p176图"><a href="#将健康计算函数做成一个分离的继承体系中的virtual函数-对于上述例子-GameCharacter-是某个继承体系的根类-体系中的EvilBadGuy-和-EyeCandyCharacter-都是derived-class-HealthCalcFunc是另一个继承体系的根类-体系中的SlowHealthLoser-和-FastHealthLoser-都是derived-class-每一个GameCharacter对象都内含一个指针-指向一个来自HealthCalcFunc继承体系的对象-参考p176图" class="headerlink" title="将健康计算函数做成一个分离的继承体系中的virtual函数.  对于上述例子,GameCharacter 是某个继承体系的根类,体系中的EvilBadGuy 和 EyeCandyCharacter 都是derived class;HealthCalcFunc是另一个继承体系的根类,体系中的SlowHealthLoser 和 FastHealthLoser 都是derived class, 每一个GameCharacter对象都内含一个指针,指向一个来自HealthCalcFunc继承体系的对象(参考p176图)"></a>将健康计算函数做成一个分离的继承体系中的virtual函数.  对于上述例子,GameCharacter 是某个继承体系的根类,体系中的EvilBadGuy 和 EyeCandyCharacter 都是derived class;HealthCalcFunc是另一个继承体系的根类,体系中的SlowHealthLoser 和 FastHealthLoser 都是derived class, 每一个GameCharacter对象都内含一个指针,指向一个来自HealthCalcFunc继承体系的对象(参考p176图)</h5><h4 id="5-摘要"><a href="#5-摘要" class="headerlink" title="5.摘要"></a>5.摘要</h4><h5 id="a-使用non-virtual-interface-NVI-手法-这是-Template-Method-设计模式的一种特殊形式"><a href="#a-使用non-virtual-interface-NVI-手法-这是-Template-Method-设计模式的一种特殊形式" class="headerlink" title="a.使用non-virtual interface (NVI)手法,这是 Template Method 设计模式的一种特殊形式."></a>a.使用non-virtual interface (NVI)手法,这是 Template Method 设计模式的一种特殊形式.</h5><h5 id="b-将virtual函数替换为”函数指针成员变量”-这是Strategy设计模式的一种分解表现形式"><a href="#b-将virtual函数替换为”函数指针成员变量”-这是Strategy设计模式的一种分解表现形式" class="headerlink" title="b.将virtual函数替换为”函数指针成员变量”,这是Strategy设计模式的一种分解表现形式"></a>b.将virtual函数替换为”函数指针成员变量”,这是Strategy设计模式的一种分解表现形式</h5><h5 id="c-以tr1-function成员变量替换virtual函数-这也是Strategy设计模式的某种形式"><a href="#c-以tr1-function成员变量替换virtual函数-这也是Strategy设计模式的某种形式" class="headerlink" title="c.以tr1::function成员变量替换virtual函数,这也是Strategy设计模式的某种形式"></a>c.以tr1::function成员变量替换virtual函数,这也是Strategy设计模式的某种形式</h5><h5 id="d-将继承体系中的virtual函数替换为另一个继承体系内的virtual函数-这是Strategy设计模式的传统实现手法"><a href="#d-将继承体系中的virtual函数替换为另一个继承体系内的virtual函数-这是Strategy设计模式的传统实现手法" class="headerlink" title="d.将继承体系中的virtual函数替换为另一个继承体系内的virtual函数,这是Strategy设计模式的传统实现手法"></a>d.将继承体系中的virtual函数替换为另一个继承体系内的virtual函数,这是Strategy设计模式的传统实现手法</h5><h2 id="注意事项-27"><a href="#注意事项-27" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式"><a href="#1-virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式" class="headerlink" title="1.virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式"></a>1.virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式</h4><h4 id="2-将机能从成员函数移到class外部函数"><a href="#2-将机能从成员函数移到class外部函数" class="headerlink" title="2.将机能从成员函数移到class外部函数"></a>2.将机能从成员函数移到class外部函数</h4><h4 id="3-tr1-function对象的行为就像一般函数指针"><a href="#3-tr1-function对象的行为就像一般函数指针" class="headerlink" title="3.tr1::function对象的行为就像一般函数指针"></a>3.tr1::function对象的行为就像一般函数指针</h4><h1 id="条款-36-绝不重新定义继承而来的non-virtual函数"><a href="#条款-36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款 36 : 绝不重新定义继承而来的non-virtual函数"></a>条款 36 : 绝不重新定义继承而来的non-virtual函数</h1><h4 id="1-non-virtual函数的性质为”不变性凌驾于特异性”-如果打算重定义-则应当使用virtual函数-当使用non-virtual函数并进行重定义-会导致指针-x2F-引用-指向一个实际的类时-所指的函数不是有实际的类决定-而是由指针-x2F-引用的类型决定"><a href="#1-non-virtual函数的性质为”不变性凌驾于特异性”-如果打算重定义-则应当使用virtual函数-当使用non-virtual函数并进行重定义-会导致指针-x2F-引用-指向一个实际的类时-所指的函数不是有实际的类决定-而是由指针-x2F-引用的类型决定" class="headerlink" title="1.non-virtual函数的性质为”不变性凌驾于特异性”,如果打算重定义,则应当使用virtual函数,当使用non-virtual函数并进行重定义,会导致指针&#x2F;引用 指向一个实际的类时,所指的函数不是有实际的类决定,而是由指针&#x2F;引用的类型决定"></a>1.non-virtual函数的性质为”不变性凌驾于特异性”,如果打算重定义,则应当使用virtual函数,当使用non-virtual函数并进行重定义,会导致指针&#x2F;引用 指向一个实际的类时,所指的函数不是有实际的类决定,而是由指针&#x2F;引用的类型决定</h4><h2 id="注意事项-28"><a href="#注意事项-28" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-绝对不要重新定义继承而来的non-virtual函数"><a href="#1-绝对不要重新定义继承而来的non-virtual函数" class="headerlink" title="1.绝对不要重新定义继承而来的non-virtual函数"></a>1.绝对不要重新定义继承而来的non-virtual函数</h4><h1 id="条款-37-绝不重新定义继承而来的缺省参数值"><a href="#条款-37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37 : 绝不重新定义继承而来的缺省参数值"></a>条款 37 : 绝不重新定义继承而来的缺省参数值</h1><h4 id="1-virtual函数是动态绑定-dynamically-bound-而缺省参数值却是静态绑定-statically"><a href="#1-virtual函数是动态绑定-dynamically-bound-而缺省参数值却是静态绑定-statically" class="headerlink" title="1.virtual函数是动态绑定(dynamically bound),而缺省参数值却是静态绑定(statically)"></a>1.virtual函数是动态绑定(dynamically bound),而缺省参数值却是静态绑定(statically)</h4><h4 id="2-考虑以下继承体系"><a href="#2-考虑以下继承体系" class="headerlink" title="2.考虑以下继承体系"></a>2.考虑以下继承体系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; RED, GREEN, BLUE&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = RED)</span><span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注意,赋予不同的缺省参数值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = GREEN)</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:<span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//若以对象调用该函数,则一定要指明参数值,但若以指针(或引用)调用此函数,则可以不指明</span></span><br><span class="line">    <span class="comment">//因为动态绑定下这个函数会从其base继承缺省参数值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在考虑这些指针</span></span><br><span class="line">Shape* ps;                           <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;              <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;           <span class="comment">//静态类型为Shape*</span></span><br><span class="line"><span class="comment">//本例中ps,pc和pr都被声明为pointer-to-shape类型，所以它们都以它为静态类型.</span></span><br><span class="line"><span class="comment">//所谓的动态类型则是指&quot;目前所指对象的类型&quot;,对上例pc为Circle*,pr为Rectangle*</span></span><br></pre></td></tr></table></figure>

<h4 id="virtual函数系动态绑定而来-调用哪一份实现代码-取决于动态类型"><a href="#virtual函数系动态绑定而来-调用哪一份实现代码-取决于动态类型" class="headerlink" title="virtual函数系动态绑定而来,调用哪一份实现代码,取决于动态类型"></a>virtual函数系动态绑定而来,调用哪一份实现代码,取决于动态类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::RED);            <span class="comment">//调用Circle::draw</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::RED);            <span class="comment">//调用Rectangle::draw</span></span><br></pre></td></tr></table></figure>

<h4 id="但对于缺省参数值-由于是静态绑定-所有derived类的缺省参数值全部取决于base中的"><a href="#但对于缺省参数值-由于是静态绑定-所有derived类的缺省参数值全部取决于base中的" class="headerlink" title="但对于缺省参数值,由于是静态绑定,所有derived类的缺省参数值全部取决于base中的"></a>但对于缺省参数值,由于是静态绑定,所有derived类的缺省参数值全部取决于base中的</h4><h4 id="3-对于这些问题-当你想令virtual函数表现出你想要的行为但却遭遇麻烦-可以考虑virtual函数的替代设计-条款35"><a href="#3-对于这些问题-当你想令virtual函数表现出你想要的行为但却遭遇麻烦-可以考虑virtual函数的替代设计-条款35" class="headerlink" title="3.对于这些问题,当你想令virtual函数表现出你想要的行为但却遭遇麻烦,可以考虑virtual函数的替代设计(条款35)"></a>3.对于这些问题,当你想令virtual函数表现出你想要的行为但却遭遇麻烦,可以考虑virtual函数的替代设计(条款35)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">do</span> <span class="title">Draw</span><span class="params">(color)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span><span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:<span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//由于non-virtual 函数绝不应该被override(条款36),这个设计很清楚的使得draw函数类的color缺省参数值总为Red</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-29"><a href="#注意事项-29" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-绝不要重定义一个继承而来的缺省参数值-因为缺省参数值是静态绑定-而virtual函数却是动态绑定"><a href="#1-绝不要重定义一个继承而来的缺省参数值-因为缺省参数值是静态绑定-而virtual函数却是动态绑定" class="headerlink" title="1.绝不要重定义一个继承而来的缺省参数值,因为缺省参数值是静态绑定,而virtual函数却是动态绑定"></a>1.绝不要重定义一个继承而来的缺省参数值,因为缺省参数值是静态绑定,而virtual函数却是动态绑定</h4><h1 id="条款-38-通过复合塑模出has-a或”根据某物实现出”"><a href="#条款-38-通过复合塑模出has-a或”根据某物实现出”" class="headerlink" title="条款 38 : 通过复合塑模出has-a或”根据某物实现出”"></a>条款 38 : 通过复合塑模出has-a或”根据某物实现出”</h1><h4 id="1-复合是类型之间的一种关系-当某种类型的对象含有它种类型的对象-便是这种关系"><a href="#1-复合是类型之间的一种关系-当某种类型的对象含有它种类型的对象-便是这种关系" class="headerlink" title="1.复合是类型之间的一种关系,当某种类型的对象含有它种类型的对象,便是这种关系"></a>1.复合是类型之间的一种关系,当某种类型的对象含有它种类型的对象,便是这种关系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    Address address;</span><br><span class="line">    PhoneNumber voiceNumber;</span><br><span class="line">    PhoneNumber faxNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-条款32曾说-”public继承”带有-is-a的意义-复合也有它的意义即"><a href="#2-条款32曾说-”public继承”带有-is-a的意义-复合也有它的意义即" class="headerlink" title="2.条款32曾说,”public继承”带有 is-a的意义. 复合也有它的意义即:"></a>2.条款32曾说,”public继承”带有 is-a的意义. 复合也有它的意义即:</h4><h5 id="a-has-a"><a href="#a-has-a" class="headerlink" title="a.has-a"></a>a.has-a</h5><h5 id="b-根据某物实现出-“is-implemented-in-terms-of”"><a href="#b-根据某物实现出-“is-implemented-in-terms-of”" class="headerlink" title="b.根据某物实现出(“is-implemented-in-terms-of”)"></a>b.根据某物实现出(“is-implemented-in-terms-of”)</h5><h4 id="当复合发生于应用域（人-汽车-一张张视频画面等）内的对象之间-表现出has-a关系-当它发生于实现域（缓冲区-互斥器-查找树等）则是表现出-“is-implemented-in-terms-of”关系"><a href="#当复合发生于应用域（人-汽车-一张张视频画面等）内的对象之间-表现出has-a关系-当它发生于实现域（缓冲区-互斥器-查找树等）则是表现出-“is-implemented-in-terms-of”关系" class="headerlink" title="当复合发生于应用域（人,汽车,一张张视频画面等）内的对象之间,表现出has-a关系;当它发生于实现域（缓冲区,互斥器,查找树等）则是表现出 “is implemented-in-terms-of”关系"></a>当复合发生于应用域（人,汽车,一张张视频画面等）内的对象之间,表现出has-a关系;当它发生于实现域（缓冲区,互斥器,查找树等）则是表现出 “is implemented-in-terms-of”关系</h4><h4 id="3-has-a-和-is-a-的区别很好区分-关键在于is-a-和-is-implemented-in-terms-of-根据某物实现出-书中给出一个由list-实现-set-的例子-由于set并不是list-只是借由list的机能复用代码实现set-所以不符合is-a关系-采用-is-implemented-in-terms-of关系"><a href="#3-has-a-和-is-a-的区别很好区分-关键在于is-a-和-is-implemented-in-terms-of-根据某物实现出-书中给出一个由list-实现-set-的例子-由于set并不是list-只是借由list的机能复用代码实现set-所以不符合is-a关系-采用-is-implemented-in-terms-of关系" class="headerlink" title="3.has-a 和 is-a 的区别很好区分,关键在于is-a 和 is-implemented-in-terms-of(根据某物实现出),书中给出一个由list 实现 set 的例子,由于set并不是list,只是借由list的机能复用代码实现set,所以不符合is-a关系,采用 is-implemented-in-terms-of关系"></a>3.has-a 和 is-a 的区别很好区分,关键在于is-a 和 is-implemented-in-terms-of(根据某物实现出),书中给出一个由list 实现 set 的例子,由于set并不是list,只是借由list的机能复用代码实现set,所以不符合is-a关系,采用 is-implemented-in-terms-of关系</h4><h2 id="注意事项-30"><a href="#注意事项-30" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-复合-composition-的意义和public继承完全不同"><a href="#1-复合-composition-的意义和public继承完全不同" class="headerlink" title="1.复合(composition)的意义和public继承完全不同"></a>1.复合(composition)的意义和public继承完全不同</h4><h4 id="2-在应用域-复合意味着-has-a，在实现域-复合意味着-is-implemented-in-terms-of"><a href="#2-在应用域-复合意味着-has-a，在实现域-复合意味着-is-implemented-in-terms-of" class="headerlink" title="2.在应用域,复合意味着 has-a，在实现域,复合意味着 is-implemented-in-terms-of"></a>2.在应用域,复合意味着 has-a，在实现域,复合意味着 is-implemented-in-terms-of</h4><h1 id="条款-39-明智还审慎地使用private继承"><a href="#条款-39-明智还审慎地使用private继承" class="headerlink" title="条款 39 : 明智还审慎地使用private继承"></a>条款 39 : 明智还审慎地使用private继承</h1><h4 id="1-private继承下-编译器不会自动将一个derived-class-对象转换成一个-base-class-对象"><a href="#1-private继承下-编译器不会自动将一个derived-class-对象转换成一个-base-class-对象" class="headerlink" title="1.private继承下,编译器不会自动将一个derived class 对象转换成一个 base class 对象"></a>1.private继承下,编译器不会自动将一个derived class 对象转换成一个 base class 对象</h4><h4 id="2-private继承意味这implemented-in-terms-o-根据某物实现出-如果D以private形式继承B-意思是D对象根据B对象实现而得-再没有其他意涵了"><a href="#2-private继承意味这implemented-in-terms-o-根据某物实现出-如果D以private形式继承B-意思是D对象根据B对象实现而得-再没有其他意涵了" class="headerlink" title="2.private继承意味这implemented-in-terms-o(根据某物实现出),如果D以private形式继承B,意思是D对象根据B对象实现而得,再没有其他意涵了"></a>2.private继承意味这implemented-in-terms-o(根据某物实现出),如果D以private形式继承B,意思是D对象根据B对象实现而得,再没有其他意涵了</h4><h6 id="private在设计层面上没有意义-其意义只存在软件实现层面"><a href="#private在设计层面上没有意义-其意义只存在软件实现层面" class="headerlink" title="private在设计层面上没有意义,其意义只存在软件实现层面"></a>private在设计层面上没有意义,其意义只存在软件实现层面</h6><h4 id="3-考虑下述例子-设定某种计时器-记录Widget每个成员函数被调用的次数"><a href="#3-考虑下述例子-设定某种计时器-记录Widget每个成员函数被调用的次数" class="headerlink" title="3.考虑下述例子,设定某种计时器,记录Widget每个成员函数被调用的次数"></a>3.考虑下述例子,设定某种计时器,记录Widget每个成员函数被调用的次数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//为了让Widget重定义Timer中的virtual函数,Widget必须继承自Timer</span></span><br><span class="line"><span class="comment">//因为Ontick并不是Widget接口的一部分,只是内部计数的实现细节,所以public继承不是好策略,会导致违反条款18</span></span><br><span class="line"><span class="comment">//的忠告:&quot;让接口容易被正常使用,不易被误用&quot;</span></span><br><span class="line"><span class="comment">//所以必须以private继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>::<span class="keyword">private</span> Timer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="这是个好设计-但private继承绝非必要-另一种做法是以复合取而代之"><a href="#这是个好设计-但private继承绝非必要-另一种做法是以复合取而代之" class="headerlink" title="这是个好设计,但private继承绝非必要,另一种做法是以复合取而代之"></a>这是个好设计,但private继承绝非必要,另一种做法是以复合取而代之</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>:<span class="keyword">public</span> Timer</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer time;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-如果考虑将Widget的编译依存性降至最低-可以将class-WidgetTimer分离出去-Widget内只留一个WidgetTimer-指针"><a href="#4-如果考虑将Widget的编译依存性降至最低-可以将class-WidgetTimer分离出去-Widget内只留一个WidgetTimer-指针" class="headerlink" title="4.如果考虑将Widget的编译依存性降至最低,可以将class WidgetTimer分离出去,Widget内只留一个WidgetTimer* 指针"></a>4.如果考虑将Widget的编译依存性降至最低,可以将class WidgetTimer分离出去,Widget内只留一个WidgetTimer* 指针</h4><h4 id="5-何时优先选择”private继承”而不是”继承加复合”-这一种激进情况涉及空间最优化"><a href="#5-何时优先选择”private继承”而不是”继承加复合”-这一种激进情况涉及空间最优化" class="headerlink" title="5.何时优先选择”private继承”而不是”继承加复合”?,这一种激进情况涉及空间最优化"></a>5.何时优先选择”private继承”而不是”继承加复合”?,这一种激进情况涉及空间最优化</h4><h6 id="只适用于你所处理的class不带任何数据是-这样的class没有non-static变量-没有virtual函数-会带来vptr-条款7-也没有virtual-base-classes-也会导致体积上的额外开销-条款40-这种所谓的-Empty-Class-不使用任何空间-但C-官方会安插一个char到空对象中-裁定凡是独立-非附属-对象都必须有非零大小"><a href="#只适用于你所处理的class不带任何数据是-这样的class没有non-static变量-没有virtual函数-会带来vptr-条款7-也没有virtual-base-classes-也会导致体积上的额外开销-条款40-这种所谓的-Empty-Class-不使用任何空间-但C-官方会安插一个char到空对象中-裁定凡是独立-非附属-对象都必须有非零大小" class="headerlink" title="只适用于你所处理的class不带任何数据是.这样的class没有non-static变量,没有virtual函数(会带来vptr,条款7),也没有virtual base classes(也会导致体积上的额外开销,条款40), 这种所谓的 Empty Class 不使用任何空间,但C++官方会安插一个char到空对象中,裁定凡是独立(非附属)对象都必须有非零大小"></a>只适用于你所处理的class不带任何数据是.这样的class没有non-static变量,没有virtual函数(会带来vptr,条款7),也没有virtual base classes(也会导致体积上的额外开销,条款40), 这种所谓的 Empty Class 不使用任何空间,但C++官方会安插一个char到空对象中,裁定凡是独立(非附属)对象都必须有非零大小</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldAnInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//会出现 sizeof(HoldAnInt) &gt; sizeof(int)</span></span><br></pre></td></tr></table></figure>

<h4 id="此时采用复合的话-HoldAnInt的对象不仅仅变大-还可能不止获得一个char的大小-由于齐位需求-条款50-如在clion下-HoldAnInt的大小变为-8"><a href="#此时采用复合的话-HoldAnInt的对象不仅仅变大-还可能不止获得一个char的大小-由于齐位需求-条款50-如在clion下-HoldAnInt的大小变为-8" class="headerlink" title="此时采用复合的话,HoldAnInt的对象不仅仅变大,还可能不止获得一个char的大小,由于齐位需求(条款50),如在clion下,HoldAnInt的大小变为 8"></a>此时采用复合的话,HoldAnInt的对象不仅仅变大,还可能不止获得一个char的大小,由于齐位需求(条款50),如在clion下,HoldAnInt的大小变为 8</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HoldAnInt</span>:<span class="keyword">private</span> Empty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前面提到了&quot;独立(非附属)&quot;的对象大小不一定为0,但这个约束不适用于derived class对象的base class </span></span><br><span class="line"><span class="comment">//所以此处 sizeof(HoldAnInt) == sizeof(int),这是所谓的空白基类最优化 (EBO)</span></span><br></pre></td></tr></table></figure>

<h4 id="这种情况较少-所以通常采用复合"><a href="#这种情况较少-所以通常采用复合" class="headerlink" title="这种情况较少,所以通常采用复合"></a>这种情况较少,所以通常采用复合</h4><h2 id="注意事项-31"><a href="#注意事项-31" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-private-意味着-根据某物实现出-它通常比复合的级别低"><a href="#1-private-意味着-根据某物实现出-它通常比复合的级别低" class="headerlink" title="1.private 意味着 根据某物实现出.它通常比复合的级别低."></a>1.private 意味着 根据某物实现出.它通常比复合的级别低.</h4><h6 id="但是当derived-class-需要访问-protected-base-class-的成员-或需重新定义继承而来的virtual-函数时-可以这样"><a href="#但是当derived-class-需要访问-protected-base-class-的成员-或需重新定义继承而来的virtual-函数时-可以这样" class="headerlink" title="但是当derived class 需要访问 protected base class 的成员,或需重新定义继承而来的virtual 函数时,可以这样"></a>但是当derived class 需要访问 protected base class 的成员,或需重新定义继承而来的virtual 函数时,可以这样</h6><h4 id="2-private继承可以实现-EBO-空白基类最优化-，这对于程序库开发者可能很重要"><a href="#2-private继承可以实现-EBO-空白基类最优化-，这对于程序库开发者可能很重要" class="headerlink" title="2.private继承可以实现,EBO(空白基类最优化)，这对于程序库开发者可能很重要"></a>2.private继承可以实现,EBO(空白基类最优化)，这对于程序库开发者可能很重要</h4><h1 id="条款-40-明智而审慎地使用多重继承"><a href="#条款-40-明智而审慎地使用多重继承" class="headerlink" title="条款 40 : 明智而审慎地使用多重继承"></a>条款 40 : 明智而审慎地使用多重继承</h1><h4 id="1-不同base-class-中含有同名函数会导致调用发生歧义-p192"><a href="#1-不同base-class-中含有同名函数会导致调用发生歧义-p192" class="headerlink" title="1.不同base class 中含有同名函数会导致调用发生歧义 p192"></a>1.不同base class 中含有同名函数会导致调用发生歧义 p192</h4><h4 id="2-菱形继承时-应采用virtual-继承-防止含有多份成员变量"><a href="#2-菱形继承时-应采用virtual-继承-防止含有多份成员变量" class="headerlink" title="2.菱形继承时,应采用virtual 继承 防止含有多份成员变量"></a>2.菱形继承时,应采用virtual 继承 防止含有多份成员变量</h4><h4 id="3-virtual-继承会导致额外的开销代价"><a href="#3-virtual-继承会导致额外的开销代价" class="headerlink" title="3.virtual 继承会导致额外的开销代价"></a>3.virtual 继承会导致额外的开销代价</h4><h4 id="4-p195给出一个良好的多重继承例子"><a href="#4-p195给出一个良好的多重继承例子" class="headerlink" title="4.p195给出一个良好的多重继承例子"></a>4.p195给出一个良好的多重继承例子</h4><h4 id="5-多重继承只是一个工具-是否采用取决于你的设计方案-采用多重还是单一哪种效果更好"><a href="#5-多重继承只是一个工具-是否采用取决于你的设计方案-采用多重还是单一哪种效果更好" class="headerlink" title="5.多重继承只是一个工具,是否采用取决于你的设计方案,采用多重还是单一哪种效果更好"></a>5.多重继承只是一个工具,是否采用取决于你的设计方案,采用多重还是单一哪种效果更好</h4><h2 id="注意事项-32"><a href="#注意事项-32" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-多重继承比单一继承复杂，他可能导致新的歧义性-以及对virtual函数的需要"><a href="#1-多重继承比单一继承复杂，他可能导致新的歧义性-以及对virtual函数的需要" class="headerlink" title="1.多重继承比单一继承复杂，他可能导致新的歧义性,以及对virtual函数的需要"></a>1.多重继承比单一继承复杂，他可能导致新的歧义性,以及对virtual函数的需要</h4><h4 id="2-virtual继承会增加大小-速度-初始化复杂度等成本"><a href="#2-virtual继承会增加大小-速度-初始化复杂度等成本" class="headerlink" title="2.virtual继承会增加大小,速度,初始化复杂度等成本."></a>2.virtual继承会增加大小,速度,初始化复杂度等成本.</h4><h4 id="3-多重继承的确有正当用途-其中一个情节涉及”public继承某个Interface-class”-和-“private-继承某个协助实现的class”的两者组合-参考-4-中的例子"><a href="#3-多重继承的确有正当用途-其中一个情节涉及”public继承某个Interface-class”-和-“private-继承某个协助实现的class”的两者组合-参考-4-中的例子" class="headerlink" title="3.多重继承的确有正当用途. 其中一个情节涉及”public继承某个Interface class” 和 “private 继承某个协助实现的class”的两者组合,参考 4 中的例子"></a>3.多重继承的确有正当用途. 其中一个情节涉及”public继承某个Interface class” 和 “private 继承某个协助实现的class”的两者组合,参考 4 中的例子</h4><h1 id="条款-41-了解隐式接口和编译期多态"><a href="#条款-41-了解隐式接口和编译期多态" class="headerlink" title="条款 41 : 了解隐式接口和编译期多态"></a>条款 41 : 了解隐式接口和编译期多态</h1><h4 id="1-对于oop-一般以显示接口和运行期多态解决问题-如下述例子"><a href="#1-对于oop-一般以显示接口和运行期多态解决问题-如下述例子" class="headerlink" title="1.对于oop 一般以显示接口和运行期多态解决问题,如下述例子"></a>1.对于oop 一般以显示接口和运行期多态解决问题,如下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Wdiget</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(Widget&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>();</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.由于w的类型被声明为Widget,所以w必须支持Widget接口,可以在源码中找出这个接口,所以称此为显式接口,也就</span></span><br><span class="line"><span class="comment">//是它在源码中明确可见</span></span><br><span class="line"><span class="comment">//2.由于Widget的某些成员函数为virtual,对这些函数的调用表现出运行期多态,即根据W的动态类型(条款37)决定掉</span></span><br><span class="line"><span class="comment">//用哪一个函数</span></span><br></pre></td></tr></table></figure>

<h4 id="2-对于Template及泛型编程-显式接口和运行期多态仍存在-但重要性变低-隐式接口和编译期多态移到前头"><a href="#2-对于Template及泛型编程-显式接口和运行期多态仍存在-但重要性变低-隐式接口和编译期多态移到前头" class="headerlink" title="2.对于Template及泛型编程,显式接口和运行期多态仍存在,但重要性变低,隐式接口和编译期多态移到前头"></a>2.对于Template及泛型编程,显式接口和运行期多态仍存在,但重要性变低,隐式接口和编译期多态移到前头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>();</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.w必须支持哪一种接口,系由template中执行在w身上的操作来决定,本例来看好像必须支持 size,normalize和</span></span><br><span class="line"><span class="comment">//swap成员函数,copy构造函数,不等比较,但这并非完全成员,总而言之这一组表达式便是T必须支持的隐式接口</span></span><br><span class="line"><span class="comment">//2.凡涉及w的任何函数调用,有可能造成template具现化,这样的行为发生在编译期.&quot;以不同的template参数具现化&quot;</span></span><br><span class="line"><span class="comment">//导致调用不同的函数,这既是所谓的编译期多态</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-33"><a href="#注意事项-33" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-classes-和-templates-都支持接口-interfaces-和-多态-ploymorphism"><a href="#1-classes-和-templates-都支持接口-interfaces-和-多态-ploymorphism" class="headerlink" title="1.classes 和 templates 都支持接口(interfaces) 和 多态(ploymorphism)"></a>1.classes 和 templates 都支持接口(interfaces) 和 多态(ploymorphism)</h4><h4 id="2-对class-接口是显式的-多态则是通过virtual函数发生于运行期"><a href="#2-对class-接口是显式的-多态则是通过virtual函数发生于运行期" class="headerlink" title="2.对class,接口是显式的,多态则是通过virtual函数发生于运行期"></a>2.对class,接口是显式的,多态则是通过virtual函数发生于运行期</h4><h4 id="3-对template-接口是隐式的-奠基于表达式-多态则是通过template具现化和函数重载解析发生于编译期"><a href="#3-对template-接口是隐式的-奠基于表达式-多态则是通过template具现化和函数重载解析发生于编译期" class="headerlink" title="3.对template,接口是隐式的,奠基于表达式.多态则是通过template具现化和函数重载解析发生于编译期."></a>3.对template,接口是隐式的,奠基于表达式.多态则是通过template具现化和函数重载解析发生于编译期.</h4><h1 id="条款-42-了解typename的双重意义"><a href="#条款-42-了解typename的双重意义" class="headerlink" title="条款 42 : 了解typename的双重意义"></a>条款 42 : 了解typename的双重意义</h1><h4 id="1-参考下述例子"><a href="#1-参考下述例子" class="headerlink" title="1.参考下述例子"></a>1.参考下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span>  <span class="comment">//目的:打印容器内的第二元素</span></span></span><br><span class="line"><span class="function"></span>&#123;                                  <span class="comment">//注意这不是有效的代码</span></span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;         <span class="comment">//获取第一个元素的迭代器</span></span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="type">int</span> value = *iter;</span><br><span class="line">        std::cout &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上述例子中出现的两个变量-iter-和-value-iter的类型是C-const-iterator-实际是什么取决于template参数C-template内出现的名称如果相依于某个template参数-称之为从属名称-如果从属名称在class内呈嵌套状-称它为嵌套从属名称-此处的C-const-iterator就是这样的名称-实际上它还是个嵌套从属类型名称"><a href="#上述例子中出现的两个变量-iter-和-value-iter的类型是C-const-iterator-实际是什么取决于template参数C-template内出现的名称如果相依于某个template参数-称之为从属名称-如果从属名称在class内呈嵌套状-称它为嵌套从属名称-此处的C-const-iterator就是这样的名称-实际上它还是个嵌套从属类型名称" class="headerlink" title="上述例子中出现的两个变量, iter 和 value. iter的类型是C::const_iterator , 实际是什么取决于template参数C. template内出现的名称如果相依于某个template参数,称之为从属名称.如果从属名称在class内呈嵌套状,称它为嵌套从属名称,此处的C::const_iterator就是这样的名称,实际上它还是个嵌套从属类型名称"></a>上述例子中出现的两个变量, iter 和 value. iter的类型是C::const_iterator , 实际是什么取决于template参数C. <u>template内出现的名称如果相依于某个template参数,称之为从属名称</u>.如果从属名称在class内呈嵌套状,称它为<u>嵌套从属名称</u>,此处的C::const_iterator就是这样的名称,实际上它还是个<u>嵌套从属类型名称</u></h4><h4 id="2-嵌套从属名称可能导致解析困难"><a href="#2-嵌套从属名称可能导致解析困难" class="headerlink" title="2.嵌套从属名称可能导致解析困难"></a>2.嵌套从属名称可能导致解析困难</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C::const_iterator* x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看起来好像好像是 const_iterator 指向一个 x</span></span><br><span class="line"><span class="comment">//但如果const_iterator 是 C里面的一个变量 , x是一个global变量名称,则上述代码变为相乘动作</span></span><br></pre></td></tr></table></figure>

<h4 id="3-解析器在template中遭遇一个嵌套从属名称-它便假设这个名称不是类型-除非你告诉它是-所以缺省情况下-嵌套从属名称不是类型-但有例外"><a href="#3-解析器在template中遭遇一个嵌套从属名称-它便假设这个名称不是类型-除非你告诉它是-所以缺省情况下-嵌套从属名称不是类型-但有例外" class="headerlink" title="3.解析器在template中遭遇一个嵌套从属名称,它便假设这个名称不是类型,除非你告诉它是.所以缺省情况下,嵌套从属名称不是类型,但有例外"></a>3.解析器在template中遭遇一个嵌套从属名称,它便假设这个名称不是类型,除非你告诉它是.所以缺省情况下,嵌套从属名称不是类型,但有例外</h4><h4 id="4-想要告诉解析器是-需要在前面加上关键字"><a href="#4-想要告诉解析器是-需要在前面加上关键字" class="headerlink" title="4.想要告诉解析器是,需要在前面加上关键字"></a>4.想要告诉解析器是,需要在前面加上关键字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typename只用来验明嵌套从属类型名称,其他名称不该有它存在,如下述例子</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                  <span class="comment">//允许使用 &quot;typename&quot; 或 &quot;class&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> C&amp; container,             <span class="comment">//不允许使用 &quot;typename&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">typename</span> C::iterator iter)</span></span>;     <span class="comment">//一定要使用 &quot;typeneme&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-例外是-typename不可以出现在base-classes-list内的嵌套从属类型名称之前-也不可在member-initialization-list-中作为base-class-修饰符"><a href="#5-例外是-typename不可以出现在base-classes-list内的嵌套从属类型名称之前-也不可在member-initialization-list-中作为base-class-修饰符" class="headerlink" title="5.例外是,typename不可以出现在base classes list内的嵌套从属类型名称之前,也不可在member initialization list 中作为base class 修饰符"></a>5.例外是,typename不可以出现在base classes list内的嵌套从属类型名称之前,也不可在member initialization list 中作为base class 修饰符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested        <span class="comment">//不允许</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        :Base&lt;T&gt;::Nested(x)                   //不允许</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">            <span class="keyword">typename</span> Base&lt;T&gt;::<span class="built_in">Nested</span>(temp);   <span class="comment">//需要</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项-34"><a href="#注意事项-34" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-声明template-参数时-前缀关键字class-和-typename-可以呼唤"><a href="#1-声明template-参数时-前缀关键字class-和-typename-可以呼唤" class="headerlink" title="1.声明template 参数时,前缀关键字class 和 typename 可以呼唤"></a>1.声明template 参数时,前缀关键字class 和 typename 可以呼唤</h4><h4 id="2-请使用关键字typename标识嵌套从属类型名称-但不得在base-class-lists-基类列-或-member-initialization-list-成员初值列-内以它作为base-class-修饰符"><a href="#2-请使用关键字typename标识嵌套从属类型名称-但不得在base-class-lists-基类列-或-member-initialization-list-成员初值列-内以它作为base-class-修饰符" class="headerlink" title="2.请使用关键字typename标识嵌套从属类型名称,但不得在base class lists(基类列) 或 member initialization list(成员初值列)内以它作为base class 修饰符"></a>2.请使用关键字typename标识嵌套从属类型名称,但不得在base class lists(基类列) 或 member initialization list(成员初值列)内以它作为base class 修饰符</h4><h1 id="条款-43-学习处理模板化基类的名称"><a href="#条款-43-学习处理模板化基类的名称" class="headerlink" title="条款 43 : 学习处理模板化基类的名称"></a>条款 43 : 学习处理模板化基类的名称</h1><h4 id="1-对于下述例子-4"><a href="#1-对于下述例子-4" class="headerlink" title="1.对于下述例子"></a>1.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>:<span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sendClear</span>(info);                   <span class="comment">//调用base class函数,这段无法通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当编译器遭遇class template 时,并不知道它继承的什么class.当然它继承的是MsgSender&lt;Company&gt;,但其中的</span></span><br><span class="line"><span class="comment">//company是一个template参数,不到后来(被具现化)不知道它是什么.</span></span><br><span class="line"><span class="comment">//而如果不知道Company是什么,就无法知道class MsgSender&lt;company&gt;看起来像什么,更明确的说是没办法知道它</span></span><br><span class="line"><span class="comment">//是否有个sendClear函数</span></span><br></pre></td></tr></table></figure>

<h4 id="2-对于下述例子"><a href="#2-对于下述例子" class="headerlink" title="2.对于下述例子"></a>2.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先提供一个全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...                                  <span class="comment">//与一般template的差距在于它没有sendClear</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在再次考虑derived class</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>:<span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">sendClear</span>(info);         <span class="comment">//如果Company == CompanyZ,这个函数不存在</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="如注释所言-base-class-被指定为MsgSender-lt-CompanyZ-gt-不合理-以为那个特化中没有提供sendClear函数-这就是为什么拒绝调用"><a href="#如注释所言-base-class-被指定为MsgSender-lt-CompanyZ-gt-不合理-以为那个特化中没有提供sendClear函数-这就是为什么拒绝调用" class="headerlink" title="如注释所言,base class 被指定为MsgSender&lt;.CompanyZ&gt;不合理.以为那个特化中没有提供sendClear函数,这就是为什么拒绝调用."></a>如注释所言,base class 被指定为MsgSender&lt;.CompanyZ&gt;不合理.以为那个特化中没有提供sendClear函数,这就是为什么拒绝调用.</h4><h5 id="个人理解-也是为什么会出现遭遇class-template时不清楚它继承了什么-因为它知道base-class-templates可能被特化-而那个特化版本不提供和一般性template相同的接口-因此它往往拒绝在-templatized-base-classes-模板化基类-内寻找继承而来的名称"><a href="#个人理解-也是为什么会出现遭遇class-template时不清楚它继承了什么-因为它知道base-class-templates可能被特化-而那个特化版本不提供和一般性template相同的接口-因此它往往拒绝在-templatized-base-classes-模板化基类-内寻找继承而来的名称" class="headerlink" title="个人理解:也是为什么会出现遭遇class template时不清楚它继承了什么,因为它知道base class templates可能被特化,而那个特化版本不提供和一般性template相同的接口. 因此它往往拒绝在 templatized base classes(模板化基类)内寻找继承而来的名称"></a>个人理解:也是为什么会出现遭遇class template时不清楚它继承了什么,因为它知道base class templates可能被特化,而那个特化版本不提供和一般性template相同的接口. 因此它往往拒绝在 templatized base classes(模板化基类)内寻找继承而来的名称</h5><h4 id="3-对此有三种办法使得C-”不进入-templatized-base-classes观察”的行为失效"><a href="#3-对此有三种办法使得C-”不进入-templatized-base-classes观察”的行为失效" class="headerlink" title="3.对此有三种办法使得C++”不进入 templatized base classes观察”的行为失效"></a>3.对此有三种办法使得C++”不进入 templatized base classes观察”的行为失效</h4><h5 id="a-使用this-gt"><a href="#a-使用this-gt" class="headerlink" title="a.使用this-&gt;"></a>a.使用this-&gt;</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>:<span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);             <span class="comment">//成立,假设sendClear将被继承</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="b-使用using-声明式（条款33"><a href="#b-使用using-声明式（条款33" class="headerlink" title="b.使用using 声明式（条款33)"></a>b.使用using 声明式（条款33)</h5><h5 id="虽然使用using也可以在这里有效运作-但两处解决的问题不相同-这里的情况并不是base-class名称被遮掩-而是编译器不进入base-class作用域查找-于是我们通过using告诉它-让它这么做"><a href="#虽然使用using也可以在这里有效运作-但两处解决的问题不相同-这里的情况并不是base-class名称被遮掩-而是编译器不进入base-class作用域查找-于是我们通过using告诉它-让它这么做" class="headerlink" title="虽然使用using也可以在这里有效运作,但两处解决的问题不相同,这里的情况并不是base class名称被遮掩,而是编译器不进入base class作用域查找,于是我们通过using告诉它,让它这么做"></a>虽然使用using也可以在这里有效运作,但两处解决的问题不相同,这里的情况并不是base class名称被遮掩,而是编译器不进入base class作用域查找,于是我们通过using告诉它,让它这么做</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>:<span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear; <span class="comment">//告诉编译器,请他假设sendClear位于baseclass内</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">endClear</span>(info);             <span class="comment">//假设sendClear将被继承</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="c-明白指出被调用的函数位于base-class-内"><a href="#c-明白指出被调用的函数位于base-class-内" class="headerlink" title="c.明白指出被调用的函数位于base class 内"></a>c.明白指出被调用的函数位于base class 内</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>:<span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);             <span class="comment">//假设sendClear将被继承</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//但这往往是最不让人满意的一个解法</span></span><br><span class="line"><span class="comment">// 如果被调用的是virtual函数,上述的 明确资格修饰 会关闭&quot;virtual&quot;绑定行为</span></span><br></pre></td></tr></table></figure>

<h4 id="4-上述的每个解法做的事情都相同-对编译器承诺-“base-class-templates的任何特化版本都将支持其一般-泛化-版本所提供的接口”"><a href="#4-上述的每个解法做的事情都相同-对编译器承诺-“base-class-templates的任何特化版本都将支持其一般-泛化-版本所提供的接口”" class="headerlink" title="4.上述的每个解法做的事情都相同,对编译器承诺: “base class templates的任何特化版本都将支持其一般(泛化)版本所提供的接口”"></a>4.上述的每个解法做的事情都相同,对编译器承诺: “base class templates的任何特化版本都将支持其一般(泛化)版本所提供的接口”</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举个例子</span></span><br><span class="line">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...</span><br><span class="line">zMsgSender.<span class="built_in">sendClearMsg</span>(msgDate);        <span class="comment">//错误,特化版本中不存在sendClear函数</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-35"><a href="#注意事项-35" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-可在derived-class-templates-内通过-“this-gt-”指涉base-class-templates-内的成员名称-或籍由一个明白写出的”base-class-资格修饰符”完成"><a href="#1-可在derived-class-templates-内通过-“this-gt-”指涉base-class-templates-内的成员名称-或籍由一个明白写出的”base-class-资格修饰符”完成" class="headerlink" title="1.可在derived class templates 内通过 “this-&gt;”指涉base class templates 内的成员名称,或籍由一个明白写出的”base class 资格修饰符”完成"></a>1.可在derived class templates 内通过 “this-&gt;”指涉base class templates 内的成员名称,或籍由一个明白写出的”base class 资格修饰符”完成</h4><h1 id="条款-44-将于参数无关的代码抽离templates"><a href="#条款-44-将于参数无关的代码抽离templates" class="headerlink" title="条款 44 : 将于参数无关的代码抽离templates"></a>条款 44 : 将于参数无关的代码抽离templates</h1><h4 id="1-对于non-template代码中-重复十分明确-你可以”看”到两个函数或两个classes之间有重复-但在template代码中-重复很隐晦"><a href="#1-对于non-template代码中-重复十分明确-你可以”看”到两个函数或两个classes之间有重复-但在template代码中-重复很隐晦" class="headerlink" title="1.对于non-template代码中,重复十分明确:你可以”看”到两个函数或两个classes之间有重复,但在template代码中,重复很隐晦"></a>1.对于non-template代码中,重复十分明确:你可以”看”到两个函数或两个classes之间有重复,但在template代码中,重复很隐晦</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//考虑下述例子</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqueareMatrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span></span>;           <span class="comment">//求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在再看下述例子</span></span><br><span class="line">SquareMatrix&lt;<span class="type">double</span>,<span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.<span class="built_in">invert</span>();                 <span class="comment">//调用SquareMatrix&lt;double,5&gt;::invert</span></span><br><span class="line">SquearMatrix&lt;<span class="type">double</span>,<span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.<span class="built_in">invert</span>();                 <span class="comment">////调用SquareMatrix&lt;double,10&gt;::invert</span></span><br></pre></td></tr></table></figure>

<h4 id="这导致具现化了两次invert函数"><a href="#这导致具现化了两次invert函数" class="headerlink" title="这导致具现化了两次invert函数"></a>这导致具现化了两次invert函数</h4><h4 id="2-对此可以将重复的代码抽离出-共享一份"><a href="#2-对此可以将重复的代码抽离出-共享一份" class="headerlink" title="2.对此可以将重复的代码抽离出,共享一份"></a>2.对此可以将重复的代码抽离出,共享一份</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>:<span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;    <span class="comment">//避免隐藏 条款33</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">invert</span>(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="此处的几个细节"><a href="#此处的几个细节" class="headerlink" title="此处的几个细节"></a>此处的几个细节</h4><h5 id="a-private继承-因为这里的base-class-只是用来帮助实现derived-class-，不是is-a关系"><a href="#a-private继承-因为这里的base-class-只是用来帮助实现derived-class-，不是is-a关系" class="headerlink" title="a.private继承,因为这里的base class 只是用来帮助实现derived class ，不是is-a关系"></a>a.private继承,因为这里的base class 只是用来帮助实现derived class ，不是is-a关系</h5><h6 id="另外几点的理解我的和书上的有出入"><a href="#另外几点的理解我的和书上的有出入" class="headerlink" title="另外几点的理解我的和书上的有出入"></a>另外几点的理解我的和书上的有出入</h6><h5 id="书上-此处的using声明用来避免隐藏-对于this-gt-若不用-模板化基类的函数名会被derived-classes遮盖"><a href="#书上-此处的using声明用来避免隐藏-对于this-gt-若不用-模板化基类的函数名会被derived-classes遮盖" class="headerlink" title="书上:此处的using声明用来避免隐藏, 对于this-&gt;若不用,模板化基类的函数名会被derived classes遮盖"></a>书上:此处的using声明用来避免隐藏, 对于this-&gt;若不用,模板化基类的函数名会被derived classes遮盖</h5><h5 id="我的-此处的using声明避免隐藏的同时-让不进入模板化基类的行为失效-this-gt-在此处有点多余了-且无法做到排除derived的遮盖-此处的例子刚好参数不同导致了重载-若变为无参-调用的还是derived-中的函数"><a href="#我的-此处的using声明避免隐藏的同时-让不进入模板化基类的行为失效-this-gt-在此处有点多余了-且无法做到排除derived的遮盖-此处的例子刚好参数不同导致了重载-若变为无参-调用的还是derived-中的函数" class="headerlink" title="我的:此处的using声明避免隐藏的同时,让不进入模板化基类的行为失效,this-&gt;在此处有点多余了,且无法做到排除derived的遮盖,此处的例子刚好参数不同导致了重载,若变为无参,调用的还是derived 中的函数"></a>我的:此处的using声明避免隐藏的同时,让不进入模板化基类的行为失效,this-&gt;在此处有点多余了,且无法做到排除derived的遮盖,此处的例子刚好参数不同导致了重载,若变为无参,调用的还是derived 中的函数</h5><h4 id="3-SquareMatrixBase-invert如何知道该操作什么数据-完整的实现如下"><a href="#3-SquareMatrixBase-invert如何知道该操作什么数据-完整的实现如下" class="headerlink" title="3.SquareMatrixBase::invert如何知道该操作什么数据,完整的实现如下"></a>3.SquareMatrixBase::invert如何知道该操作什么数据,完整的实现如下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n,T* pMem)<span class="comment">//存储矩阵大小和一个指针,指向矩阵数值</span></span><br><span class="line">        :<span class="built_in">size</span>(n),<span class="built_in">pData</span>(pMem)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T* ptr)</span></span>&#123; pData = ptr; &#125;<span class="comment">//重新赋值给pData</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;                      <span class="comment">//矩阵的大小</span></span><br><span class="line">    T* pData;                              <span class="comment">//指针,指向矩阵内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这允许derived class 决定内存的分配方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>:<span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>()</span><br><span class="line">        :<span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n,data)&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种做法是,通过new来分配内存到heap上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,std::<span class="type">szie_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>:<span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>()</span><br><span class="line">        :<span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n,<span class="number">0</span>)   <span class="comment">//将base class 的数据指针设为null</span></span><br><span class="line">        ,<span class="built_in">pData</span>(<span class="keyword">new</span> T[n*n])          <span class="comment">//为derived内的指针分配内存</span></span><br><span class="line">        &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>());&#125;<span class="comment">//将它的一个副本交给base class</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    boost::scoped_array&lt;T&gt; pData;   <span class="comment">//boost::scoped_array 见条款13</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-p216面下半部分未理解-大概意思是1-抽取公共代码到新的类导致对象大小的增加-此处就是多了一个data指针2-此处的n在模板参数中的话可能会有更多的优化-但作为函数参数的话就失去了这些优化-是否应该抽取公共代码-需要根据实际做出选择"><a href="#4-p216面下半部分未理解-大概意思是1-抽取公共代码到新的类导致对象大小的增加-此处就是多了一个data指针2-此处的n在模板参数中的话可能会有更多的优化-但作为函数参数的话就失去了这些优化-是否应该抽取公共代码-需要根据实际做出选择" class="headerlink" title="4.p216面下半部分未理解 大概意思是1.抽取公共代码到新的类导致对象大小的增加,此处就是多了一个data指针2.此处的n在模板参数中的话可能会有更多的优化,但作为函数参数的话就失去了这些优化  是否应该抽取公共代码,需要根据实际做出选择"></a>4.p216面下半部分未理解 大概意思是1.抽取公共代码到新的类导致对象大小的增加,此处就是多了一个data指针2.此处的n在模板参数中的话可能会有更多的优化,但作为函数参数的话就失去了这些优化  是否应该抽取公共代码,需要根据实际做出选择</h4><h4 id="5-目前这个条款只讨论了non-type-template-parameters-非类型模板参数-带来的膨胀-也就是代码的膨胀是由于相同算法多次具现化导致的-在本例就是矩阵的逆运算算法带来的-类型参数-type-parameters-也会导致膨胀-例如许多平台上-int-和-long-有完全相同的二进制表述-所以像vector-lt-int-gt-和vector-lt-long-gt-的成员函数有可能完全相同-这就导致了膨胀"><a href="#5-目前这个条款只讨论了non-type-template-parameters-非类型模板参数-带来的膨胀-也就是代码的膨胀是由于相同算法多次具现化导致的-在本例就是矩阵的逆运算算法带来的-类型参数-type-parameters-也会导致膨胀-例如许多平台上-int-和-long-有完全相同的二进制表述-所以像vector-lt-int-gt-和vector-lt-long-gt-的成员函数有可能完全相同-这就导致了膨胀" class="headerlink" title="5.目前这个条款只讨论了non-type template parameters (非类型模板参数)带来的膨胀,也就是代码的膨胀是由于相同算法多次具现化导致的,在本例就是矩阵的逆运算算法带来的.类型参数(type parameters)也会导致膨胀,例如许多平台上 int 和 long 有完全相同的二进制表述, 所以像vector&lt;int.&gt;和vector&lt;long.&gt;的成员函数有可能完全相同,这就导致了膨胀"></a>5.目前这个条款只讨论了non-type template parameters (非类型模板参数)带来的膨胀,也就是代码的膨胀是由于相同算法多次具现化导致的,在本例就是矩阵的逆运算算法带来的.类型参数(type parameters)也会导致膨胀,例如许多平台上 int 和 long 有完全相同的二进制表述, 所以像vector&lt;int.&gt;和vector&lt;long.&gt;的成员函数有可能完全相同,这就导致了膨胀</h4><h2 id="注意事项-36"><a href="#注意事项-36" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-Templates生成多个classes和多个函数-所以任何template代码都不该于某个造成膨胀的template参数产生相依关系-理解-使用模板时应避免产生代码膨胀"><a href="#1-Templates生成多个classes和多个函数-所以任何template代码都不该于某个造成膨胀的template参数产生相依关系-理解-使用模板时应避免产生代码膨胀" class="headerlink" title="1.Templates生成多个classes和多个函数,所以任何template代码都不该于某个造成膨胀的template参数产生相依关系(理解:使用模板时应避免产生代码膨胀)"></a>1.Templates生成多个classes和多个函数,所以任何template代码都不该于某个造成膨胀的template参数产生相依关系(理解:使用模板时应避免产生代码膨胀)</h4><h4 id="2-因非类型模板参数而造成的代码膨胀-往往可以消除-做法是以函数参数或class成员变量替换template参数"><a href="#2-因非类型模板参数而造成的代码膨胀-往往可以消除-做法是以函数参数或class成员变量替换template参数" class="headerlink" title="2.因非类型模板参数而造成的代码膨胀,往往可以消除,做法是以函数参数或class成员变量替换template参数"></a>2.因非类型模板参数而造成的代码膨胀,往往可以消除,做法是以函数参数或class成员变量替换template参数</h4><h4 id="3-因类型参数而造成的代码膨胀-往往可以降低-做法是带有完全相同的二进制表述的具现类型共享实现码"><a href="#3-因类型参数而造成的代码膨胀-往往可以降低-做法是带有完全相同的二进制表述的具现类型共享实现码" class="headerlink" title="3.因类型参数而造成的代码膨胀,往往可以降低,做法是带有完全相同的二进制表述的具现类型共享实现码"></a>3.因类型参数而造成的代码膨胀,往往可以降低,做法是带有完全相同的二进制表述的具现类型共享实现码</h4><h1 id="条款-45-运用成员函数模板接受所有兼容类型"><a href="#条款-45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45 : 运用成员函数模板接受所有兼容类型"></a>条款 45 : 运用成员函数模板接受所有兼容类型</h1><h4 id="1-本条款给出下述例子-定义智能指针-指向某继承体系"><a href="#1-本条款给出下述例子-定义智能指针-指向某继承体系" class="headerlink" title="1.本条款给出下述例子,定义智能指针,指向某继承体系"></a>1.本条款给出下述例子,定义智能指针,指向某继承体系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三层继承体系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>:<span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>:<span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle;               <span class="comment">//将Middle* 转换为 Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom;               <span class="comment">//将Bottom* 转换为 Top*</span></span><br><span class="line"><span class="type">const</span> Top* pct2 = pt1;               <span class="comment">//将Top* 转换为 const Top*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的智能指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>;   <span class="comment">//以内置(原始)指针完成初始化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果改为自定义的智能指针 </span></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);  <span class="comment">//将SmartPtr&lt;Middle&gt;转换为SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);  <span class="comment">//下同</span></span><br><span class="line">SmartPtr&lt;Top&gt; pct2 = pt1;</span><br></pre></td></tr></table></figure>

<h4 id="对于上述例子，同一个template的不同具现体之间不存在什么关系"><a href="#对于上述例子，同一个template的不同具现体之间不存在什么关系" class="headerlink" title="对于上述例子，同一个template的不同具现体之间不存在什么关系"></a>对于上述例子，同一个template的不同具现体之间不存在什么关系</h4><h6 id="这里意指如果以带有base-derived-关系的B-D两类型分别具现化某个template-产生的两个具现体-并不带有base"><a href="#这里意指如果以带有base-derived-关系的B-D两类型分别具现化某个template-产生的两个具现体-并不带有base" class="headerlink" title="这里意指如果以带有base-derived 关系的B,D两类型分别具现化某个template,产生的两个具现体,并不带有base"></a>这里意指如果以带有base-derived 关系的B,D两类型分别具现化某个template,产生的两个具现体,并不带有base</h6><h6 id="derived关系-所以完全为不同的两个classes"><a href="#derived关系-所以完全为不同的两个classes" class="headerlink" title="derived关系,所以完全为不同的两个classes"></a>derived关系,所以完全为不同的两个classes</h6><h4 id="2-对此需要的应该是member-function-template-，需要一个构造模板"><a href="#2-对此需要的应该是member-function-template-，需要一个构造模板" class="headerlink" title="2.对此需要的应该是member function template ，需要一个构造模板"></a>2.对此需要的应该是member function template ，需要一个构造模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="上述例子的意思-对任何类型T和任何类型U-这里可以根据SmartPtr-lt-U-gt-生成一个Smart-lt-T-gt"><a href="#上述例子的意思-对任何类型T和任何类型U-这里可以根据SmartPtr-lt-U-gt-生成一个Smart-lt-T-gt" class="headerlink" title="上述例子的意思,对任何类型T和任何类型U,这里可以根据SmartPtr&lt;.U&gt;生成一个Smart&lt;T.&gt;"></a>上述例子的意思,对任何类型T和任何类型U,这里可以根据SmartPtr&lt;.U&gt;生成一个Smart&lt;T.&gt;</h5><h4 id="3-由此可以实现我们想要的"><a href="#3-由此可以实现我们想要的" class="headerlink" title="3.由此可以实现我们想要的"></a>3.由此可以实现我们想要的</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span><br><span class="line">    :<span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>()) &#123; ... &#125;          <span class="comment">//关键 heldPtr(get())</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;           <span class="comment">//原始指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="以初值列标来初始化-这个行为仅当U指针转为一个T指针时才能通过编译"><a href="#以初值列标来初始化-这个行为仅当U指针转为一个T指针时才能通过编译" class="headerlink" title="以初值列标来初始化,这个行为仅当U指针转为一个T指针时才能通过编译"></a>以初值列标来初始化,这个行为仅当U指针转为一个T指针时才能通过编译</h5><h4 id="4-泛化copyi构造并不阻止编译器生成自己的copy构造-你必须同时声明泛化版本和正常版本"><a href="#4-泛化copyi构造并不阻止编译器生成自己的copy构造-你必须同时声明泛化版本和正常版本" class="headerlink" title="4.泛化copyi构造并不阻止编译器生成自己的copy构造,你必须同时声明泛化版本和正常版本"></a>4.泛化copyi构造并不阻止编译器生成自己的copy构造,你必须同时声明泛化版本和正常版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//copy构造 和 泛化copy构造</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span> &amp; r);</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;</span><br><span class="line">    <span class="comment">//普通copy assignment 和 泛化版本</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;T&gt; <span class="type">const</span>&amp; r);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项：-4"><a href="#注意事项：-4" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-请使用member-function-templates-生成-“可接受所有兼容类型”的函数"><a href="#1-请使用member-function-templates-生成-“可接受所有兼容类型”的函数" class="headerlink" title="1.请使用member function templates 生成 “可接受所有兼容类型”的函数"></a>1.请使用member function templates 生成 “可接受所有兼容类型”的函数</h4><h4 id="2-如果你声明的member-template-用于”泛化copy构造”或”泛化assignment”操作-你还是需要声明正常的copy构造和copyassignment操作符"><a href="#2-如果你声明的member-template-用于”泛化copy构造”或”泛化assignment”操作-你还是需要声明正常的copy构造和copyassignment操作符" class="headerlink" title="2.如果你声明的member template 用于”泛化copy构造”或”泛化assignment”操作,你还是需要声明正常的copy构造和copyassignment操作符"></a>2.如果你声明的member template 用于”泛化copy构造”或”泛化assignment”操作,你还是需要声明正常的copy构造和copyassignment操作符</h4><h1 id="条款-46-需要类型转换时请为模板定义非成员函数"><a href="#条款-46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46 : 需要类型转换时请为模板定义非成员函数"></a>条款 46 : 需要类型转换时请为模板定义非成员函数</h1><h4 id="1-对于下述例子-5"><a href="#1-对于下述例子-5" class="headerlink" title="1.对于下述例子"></a>1.对于下述例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:           <span class="comment">//pass-by-referenece 条款20</span></span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator=<span class="number">0</span>,<span class="type">const</span> T&amp; denominator=<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span><span class="type">const</span></span>;<span class="comment">//pass-by-value 条款28 返回引用(handle)会导致修改private变量</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    ...               <span class="comment">//使用 const 条款3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"><span class="comment">//像条款24 (此例子的普通版本来自于条款24)   区别:改为template</span></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;         </span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;   <span class="comment">//错误 无法通过编译</span></span><br><span class="line"><span class="comment">//问题在于编译器不知道该如何具现化出这个函数,为了完成这一动作,必须先算出T是什么,但编译器不行</span></span><br><span class="line"><span class="comment">//对于第一实参,能够顺利推导出T为int,但对于第二实参类型为 int ? 你可能期盼编译器使用Rational&lt;int&gt;的non-explicit 构造函数 将 2 转化为内 Rational&lt;int&gt; , 进而将T推到为int,但它们不这么做</span></span><br></pre></td></tr></table></figure>

<h4 id="因为在template实参推到过程中从不将隐式类型转换函数纳入考虑"><a href="#因为在template实参推到过程中从不将隐式类型转换函数纳入考虑" class="headerlink" title="因为在template实参推到过程中从不将隐式类型转换函数纳入考虑"></a>因为在template实参推到过程中从不将隐式类型转换函数纳入考虑</h4><h4 id="2-e-g"><a href="#2-e-g" class="headerlink" title="2. e.g"></a>2. e.g</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处编译可以通过,frined 函数在class被声明的时候,随着class同时被具现出来,<strong>后者由此作为一个函数而非模板函数,因此编译器可以调用它时用隐式转换函数</strong></p>
<h6 id="但此处-无法链接-因为具现化的时候class内只是声明了-但没有定义-类外那个template和它关系不大-所以连接器链接不上"><a href="#但此处-无法链接-因为具现化的时候class内只是声明了-但没有定义-类外那个template和它关系不大-所以连接器链接不上" class="headerlink" title="但此处,无法链接,因为具现化的时候class内只是声明了,但没有定义,类外那个template和它关系不大,所以连接器链接不上"></a>但此处,无法链接,因为具现化的时候class内只是声明了,但没有定义,类外那个template和它关系不大,所以连接器链接不上</h6><h4 id="3-对此最简单的解决方法"><a href="#3-对此最简单的解决方法" class="headerlink" title="3.对此最简单的解决方法"></a>3.对此最简单的解决方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                        lhs.<span class="built_in">denominator</span>() * rbs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的friend与传统的目的不同,传统的friend是用来让<strong>non-member函数访问non-public成员</strong>,但此处是为了实现<strong>类型转换</strong>,而为了实现类型转应采用<strong>non-member</strong>函数,而为了在class内声明<strong>non-member函数,<strong>我们需要</strong>friend</strong></p>
<h4 id="4-另一种做法是为了减小inline的影响-采用辅助函数的方法"><a href="#4-另一种做法是为了减小inline的影响-采用辅助函数的方法" class="headerlink" title="4.另一种做法是为了减小inline的影响,采用辅助函数的方法"></a>4.另一种做法是为了减小inline的影响,采用辅助函数的方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs,<span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="built_in">doMultiply</span>(lhs,rhs); &#125;          <span class="comment">//令friend调用helper</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里是让<strong>operator*只是用来进行转换</strong>，用来支持混合式乘法，<strong>实现交给doMultiply</strong>,有种<strong>各司其职</strong>的感觉,因为doMultiply因为是template class 不支持混合式乘法，但operator提供了类型转换</p>
<h4 id="5-还有一种做法-教官提出来的-但我的编译器上实现有问题"><a href="#5-还有一种做法-教官提出来的-但我的编译器上实现有问题" class="headerlink" title="5.还有一种做法,教官提出来的,但我的编译器上实现有问题"></a>5.还有一种做法,教官提出来的,但我的编译器上实现有问题</h4><h2 id="注意事项-37"><a href="#注意事项-37" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-当编写的class-template-而它提供的template相关的函数支持”所有参数的隐式转换”时，请将那些函数定义为class-template-内的-friend函数"><a href="#1-当编写的class-template-而它提供的template相关的函数支持”所有参数的隐式转换”时，请将那些函数定义为class-template-内的-friend函数" class="headerlink" title="1.当编写的class template , 而它提供的template相关的函数支持”所有参数的隐式转换”时，请将那些函数定义为class template 内的 friend函数"></a>1.当编写的class template , 而它提供的template相关的函数支持”所有参数的隐式转换”时，请将那些函数定义为class template 内的 friend函数</h4><h1 id="条款-47-请试用traits-classes表现类型信息"><a href="#条款-47-请试用traits-classes表现类型信息" class="headerlink" title="条款 47 : 请试用traits classes表现类型信息"></a>条款 47 : 请试用traits classes表现类型信息</h1><h5 id="首先为更好的理解下述例子-给出不同迭代器的定义"><a href="#首先为更好的理解下述例子-给出不同迭代器的定义" class="headerlink" title="首先为更好的理解下述例子,给出不同迭代器的定义:"></a>首先为更好的理解下述例子,给出不同迭代器的定义:</h5><ol>
<li>Input迭代器:只能向前移动,一次一步,只读</li>
<li>Output迭代器:只能向前移动,一次一步,只写</li>
<li>forward迭代器:做前两种迭代器能做的事情,可读可写</li>
<li>Bidirectional迭代器:比前一个能做的事更多,既可以向前还可以向后</li>
<li>random access迭代器:可以移动任意距离</li>
</ol>
<h5 id="它们之间具有一系列的继承关系"><a href="#它们之间具有一系列的继承关系" class="headerlink" title="它们之间具有一系列的继承关系:"></a>它们之间具有一系列的继承关系:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span>:<span class="keyword">public</span> input_iterator_tag&#123;&#125;;</span><br><span class="line">sturct bidirectional_iterator_tag:<span class="keyword">public</span> forward_iterator_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span>:<span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-文中给出一个advance函数-用来对某个迭代器移动某个给定距离-代码如下"><a href="#1-文中给出一个advance函数-用来对某个迭代器移动某个给定距离-代码如下" class="headerlink" title="1.文中给出一个advance函数,用来对某个迭代器移动某个给定距离,代码如下"></a>1.文中给出一个advance函数,用来对某个迭代器移动某个给定距离,代码如下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter is a random access iterator)</span><br><span class="line">    &#123;</span><br><span class="line">        iter += d;                <span class="comment">//针对random access迭代器使用迭代器算数运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;                             <span class="comment">//针对其它迭代器分类</span></span><br><span class="line">        <span class="keyword">if</span> ( d&gt;=<span class="number">0</span> ) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“traits必须能够施行于内置类型”意味着”类型内的嵌套信息”这种东西出局了,因为我们无法将信息嵌套于原始指针内,因此类型的traits信息必须位于类型自身之外.标准技术是把它放进一个template及其一个或多个特化版本中,这样的templates在标准程序库中有若干个,其中针对迭代器的被命名为iterator_traits</p>
</blockquote>
<h5 id="对于这段话的理解-一般实现traits技术时-是在每个类型中-此例子中就是每个迭代器类型中-声明一个typedef这也就是”类型内的嵌套信息”-而指针也相当于迭代器-但普通指针不是类-也就不存在”类型内的嵌套信息”-对于这种类型-tratis就需要提供特化版本"><a href="#对于这段话的理解-一般实现traits技术时-是在每个类型中-此例子中就是每个迭代器类型中-声明一个typedef这也就是”类型内的嵌套信息”-而指针也相当于迭代器-但普通指针不是类-也就不存在”类型内的嵌套信息”-对于这种类型-tratis就需要提供特化版本" class="headerlink" title="对于这段话的理解,一般实现traits技术时,是在每个类型中,此例子中就是每个迭代器类型中,声明一个typedef这也就是”类型内的嵌套信息”,而指针也相当于迭代器,但普通指针不是类,也就不存在”类型内的嵌套信息”,对于这种类型,tratis就需要提供特化版本"></a>对于这段话的理解,一般实现traits技术时,是在每个类型中,此例子中就是每个迭代器类型中,声明一个typedef这也就是”类型内的嵌套信息”,而指针也相当于迭代器,但普通指针不是类,也就不存在”类型内的嵌套信息”,对于这种类型,tratis就需要提供特化版本</h5><h4 id="2-iterator-traits的运作方式-针对每一个类型IterT-在struct-iterator-traits-lt-IterT-gt-内一定声明某个typedef名为iterator-category-这个typedef用来确认IterT的迭代器分类"><a href="#2-iterator-traits的运作方式-针对每一个类型IterT-在struct-iterator-traits-lt-IterT-gt-内一定声明某个typedef名为iterator-category-这个typedef用来确认IterT的迭代器分类" class="headerlink" title="2.iterator_traits的运作方式,针对每一个类型IterT,在struct iterator_traits&lt;IterT.&gt;内一定声明某个typedef名为iterator_category,这个typedef用来确认IterT的迭代器分类"></a>2.iterator_traits的运作方式,针对每一个类型IterT,在struct iterator_traits&lt;IterT.&gt;内一定声明某个typedef名为iterator_category,这个typedef用来确认IterT的迭代器分类</h4><h5 id="同时Iterator-traits以两个部分来实现-首先它要求自定义的迭代器类型必须嵌套一个typedef-名为iterator-category"><a href="#同时Iterator-traits以两个部分来实现-首先它要求自定义的迭代器类型必须嵌套一个typedef-名为iterator-category" class="headerlink" title="同时Iterator_traits以两个部分来实现,首先它要求自定义的迭代器类型必须嵌套一个typedef ,名为iterator_ category"></a>同时Iterator_traits以两个部分来实现,首先它要求自定义的迭代器类型必须嵌套一个typedef ,名为iterator_ category</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//deque的例子</span></span><br><span class="line"><span class="keyword">template</span> &lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//list的例子</span></span><br><span class="line"><span class="keyword">template</span> &lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="而对于iterator-traits的另一部分实现如下"><a href="#而对于iterator-traits的另一部分实现如下" class="headerlink" title="而对于iterator_traits的另一部分实现如下"></a>而对于iterator_traits的另一部分实现如下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//嵌套从属名称,用typename来表示它是一个类型 参考条款42</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//而对于指针迭代器则需要一个特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-这就是如何实现traits-class"><a href="#3-这就是如何实现traits-class" class="headerlink" title="3.这就是如何实现traits class"></a>3.这就是如何实现traits class</h4><ol>
<li>确认若干你希望将来可取得的类型相关信息.例如对于迭代器,我们希望将来可取得其分类</li>
<li>为该信息选择一个名称(如iterator_category)</li>
<li>提供一个template 和 一些特化版本</li>
</ol>
<h4 id="4-接下来就是如何使用tratis-class了-对于先前的代码可以如下改写"><a href="#4-接下来就是如何使用tratis-class了-对于先前的代码可以如下改写" class="headerlink" title="4.接下来就是如何使用tratis class了,对于先前的代码可以如下改写"></a>4.接下来就是如何使用tratis class了,对于先前的代码可以如下改写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DistT&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category</span><br><span class="line">        == <span class="built_in">typeid</span>(std::random_access_iterator_tag) ))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前看起来很好,但会导致编译问题,条款48会讨论这点</span></span><br></pre></td></tr></table></figure>

<h4 id="5-还有一个问题是-IterT类型可以在编译期确定-但if要在运行期才被核定-为解决这个问题-引出来另一做法-通过重载来决定-因为重载会优先选择最匹配的重载件"><a href="#5-还有一个问题是-IterT类型可以在编译期确定-但if要在运行期才被核定-为解决这个问题-引出来另一做法-通过重载来决定-因为重载会优先选择最匹配的重载件" class="headerlink" title="5.还有一个问题是,IterT类型可以在编译期确定,但if要在运行期才被核定,为解决这个问题,引出来另一做法,通过重载来决定,因为重载会优先选择最匹配的重载件"></a>5.还有一个问题是,IterT类型可以在编译期确定,但if要在运行期才被核定,为解决这个问题,引出来另一做法,通过重载来决定,因为重载会优先选择最匹配的重载件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter,DistT d,std::random_access_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter += d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">doAdvance</span>(IterT&amp; iter,DistT d,std::bidirectionla_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d&gt;=<span class="number">0</span>) &#123;<span class="keyword">while</span> (d--)++iter;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">while</span> (d++) --iter;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter,DistT d,std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    doAdvance&#123;iter,d,<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="上述即是怎么使用traits-class"><a href="#上述即是怎么使用traits-class" class="headerlink" title="上述即是怎么使用traits class"></a>上述即是怎么使用traits class</h5><ol>
<li>建立一组重载函数,根据不同的traits信息,给出不同实现</li>
<li>建立一个控制函数,调用上述重载函数,并传递tratis class 所提供的信息</li>
</ol>
<h2 id="注意事项-38"><a href="#注意事项-38" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-Tratis-classes使得”类型相关信息”在编译期可用-它们以templates和-“templates-特化”-完成实现"><a href="#1-Tratis-classes使得”类型相关信息”在编译期可用-它们以templates和-“templates-特化”-完成实现" class="headerlink" title="1.Tratis classes使得”类型相关信息”在编译期可用.它们以templates和 “templates 特化” 完成实现"></a>1.Tratis classes使得”类型相关信息”在编译期可用.它们以templates和 “templates 特化” 完成实现</h4><h4 id="2-整合重载技术后-tratis-classes可能在编译期对类型执行if…else测试-如同书中上述例子"><a href="#2-整合重载技术后-tratis-classes可能在编译期对类型执行if…else测试-如同书中上述例子" class="headerlink" title="2.整合重载技术后,tratis classes可能在编译期对类型执行if…else测试,如同书中上述例子"></a>2.整合重载技术后,tratis classes可能在编译期对类型执行if…else测试,如同书中上述例子</h4><h1 id="条款-48-认识template元编程"><a href="#条款-48-认识template元编程" class="headerlink" title="条款 48 : 认识template元编程"></a>条款 48 : 认识template元编程</h1><h4 id="1-以C-写成-执行与C-编译期内的程序-一旦TMP程序结束执行-其输出-也就是从template具现出来的若干C-源码-便会一如既往地被编译"><a href="#1-以C-写成-执行与C-编译期内的程序-一旦TMP程序结束执行-其输出-也就是从template具现出来的若干C-源码-便会一如既往地被编译" class="headerlink" title="1.以C++写成,执行与C++编译期内的程序.一旦TMP程序结束执行,其输出,也就是从template具现出来的若干C++源码,便会一如既往地被编译"></a>1.以C++写成,执行与C++编译期内的程序.一旦TMP程序结束执行,其输出,也就是从template具现出来的若干C++源码,便会一如既往地被编译</h4><h4 id="2-TMP的两个优势-a-让某些事情更容易-如果不用TMP甚至不可能-b-TMP执行于编译期-编译期执行带来的好处-较小的文件-较短的运行期-较少的内存需求-但是编译时间变长"><a href="#2-TMP的两个优势-a-让某些事情更容易-如果不用TMP甚至不可能-b-TMP执行于编译期-编译期执行带来的好处-较小的文件-较短的运行期-较少的内存需求-但是编译时间变长" class="headerlink" title="2.TMP的两个优势 a.让某些事情更容易,如果不用TMP甚至不可能 b.TMP执行于编译期,编译期执行带来的好处,较小的文件,较短的运行期,较少的内存需求,但是编译时间变长."></a>2.TMP的两个优势 a.让某些事情更容易,如果不用TMP甚至不可能 b.TMP执行于编译期,编译期执行带来的好处,较小的文件,较短的运行期,较少的内存需求,但是编译时间变长.</h4><h4 id="3-条款47曾说过下属例子-会编译错误"><a href="#3-条款47曾说过下属例子-会编译错误" class="headerlink" title="3.条款47曾说过下属例子,会编译错误"></a>3.条款47曾说过下属例子,会编译错误</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category)</span><br><span class="line">       == <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">    &#123;</span><br><span class="line">        iter += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( d&gt;=<span class="number">0</span> ) &#123;<span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里就体现出了TMP与之相比的优势</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">advance</span>(iter,<span class="number">10</span>);         </span><br><span class="line"><span class="comment">//无法通过编译,有上述调用可用产生以下实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(std::iter&lt;<span class="type">int</span>&gt;::iterator&amp; iter,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(std::iterator_traits&lt;std::list&lt;<span class="type">int</span>&gt;::iterator&gt;::iterator_category)</span><br><span class="line">       == <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">    &#123;</span><br><span class="line">        iter += d;            <span class="comment">//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处尝试在一个 bidirectional迭代器上使用 += 导致错误</span></span><br></pre></td></tr></table></figure>

<p>TMP是一个**”函数式语言”**</p>
<h4 id="4-一个TMP程序的例子-魔法"><a href="#4-一个TMP程序的例子-魔法" class="headerlink" title="4.一个TMP程序的例子(魔法)"></a>4.一个TMP程序的例子(魔法)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;value = n*Factorial&lt;n<span class="number">-1</span>&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span>&#123;value = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="为何使用TMP的三个原因（p237）"><a href="#为何使用TMP的三个原因（p237）" class="headerlink" title="为何使用TMP的三个原因（p237）"></a>为何使用TMP的三个原因（p237）</h4><ol>
<li>确保量度单位正确</li>
<li>优化矩阵运算</li>
<li>可用生成客户定制的设计模式</li>
</ol>
<h2 id="注意事项-39"><a href="#注意事项-39" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-TMP-模板元编程-可讲工作由运行期移至编译期-由此可用实现早期错误侦测，以及更高的效率"><a href="#1-TMP-模板元编程-可讲工作由运行期移至编译期-由此可用实现早期错误侦测，以及更高的效率" class="headerlink" title="1.TMP (模板元编程)可讲工作由运行期移至编译期,由此可用实现早期错误侦测，以及更高的效率"></a>1.TMP (模板元编程)可讲工作由运行期移至编译期,由此可用实现早期错误侦测，以及更高的效率</h4><h4 id="2-TMP可被用来生成”基于政策选择组合”的客户定制代码-也可以避免生成对某些特殊类型并不适合的代码"><a href="#2-TMP可被用来生成”基于政策选择组合”的客户定制代码-也可以避免生成对某些特殊类型并不适合的代码" class="headerlink" title="2.TMP可被用来生成”基于政策选择组合”的客户定制代码,也可以避免生成对某些特殊类型并不适合的代码"></a>2.TMP可被用来生成”基于政策选择组合”的客户定制代码,也可以避免生成对某些特殊类型并不适合的代码</h4><h1 id="条款-49-了解new-handler的行为"><a href="#条款-49-了解new-handler的行为" class="headerlink" title="条款 49 : 了解new-handler的行为"></a>条款 49 : 了解new-handler的行为</h1><p>new-handler相当于一个<strong>处理错误的函数</strong>,当new<strong>遇到分配内存失败的情况时就会调用这个函数</strong>,new_handler也能通过<strong>set_new_handler来设置我们自己的</strong></p>
<h4 id="1-这是一个声明于-lt-new-gt-的标准程序库函数"><a href="#1-这是一个声明于-lt-new-gt-的标准程序库函数" class="headerlink" title="1.这是一个声明于&lt;new.&gt;的标准程序库函数"></a>1.这是一个声明于&lt;new.&gt;的标准程序库函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数的参数是个指针,目的是接受传进去的用来设置遇到错误时调用的函数,返回值也是一个指针,返回设置前的错误处</span></span><br><span class="line"><span class="comment">//理函数也就是默认的那个 , 后面会给出使用例子,就能理解为什么返回也是一个函数指针了</span></span><br></pre></td></tr></table></figure>

<h4 id="2-下面是一些简单的使用例子"><a href="#2-下面是一些简单的使用例子" class="headerlink" title="2.下面是一些简单的使用例子"></a>2.下面是一些简单的使用例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to satisfy request for memory\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">    <span class="type">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000L</span>];   <span class="comment">//开辟一块不能满足的内存</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当operator new 无法满足内存申请时,就会不断调用 new_handler 函数,即错误处理函数</span></span><br></pre></td></tr></table></figure>

<h4 id="对此一个设计优秀的new-handler函数-必须做以下事情"><a href="#对此一个设计优秀的new-handler函数-必须做以下事情" class="headerlink" title="对此一个设计优秀的new_handler函数,必须做以下事情"></a>对此一个设计优秀的new_handler函数,必须做以下事情</h4><ol>
<li><strong>让更多内存可被使用</strong>,我的理解就是清理内存,或者提前准备一部分内存以防发生分配不足的情况</li>
<li><strong>安装另一个new_handler</strong>,当前new_handler不能处理,那么交给另一个能处理的new_handler</li>
<li><strong>卸除new_handler</strong>,将null指针传给set_newhandler,一旦没有安装任何new_handler,在不足时会抛出异常</li>
<li><strong>抛出bad_alloc异常</strong>,这样的异常不会被operator new 捕捉,因此会传播到内存索求处</li>
<li><strong>不返回,通常调用abort或eixt</strong></li>
</ol>
<h4 id="3-C-并不支持class专属的new-handler-但你可以自己实现-只需要自己提供set-new-handler和operator-new即可"><a href="#3-C-并不支持class专属的new-handler-但你可以自己实现-只需要自己提供set-new-handler和operator-new即可" class="headerlink" title="3.C++并不支持class专属的new_handler,但你可以自己实现,只需要自己提供set_new_handler和operator new即可"></a>3.C++并不支持class专属的new_handler,但你可以自己实现,只需要自己提供set_new_handler和operator new即可</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1中提到的例子</span></span><br><span class="line"><span class="comment">//首先是一个自定义的class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意不是std::set_new_handler此处的只是用来设定Widget中的new_handler而不是全局中的</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span><span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//operator new 中调用的才是std::那个 用来改变全局中的new_hander</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Widget中函数的实现   下例函数也是标准版中的作为</span></span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> olHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处用一个资源管理类保存装载Widget类的new_handler之前的全局new_handler也就是 null</span></span><br><span class="line">    <span class="comment">//在结束时恢复全局new_handler 通过资源管理类中的析构函数实现</span></span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其次需要一个资源处理类用来管理new_handler的释放于归还</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">//获得没装载前的全局new_handler</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandLerHolder</span><span class="params">(std::new_handler nh)</span></span></span><br><span class="line"><span class="function">        :handler(nh)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() <span class="comment">//析构时恢复全局new_handler</span></span><br><span class="line">    &#123; std::<span class="built_in">set_new_handler</span>(handler);&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;);          <span class="comment">//阻止copying,也可以用delete</span></span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用如下</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">outOfMem</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget::<span class="built_in">set_new_handler</span>(outOfMem); <span class="comment">//为Widge指定 new_handler</span></span><br><span class="line">    Widget* pw1 = <span class="keyword">new</span> Widget;          <span class="comment">//如果分配失败调用 outOfMem</span></span><br><span class="line">    </span><br><span class="line">    std::String* ps = <span class="keyword">new</span> std::string; <span class="comment">//如果分配失败调用全局new_handler,</span></span><br><span class="line">                                       <span class="comment">//因为恢复了原先的new_handler</span></span><br><span class="line">    Widget::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">    Widget* pw2 = <span class="keyword">new</span> Widget;          <span class="comment">//如果失败,抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-另一种做法是采用继承和模板"><a href="#4-另一种做法是采用继承和模板" class="headerlink" title="4.另一种做法是采用继承和模板"></a>4.另一种做法是采用继承和模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;          <span class="comment">//&quot;mixin&quot;风格</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span><span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...                                           <span class="comment">//其它operator new 版本 见条款52</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line">...    <span class="comment">//省略实现, 见 p245例子</span></span><br><span class="line"><span class="comment">//对此Widget只需要继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>:<span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其他调用基本如前</span></span><br></pre></td></tr></table></figure>

<h4 id="该技术被称为-“怪异的循环模板模式”-CRTP"><a href="#该技术被称为-“怪异的循环模板模式”-CRTP" class="headerlink" title="该技术被称为 “怪异的循环模板模式” CRTP"></a>该技术被称为 “怪异的循环模板模式” CRTP</h4><h6 id="使用”mixin”风格的继承肯定导致多重继承的争议-见条款40"><a href="#使用”mixin”风格的继承肯定导致多重继承的争议-见条款40" class="headerlink" title="使用”mixin”风格的继承肯定导致多重继承的争议,见条款40"></a>使用”mixin”风格的继承肯定导致多重继承的争议,见条款40</h6><h4 id="5-nothrow-new-和-普通的new-nothrow-new在分配失败时返回null"><a href="#5-nothrow-new-和-普通的new-nothrow-new在分配失败时返回null" class="headerlink" title="5.nothrow new 和 普通的new , nothrow-new在分配失败时返回null"></a>5.nothrow new 和 普通的new , nothrow-new在分配失败时返回null</h4><h6 id="nothrow-的一些理解见p247最上面一段"><a href="#nothrow-的一些理解见p247最上面一段" class="headerlink" title="nothrow 的一些理解见p247最上面一段"></a>nothrow 的一些理解见p247最上面一段</h6><h2 id="注意事项-40"><a href="#注意事项-40" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-set-new-handler允许客户指定一个函数-在内存分配失败时被调用"><a href="#1-set-new-handler允许客户指定一个函数-在内存分配失败时被调用" class="headerlink" title="1.set_new_handler允许客户指定一个函数,在内存分配失败时被调用"></a>1.set_new_handler允许客户指定一个函数,在内存分配失败时被调用</h4><h4 id="2-Nothrow-new-是一个颇为局限的工具"><a href="#2-Nothrow-new-是一个颇为局限的工具" class="headerlink" title="2.Nothrow new 是一个颇为局限的工具."></a>2.Nothrow new 是一个颇为局限的工具.</h4><h1 id="条款-50-了解-new-和-delete的合理替换时机"><a href="#条款-50-了解-new-和-delete的合理替换时机" class="headerlink" title="条款 50 : 了解 new 和 delete的合理替换时机"></a>条款 50 : 了解 new 和 delete的合理替换时机</h1><h4 id="就是为啥不用编译期提供的而要自己定义"><a href="#就是为啥不用编译期提供的而要自己定义" class="headerlink" title="就是为啥不用编译期提供的而要自己定义"></a>就是为啥不用编译期提供的而要自己定义</h4><ol>
<li><strong>用来检测运用上的错误</strong>,能够实现将使用出错时记录下来</li>
<li><strong>为了强化效能</strong>,编译期提供的主要用于一般目的,而在例如(网页服务器,web servers)则可能需要进行替换</li>
<li><strong>为了收集使用上的统计数据</strong>,收集分配删除时的一些信息</li>
</ol>
<h4 id="e-g-是一个例子-促进并协助检测”overruns”-写入点在分配区块尾端之后-或”underruns”-写入点在分配区块起点之前-的定制-operator-new"><a href="#e-g-是一个例子-促进并协助检测”overruns”-写入点在分配区块尾端之后-或”underruns”-写入点在分配区块起点之前-的定制-operator-new" class="headerlink" title="e.g 是一个例子,促进并协助检测”overruns”(写入点在分配区块尾端之后)或”underruns”(写入点在分配区块起点之前)的定制 operator new"></a>e.g 是一个例子,促进并协助检测”overruns”(写入点在分配区块尾端之后)或”underruns”(写入点在分配区块起点之前)的定制 operator new</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> signature = <span class="number">0XDEADBEEF</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Byte;</span><br><span class="line"><span class="comment">//代码还存在一些问题,详下</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">size_t</span> realSize = size + <span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>) <span class="comment">//增加大小,使得能够塞入两个signature</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>* pMem = <span class="built_in">malloc</span>(realSize);         <span class="comment">//使用malloc分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    <span class="comment">//将signature写入最前和最后段    由于不清楚这个定制operator new是干啥的,此处不需要过度考虑</span></span><br><span class="line">                                <span class="comment">//此operator new 只是用来了解怎样定制一个 opeator new</span></span><br><span class="line">    *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">    *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="built_in">sizeof</span>(<span class="type">int</span>))) = signature;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回指针,指向第一个signature之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem)+<span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的一些问题</p>
<ol>
<li>“没有坚持c++的规矩”, 条款51说所有operator new 都应该内含一个循环,反复调用某个new_handing函数，z这里却没有,另一个问题 就是 齐位</li>
<li>“齐位”,C++要求所有的operator new 返回的指针都有适当的齐位,否则不安全,具体的详细介绍见p249</li>
</ol>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h4><ol>
<li>为了检测运用错误(如前所述)</li>
<li>为了收集动态分配内存的使用统计信息(如前所述)</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低默认版本带来的空间额外开销</li>
<li>为了弥补默认分配器中的非最佳齐位</li>
<li><strong>为了将相关对象成簇集中</strong></li>
<li>为了获得非传统行为</li>
</ol>
<h2 id="注意事项-41"><a href="#注意事项-41" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-你有许多理由需要写个自定的new和delte-本条款就是介绍了一些使用的理由"><a href="#1-你有许多理由需要写个自定的new和delte-本条款就是介绍了一些使用的理由" class="headerlink" title="1.你有许多理由需要写个自定的new和delte,本条款就是介绍了一些使用的理由"></a>1.你有许多理由需要写个自定的new和delte,本条款就是介绍了一些使用的理由</h4><h1 id="条款-51-编写new和delete时需固守常规"><a href="#条款-51-编写new和delete时需固守常规" class="headerlink" title="条款 51 : 编写new和delete时需固守常规"></a>条款 51 : 编写new和delete时需固守常规</h1><p>条款50说过了你何时需要写一个自己的new和delete,本条款主要用来说明写自己的new和delete时需要遵守的一些规范</p>
<ol>
<li>一个循环,不断尝试分配内存并在失败时调用new_handler</li>
<li>有能力处理0bytes申请</li>
<li>class的专属版本还应处理 继承时 “比正确大小更大的错误申请”</li>
<li>delete在收到null时应该不做任何事</li>
<li>class的版本还应处理”比正确大小更大的错误申请”</li>
</ol>
<h4 id="1-下面是一些伪码"><a href="#1-下面是一些伪码" class="headerlink" title="1.下面是一些伪码"></a>1.下面是一些伪码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;                         <span class="comment">//你的可能还有一些别的参数,这里只是给出一些需要遵守的共同部分</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">        size = <span class="number">1</span>;         <span class="comment">//将0-byte申请 视为 1-byte申请</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        尝试分配;</span><br><span class="line">        <span class="keyword">if</span> (分配成功)</span><br><span class="line">            <span class="keyword">return</span> (指针,指向分配的内存)</span><br><span class="line">        <span class="comment">//分配失败</span></span><br><span class="line">        new_handler globalHandler = <span class="built_in">set_new_hander</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (globalHandler)</span><br><span class="line">            (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用set-new-handler找出new-handler指针-因为没有别的好方法-这样虽然拙劣-但有效"><a href="#用set-new-handler找出new-handler指针-因为没有别的好方法-这样虽然拙劣-但有效" class="headerlink" title="用set_new_handler找出new_handler指针,因为没有别的好方法,这样虽然拙劣,但有效"></a>用set_new_handler找出new_handler指针,因为没有别的好方法,这样虽然拙劣,但有效</h4><h4 id="2-在出现继承时的情况"><a href="#2-在出现继承时的情况" class="headerlink" title="2.在出现继承时的情况"></a>2.在出现继承时的情况</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base &#123; ... &#125;;   <span class="comment">//假设Derived未声明自己的operator new</span></span><br><span class="line">Derived* p = <span class="keyword">new</span> Derived;            <span class="comment">//这里将调用 Base::operator new</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于 Base 的operator new 只是针对Base 的,对于Derived的意外继承应采取措施</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base))        <span class="comment">//如果大小错误,则采取标准的.此处理同时将0的情况也处理了,所</span></span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size); <span class="comment">//以不需要额外对0的情况进行处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于-new-详细见-p254下面段落"><a href="#对于-new-详细见-p254下面段落" class="headerlink" title="对于 new [] 详细见 p254下面段落"></a>对于 new [] 详细见 p254下面段落</h4><h4 id="3-对于delete情况"><a href="#3-对于delete情况" class="headerlink" title="3.对于delete情况"></a>3.对于delete情况</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    归还内存;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-对于class情况"><a href="#4-对于class情况" class="headerlink" title="4.对于class情况"></a>4.对于class情况</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory,std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory,std::<span class="type">size_t</span> size)</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Base))&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMrmory)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    归还内存;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//欠缺virtual析构可能出现的一些问题,见条款7</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项-42"><a href="#注意事项-42" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-operator-new-应该内含一个无穷循环-不断尝试分配内存-若失败则调用new-handler-有能力处理0-byte申请-class版本还应该处理”并正确大小更大的申请”"><a href="#1-operator-new-应该内含一个无穷循环-不断尝试分配内存-若失败则调用new-handler-有能力处理0-byte申请-class版本还应该处理”并正确大小更大的申请”" class="headerlink" title="1.operator new 应该内含一个无穷循环,不断尝试分配内存,若失败则调用new_handler,有能力处理0 byte申请,class版本还应该处理”并正确大小更大的申请”"></a>1.operator new 应该内含一个无穷循环,不断尝试分配内存,若失败则调用new_handler,有能力处理0 byte申请,class版本还应该处理”并正确大小更大的申请”</h4><h4 id="3-operator-delete-应该在收到null时不做任何事情-class版本还应该处理”并正确大小更大的申请”"><a href="#3-operator-delete-应该在收到null时不做任何事情-class版本还应该处理”并正确大小更大的申请”" class="headerlink" title="3.operator delete 应该在收到null时不做任何事情,class版本还应该处理”并正确大小更大的申请”"></a>3.operator delete 应该在收到null时不做任何事情,class版本还应该处理”并正确大小更大的申请”</h4><h1 id="条款-52-写了placement-new也要写placement-delete"><a href="#条款-52-写了placement-new也要写placement-delete" class="headerlink" title="条款 52 : 写了placement new也要写placement delete"></a>条款 52 : 写了placement new也要写placement delete</h1><h4 id="1-条款首先引入一条例子-告诉我们为什么要如此做"><a href="#1-条款首先引入一条例子-告诉我们为什么要如此做" class="headerlink" title="1.条款首先引入一条例子,告诉我们为什么要如此做"></a>1.条款首先引入一条例子,告诉我们为什么要如此做</h4><p><code>Widget* pw = new Widget;</code></p>
<p>此处公有两个函数被调用,一是用以分配内存的operator new , 另一个是 Widget的构造函数 </p>
<p>问题就出在此,假设<strong>第一个函数调用成功</strong>,而<strong>构造的时候抛出异常</strong>,这个时候就<strong>需要取消分配的内存</strong>,否则会造成内存泄漏,但Widget抛出异常导致**,pw并未被赋值**,也就是客户没有能力归还内存,所以<strong>取消内存的责任落在C++运行期系统</strong>身上,<strong>运行期系统会调用与operator new 相应的 operator delete版本</strong>,如果是正常形式的new 和 delete的话,运行期系统毫无问题可以知道该用那个delete</p>
<h4 id="2-首先简单介绍一下术语placement-new"><a href="#2-首先简单介绍一下术语placement-new" class="headerlink" title="2.首先简单介绍一下术语placement new"></a>2.首先简单介绍一下术语placement new</h4><p>placement new 实际上<strong>不只是</strong>一个特殊的new,之前我以为<strong>只是一个能在指定区域分配的内存的new</strong>,实际上placement new <strong>是一系列特殊new的统称,意味着带任意额外参数的new</strong>,而那个能在指定区域分配内存的new,是最早的placement new 版本,这也是这个函数命名的根据,由此placement new 有多重定义,大多数时候是这个**”接受一个指针指向对象被构造之处”**,也就是下面这个C++标准库中的placement new</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>,<span class="type">void</span>* pMemory)</span><span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-一个非正常-operator-new-的例子"><a href="#3-一个非正常-operator-new-的例子" class="headerlink" title="3.一个非正常 operator new 的例子"></a>3.一个非正常 operator new 的例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...<span class="comment">//如果operator new接受的参数除了size_t华友其他的,这便是所谓的placement new</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size,std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">        <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;                 <span class="comment">//非正常形式的new</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,std::<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">        <span class="title">throw</span><span class="params">()</span></span>;                               <span class="comment">//正常的class专属delete</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这个设计有问题</span></span><br><span class="line">Widget* pw = <span class="built_in">new</span>(std::cerr)Widget;</span><br><span class="line"><span class="comment">//如果如1一样构造时抛出异常,则运行期系统则会寻找对应的delete&quot;参数个数和类型都与operator new相同的&quot;</span></span><br><span class="line"><span class="comment">//也就是如下的delete</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*,std::ostream&amp;)</span><span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">//placement delete</span></span><br></pre></td></tr></table></figure>

<h4 id="4-对此应该提供对应的operator-delete"><a href="#4-对此应该提供对应的operator-delete" class="headerlink" title="4.对此应该提供对应的operator delete"></a>4.对此应该提供对应的operator delete</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size,std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">        <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span><span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,std::ostream&amp; logStream)</span></span></span><br><span class="line"><span class="function">        <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget* pw = <span class="built_in">new</span>(std::cerr)Widget;               <span class="comment">//不再泄漏</span></span><br><span class="line"><span class="keyword">delete</span> pw;                                       <span class="comment">//调用正常的operator new</span></span><br></pre></td></tr></table></figure>

<p>在与placement new 相关内存泄漏宣战时,必须同时提供一个正常的operator new(用于构造无任何异常被抛出)和一个placement 版本(用于构造期间有异常抛出)</p>
<h4 id="5-注意名称遮盖问题-比较好理解就是如果class只声明了一种则会遮掩其他的-解决方法就是声明一个base-class-储存正常的-让derivde继承-并using-使其在derived中可见"><a href="#5-注意名称遮盖问题-比较好理解就是如果class只声明了一种则会遮掩其他的-解决方法就是声明一个base-class-储存正常的-让derivde继承-并using-使其在derived中可见" class="headerlink" title="5.注意名称遮盖问题,比较好理解就是如果class只声明了一种则会遮掩其他的,解决方法就是声明一个base class 储存正常的,让derivde继承,并using 使其在derived中可见"></a>5.注意名称遮盖问题,比较好理解就是如果class只声明了一种则会遮掩其他的,解决方法就是声明一个base class 储存正常的,让derivde继承,并using 使其在derived中可见</h4><h2 id="注意事项-43"><a href="#注意事项-43" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-当你写一个placement-new-请确定写出placement-operator-delete-否则回导致隐微的内存泄漏"><a href="#1-当你写一个placement-new-请确定写出placement-operator-delete-否则回导致隐微的内存泄漏" class="headerlink" title="1.当你写一个placement new 请确定写出placement operator delete,否则回导致隐微的内存泄漏"></a>1.当你写一个placement new 请确定写出placement operator delete,否则回导致隐微的内存泄漏</h4><h4 id="2-当你声明placement-new-和-placement-delete时-注意不要遮掩它们的正常版本"><a href="#2-当你声明placement-new-和-placement-delete时-注意不要遮掩它们的正常版本" class="headerlink" title="2.当你声明placement new 和 placement delete时,注意不要遮掩它们的正常版本"></a>2.当你声明placement new 和 placement delete时,注意不要遮掩它们的正常版本</h4><h1 id="条款-53-不要轻忽编译器的警告"><a href="#条款-53-不要轻忽编译器的警告" class="headerlink" title="条款 53 : 不要轻忽编译器的警告"></a>条款 53 : 不要轻忽编译器的警告</h1><p>编译期提示的警告信息,可能与你想的含义不一样,不能忽略它们,要了解编译期真正想告诉你的是什么,并从中吸取经验,尽量做到no-warming,不同的编译器警告可能不同,在这个编译器无警告的代码,在另一可能会有警告</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//warming: D::F() hides virtual B::f()</span></span><br></pre></td></tr></table></figure>

<p>上述代码你可能觉得想得和你一样,D::f 遮掩了 B::f ,实际上编译器是想告诉你,B中的f没有被override,而是被遮掩了,因为B中的签名式const 而D中没有</p>
<h2 id="注意事项：-5"><a href="#注意事项：-5" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-严肃对待编译器发出的警告-尽量在编译期的最高警告级别下争取”no-warming”"><a href="#1-严肃对待编译器发出的警告-尽量在编译期的最高警告级别下争取”no-warming”" class="headerlink" title="1.严肃对待编译器发出的警告,尽量在编译期的最高警告级别下争取”no-warming”"></a>1.严肃对待编译器发出的警告,尽量在编译期的最高警告级别下争取”no-warming”</h4><h4 id="2-不要过度依赖编译器的警告-因为不同的编译器对待事情的态度并不相同"><a href="#2-不要过度依赖编译器的警告-因为不同的编译器对待事情的态度并不相同" class="headerlink" title="2.不要过度依赖编译器的警告,因为不同的编译器对待事情的态度并不相同"></a>2.不要过度依赖编译器的警告,因为不同的编译器对待事情的态度并不相同</h4><h1 id="条款-54-让自己熟悉包括TR1在内的标准程序库"><a href="#条款-54-让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款 54 : 让自己熟悉包括TR1在内的标准程序库"></a>条款 54 : 让自己熟悉包括TR1在内的标准程序库</h1><p>各种标准程序库</p>
<h2 id="注意事项：-6"><a href="#注意事项：-6" class="headerlink" title="注意事项："></a>注意事项：</h2><h4 id="1-C-标准程序库主要由STL-iostreams-locales组成-并包括c99标准程序库"><a href="#1-C-标准程序库主要由STL-iostreams-locales组成-并包括c99标准程序库" class="headerlink" title="1.C++标准程序库主要由STL,iostreams,locales组成.并包括c99标准程序库"></a>1.C++标准程序库主要由STL,iostreams,locales组成.并包括c99标准程序库</h4><h4 id="2-TR1添加了智能指针-一般化函数指针-tr1-function-包装器-hash-based容器-正则表达式-regular-expression-以及另外10个组件"><a href="#2-TR1添加了智能指针-一般化函数指针-tr1-function-包装器-hash-based容器-正则表达式-regular-expression-以及另外10个组件" class="headerlink" title="2.TR1添加了智能指针,一般化函数指针(tr1::function 包装器),hash-based容器,正则表达式(regular expression)以及另外10个组件"></a>2.TR1添加了智能指针,一般化函数指针(tr1::function 包装器),hash-based容器,正则表达式(regular expression)以及另外10个组件</h4><h4 id="3-TR1自身只是一份规范-为获得TR1提供的好处-你需要一份实物-来自Boost"><a href="#3-TR1自身只是一份规范-为获得TR1提供的好处-你需要一份实物-来自Boost" class="headerlink" title="3.TR1自身只是一份规范.为获得TR1提供的好处,你需要一份实物,来自Boost"></a>3.TR1自身只是一份规范.为获得TR1提供的好处,你需要一份实物,来自Boost</h4><h1 id="条款-55-让自己熟悉Boost"><a href="#条款-55-让自己熟悉Boost" class="headerlink" title="条款 55 : 让自己熟悉Boost"></a>条款 55 : 让自己熟悉Boost</h1><p>Boost一个社区,由于和C++委员会重合很大,所以与其他的C++社区相比比较有分量</p>
<h2 id="注意事项-44"><a href="#注意事项-44" class="headerlink" title="注意事项:"></a>注意事项:</h2><h4 id="1-Boost是一个社群-也是一个网站-提供免费-开源的C-程序库"><a href="#1-Boost是一个社群-也是一个网站-提供免费-开源的C-程序库" class="headerlink" title="1.Boost是一个社群,也是一个网站,提供免费,开源的C++程序库"></a>1.Boost是一个社群,也是一个网站,提供免费,开源的C++程序库</h4><h4 id="2-Boost提供许多TR1组件实现品"><a href="#2-Boost提供许多TR1组件实现品" class="headerlink" title="2.Boost提供许多TR1组件实现品"></a>2.Boost提供许多TR1组件实现品</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AuroraFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/17/Effective%20note/">http://example.com/2022/04/17/Effective%20note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Aurora</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/background.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note/"><img class="prev-cover" src="/./img/suanfa.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法笔记 Note</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/16/hello-world/"><img class="next-cover" src="/./img/rise.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hello,world</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/headd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AuroraFish</div><div class="author-info__description">保持幻想</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AuroraFish"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AuroraFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:205878047@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只是睡着了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TR1-%E5%92%8C-Boost"><span class="toc-number">1.</span> <span class="toc-text">TR1 和 Boost</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-54-Tr1"><span class="toc-number">1.0.1.</span> <span class="toc-text">条款 54 Tr1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%9CTechnical-Report-1%E2%80%9D-%E6%98%AF%E4%B8%80%E4%BB%BD%E8%A7%84%E8%8C%83%EF%BC%8C%E6%8F%8F%E8%BF%B0%E5%8A%A0%E5%85%A5C-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93%E7%9A%84%E8%AF%B8%E5%A4%9A%E6%96%B0%E6%9C%BA%E8%83%BD"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">“Technical Report 1”, 是一份规范，描述加入C++标准程序库的诸多新机能.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-55-Boost"><span class="toc-number">1.0.2.</span> <span class="toc-text">条款 55 Boost</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Boost-%E6%98%AF%E4%B8%AA%E7%BB%84%E7%BB%87-x2F-%E7%BD%91%E7%AB%99-%E6%8F%90%E4%BE%9B%E5%BC%80%E6%BA%90%E7%9A%84C-%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">Boost 是个组织&#x2F;网站, 提供开源的C++程序库</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-01"><span class="toc-number">2.</span> <span class="toc-text">条款 01 :</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">1.C</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-Oriented-C-oop"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">2.Object-Oriented C++ (oop)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Template-C"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">3.Template C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-STL"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">4.STL</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-02-%E4%BD%BF%E7%94%A8const-enum-inline%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">3.</span> <span class="toc-text">条款 02 : 使用const,enum,inline替换#define</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-const"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">1.const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-enum-%E7%B1%BB%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">2.enum 类内使用相当于常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-inline-%E6%9B%BF%E6%8D%A2-define-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">3.inline 替换 #define 定义的函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">4.</span> <span class="toc-text">条款 03 : 尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8D%E5%81%9A%E6%9B%B4%E6%94%B9%E6%89%93%E7%AE%97%E7%9A%84-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8const-%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0-a-b-x3D-x3D-c%E5%86%99%E6%88%90%E8%B5%8B%E5%80%BC%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">1.对于不做更改打算的,尽量使用const,防止出现 a*b &#x3D;&#x3D; c写成赋值的错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mutabel-%E9%87%8A%E6%94%BE%E6%8E%89const%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">2.mutabel 释放掉const的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-const-%E4%B8%8E-non-const-%E4%B8%80%E4%B8%AAop-%E7%9A%84%E4%BE%8B%E5%AD%90-%E8%AF%B4%E6%98%8E%E5%8F%AF%E4%BB%A5%E7%B1%8D%E7%94%B1non-const-%E8%B0%83%E7%94%A8const-%E4%BD%86%E7%BB%9D%E5%AF%B9%E4%B8%8D%E8%83%BD%E5%8F%8D%E5%90%91%E6%93%8D%E4%BD%9C-%E7%B1%8D%E7%94%B1const-%E8%B0%83%E7%94%A8non-const"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">3.const 与 non-const 一个op[] 的例子,说明可以籍由non-const 调用const,但绝对不能反向操作,籍由const 调用non-const,</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%BAconst%E6%9C%89%E5%8A%A9%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E4%BE%A6%E5%AF%9F%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">1.声明为const有助于编译器侦察错误用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%BA%E5%88%B6%E5%AE%9E%E6%96%BDbitwise-constness-const%E4%B8%80%E5%88%87%E9%83%BD%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%94%B9-%E7%94%A8%E6%88%B7%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E2%80%9D%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%9A%84%E5%B8%B8%E9%87%8F%E6%80%A7%E2%80%9D-%E7%94%A8mutable%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">2.编译器强制实施bitwise constness(const一切都不能更改),用户应该使用”概念上的常量性”,用mutable实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8const-%E6%9D%A5%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E9%80%9A%E8%BF%87non-const-%E8%B0%83%E7%94%A8-const"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">3.用const 来避免代码复用,通过non-const 调用 const</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">条款 04 : 确定对象被使用前已初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8EC-part-of-C-%E5%92%8C-non-C-parts-of-C-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E6%9C%89%E7%82%B9%E4%B8%8D%E5%90%8C-%E6%9C%80%E5%A5%BD%E7%9A%84%E5%8A%9E%E6%B3%95%E6%98%AF%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">1.对于C part of C++ 和 non-C parts of C++ 初始化规则有点不同,最好的办法是对于所有的对象都初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%8A%80%E6%9C%AF-%E5%AF%B9%E4%BA%8E%E9%83%A8%E5%88%86%E6%9E%84%E9%80%A0%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E6%80%A7%E7%9A%84%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%B5%8B%E5%80%BC%E6%9D%A5%E6%9B%BF%E6%8D%A2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">2.对于构造函数可以使用初始化列表技术,对于部分构造可以选择性的在构造函数体中使用赋值来替换初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E2%80%9C%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AC%A1%E5%BA%8F%E2%80%9D-base-classes%E6%9B%B4%E6%97%A9%E4%BA%8E%E5%85%B6%E4%BB%96derived-classes-%E8%80%8Cclass%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%80%BB%E4%BB%A5%E5%85%B6%E5%A3%B0%E6%98%8E%E6%AC%A1%E5%BA%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.0.0.3.</span> <span class="toc-text">3.“成员初始化次序” ,base classes更早于其他derived classes,而class的成员变量总以其声明次序被初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E2%80%9C%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E5%86%85%E5%AE%9A%E4%B9%89non-local-static%E5%AF%B9%E8%B1%A1%E2%80%9D"><span class="toc-number">5.0.0.4.</span> <span class="toc-text">4.“不同编译单元内定义non-local static对象”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%83%B3%E8%B0%83%E7%94%A8Directory%E7%9A%84%E6%9E%84%E9%80%A0-%E5%88%99-tfs-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%BF%85%E9%A1%BB%E5%9C%A8%E4%B9%8B%E5%89%8D-%E4%BD%86C-%E5%AF%B9%E2%80%9C%E5%AE%9A%E4%B9%89%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E5%86%85%E7%9A%84non-local-static%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%AF%B9%E6%AC%A1%E5%BA%8F%E6%97%A0%E6%98%8E%E7%A1%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">5.0.0.5.</span> <span class="toc-text">如果想调用Directory的构造 则 tfs 的初始必须在之前,但C++对“定义于不同的编译单元内的non-local static对象”的初始化相对次序无明确定义.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E8%AE%BE%E8%AE%A1-%E5%B0%86%E6%AF%8F%E4%B8%AAnon-local-static%E5%AF%B9%E8%B1%A1%E6%90%AC%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%87%BD%E6%95%B0%E5%86%85-%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference%E6%8C%87%E5%90%91%E5%AE%83%E6%89%80%E5%90%AB%E7%9A%84%E5%AF%B9%E8%B1%A1-%E7%94%A8%E6%88%B7%E8%B0%83%E7%94%A8%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0-%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%B6%89%E7%8C%8E%E8%BF%99%E4%BA%9B%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.0.0.6.</span> <span class="toc-text">一个小小的设计:将每个non-local static对象搬到自己的专属函数内,这些函数返回一个reference指向它所含的对象,用户调用这些函数,而不直接涉猎这些对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">5.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%89%8B%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96-C-%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%96%E4%BB%AC"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">1.为内置对象手动初始化,C++不保证初始化他们</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">2.对构造函数使用初始化列表技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E4%BA%8E%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E7%9A%84non-local-static-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">3.对于跨编译单元的non-local static 对象的处理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-05-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E8%AE%A4%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">条款 05 : 了解C++默认编写并调用哪些函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-default%E6%9E%84%E9%80%A0-copy%E6%9E%84%E9%80%A0-copy-assignment%E8%B5%8B%E5%80%BC-%E6%9E%90%E6%9E%84"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">1.default构造,copy构造,copy assignment赋值,析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84copy%E4%B8%BA%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">2.编译器提供的copy为浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BA%A7%E5%87%BA%E7%9A%84%E6%9E%90%E6%9E%84%E4%B8%BAnon-vitrual%E6%9E%90%E6%9E%84"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">3.编译器产出的析构为non-vitrual析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E5%B7%B2%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E5%86%8D%E6%8F%90%E4%BE%9Bdefault%E6%9E%84%E9%80%A0"><span class="toc-number">6.0.0.4.</span> <span class="toc-text">4.如果已声明构造,编译器不会再提供default构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9%E4%BA%8E%E5%86%85%E5%90%ABreference%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB-%E5%BA%94%E6%8F%90%E4%BE%9B%E8%87%AA%E5%AE%9A%E4%B9%89copy-assignment"><span class="toc-number">6.0.0.5.</span> <span class="toc-text">5.对于内含reference成员的类,应提供自定义copy assignment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E5%B0%86base-class-%E7%9A%84-copy-assignment-%E5%A3%B0%E6%98%8E%E4%B8%BA-private%EF%BC%8C%E5%88%99-derived-class-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E6%8F%90%E4%BE%9Bcopy-assignment"><span class="toc-number">6.0.0.6.</span> <span class="toc-text">6.如果将base class 的 copy assignment 声明为 private，则 derived class 编译器不会提供copy assignment</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-06-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0-%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">7.</span> <span class="toc-text">条款 06 : 若不想使用编译器自动生成的函数,应该明确拒绝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E6%8B%92%E7%BB%9D%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84copy%E6%9E%84%E9%80%A0%E5%92%8Ccopy-assignment"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">1.如何拒绝使用编译器提供的copy构造和copy assignment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%86%E5%85%B6%E5%A3%B0%E6%98%8E%E4%B8%BAprivate-%E4%BD%86%E4%B8%8D%E5%AE%9A%E4%B9%89-%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8Ccopy%E8%A1%8C%E4%B8%BA%E6%97%B6%E4%BC%9A%E7%BB%99%E5%87%BA%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E6%88%96%E8%BF%9E%E6%8E%A5%E6%80%A7%E9%94%99%E8%AF%AF-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E6%BA%90%E8%87%AAprivate%E7%B1%BB%E5%A4%96%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE-%E9%93%BE%E6%8E%A5%E6%80%A7%E9%94%99%E8%AF%AF%E6%BA%90%E8%87%AAmember-%E6%88%96-friend-%E5%87%BD%E6%95%B0%E9%93%BE%E6%8E%A5%E4%B8%8D%E5%88%B0%E5%85%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">2.将其声明为private(但不定义),对其进行copy行为时会给出编译错误或连接性错误,编译错误源自private类外不能访问,链接性错误源自member 或 friend 函数链接不到其定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E9%A9%B3%E5%9B%9E%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%BA%E8%83%BD-%E5%8F%AF%E5%B0%86%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BAprivate-%E5%B9%B6%E4%B8%94%E4%B8%8D%E4%BA%88%E5%AE%9A%E4%B9%89-%E6%88%96%E4%BD%BF%E7%94%A8%E5%83%8F-Uncopyable-%E8%BF%99%E6%A0%B7%E7%9A%84-base-class"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">1.为驳回编译器自动提供的机能,可将其对应的成员函数声明为private 并且不予定义,或使用像 Uncopyable 这样的 base class</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-07-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">条款 07 : 为多态基类声明virtual析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E6%9E%9Cbase-class-%E6%9E%90%E6%9E%84%E4%B8%8D%E6%98%AFvitrual-%E5%BD%93derived-class-%E5%AF%B9%E8%B1%A1%E7%BB%8F%E7%94%B1%E4%B8%80%E4%B8%AAbase-class-%E6%8C%87%E9%92%88%E5%88%A0%E9%99%A4%EF%BC%8C%E9%80%9A%E5%B8%B8%E5%8F%91%E7%94%9Fderived-%E6%88%90%E5%88%86%E6%B2%A1%E9%94%80%E6%AF%81-%E5%AF%BC%E8%87%B4%E2%80%9D%E5%B1%80%E9%83%A8%E9%94%80%E6%AF%81%E2%80%9D-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E5%BA%94%E7%BB%99base-class-%E4%B8%80%E4%B8%AAvirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%BF%99%E6%A0%B7%E5%B0%B1%E8%83%BD%E6%AD%A3%E5%B8%B8%E9%94%80%E6%AF%81%E6%95%B4%E4%B8%AA%E5%AF%B9%E8%B1%A1-%E5%8C%85%E6%8B%ACderived-class-%E6%88%90%E5%88%86"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">1.如果base class 析构不是vitrual,当derived class 对象经由一个base class 指针删除，通常发生derived 成分没销毁,导致”局部销毁”,内存泄露,应给base class 一个virtual析构函数,这样就能正常销毁整个对象,包括derived class 成分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%84%8F%E5%9B%BE%E7%94%A8%E4%BA%8Ebase-class-%E5%88%99%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BB%A4%E5%85%B6%E6%9E%90%E6%9E%84%E4%B8%BAvirtual%EF%BC%8Cvirtual%E5%A3%B0%E6%98%8E%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B1%BB%E5%88%9B%E5%BB%BAvptr-%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88-%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E6%94%AF-%E5%8F%AA%E6%9C%89%E5%BD%93class%E5%86%85%E8%87%B3%E5%B0%91%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AAvirtual%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%8D%E4%B8%BA%E5%AE%83%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.0.0.2.</span> <span class="toc-text">2.如果没有意图用于base class 则不应该令其析构为virtual，virtual声明会导致类创建vptr(虚表指针),会导致不必要的内存开支,只有当class内至少含有一个virtual函数，才为它声明virtual析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-pure-virtual-%E7%BA%AF%E8%99%9A-gt-abstract-%E6%8A%BD%E8%B1%A1-classes-%E2%80%94-%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84class"><span class="toc-number">8.0.0.3.</span> <span class="toc-text">3.pure virtual (纯虚)-&gt;abstract(抽象) classes — 不能被实例化的class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%A6%81class%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AApure-virtual-%E5%87%BD%E6%95%B0-%E5%88%99%E8%BF%99%E4%B8%AA%E7%B1%BB%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E4%BD%A0%E5%BF%85%E9%A1%BB%E4%B8%BA%E8%BF%99%E4%B8%AApure-virtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%8F%90%E4%BE%9B%E4%B8%80%E4%BB%BD%E5%AE%9A%E4%B9%89"><span class="toc-number">8.0.0.4.</span> <span class="toc-text">只要class含有一个pure virtual 函数,则这个类为抽象类,注意事项:你必须为这个pure virtual 析构函数提供一份定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E4%BD%9C%E8%A7%84%E5%88%99-%E7%94%B1%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84-derived-class-%E5%BC%80%E5%A7%8B%E6%9E%90%E6%9E%84-%E7%84%B6%E5%90%8E%E6%98%AF%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA-base-class%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E5%9C%A8AMOV%E7%9A%84-derived-classes-%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9-AMOV%E7%9A%84%E8%B0%83%E7%94%A8%E5%8A%A8%E4%BD%9C-%E6%89%80%E4%BB%A5%E4%BD%A0%E5%BF%85%E9%A1%BB%E4%B8%BA%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8F%90%E4%BE%9B%E4%B8%80%E4%BB%BD%E5%AE%9A%E4%B9%89-%E7%AC%AC3%E7%82%B9-%E5%90%A6%E5%88%99%E8%BF%9E%E6%8E%A5%E5%99%A8%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-number">8.0.0.5.</span> <span class="toc-text">4.析构函数的运作规则,由最外层的 derived class 开始析构,然后是其每一个 base class的析构函数被调用.编译器会在AMOV的 derived classes 的析构函数中创建一个对~AMOV的调用动作,所以你必须为这个函数提供一份定义(第3点),否则连接器会报错</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">8.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E5%85%B7%E6%9C%89%E5%A4%9A%E6%80%81%E6%80%A7%E8%B4%A8%E7%9A%84base-classes-%E5%BA%94%E8%AF%A5%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAvirtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E6%88%96%E8%80%85class%E5%B8%A6%E6%9C%89%E4%BB%BB%E4%BD%95virtual%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%83%E4%B9%9F%E5%BA%94%E8%AF%A5%E6%8B%A5%E6%9C%89virtual-%E6%9E%90%E6%9E%84"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">1.对于具有多态性质的base classes 应该声明一个virtual 析构函数,或者class带有任何virtual函数，它也应该拥有virtual 析构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9Cclass%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%8D%E6%98%AF%E4%BD%9C%E4%B8%BAbase-class-%E5%88%99%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">2.如果class的目的不是作为base class 则不应该声明virtual析构函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-08-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">条款 08 : 别让异常逃离析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E6%9E%9C%E6%9E%90%E6%9E%84%E5%90%90%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%88%99%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%A8%8B%E5%BA%8F%E6%8F%90%E5%89%8D%E7%BB%93%E6%9D%9F%E6%88%96%E5%87%BA%E7%8E%B0%E4%B8%8D%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">1.如果析构吐出异常，则会导致程序提前结束或出现不明确的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E5%88%99%E4%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%AF%BC%E8%87%B4%E9%97%AE%E9%A2%98-%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">9.0.0.2.</span> <span class="toc-text">2.如果调用失败则会抛出异常，导致问题,两种解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8A%E8%BF%B0%E6%96%B9%E6%B3%95%E7%94%A8%E5%A4%84%E4%B8%8D%E5%A4%A7%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%BA%E4%B8%BA%E5%AE%A2%E6%88%B7%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E7%9A%84%E6%9C%BA%E4%BC%9A"><span class="toc-number">9.0.0.3.</span> <span class="toc-text">3.上述方法用处不大，一个更好的解决方法为为客户提供一个处理发生异常的机会</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%AA%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E5%9C%A8%E5%A4%B1%E8%B4%A5%E6%97%B6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E8%80%8C%E5%8F%88%E5%AD%98%E5%9C%A8%E6%9F%90%E7%A7%8D%E9%9C%80%E8%A6%81%E5%BF%85%E9%A1%BB%E5%A4%84%E7%90%86%E8%AF%A5%E5%BC%82%E5%B8%B8%EF%BC%8C%E9%82%A3%E8%BF%99%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%BF%85%E9%A1%BB%E6%9D%A5%E8%87%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%BE%88%E5%8D%B1%E9%99%A9%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%8F%90%E5%89%8D%E7%BB%93%E6%9D%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%8C%E6%88%96%E5%8F%91%E7%94%9F%E4%B8%8D%E6%98%8E%E7%A1%AE%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.0.0.4.</span> <span class="toc-text">如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那这个异常必须来自析构函数以外的某个函数，因为析构函数抛出异常很危险，会导致提前结束程序的风险，或发生不明确行为</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">9.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%AF%E8%83%BD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E6%8D%95%E6%8D%89%E4%BB%BB%E4%BD%95%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%90%9E%E4%B8%8B%E5%AE%83%E6%88%96%E6%8F%90%E5%89%8D%E7%BB%93%E6%9D%9F%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.1.0.1.</span> <span class="toc-text">1.析构函数不应抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，吞下它或提前结束程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E4%BB%A5%E7%BB%99%E5%AE%A2%E6%88%B7%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.0.2.</span> <span class="toc-text">2.可以给客户提供一个处理程序中异常的接口，一个普通函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-09-%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">条款 09 : 绝不在构造和析构过程中调用virtual函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8base-class-%E6%9E%84%E9%80%A0%E6%9C%9F%E9%97%B4-virtual-%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">1.在base class 构造期间,virtual 函数不是 virtual 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8derived-class-%E5%AF%B9%E8%B1%A1%E7%9A%84base-class-%E6%9E%84%E9%80%A0%E6%9C%9F%E9%97%B4-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%98%AFbase-class-%E4%B8%8D%E6%98%AFderived-class"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">2.在derived class 对象的base class 构造期间,对象类型是base class,不是derived class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%83%BD%E6%B2%A1%E6%9C%89-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%88%9B%E5%BB%BA%E5%92%8C%E8%A2%AB%E9%94%80%E6%AF%81%E6%9C%9F%E9%97%B4-%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0-%E8%80%8C%E5%AE%83%E4%BB%AC%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E4%B9%9F%E9%83%BD%E6%9C%8D%E4%BB%8E%E5%90%8C%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="toc-number">10.0.0.3.</span> <span class="toc-text">3.确定你的构造函数都没有(在对象被创建和被销毁期间)调用virtual函数,而它们调用的函数也都服从同一约束,</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E6%9C%AC%E4%BE%8B%E4%B8%AD%E6%AF%94%E8%B5%B7-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%86%85%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%BA%88%E6%95%B0%E6%8D%AE-%E5%88%A9%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%80%BC%E4%BC%A0%E7%BB%99%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9B%B4%E6%96%B9%E4%BE%BF-%E6%9B%B4%E5%8F%AF%E8%AF%BB-%E5%A3%B0%E6%98%8E%E4%B8%BAstatic-%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0-%E2%80%9C%E9%82%A3%E4%BA%9B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A4%84%E4%BA%8E%E4%B8%BA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81%E2%80%9D"><span class="toc-number">10.0.0.4.</span> <span class="toc-text">注意本例中比起 初始化列表内直接给予数据 利用辅助函数创建一个值传给构造函数更方便(更可读),声明为static 防止出现 “那些成员变量处于为定义状态”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-number">10.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E6%9C%9F%E9%97%B4%E4%B8%8D%E8%A6%81%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E7%B1%BB%E8%B0%83%E7%94%A8%E4%B8%8D%E4%BC%9A%E4%B8%8B%E9%99%8D%E8%87%B3derived-class-%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%E5%9C%A8base-class-%E6%9E%84%E9%80%A0%E6%9C%9F%E9%97%B4-virtua%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%B1%9E%E4%BA%8Ebase%E7%9A%84%E9%82%A3%E4%B8%AA"><span class="toc-number">10.1.0.1.</span> <span class="toc-text">1.在构造和析构期间不要调用virtual函数，因为这类调用不会下降至derived class,换句话说在base class 构造期间,virtua函数调用属于base的那个</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-10-%E4%BB%A4operator-x3D-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="toc-number">11.</span> <span class="toc-text">条款 10 : 令operator&#x3D;返回一个reference to *this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8D%E4%BB%85%E4%BB%85%E9%80%82%E7%94%A8%E4%BA%8E-x3D-%E4%B9%9F%E9%80%82%E7%94%A8%E4%BA%8E-x3D-x3D-x3D-%E7%AD%89%E7%AD%89"><span class="toc-number">11.0.0.1.</span> <span class="toc-text">1.不仅仅适用于&#x3D;,也适用于+&#x3D;,-&#x3D;,*&#x3D;等等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%99%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%AA%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%97%A0%E5%BC%BA%E5%88%B6%E6%80%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%9C%80%E6%B1%82%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E9%81%B5%E5%AE%88%E5%AE%83"><span class="toc-number">11.0.0.2.</span> <span class="toc-text">2.这仅仅是个协议，无强制性，如果你有自己的实现需求，可以不遵守它</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-number">11.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A4assignment-%E8%B5%8B%E5%80%BC-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="toc-number">11.1.0.1.</span> <span class="toc-text">1.令assignment(赋值)操作符返回一个 reference to * this</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-11-%E5%9C%A8operator-x3D-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9D%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="toc-number">12.</span> <span class="toc-text">条款 11 : 在operator&#x3D;中处理”自我赋值”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8D%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E7%9A%84%E5%90%8E%E6%9E%9C-%E5%9C%A8%E2%80%9C%E5%81%9C%E6%AD%A2%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90%E5%89%8D%E6%84%8F%E5%A4%96%E9%87%8A%E6%94%BE%E4%BA%86%E5%AE%83%E2%80%9D"><span class="toc-number">12.0.0.1.</span> <span class="toc-text">1.不处理自我赋值的后果,在“停止使用资源前意外释放了它”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">12.0.0.2.</span> <span class="toc-text">2.解决方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="toc-number">12.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AE%E4%BF%9D%E5%A4%84%E7%90%86%E2%80%9D%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%8A%E8%BF%B0%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86"><span class="toc-number">12.1.0.1.</span> <span class="toc-text">1.确保处理”自我赋值”，包括上述三种方式的技术可以处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E4%BB%BB%E4%BD%95%E5%87%BD%E6%95%B0%E5%A6%82%E6%9E%9C%E6%93%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1-%E8%80%8C%E5%85%B6%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%97%B6-%E5%85%B6%E8%A1%8C%E4%B8%BA%E4%BB%BB%E7%84%B6%E6%AD%A3%E7%A1%AE-%E5%B0%B1%E5%83%8F%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E4%B8%AD-%E8%B5%8B%E5%80%BC-%E5%92%8C-%E8%A2%AB%E8%B5%8B%E5%80%BC-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA"><span class="toc-number">12.1.0.2.</span> <span class="toc-text">2.确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为任然正确,就像第一个示例中 赋值 和 被赋值 的对象是同一个</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">13.</span> <span class="toc-text">条款 12 : 复制对象时勿忘其每一个成分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BE%80%E7%B1%BB%E4%B8%AD%E6%96%B0%E6%B7%BB%E6%88%90%E5%91%98-%E5%90%8C%E6%97%B6%E4%B9%9F%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9copying%E5%87%BD%E6%95%B0-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E6%8F%90%E9%86%92-%E5%AF%BC%E8%87%B4%E5%8F%AF%E8%83%BD%E5%B1%80%E9%83%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">13.0.0.1.</span> <span class="toc-text">1.往类中新添成员,同时也需要修改copying函数,编译器不会提醒,导致可能局部拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%93%E4%BD%A0%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAcopying%E5%87%BD%E6%95%B0%EF%BC%8C%E7%A1%AE%E4%BF%9D%E5%A4%8D%E5%88%B6%E6%89%80%E6%9C%89local%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89base-class%E5%86%85%E9%80%82%E5%BD%93%E7%9A%84copying%E5%87%BD%E6%95%B0"><span class="toc-number">13.0.0.2.</span> <span class="toc-text">2.当你编写一个copying函数，确保复制所有local成员变量，调用所有base class内适当的copying函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%A0%E4%B8%8D%E8%AF%A5%E4%BB%A4copy-assignment%E6%93%8D%E4%BD%9C%E7%AC%A6-%E8%B0%83%E7%94%A8-copy%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8F%8D%E8%BF%87%E6%9D%A5%E4%B9%9F%E4%B8%8D%E8%83%BD%E4%BB%A4copy%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8copy-assignment%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">13.0.0.3.</span> <span class="toc-text">3.你不该令copy assignment操作符 调用 copy构造函数,反过来也不能令copy构造函数调用copy assignment操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="toc-number">13.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-copying%E5%87%BD%E6%95%B0%E5%BA%94%E7%A1%AE%E4%BF%9D%E5%A4%8D%E5%88%B6%E2%80%9D%E5%AF%B9%E8%B1%A1%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E2%80%9D%E5%8F%8A%E2%80%9D%E6%89%80%E6%9C%89base-class-%E6%88%90%E5%88%86%E2%80%9D"><span class="toc-number">13.1.0.1.</span> <span class="toc-text">1.copying函数应确保复制”对象内的所有成员变量”及”所有base class 成分”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E8%A6%81%E5%B0%9D%E8%AF%95%E4%BB%A5%E6%9F%90%E4%B8%AAcopying%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AAcopying%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BA%94%E5%B0%86%E5%85%B1%E5%90%8C%E6%9C%BA%E8%83%BD%E6%94%BE%E8%BF%9B%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B9%B6%E7%94%B1%E4%B8%A4%E4%B8%AAcopying%E5%87%BD%E6%95%B0%E5%85%B1%E5%90%8C%E8%B0%83%E7%94%A8"><span class="toc-number">13.1.0.2.</span> <span class="toc-text">2.不要尝试以某个copying函数实现另一个copying函数，应将共同机能放进第三个函数，并由两个copying函数共同调用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-13-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">14.</span> <span class="toc-text">条款 13 : 以对象管理资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">14.0.0.1.</span> <span class="toc-text">1.为何需要以对象管理资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8auto-ptr-pointer-like-%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E5%85%B6%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8delete"><span class="toc-number">14.0.0.2.</span> <span class="toc-text">2.利用auto_ptr(pointer-like),也就是智能指针,其析构函数会自动调用delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%E2%80%9D%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E6%83%B3%E6%B3%95"><span class="toc-number">14.0.0.3.</span> <span class="toc-text">“以对象管理资源”的两个关键想法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E8%8E%B7%E5%BE%97%E8%B5%84%E6%BA%90%E5%90%8E%E7%AB%8B%E5%88%BB%E6%94%BE%E8%BF%9B%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1-%E8%AF%A5%E8%A7%82%E5%BF%B5%E8%A2%AB%E7%A7%B0%E4%B8%BA%E2%80%9C%E8%B5%84%E6%BA%90%E5%8F%96%E5%BE%97%E6%97%B6%E6%9C%BA%E4%BE%BF%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA%E2%80%9D-RAII"><span class="toc-number">14.0.0.3.1.</span> <span class="toc-text">a.获得资源后立刻放进管理对象,该观念被称为“资源取得时机便是初始化时机”(RAII)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%A1%AE%E4%BF%9D%E8%B5%84%E6%BA%90%E8%A2%AB%E9%87%8A%E6%94%BE"><span class="toc-number">14.0.0.3.2.</span> <span class="toc-text">b.管理对象运用析构函数确保资源被释放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%B1%E4%BA%8E%E5%85%B6%E8%87%AA%E5%8A%A8%E9%94%80%E6%AF%81-%E6%B3%A8%E6%84%8F%E5%88%AB%E8%AE%A9%E5%A4%9A%E4%B8%AAauto-ptr%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E5%AF%B9%E8%B1%A1-%E5%90%A6%E5%88%99%E4%BC%9A%E5%AF%BC%E8%87%B4%E2%80%9D%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E2%80%9D-%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98-auto-ptr%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AF%BB%E5%B8%B8%E7%9A%84%E6%80%A7%E8%B4%A8-%E8%8B%A5%E9%80%9A%E8%BF%87copy%E6%9E%84%E9%80%A0%E6%88%96copy-assignment-%E5%A4%8D%E5%88%B6%E5%AE%83%E4%BB%AC-%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%8F%98%E6%88%90null-%E5%A4%8D%E5%88%B6%E6%89%80%E5%BE%97%E6%8C%87%E9%92%88%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%E7%9A%84%E5%94%AF%E4%B8%80%E6%8B%A5%E6%9C%89%E6%9D%83"><span class="toc-number">14.0.0.4.</span> <span class="toc-text">3.由于其自动销毁,注意别让多个auto_ptr指向同一对象,否则会导致”未定义行为”,对于这个问题,auto_ptr有一个不寻常的性质: 若通过copy构造或copy assignment 复制它们,它们会变成null,复制所得指针获取资源的唯一拥有权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E5%8F%97auto-ptr%E7%AE%A1%E7%90%86%E7%9A%84%E8%B5%84%E6%BA%90%E5%BF%85%E9%A1%BB%E7%BB%9D%E5%AF%B9%E6%B2%A1%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84auto-ptr%E5%90%8C%E6%97%B6%E6%8C%87%E5%90%91%E5%AE%83%E2%80%9D"><span class="toc-number">14.0.0.5.</span> <span class="toc-text">“受auto_ptr管理的资源必须绝对没有一个以上的auto_ptr同时指向它”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%A6%E4%B8%80%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E2%80%9C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%9E%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E2%80%9D-RCSP-RCSP%E6%8C%81%E7%BB%AD%E8%BF%BD%E8%B8%AA%E5%85%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E6%9F%90%E8%B5%84%E6%BA%90-%E5%B9%B6%E5%9C%A8%E6%97%A0%E4%BA%BA%E6%8C%87%E5%90%91%E5%AE%83%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4%E8%AF%A5%E8%B5%84%E6%BA%90"><span class="toc-number">14.0.0.6.</span> <span class="toc-text">4.另一替代方案“引用计数型智能指针”(RCSP).RCSP持续追踪共有多少对象指向某资源,并在无人指向它时自动删除该资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tr1%E7%9A%84tr1-shared-ptr-%E5%B0%B1%E6%98%AF%E4%B8%AARCSP"><span class="toc-number">14.0.0.7.</span> <span class="toc-text">Tr1的tr1::shared_ptr 就是个RCSP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-auto-ptr%E5%92%8Cshared-ptr%E9%83%BD%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%86%85%E5%81%9Adelete%E8%80%8C%E4%B8%8D%E6%98%AFdelete-%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84array%E4%B8%8D%E8%83%BD%E5%9C%A8auto-ptr%E6%88%96shared-ptr%E4%B8%8A%E4%BD%BF%E7%94%A8-%E5%A6%82%E6%9C%89%E9%9C%80%E6%B1%82%E8%A7%81%E6%9D%A1%E6%AC%BE55"><span class="toc-number">14.0.0.8.</span> <span class="toc-text">5.auto_ptr和shared_ptr都在析构函数内做delete而不是delete[],这意味着动态分配的array不能在auto_ptr或shared_ptr上使用(如有需求见条款55)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8"><span class="toc-number">14.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F-%E5%BA%94%E4%BD%BF%E7%94%A8RAII%E5%AF%B9%E8%B1%A1-%E5%AE%83%E4%BB%AC%E5%9C%A8%E6%9E%84%E9%80%A0%E6%97%B6%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90-%E6%9E%90%E6%9E%84%E6%97%B6%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">14.1.0.1.</span> <span class="toc-text">1.为防止资源泄漏,应使用RAII对象,它们在构造时获取资源,析构时释放资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84RAII%E5%AF%B9%E8%B1%A1-tr1-shared-ptr-%E5%92%8C-auto-ptr-%E4%B8%A4%E5%8F%AA%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%E5%A4%8D%E5%88%B6%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">14.1.0.2.</span> <span class="toc-text">2.两个常用的RAII对象,tr1::shared_ptr 和 auto_ptr,两只区别在于复制行为的不同</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-14-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="toc-number">15.</span> <span class="toc-text">条款 14 : 在资源管理类中小心copying行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E5%B9%B6%E9%9D%9Eheap-based%E7%9A%84%E8%B5%84%E6%BA%90-auto-pt-%E6%88%96-tr1-shared-ptr-%E5%BE%80%E5%BE%80%E4%B8%8D%E9%80%82%E5%90%88-%E5%9B%A0%E6%AD%A4%E4%BD%A0%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="toc-number">15.0.0.1.</span> <span class="toc-text">1.对于并非heap_based的资源,auto_pt 或 tr1::shared_ptr 往往不适合,因此你需要建立自己的资源管理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%80%83%E8%99%91%E5%A6%82%E6%9E%9CLock%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%A4%8D%E5%88%B6-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">15.0.0.2.</span> <span class="toc-text">2.考虑如果Lock对象被复制,会发生什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6-%E8%AE%B8%E5%A4%9A%E6%97%B6%E5%80%99%E5%85%81%E8%AE%B8RAII%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%A4%8D%E5%88%B6%E5%B9%B6%E4%B8%8D%E5%90%88%E7%90%86-%E5%A6%82%E6%9E%9C%E5%A4%8D%E5%88%B6%E5%8A%A8%E4%BD%9C%E5%AF%B9RAII-class-%E5%B9%B6%E4%B8%8D%E5%90%88%E7%90%86-%E5%BA%94%E8%AF%A5%E5%B0%86%E5%85%B6%E7%A6%81%E6%AD%A2-%E9%80%9A%E8%BF%87%E5%B0%86copying%E6%93%8D%E4%BD%9C%E5%A3%B0%E6%98%8E%E4%B8%BAprivate-%E6%9D%A1%E6%AC%BE6"><span class="toc-number">15.0.0.2.1.</span> <span class="toc-text">a.禁止复制,许多时候允许RAII对象被复制并不合理.如果复制动作对RAII class 并不合理,应该将其禁止,通过将copying操作声明为private(条款6)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%AF%B9%E5%BA%95%E5%B1%82%E8%B5%84%E6%BA%90%E7%A5%AD%E5%87%BA%E2%80%9C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E2%80%9D-%E5%A6%82-tr1-shared-ptr"><span class="toc-number">15.0.0.2.2.</span> <span class="toc-text">b.对底层资源祭出“引用计数法”,如 tr1::shared_ptr.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E5%B8%B8%E5%86%85%E5%90%AB%E4%B8%80%E4%B8%AAtr1-shared-ptr%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-RAII-class-%E4%BE%BF%E5%8F%AF%E5%AE%9E%E7%8E%B0-reference-counting-copying-%E8%A1%8C%E4%B8%BA-%E5%A6%82-%E8%8B%A5%E5%89%8D%E8%BF%B0%E7%9A%84Lock%E6%89%93%E7%AE%97%E4%BD%BF%E7%94%A8reference-couting-%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98mutexPtr%E7%9A%84%E7%B1%BB%E5%9E%8B-%E6%94%B9%E4%B8%BA-tr1-shared-ptr-lt-Mutex-gt-%EF%BC%8Ctr1-shared-ptr-%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E4%B8%BA%E2%80%9C%E5%BD%93%E5%BC%95%E7%94%A8%E6%AC%A1%E6%95%B0%E4%B8%BA0%E6%97%B6%E5%88%A0%E9%99%A4%E5%85%B6%E6%89%80%E6%8C%87%E7%89%A9%E2%80%9D-%E8%BF%99%E4%B8%8D%E6%98%AFLock%E6%83%B3%E8%A6%81%E7%9A%84%E8%A1%8C%E4%B8%BA-%E4%BD%86tr1-shared-ptr%E5%85%81%E8%AE%B8%E6%8C%87%E5%AE%9A%E6%89%80%E8%B0%93%E7%9A%84%E2%80%9D%E5%88%A0%E9%99%A4%E5%99%A8%E2%80%9D-%E9%82%A3%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-%E5%BD%93%E5%BC%95%E7%94%A8%E6%AC%A1%E6%95%B0%E4%B8%BA0%E7%9A%84%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8"><span class="toc-number">15.0.0.2.3.</span> <span class="toc-text">通常内含一个tr1::shared_ptr成员变量,RAII class 便可实现 reference-counting copying 行为,如 若前述的Lock打算使用reference couting ，它可以改变mutexPtr的类型,改为 tr1::shared_ptr&lt;Mutex.&gt;，tr1::shared_ptr 的默认行为为“当引用次数为0时删除其所指物”,这不是Lock想要的行为,但tr1::shared_ptr允许指定所谓的”删除器”,那是一个函数或函数对象,当引用次数为0的时候调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E5%A4%8D%E5%88%B6%E5%BA%95%E5%B1%82%E8%B5%84%E6%BA%90-%EF%BC%8C%E5%A4%8D%E5%88%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6-%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%BA%94%E6%98%AF-%E2%80%9C%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D%E2%80%9D"><span class="toc-number">15.0.0.2.4.</span> <span class="toc-text">c.复制底层资源 ，复制资源管理类对象时,进行的应是 “深度拷贝”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E8%BD%AC%E7%A7%BB%E5%BA%95%E9%83%A8%E8%B5%84%E6%BA%90%E7%9A%84%E6%8B%A5%E6%9C%89%E6%9D%83%EF%BC%8C%E5%A6%82%E6%9D%A1%E6%AC%BE13-%E8%BF%99%E6%98%AFauto-ptr%E7%9A%84%E5%A4%8D%E5%88%B6%E6%84%8F%E4%B9%89"><span class="toc-number">15.0.0.2.5.</span> <span class="toc-text">d.转移底部资源的拥有权，如条款13 ,这是auto_ptr的复制意义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-9"><span class="toc-number">15.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%8D%E5%88%B6RAII%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E4%B8%80%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%AE%83%E6%89%80%E7%AE%A1%E7%90%86%E7%9A%84%E8%B5%84%E6%BA%90-%E6%89%80%E4%BB%A5%E8%B5%84%E6%BA%90%E7%9A%84copying%E8%A1%8C%E4%B8%BA%E5%86%B3%E5%AE%9ARAII%E5%AF%B9%E8%B1%A1%E7%9A%84copying%E8%A1%8C%E4%B8%BA"><span class="toc-number">15.1.0.1.</span> <span class="toc-text">1.复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9A%84RAII-class-copying-%E8%A1%8C%E4%B8%BA%E4%B8%BA%EF%BC%9A%E6%8A%91%E5%88%B6copying-%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6-reference-counting"><span class="toc-number">15.1.0.2.</span> <span class="toc-text">2.常见的的RAII class copying 行为为：抑制copying(禁止复制) , reference counting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95-%E5%85%B6%E4%BB%96%E8%A1%8C%E4%B8%BA%E4%B9%9F%E5%8F%AF%E8%83%BD%E8%A2%AB%E5%AE%9E%E7%8E%B0%E5%A6%82-c-d"><span class="toc-number">15.1.0.3.</span> <span class="toc-text">(引用计数法), 其他行为也可能被实现如 c,d.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">16.</span> <span class="toc-text">条款 15 : 在资源管理类中提供对原始资源的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">16.0.0.1.</span> <span class="toc-text">1.为什么引入对原始资源的直接访问:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90%E6%83%B3%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAint%E5%9E%8B%E7%9A%84%E5%A4%A9%E6%95%B0%E5%8D%B4%E9%80%9A%E4%B8%8D%E8%BF%87%E7%BC%96%E8%AF%91-%E5%9B%A0%E4%B8%BAdaysHeld%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF-Investment-%E6%8C%87%E9%92%88"><span class="toc-number">16.0.0.2.</span> <span class="toc-text">下述例子想返回一个int型的天数却通不过编译,因为daysHeld需要的是 Investment*指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%86%E4%BC%A0%E7%BB%99%E5%AE%83%E7%9A%84%E5%8D%B4%E6%98%AF%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%B8%BAtr1-shared-ptr-lt-Investment-gt-%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.0.0.3.</span> <span class="toc-text">但传给它的却是个类型为tr1::shared_ptr&lt;.Investment&gt;的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%BE%BE%E6%88%90%E7%9B%AE%E7%9A%84-%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-tr1-shared-ptr%E5%92%8Cauto-ptr%E9%83%BD%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAget%E5%87%BD%E6%95%B0-%E7%94%A8%E6%9D%A5%E6%89%A7%E8%A1%8C%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2-%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%AE%83%E4%BC%9A%E8%BF%94%E5%9B%9E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%86%85%E9%83%A8%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88-%E7%9A%84%E5%A4%8D%E4%BB%B6"><span class="toc-number">16.0.0.4.</span> <span class="toc-text">2.两种做法可以达成目的,显示转换和隐式转换. tr1::shared_ptr和auto_ptr都提供一个get函数,用来执行显示转换,也就是它会返回智能指针内部的原始指针(的复件).</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">16.0.0.5.</span> <span class="toc-text">3.显示转换和隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E5%B8%B8%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E7%94%A8%E7%9A%84%E6%9B%B4%E5%A4%9A-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BC%9A%E5%A2%9E%E5%8A%A0%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%91%E7%94%9F-RAII-class-%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%BA%E4%BA%86%E5%B0%81%E8%A3%85%E8%80%8C%E5%AD%98%E5%9C%A8"><span class="toc-number">16.0.0.6.</span> <span class="toc-text">4.通常显示转换用的更多,隐式转换会增加错误的发生.RAII class 并不是为了封装而存在:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E7%9B%AE%E7%9A%84%E4%B8%BA%E2%80%9D%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E8%A1%8C%E4%B8%BA%E2%80%93%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE%E2%80%93%E4%BC%9A%E5%8F%91%E7%94%9F%E2%80%9D-%E6%89%80%E4%BB%A5RAII-class%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%87%BD%E6%95%B0%E5%B9%B6%E9%9D%9E%E8%AE%BE%E8%AE%A1%E7%81%BE%E9%9A%BE"><span class="toc-number">16.0.0.7.</span> <span class="toc-text">其目的为”确保一个特殊行为–资源释放–会发生”,所以RAII class中返回原始资源的函数并非设计灾难</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-10"><span class="toc-number">16.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-APIs%E5%BE%80%E5%BE%80%E8%A6%81%E6%B1%82%E8%AE%BF%E9%97%AE%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90-%E6%89%80%E4%BB%A5%E6%AF%8F%E4%B8%80%E4%B8%AARAII-class-%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E2%80%9D%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E2%80%9D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">16.1.0.1.</span> <span class="toc-text">1.APIs往往要求访问原始资源,所以每一个RAII class 应该提供一个”获取原始资源”的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%E6%88%96%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE-%E4%BD%86%E6%98%BE%E7%A4%BA%E6%9B%B4%E5%AE%89%E5%85%A8-%E9%9A%90%E5%BC%8F%E5%A2%9E%E5%8A%A0%E4%BA%86%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%91%E7%94%9F%E4%BD%86%E6%9B%B4%E6%96%B9%E4%BE%BF"><span class="toc-number">16.1.0.2.</span> <span class="toc-text">2.通过显示转换或隐式转换都可以访问,但显示更安全,隐式增加了错误的发生但更方便</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%87%87%E7%94%A8%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">条款 16 : 成对使用new和delete时采用相同形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-new-%E4%B8%8E-delete-%E5%BA%94%E8%AF%A5%E6%88%90%E5%AF%B9%E9%85%8D%E5%A5%97%E5%87%BA%E7%8E%B0-new-%E4%B8%8E-delete-new-%E4%B8%8E-delete"><span class="toc-number">17.0.0.1.</span> <span class="toc-text">1.new 与 delete 应该成对配套出现 , new 与 delete , new [] 与 delete[]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E5%9B%A0-%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E5%86%85%E5%AD%98%E9%80%9A%E5%B8%B8%E8%BF%98%E5%8C%85%E6%8B%AC%E2%80%9D%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E2%80%9D%E7%9A%84%E8%AE%B0%E5%BD%95-%E4%BB%A5%E4%BE%BFdelete%E7%9F%A5%E9%81%93%E8%B0%83%E7%94%A8%E5%A4%9A%E5%B0%91%E6%AC%A1%E6%9E%90%E6%9E%84-%E5%8D%95%E4%B8%80%E5%86%85%E5%AD%98%E5%88%99%E6%B2%A1%E6%9C%89%E8%BF%99%E7%AC%94%E8%AE%B0%E5%BD%95"><span class="toc-number">17.0.0.2.</span> <span class="toc-text">2.原因,数组所有内存通常还包括”数组大小”的记录,以便delete知道调用多少次析构,单一内存则没有这笔记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E5%A4%A7%E6%A6%82%E6%8F%8F%E8%BF%B0%E4%BA%86%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0-%E4%BD%86%E5%B9%B6%E9%9D%9E%E6%89%80%E6%9C%89%E7%BC%96%E8%AF%91%E9%83%BD%E6%98%AF%E5%A6%82%E6%AD%A4-%E4%BD%86%E8%B6%B3%E5%A4%9F%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%85%8D%E5%A5%97%E4%BD%BF%E7%94%A8"><span class="toc-number">17.0.0.3.</span> <span class="toc-text">上述大概描述了编译器中的实现,但并非所有编译都是如此,但足够解释为什么配套使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9typedef%E4%B9%9F%E6%98%AF%E5%A6%82%E6%AD%A4-%E8%80%83%E8%99%91%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">17.0.0.4.</span> <span class="toc-text">3.对typedef也是如此,考虑下述例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-11"><span class="toc-number">17.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-new-%E5%92%8C-delete-%EF%BC%8Cnew-%E5%92%8C-delete-%E9%9C%80%E6%88%90%E5%AF%B9%E9%85%8D%E5%A5%97%E5%87%BA%E7%8E%B0%E4%BD%BF%E7%94%A8"><span class="toc-number">17.1.0.1.</span> <span class="toc-text">1.new 和 delete ，new [] 和 delete [] 需成对配套出现使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newd%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">18.</span> <span class="toc-text">条款 17 : 以独立语句将newd对象置入智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">18.0.0.1.</span> <span class="toc-text">1.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8E%9F%E5%9B%A0%E5%9C%A8%E4%BA%8E%E8%B0%83%E7%94%A8processWidget%E4%B9%8B%E5%89%8D-%E5%BF%85%E9%A1%BB%E5%85%88%E6%A0%B8%E7%AE%97%E8%A2%AB%E4%BC%A0%E9%80%92%E7%9A%84%E5%AE%9E%E5%8F%82-%E4%B8%8A%E8%BF%B0%E7%AC%AC%E4%BA%8C%E5%AE%9E%E5%8F%82%E6%9C%89%E4%B8%80%E4%B8%AApriority%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E4%BD%86%E7%AC%AC%E4%B8%80%E5%AE%9E%E5%8F%82%E7%94%B1%E4%B8%A4%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90-%E2%80%9C%E6%89%A7%E8%A1%8Cnew-Widget-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%9D-%E2%80%9D%E8%B0%83%E7%94%A8tr1-shared%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D"><span class="toc-number">18.0.0.2.</span> <span class="toc-text">2.原因在于调用processWidget之前,必须先核算被传递的实参,上述第二实参有一个priority函数调用,但第一实参由两部分组成,“执行new Widget 表达式”,”调用tr1::shared构造函数”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E5%86%8D%E8%B0%83%E7%94%A8processWidget%E4%B9%8B%E5%89%8D%E6%9C%89%E4%B8%89%E4%BB%B6%E4%BA%8B"><span class="toc-number">18.0.0.3.</span> <span class="toc-text">所以再调用processWidget之前有三件事</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E8%B0%83%E7%94%A8priority"><span class="toc-number">18.0.0.3.1.</span> <span class="toc-text">a.调用priority</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E6%89%A7%E8%A1%8C%E2%80%9Dnew-Widget%E2%80%9D"><span class="toc-number">18.0.0.3.2.</span> <span class="toc-text">b.执行”new Widget”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E8%B0%83%E7%94%A8tr1-shared-ptr-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">18.0.0.3.3.</span> <span class="toc-text">c.调用tr1::shared_ptr 构造函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E8%BF%99%E4%BA%9B%E4%BA%8B%E6%83%85%E7%9A%84%E6%AC%A1%E5%BA%8F%E5%85%B7%E6%9C%89%E5%BC%B9%E6%80%A7-%E5%A6%82%E6%9E%9C%E6%9C%80%E7%BB%88%E8%8E%B7%E5%BE%97%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97"><span class="toc-number">18.0.0.4.</span> <span class="toc-text">编译完成这些事情的次序具有弹性,如果最终获得这样的操作序列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E6%89%A7%E8%A1%8C%E2%80%9Dnew-Widget%E2%80%9D"><span class="toc-number">18.0.0.4.1.</span> <span class="toc-text">a.执行”new Widget”</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E8%B0%83%E7%94%A8priority"><span class="toc-number">18.0.0.4.2.</span> <span class="toc-text">b.调用priority</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E8%B0%83%E7%94%A8tr1-shared-ptr-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">18.0.0.4.3.</span> <span class="toc-text">c.调用tr1::shared_ptr 构造函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9Cpriority%E7%9A%84%E8%B0%83%E7%94%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-%E5%88%99%E4%BC%9A%E5%AF%BC%E8%87%B4-%E2%80%9Cnew-Widget%E2%80%9D-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%8C%87%E9%92%88%E9%81%97%E5%A4%B1-%E5%BC%95%E5%8F%91%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="toc-number">18.0.0.5.</span> <span class="toc-text">如果priority的调用抛出异常,则会导致 “new Widget” 返回的指针遗失,引发资源泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">18.0.0.6.</span> <span class="toc-text">3.如何处理:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-12"><span class="toc-number">18.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newd%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%BF%99%E4%B9%88%E5%81%9A-%E4%B8%80%E6%97%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-%E5%88%99%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E9%9A%BE%E4%BB%A5%E5%AF%9F%E8%A7%89%E7%9A%84%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="toc-number">18.1.0.1.</span> <span class="toc-text">1.以独立语句将newd对象存储于智能指针,如果不这么做,一旦抛出异常,则可能导致难以察觉的资源泄漏</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">19.</span> <span class="toc-text">条款 18 : 让接口容易被正确使用,不易被误用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%BC%E5%85%A5%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%96%E8%A6%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.0.0.1.</span> <span class="toc-text">1.导入简单的外覆类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%90%E4%BE%9B%E8%A1%8C%E4%B8%BA%E4%B8%80%E8%87%B4%E7%9A%84%E6%8E%A5%E5%8F%A3-%E5%A6%82%E6%9E%9CSTL%E5%AE%B9%E5%99%A8%E6%AF%8F%E4%B8%AA%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AAsize%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-%E5%91%8A%E8%AF%89%E8%B0%83%E7%94%A8%E8%80%85%E5%AE%B9%E5%99%A8%E5%86%85%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.0.0.2.</span> <span class="toc-text">2.提供行为一致的接口,如果STL容器每个都有一个size成员函数,告诉调用者容器内有多少个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">19.0.0.3.</span> <span class="toc-text">3.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%81%87%E8%AE%BE%E8%B0%83%E7%94%A8%E8%80%85%E6%9C%9F%E8%AE%B8%E5%B0%86%E6%8C%87%E9%92%88%E4%BC%A0%E7%BB%99%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E7%9A%84%E9%94%80%E6%AF%81%E8%80%8C%E4%B8%8D%E6%98%AFdelete%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E5%B0%86%E5%85%B6%E7%BB%91%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">19.0.0.4.</span> <span class="toc-text">4.假设调用者期许将指针传给一个特定的函数来执行特定的销毁而不是delete可以尝试将其绑定一个删除器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%98%B2%E8%8C%83%E2%80%9Ccross-DLL-problem%E2%80%9D-%E4%B8%8D%E6%B8%85%E6%A5%9ADLL%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BC%BC%E4%B9%8E%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%85%B3"><span class="toc-number">19.0.0.5.</span> <span class="toc-text">5.防范“cross-DLL-problem”   (不清楚DLL是什么,似乎与多线程有关)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-13"><span class="toc-number">20.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BA%94%E5%B0%BD%E9%87%8F%E5%9C%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9E%E7%8E%B0-%E4%B8%8D%E5%AE%B9%E6%98%93%E8%AF%AF%E7%94%A8%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">20.0.0.1.</span> <span class="toc-text">1.应尽量在接口中实现,不容易误用的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%85%BC%E5%AE%B9"><span class="toc-number">20.0.0.2.</span> <span class="toc-text">2.实现接口的一致性,以及与内置类型的行为兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E2%80%9D%E9%98%BB%E6%AD%A2%E8%AF%AF%E7%94%A8%E2%80%9D-a-%E5%BB%BA%E7%AB%8B%E6%96%B0%E7%B1%BB%E5%9E%8B-b-%E9%99%90%E5%88%B6%E7%B1%BB%E5%9E%8B%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C-c-%E6%9D%9F%E7%BC%9A%E5%AF%B9%E8%B1%A1%E5%80%BC-d-%E6%B6%88%E9%99%A4%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E8%87%AA%E8%AE%A4"><span class="toc-number">20.0.0.3.</span> <span class="toc-text">3.”阻止误用” a.建立新类型 b.限制类型上的操作 c.束缚对象值 d.消除客户的资源管理自认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-tr1-shared-ptr-%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8-%E8%BF%99%E5%8F%AF%E9%98%B2%E8%8C%83DLL-%E9%97%AE%E9%A2%98"><span class="toc-number">20.0.0.4.</span> <span class="toc-text">4.tr1::shared_ptr 可以自定义删除器 , 这可防范DLL 问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-19-%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82type"><span class="toc-number">21.</span> <span class="toc-text">条款 19 : 设计class犹如type</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B0type%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">21.0.0.1.</span> <span class="toc-text">1.新type的对象该如何创建和销毁?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%83%E8%99%91%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84-%E4%BB%A5%E5%8F%8Anew-%E5%92%8C-delete-%E9%87%8D%E8%BD%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">21.0.0.1.0.1.</span> <span class="toc-text">考虑构造和析构,以及new 和 delete 重载的设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB"><span class="toc-number">21.0.0.2.</span> <span class="toc-text">2.初始化和对象的赋值该有什么差别?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%B7%B7%E6%B7%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Coperator-x3D"><span class="toc-number">21.0.0.2.0.1.</span> <span class="toc-text">不要混淆对象的构造函数和operator&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B0type%E5%AF%B9%E8%B1%A1%E5%A6%82%E6%9E%9C-pass-by-value-%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88"><span class="toc-number">21.0.0.3.</span> <span class="toc-text">3.新type对象如果 pass-by-value 意味着什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E5%B8%B8%E7%94%A8copy%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%9E%E7%8E%B0pass-by-value"><span class="toc-number">21.0.0.3.0.1.</span> <span class="toc-text">通常用copy构造函数来实现pass by value</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%96%B0type%E7%9A%84%E5%90%88%E6%B3%95%E5%80%BC"><span class="toc-number">21.0.0.4.</span> <span class="toc-text">4.新type的合法值?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9class%E8%8C%83%E5%9B%B4%E7%9A%84%E7%BA%A6%E6%9D%9F-%E5%AF%B9%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E5%B7%A5%E4%BD%9C"><span class="toc-number">21.0.0.4.0.1.</span> <span class="toc-text">对class范围的约束,对成员函数需要进行的错误检测工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%A0%E7%9A%84%E6%96%B0type%E9%9C%80%E8%A6%81%E9%85%8D%E5%90%88%E6%9F%90%E4%B8%AA%E7%BB%A7%E6%89%BF%E5%9B%BE%E7%B3%BB%E5%90%97"><span class="toc-number">21.0.0.5.</span> <span class="toc-text">5.你的新type需要配合某个继承图系吗?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%BB%A7%E6%89%BF%E4%B8%ADnon-virtual-%E5%92%8C-virtual-%E5%A3%B0%E6%98%8E%E7%9A%84%E8%80%83%E8%99%91-%E5%B0%A4%E5%85%B6%E6%98%AF%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BAvirtual-%E6%9D%A1%E6%AC%BE-34-36"><span class="toc-number">21.0.0.5.0.1.</span> <span class="toc-text">对于继承中non-virtual 和 virtual 声明的考虑,尤其是析构函数是否为virtual   (条款 34,36)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%A0%E7%9A%84%E6%96%B0type%E9%9C%80%E8%A6%81%E5%A3%B0%E6%98%8E%E6%A0%B7%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">21.0.0.6.</span> <span class="toc-text">6.你的新type需要声明样的转换？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#types%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%80%83%E8%99%91-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-%E6%88%96-i%E6%8C%89%E6%97%B6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">21.0.0.6.0.1.</span> <span class="toc-text">types之间的转换考虑, 隐式转换 或 i按时转换函数的设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AD%A4%E6%96%B0type%E6%98%AF%E5%90%88%E7%90%86%E7%9A%84"><span class="toc-number">21.0.0.7.</span> <span class="toc-text">7.什么样的操作符和函数对此新type是合理的?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%83%E8%99%91%E8%AF%A5type%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%A6%82list%E9%9C%80%E8%A6%81insert-%E6%9D%A1%E6%AC%BE-23-24-46"><span class="toc-number">21.0.0.7.0.1.</span> <span class="toc-text">考虑该type需要什么函数和操作符,如list需要insert  (条款 23,24,46)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E8%AF%A5%E9%A9%B3%E5%9B%9E"><span class="toc-number">21.0.0.8.</span> <span class="toc-text">8.什么样的标准函数该驳回?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E7%BC%96%E8%AF%91%E5%99%A8%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BE%9B%E7%9A%84copying-%E5%87%BD%E6%95%B0-%E5%8D%B3%E5%BA%94%E8%AF%A5%E5%B0%86%E5%85%B6%E5%A3%B0%E6%98%8E%E4%B8%BAprivate-%E6%9D%A1%E6%AC%BE-6"><span class="toc-number">21.0.0.8.0.1.</span> <span class="toc-text">如你不需要编译器默认提供的copying 函数,即应该将其声明为private (条款 6)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%B0%81%E8%AF%A5%E5%8F%96%E7%94%A8type%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">21.0.0.9.</span> <span class="toc-text">9.谁该取用type的成员?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%83%E8%99%91%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83-%E6%98%AF%E5%A3%B0%E6%98%8E%E4%B8%BAprivate-public-%E8%BF%98%E5%89%A9-protected"><span class="toc-number">21.0.0.9.0.1.</span> <span class="toc-text">考虑成员的访问权,是声明为private , public, 还剩 protected</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B0type%E7%9A%84%E2%80%9D%E6%9C%AA%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3%E2%80%9D"><span class="toc-number">21.0.0.10.</span> <span class="toc-text">10.什么是新type的”未声明接口”?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E7%90%86%E8%A7%A3-%E8%A7%81%E6%9D%A1%E6%AC%BE29"><span class="toc-number">21.0.0.10.0.1.</span> <span class="toc-text">不理解(见条款29)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E4%BD%A0%E7%9A%84%E6%96%B0type%E6%9C%89%E5%A4%9A%E4%B9%88%E4%B8%80%E8%88%AC%E5%8C%96"><span class="toc-number">21.0.0.11.</span> <span class="toc-text">11.你的新type有多么一般化?</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%83%E8%99%91%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-template-class"><span class="toc-number">21.0.0.11.0.1.</span> <span class="toc-text">考虑是否需要使用 template class</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E4%BD%A0%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84type%E5%90%97%EF%BC%9F"><span class="toc-number">21.0.0.12.</span> <span class="toc-text">12.你真的需要一个新的type吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%83%E8%99%91%E7%BB%A7%E6%89%BF-%E8%87%AA-base-class-%E5%8D%B3%E5%9C%A8-derived-class-%E4%B8%8A%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%9C%BA%E8%83%BD"><span class="toc-number">21.0.0.12.0.1.</span> <span class="toc-text">考虑继承 自 base class 即在 derived class 上添加新机能</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-14"><span class="toc-number">22.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%8D%E8%AE%BE%E8%AE%A1class-%E4%B9%8B%E5%89%8D%E7%A1%AE%E5%AE%9A%E4%BD%A0%E5%B7%B2%E7%BB%8F%E8%80%83%E8%99%91%E8%BF%87%E6%9C%AC%E6%9D%A1%E6%AC%BE%E6%89%80%E6%9C%89%E8%AE%A8%E8%AE%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">22.0.0.1.</span> <span class="toc-text">1.再设计class 之前确定你已经考虑过本条款所有讨论主题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-20-%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value"><span class="toc-number">23.</span> <span class="toc-text">条款 20 : 以pass-by-reference-to-const替换pass-by-value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%80%83%E8%99%91%E4%B8%8B%E8%BF%B0%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">23.0.0.1.</span> <span class="toc-text">1.考虑下述继承体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98-%E4%BD%86-pass-by-value-%E6%97%B6%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E4%B8%B4%E6%97%B6%E7%9A%84Student-Student%E5%86%85%E5%8F%88%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AAstring-%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BF%E8%87%AAPerosn-Base-Class-%E5%8F%88%E8%A6%81%E6%9E%84%E5%BB%BAPerson-Person%E5%8F%88%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AAstring-%E6%80%BB%E4%BD%93%E4%B8%8A%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%85%AD%E6%AC%A1%E6%9E%84%E9%80%A0%E5%92%8C%E5%85%AD%E6%AC%A1%E6%9E%90%E6%9E%84-%E6%95%88%E7%8E%87%E6%9E%81%E4%BD%8E"><span class="toc-number">23.0.0.2.</span> <span class="toc-text">上述函数实现上没有问题,但 pass-by-value 时构造一个临时的Student,Student内又包含两个string,同时继承自Perosn Base-Class 又要构建Person ,Person又包含两个string,总体上进行了六次构造和六次析构,效率极低</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%AD%A4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E5%8D%B3%E4%B8%BApass-by-reference"><span class="toc-number">23.0.0.3.</span> <span class="toc-text">2.对此的解决方式即为pass-by-reference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-by-reference%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8Dslicing-%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2-%E6%AD%A4%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E4%BA%8E%E5%B0%86derived-class-%E4%BB%A5-by-value%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BC%A0%E9%80%92%E7%BB%99%E5%BD%A2%E5%8F%82%E4%B8%BAbase-class-%E7%9A%84%E5%87%BD%E6%95%B0-%E8%80%83%E8%99%91%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">23.0.0.4.</span> <span class="toc-text">3.by-reference可以避免slicing(对象切割),此问题产生于将derived class 以 by-value的方式传递给形参为base-class 的函数,考虑下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-pass-by-refernce-%E5%BE%80%E5%BE%80%E6%AF%94-pass-by-value-%E6%9B%B4%E9%AB%98%E6%95%88"><span class="toc-number">23.0.0.5.</span> <span class="toc-text">4.pass-by-refernce 往往比 pass-by-value 更高效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9%E4%BA%8E%E5%A4%A7%E9%83%A8%E5%88%86%E7%B1%BB%E5%9E%8B%E5%BA%94%E8%AF%A5%E9%80%89%E7%94%A8by-reference-%E4%BD%86%E5%AF%B9%E4%BA%8E%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-%E5%8F%8ASTL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%89%E6%8B%A9pass-by-value%E5%B9%B6%E9%9D%9E%E6%B2%A1%E6%9C%89%E9%81%93%E7%90%86"><span class="toc-number">23.0.0.6.</span> <span class="toc-text">5.对于大部分类型应该选用by-reference 但对于内置类型,及STL迭代器和函数对象选择pass-by-value并非没有道理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-15"><span class="toc-number">23.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%BD%E9%87%8F%E4%BB%A5pass-by-reference-%E6%9B%BF%E6%8D%A2-pass-by-value-%EF%BC%8C%E9%AB%98%E6%95%88%E4%B8%94%E9%81%BF%E5%85%8D%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">23.1.0.1.</span> <span class="toc-text">1.尽量以pass-by-reference 替换 pass-by-value ，高效且避免切割问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A5%E4%B8%8A%E8%A7%84%E5%88%99%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-%E4%BB%A5%E5%8F%8ASTL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">23.1.0.2.</span> <span class="toc-text">2.以上规则不适用于内置类型,以及STL迭代器和函数对象</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6-%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9Ereference"><span class="toc-number">24.</span> <span class="toc-text">条款 21 : 必须返回对象时,别妄想返回reference</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E-reference"><span class="toc-number">24.0.0.1.</span> <span class="toc-text">1.返回 reference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8stack-%E6%88%96-heap-%E7%A9%BA%E9%97%B4%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%94%E5%9B%9E"><span class="toc-number">24.0.0.2.</span> <span class="toc-text">2.在stack 或 heap 空间创建并返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8static-%E5%91%A2"><span class="toc-number">24.0.0.3.</span> <span class="toc-text">3.如果使用static 呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%BC%E4%B8%8A%EF%BC%8C%E4%B8%80%E4%B8%AA%E2%80%9D%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E6%96%B0%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%9A%84%E5%87%BD%E6%95%B0%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95%E6%98%AF%EF%BC%9Areturn-%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AF%B9%E8%B1%A1-%E8%80%8C%E4%B8%8D%E6%98%AFrefernce"><span class="toc-number">24.0.0.4.</span> <span class="toc-text">4.综上，一个”必须返回新对象”的函数正确写法是：return 一个新对象 而不是refernce</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-16"><span class="toc-number">24.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%9D%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9Epointer%E6%88%96reference%E6%8C%87%E5%90%91local-stack-%E5%AF%B9%E8%B1%A1-%E6%88%96%E8%BF%94%E5%9B%9Ereference-%E6%8C%87%E5%90%91-heap-allocated-%E5%AF%B9%E8%B1%A1-%E6%88%96%E8%BF%94%E5%9B%9E-reference-%E6%8C%87%E5%90%91local-static-%E5%AF%B9%E8%B1%A1-%E6%9D%A1%E6%AC%BE4-%E4%B8%BA%E2%80%9D%E5%9C%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%90%88%E7%90%86%E8%BF%94%E5%9B%9Ereference%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AAlocal-statci%E5%AF%B9%E8%B1%A1%E2%80%9D%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%BB%BD%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B"><span class="toc-number">24.1.0.1.</span> <span class="toc-text">1.绝不要返回pointer或reference指向local stack 对象 ,或返回reference 指向 heap-allocated 对象, 或返回 reference 指向local-static 对象.(条款4)为”在单线程环境中合理返回reference指向一个local statci对象”提供了一份设计实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-22-%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-number">25.</span> <span class="toc-text">条款 22 : 将成员变量声明为private</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%9D%E8%AF%81%E8%AF%AD%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">25.0.0.1.</span> <span class="toc-text">1.保证语法一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E6%9B%B4%E7%B2%BE%E7%A1%AE%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">25.0.0.2.</span> <span class="toc-text">2.对成员变量进行更精确的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BF%9D%E8%AF%81%E5%B0%81%E8%A3%85%E6%80%A7-%E4%BB%8E%E5%B0%81%E8%A3%85%E7%9A%84%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91-%E5%85%B6%E5%AE%9E%E5%8F%AA%E6%9C%89%E4%B8%A4%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90-private-%E5%92%8C-%E5%85%B6%E4%BB%96"><span class="toc-number">25.0.0.3.</span> <span class="toc-text">3.保证封装性,从封装的角度出发,其实只有两种访问权限:private 和 其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E6%9F%90%E4%BA%9B%E4%B8%9C%E8%A5%BF%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7%E4%BA%8E%E2%80%9D%E5%BD%93%E5%85%B6%E5%86%85%E5%AE%B9%E6%94%B9%E5%8F%98%E6%97%B6%E9%80%A0%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A0%B4%E5%9D%8F%E9%87%8F%E2%80%9D%E6%88%90%E5%8F%8D%E6%AF%94"><span class="toc-number">25.0.0.4.</span> <span class="toc-text">4.条款23：某些东西的封装性于”当其内容改变时造成的代码破坏量”成反比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-17"><span class="toc-number">25.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%87%E8%AE%B0%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate-%E8%B5%8B%E4%BA%88%E5%AE%A2%E6%88%B7%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-%E5%8D%B3%E9%80%9A%E8%BF%87Public%E6%96%B9%E6%B3%95%E6%9D%A5%E8%AE%BF%E9%97%AE-%E5%8F%AF%E7%BB%86%E5%BE%AE%E5%88%92%E5%88%86%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E5%85%81%E8%AF%BA%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E8%8E%B7%E5%BE%97%E4%BF%9D%E8%AF%81-%E6%8F%90%E4%BE%9Bclass-%E4%BD%9C%E8%80%85%E5%85%85%E5%88%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BC%B9%E6%80%A7"><span class="toc-number">25.1.0.1.</span> <span class="toc-text">1.切记将成员变量声明为private,赋予客户访问数据的一致性(即通过Public方法来访问),可细微划分访问控制,允诺约束条件获得保证,提供class 作者充分的实现弹性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-proteced-%E5%B9%B6%E4%B8%8D%E6%AF%94-public-%E6%9B%B4%E5%85%B7%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">25.1.0.2.</span> <span class="toc-text">2.proteced 并不比 public 更具封装性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-23-%E5%AE%81%E4%BB%A5non-member-non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text">条款 23 : 宁以non-member-non-friend替换member函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-1"><span class="toc-number">26.0.0.1.</span> <span class="toc-text">1.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clearBrowser%E5%85%B7%E6%9C%89%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">26.0.0.2.</span> <span class="toc-text">clearBrowser具有更大的封装性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-C-%E4%B8%AD%E6%9B%B4%E8%87%AA%E7%84%B6%E7%9A%84%E5%81%9A%E6%B3%95%E6%98%AF%E8%AE%A9clearBrowser-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AAnon-member-%E4%B8%94%E4%B8%8E%E5%85%B6%E5%9C%A8%E5%90%8C%E4%B8%80namespace"><span class="toc-number">26.0.0.3.</span> <span class="toc-text">2.C++中更自然的做法是让clearBrowser 作为一个non-member 且与其在同一namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-namespcae-%E7%9A%84%E5%A5%BD%E5%A4%84-a-%E5%8F%AF%E8%B7%A8%E8%B6%8A%E5%A4%9A%E4%B8%AA%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6-%E8%80%8C%E5%90%8E%E8%80%85%E4%B8%8D%E8%83%BD-b-%E5%B0%86%E6%89%80%E6%9C%89%E4%BE%BF%E5%88%A9%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BD%86%E9%9A%B6%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AAnamespace-%E6%84%8F%E5%91%B3%E7%9D%80%E5%8F%AF%E4%BB%A5%E6%9B%B4%E8%BD%BB%E6%9D%BE%E7%9A%84%E6%89%A9%E5%B1%95-class-%E5%AF%B9%E4%BA%8E%E5%AE%A2%E6%88%B7%E6%98%AF%E4%B8%8D%E8%83%BD%E6%89%A9%E5%B1%95%E7%9A%84"><span class="toc-number">26.0.0.4.</span> <span class="toc-text">3.namespcae 的好处: a.可跨越多个源码文件,而后者不能 b.将所有便利函数放在多个头文件但隶属于同一个namespace 意味着可以更轻松的扩展 ,class 对于客户是不能扩展的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-18"><span class="toc-number">26.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A5non-member-non-friend-%E6%9B%BF%E6%8D%A2-member-%E5%87%BD%E6%95%B0-%E4%BE%9D%E6%AC%A1%E5%A2%9E%E5%8A%A0%E5%B0%81%E8%A3%85%E6%80%A7-%E5%8C%85%E8%A3%B9%E5%BC%B9%E6%80%A7-%E5%92%8C%E6%9C%BA%E8%83%BD%E6%89%A9%E5%85%85%E6%80%A7"><span class="toc-number">26.1.0.1.</span> <span class="toc-text">1.以non-member-non-friend 替换 member 函数,依次增加封装性,包裹弹性?和机能扩充性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member-%E5%87%BD%E6%95%B0"><span class="toc-number">27.</span> <span class="toc-text">条款 24 : 若所有参数皆需类型转换,为此采用non-member 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-2"><span class="toc-number">27.0.0.1.</span> <span class="toc-text">1.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%AD%A4%E5%8F%AF%E4%BB%A5%E4%BB%A5non-member%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">27.0.0.2.</span> <span class="toc-text">2.对此可以以non-member函数实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-member%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8D%E9%9D%A2%E6%98%AFnon-member%E5%87%BD%E6%95%B0-%E4%B8%8D%E6%98%AFfriend%E5%87%BD%E6%95%B0"><span class="toc-number">27.0.0.3.</span> <span class="toc-text">3.member函数的反面是non-member函数,不是friend函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-19"><span class="toc-number">27.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E6%9E%9C%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%BA%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0-%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%AAnon-member"><span class="toc-number">27.1.0.1.</span> <span class="toc-text">1.如果你需要为某个函数的所有参数 进行类型转换,那么这个函数必须是个non-member</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">28.</span> <span class="toc-text">条款 25 : 考虑写出一个不抛出异常的swap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%80%83%E8%99%91%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">28.0.0.1.</span> <span class="toc-text">1.考虑下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%80%E6%97%A6%E8%A6%81%E7%BD%AE%E6%8D%A2%E4%B8%A4%E4%B8%AAWidget%E5%AF%B9%E8%B1%A1%E5%80%BC-%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E6%98%AF%E7%BD%AE%E6%8D%A2pImpl%E6%8C%87%E9%92%88-%E4%BD%86%E9%BB%98%E8%AE%A4%E7%9A%84swap%E7%AE%97%E6%B3%95%E4%B8%8D%E7%9F%A5%E9%81%93%E8%BF%99%E7%82%B9-%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BC%9A%E8%B5%8B%E5%80%BC%E4%B8%89%E4%B8%AAWidgets-%E5%92%8C-%E4%B8%89%E4%B8%AAWidgetImpl-%E6%95%88%E7%8E%87%E6%9E%81%E4%BD%8E-%E5%AF%B9%E6%AD%A4%E5%8F%AF%E4%BB%A5%E5%AF%B9std-swap%E6%8F%90%E4%BE%9B%E9%92%88%E5%AF%B9Widget%E7%9A%84%E7%89%B9%E5%8C%96"><span class="toc-number">28.0.0.2.</span> <span class="toc-text">2.一旦要置换两个Widget对象值,需要做的是置换pImpl指针,但默认的swap算法不知道这点,默认的会赋值三个Widgets 和 三个WidgetImpl 效率极低,对此可以对std::swap提供针对Widget的特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%81%87%E8%AE%BEWidget%E5%92%8CWidgetImpl-%E9%83%BD%E6%98%AFclass-templates-%E8%80%8C%E4%B8%8D%E6%98%AF-classes"><span class="toc-number">28.0.0.3.</span> <span class="toc-text">3.假设Widget和WidgetImpl 都是class templates 而不是 classes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%80%E8%88%AC%E8%80%8C%E8%A8%80%E9%87%8D%E8%BD%BDfunction-template-%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98-%E4%BD%86std%E6%98%AF%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84namespace-%E5%85%B6%E7%AE%A1%E7%90%86%E8%A7%84%E5%88%99%E6%AF%94%E8%BE%83%E7%89%B9%E6%AE%8A-%E5%AE%A2%E6%88%B7%E5%8F%AF%E4%BB%A5%E5%85%A8%E7%89%B9%E5%8C%96-%E5%85%B6%E4%B8%AD%E7%9A%84templates-%E4%BD%86%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84templates-%E5%8D%B3%E4%B8%BA%E6%AD%A4%E5%A4%84%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%BD%BDstd-swap%E4%B8%8D%E5%90%88%E6%B3%95%E7%9A%84%E5%8E%9F%E5%9B%A0-%E6%89%80%E4%BB%A5%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%88%B0std%E9%87%8C%E5%A4%B4"><span class="toc-number">28.0.0.4.</span> <span class="toc-text">4.一般而言重载function template 没有问题,但std是个特殊的namespace ,其管理规则比较特殊, 客户可以全特化 其中的templates 但不可以添加新的templates,即为此处为什么重载std::swap不合法的原因,所以请不要添加新的东西到std里头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%80%E4%BB%A5%E5%AF%B9-3-%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E4%B8%BA-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAnon-member-swap-%E8%AE%A9%E4%BB%96%E8%B0%83%E7%94%A8member-swap%EF%BC%8C%E4%BD%86%E4%B8%8D%E5%86%8D%E5%B0%86%E8%BF%99%E4%B8%AAswap%E5%A3%B0%E6%98%8E%E4%B8%BAstd-swap%E7%9A%84%E7%89%B9%E5%8C%96%E6%88%96%E9%87%8D%E8%BD%BD%E7%89%88%E6%9C%AC"><span class="toc-number">28.0.0.5.</span> <span class="toc-text">5.所以对 3 中的解决办法为 声明一个non-member-swap,让他调用member-swap，但不再将这个swap声明为std::swap的特化或重载版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%BA%94%E8%AF%A5%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%AAswap-std-swap%E7%9A%84%E4%B8%80%E8%88%AC%E5%8C%96-%E8%BF%98%E6%98%AF%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC-%E6%A0%96%E8%BA%AB%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84T%E4%B8%93%E5%B1%9E%E7%89%88%E6%9C%AC"><span class="toc-number">28.0.0.6.</span> <span class="toc-text">6.应该调用哪个swap? std::swap的一般化,还是可能存在的特化版本,栖身于某个命名空间的T专属版本?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%AD%A4%E5%A4%84%E5%B7%B2%E7%BB%8F%E8%AE%A8%E8%AE%BA%E8%BF%87-default-swap-member-swap-non-member-swap-std-swap-%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC-%E4%BB%A5%E5%8F%8A%E5%AF%B9swap%E7%9A%84%E8%B0%83%E7%94%A8-%E5%A6%82%E6%9E%9Cswap%E9%BB%98%E8%AE%A4%E7%89%88%E6%9C%AC%E6%95%88%E7%8E%87%E4%B8%8D%E5%A4%9F-%E5%B0%9D%E8%AF%95%E5%81%9A%E4%BB%A5%E4%B8%8B%E4%BA%8B"><span class="toc-number">28.0.0.7.</span> <span class="toc-text">7.此处已经讨论过 default swap,member swap,non-member swap,std::swap 特化版本,以及对swap的调用,如果swap默认版本效率不够,尝试做以下事</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AApublic-swap-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-%E6%AD%A4%E5%87%BD%E6%95%B0%E7%BB%9D%E4%B8%8D%E8%AF%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">28.0.0.7.1.</span> <span class="toc-text">a.提供一个public swap 成员函数,此函数绝不该抛出异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%9C%A8%E4%BD%A0%E7%9A%84class-%E6%88%96-template-%E6%89%80%E5%9C%A8%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%85%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAnon-member-swap"><span class="toc-number">28.0.0.7.2.</span> <span class="toc-text">b.在你的class 或 template 所在的命名空间内提供一个non-member swap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9C%A8%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAclass-%EF%BC%8C%E4%B8%BA%E4%BD%A0%E7%9A%84class-%E7%89%B9%E5%8C%96std-swap"><span class="toc-number">28.0.0.7.3.</span> <span class="toc-text">c.如果你在编写一个class ，为你的class 特化std::swap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E8%B0%83%E7%94%A8%E6%97%B6%E7%A1%AE%E5%AE%9A%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AAusing-%E5%A3%B0%E6%98%8E%E5%BC%8F-%E4%BD%BFstd-swap%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E6%9B%9D%E5%85%89"><span class="toc-number">28.0.0.7.4.</span> <span class="toc-text">d.调用时确定包含一个using 声明式,使std::swap在函数内曝光</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-1"><span class="toc-number">28.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%93std-swap-%E6%95%88%E7%8E%87%E4%B8%8D%E9%AB%98%E6%97%B6-%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E7%BB%9D%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">28.1.0.1.</span> <span class="toc-text">1.当std::swap 效率不高时,提供一个绝不抛出异常的swap成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAmember-swap%EF%BC%8C%E4%B9%9F%E8%AF%A5%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAnon-member-swap%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0-%E9%98%9F%E4%B8%8Eclasses-%E8%80%8C%E9%9D%9Etemplates-%E8%AF%B7%E7%89%B9%E5%8C%96std-swap"><span class="toc-number">28.1.0.2.</span> <span class="toc-text">2.如果你提供一个member swap，也该提供一个non-member swap来调用函数,队与classes(而非templates) 请特化std::swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8swap%E6%97%B6%E5%BA%94%E8%AF%A5%E9%92%88%E5%AF%B9std-swap%E4%BD%BF%E7%94%A8using-%E5%A3%B0%E6%98%8E"><span class="toc-number">28.1.0.3.</span> <span class="toc-text">3.调用swap时应该针对std::swap使用using 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8D%E8%A6%81%E5%9C%A8std-namespcae-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF-%E4%BD%86%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9Btemplate%E7%9A%84%E7%89%B9%E5%8C%96"><span class="toc-number">28.1.0.4.</span> <span class="toc-text">4.不要在std namespcae 中添加新的东西,但可以提供template的特化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-26-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-number">29.</span> <span class="toc-text">条款 26 : 尽可能延后变量定义式的出现时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-3"><span class="toc-number">29.0.0.1.</span> <span class="toc-text">1.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E5%BE%AA%E7%8E%AF%E6%9D%A5%E8%AF%B4%E5%91%A2"><span class="toc-number">29.0.0.2.</span> <span class="toc-text">2.对于循环来说呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E4%BD%93%E4%B8%8AA%E6%9B%B4%E9%AB%98%E6%95%88-%E5%B0%A4%E5%85%B6%E5%BD%93n%E5%BE%88%E5%A4%A7%E7%9A%84%E6%97%B6%E5%80%99-%E5%90%A6%E5%88%99%E5%81%9A%E6%B3%95B%E6%88%96%E8%AE%B8%E6%AF%94%E8%BE%83%E5%A5%BD-A%E9%80%A0%E6%88%90%E5%90%8D%E7%A7%B0w%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%AF%94B%E5%A4%A7-%E5%8F%AF%E8%83%BD%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%E5%92%8C%E6%98%93%E7%BB%B4%E6%8A%A4%E6%80%A7%E9%80%A0%E6%88%90%E5%86%B2%E7%AA%81-%E5%9B%A0%E6%AD%A4%E9%99%A4%E9%9D%9E%E4%BD%A0%E7%9F%A5%E9%81%93"><span class="toc-number">29.0.0.3.</span> <span class="toc-text">大体上A更高效,尤其当n很大的时候,否则做法B或许比较好.A造成名称w的作用域比B大,可能对程序的可理解性和易维护性造成冲突,因此除非你知道:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E8%B5%8B%E5%80%BC%E6%88%90%E6%9C%AC%E6%AF%94%E2%80%9D%E6%9E%90%E6%9E%84-%E6%9E%84%E9%80%A0%E2%80%9C%E4%BD%8E"><span class="toc-number">29.0.0.3.1.</span> <span class="toc-text">a.赋值成本比”析构+构造“低</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E4%BD%A0%E6%AD%A3%E5%9C%A8%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%95%88%E7%8E%87%E9%AB%98%E5%BA%A6%E6%95%8F%E6%84%9F%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-number">29.0.0.3.2.</span> <span class="toc-text">b.你正在处理代码中效率高度敏感的部分</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-20"><span class="toc-number">29.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0-%E4%BB%A5%E5%A2%9E%E5%8A%A0%E7%A8%8B%E5%BA%8F%E6%B8%85%E6%99%B0%E5%BA%A6-%E5%B9%B6%E6%94%B9%E5%96%84%E6%95%88%E7%8E%87"><span class="toc-number">29.1.0.1.</span> <span class="toc-text">1.尽可能延后变量定义式的出现,以增加程序清晰度,并改善效率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-27-%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">30.</span> <span class="toc-text">条款 27 : 尽量少做转型动作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E2%80%9D%E6%97%A7%E5%BC%8F%E8%BD%AC%E6%8D%A2%E2%80%9D-T-expression-%E5%92%8C-T-expression-C-%E6%8F%90%E4%BE%9B%E5%9B%9B%E7%A7%8D%E6%96%B0%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">30.0.0.1.</span> <span class="toc-text">1.”旧式转换”: (T)expression 和 T(expression) , C++提供四种新式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-const-cast-%E9%80%9A%E5%B8%B8%E7%94%A8%E6%9D%A5%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E9%87%8F%E6%80%A7%E8%BD%AC%E9%99%A4-cast-away-the-constness-%E4%B9%9F%E6%98%AF%E5%94%AF%E4%B8%80%E6%9C%89%E6%AC%A1%E8%83%BD%E5%8A%9B%E7%9A%84C-style%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">30.0.0.1.1.</span> <span class="toc-text">a. const_cast 通常用来将对象的常量性转除 (cast away the constness),也是唯一有次能力的C++-style操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-dynamic-cast-%E7%94%A8%E6%9D%A5%E6%89%A7%E8%A1%8C%E2%80%9D%E5%AE%89%E5%85%A8%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E2%80%9D-safe-downcasting-%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%9D%A5%E5%86%B3%E5%AE%9A%E6%9F%90%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%BD%92%E5%B1%9E%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E7%B1%BB%E5%9E%8B-%E5%94%AF%E4%B8%80%E6%97%A0%E6%B3%95%E7%94%B1%E6%97%A7%E8%AF%AD%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8A%A8%E4%BD%9C-%E8%80%8C%E4%B8%94%E5%BC%80%E9%94%80%E5%B7%A8%E5%A4%A7"><span class="toc-number">30.0.0.1.2.</span> <span class="toc-text">b. dynamic_cast 用来执行”安全向下转型” (safe downcasting) ,也就是来决定某对象是否归属继承体系中的某个类型,唯一无法由旧语法执行的动作,而且开销巨大</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-reinterpret-cast-%E6%84%8F%E5%9B%BE%E6%89%A7%E8%A1%8C%E4%BD%8E%E7%BA%A7%E8%BD%AC%E5%9E%8B"><span class="toc-number">30.0.0.1.3.</span> <span class="toc-text">c. reinterpret_cast 意图执行低级转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-static-cast-%E7%94%A8%E6%9D%A5%E5%BC%BA%E8%BF%AB%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-%E4%BE%8B%E5%A6%82%E5%B0%86non-const-%E8%BD%AC%E6%8D%A2%E4%B8%BA-const%E5%AF%B9%E8%B1%A1-%E6%9D%A1%E6%AC%BE3-%E6%88%96%E5%83%8Fint-%E8%BD%AC%E4%B8%BA-double-%E4%BD%86%E4%BB%96%E6%97%A0%E6%B3%95%E5%81%9A%E5%88%B0const%E8%BD%AC%E4%B8%BAnon-const"><span class="toc-number">30.0.0.1.4.</span> <span class="toc-text">d. static_cast 用来强迫隐式转换,例如将non-const 转换为 const对象(条款3),或像int 转为 double,但他无法做到const转为non-const</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-C-%E6%96%B0%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%BE%88%E5%8F%97%E6%AC%A2%E8%BF%8E-%E4%BD%86%E6%97%A7%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%BB%8D%E7%84%B6%E6%9C%89%E6%9B%B4%E9%80%82%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-%E5%8F%82%E8%80%83%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">30.0.0.2.</span> <span class="toc-text">2.C++新式转换很受欢迎,但旧式转换仍然有更适合的使用时机 ,参考下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AD%A4%E8%93%84%E6%84%8F%E7%9A%84%E2%80%9D%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90%E2%80%9D-%E5%8A%A8%E4%BD%9C%E4%B8%8A%E4%B8%8D%E5%83%8F%E2%80%9D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E2%80%9D-%E6%89%80%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%97%A7%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%8F%AF%E8%83%BD%E6%9B%B4%E6%81%B0%E5%BD%93-%E4%BD%86%E5%A7%8B%E7%BB%88%E4%BD%BF%E7%94%A8%E6%96%B0%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B9%9F%E6%98%AF%E5%A5%BD%E7%9A%84%E4%B9%A0%E6%83%AF"><span class="toc-number">30.0.0.3.</span> <span class="toc-text">对此蓄意的”对象生成”,动作上不像”类型转换”,所以使用旧式转换可能更恰当,但始终使用新式转换也是好的习惯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E4%BA%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E5%81%9A%E5%90%97%EF%BC%9F%E5%8F%82%E8%80%83%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">30.0.0.4.</span> <span class="toc-text">3.对于类型转换,编译器什么都没做吗？参考下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%82%E8%80%83%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-%E4%B8%80%E4%B8%AAbase-class-%E5%92%8C-derived-class-%E4%B8%A4%E8%80%85%E9%83%BD%E5%AE%9A%E4%B9%89%E4%BA%86virtual-%E5%87%BD%E6%95%B0-%E8%A6%81%E6%B1%82%E5%85%88%E5%9C%A8derived-class-%E7%9A%84virtual-%E4%B8%AD-%E8%B0%83%E7%94%A8-base-class-%E7%9A%84virtua"><span class="toc-number">30.0.0.5.</span> <span class="toc-text">4.参考下述例子,一个base class 和 derived class ,两者都定义了virtual 函数,要求先在derived class 的virtual 中 调用 base class 的virtua</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A7%A3%E5%86%B3%E7%9A%84%E5%8A%9E%E6%B3%95%E5%BA%94%E8%AF%A5%E6%98%AF%E6%8B%BF%E6%8E%89%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C-%E9%87%87%E7%94%A8%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">30.0.0.6.</span> <span class="toc-text">5.解决的办法应该是拿掉转型动作,采用下述例子的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%B9%E4%BA%8Edynamic-cast-%E5%BA%94%E8%AF%A5%E6%B3%A8%E9%87%8D%E4%BB%96%E5%AF%B9%E6%95%88%E7%8E%87%E7%9A%84%E5%BD%B1%E5%93%8D-%E4%B9%8B%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-dynamic-cast-%EF%BC%8C%E9%80%9A%E5%B8%B8%E6%98%AF%E5%9B%A0%E4%B8%BA%E4%BD%A0%E6%83%B3%E8%A6%81%E5%9C%A8%E4%B8%80%E4%B8%AA%E4%BD%A0%E8%AE%A4%E5%AE%9A%E4%B8%BAderived-class-%E5%AF%B9%E8%B1%A1%E8%BA%AB%E4%B8%8A%E6%89%A7%E8%A1%8Cderived-class%E6%93%8D%E4%BD%9C-%E4%BD%86%E4%BD%A0%E7%9A%84%E6%89%8B%E4%B8%8A%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E2%80%9D%E6%8C%87%E5%90%91base%E2%80%9D%E7%9A%84pointer%E6%88%96reference-%E4%B8%80%E8%88%AC%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3"><span class="toc-number">30.0.0.7.</span> <span class="toc-text">6.对于dynamic_cast 应该注重他对效率的影响,之所以需要使用:dynamic_cast ，通常是因为你想要在一个你认定为derived class 对象身上执行derived class操作,但你的手上只有一个”指向base”的pointer或reference,一般两种做法可以解决:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80-%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%9C%A8%E5%85%B6%E4%B8%AD%E5%AD%98%E5%82%A8%E6%8C%87%E5%90%91-derived-class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88-%E9%80%9A%E5%B8%B8%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E6%9D%A1%E6%AC%BE13"><span class="toc-number">30.0.0.7.0.1.</span> <span class="toc-text">第一,使用容器并在其中存储指向 derived class 对象的指针(通常是智能指针,条款13)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E5%85%88%E5%89%8D%E7%9A%84Window-x2F-SpecialWindow-%E7%BB%A7%E6%89%BF%E4%B8%AD-%E5%8F%AA%E6%9C%89SpecialWindow-%E6%94%AF%E6%8C%81%E9%97%AA%E7%83%81"><span class="toc-number">30.0.0.7.0.2.</span> <span class="toc-text">假设先前的Window &#x2F; SpecialWindow 继承中,只有SpecialWindow 支持闪烁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E8%AE%BA%E5%93%AA%E7%A7%8D%E5%86%99%E6%B3%95-1-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8-2-%E5%B0%86virtual%E5%87%BD%E6%95%B0%E5%BE%80%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8A%E6%96%B9%E7%A7%BB%E5%8A%A8-%E2%80%94-%E9%83%BD%E5%B9%B6%E9%9D%9E%E5%AE%8C%E7%BE%8E%E7%9A%84%E6%96%B9%E6%A1%88-%E4%BD%86%E5%9C%A8%E8%AE%B8%E5%A4%9A%E6%83%85%E5%86%B5%E4%B8%8B%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A1%8C%E7%9A%84dynamic-cast%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">30.0.0.8.</span> <span class="toc-text">无论哪种写法 1.使用类型安全容器 2.将virtual函数往继承体系上方移动 —-都并非完美的方案,但在许多情况下提供了一个可行的dynamic_cast替代方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%9D%E5%AF%B9%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E6%98%AF%E6%89%80%E8%B0%93%E7%9A%84-%E2%80%9C%E8%BF%9E%E4%B8%B2-dynamic-cast%E2%80%9D"><span class="toc-number">30.0.0.9.</span> <span class="toc-text">7.绝对需要避免的是所谓的 “连串 dynamic-cast”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%88%E5%A4%A7%E5%8F%88%E6%85%A2-%E4%B8%94%E4%B8%80%E6%97%A6base-class-%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98-%E9%9C%80%E8%A6%81%E8%8A%B1%E8%B4%B9%E5%A4%A7%E9%87%8F%E7%9A%84%E6%97%B6%E9%97%B4%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9-%E5%BA%94%E5%BD%93%E9%87%87%E7%94%A8%E4%B8%8A%E8%BF%B0%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-%E5%B0%86%E5%85%B6%E6%9B%BF%E6%8D%A2"><span class="toc-number">30.0.0.10.</span> <span class="toc-text">这样的代码又大又慢,且一旦base class 发生改变,需要花费大量的时间检查是否需要修改,应当采用上述替代方案,将其替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-21"><span class="toc-number">30.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C-%E5%B0%A4%E5%85%B6%E6%98%AF%E5%9C%A8%E6%95%88%E7%8E%87%E6%95%8F%E6%84%9F%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%89%A7%E8%A1%8C-dynamic-cast"><span class="toc-number">30.1.0.1.</span> <span class="toc-text">1.尽量避免转型动作,尤其是在效率敏感的代码中执行 dynamic_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E8%BD%AC%E5%9E%8B%E6%98%AF%E5%BF%85%E8%A6%81%E7%9A%84-%E8%AF%95%E7%9D%80%E5%B0%86%E5%AE%83%E9%9A%90%E8%97%8F%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E8%83%8C%E5%90%8E-%E5%AE%A2%E6%88%B7%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8%E8%AF%A5%E5%87%BD%E6%95%B0%E8%BE%BE%E5%88%B0%E7%9B%AE%E7%9A%84-%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%B0%86%E4%BB%96%E6%94%BE%E5%85%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">30.1.0.2.</span> <span class="toc-text">2.如果转型是必要的,试着将它隐藏于某个函数背后,客户通过调用该函数达到目的,而不是直接将他放入代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%96%B0%E5%BC%8F%E8%80%8C%E4%B8%8D%E7%94%A8%E6%97%A7%E5%BC%8F-%E6%96%B0%E5%BC%8F%E6%96%B9%E4%BE%BF%E8%BE%A8%E8%AE%A4%E7%9B%AE%E7%9A%84"><span class="toc-number">30.1.0.3.</span> <span class="toc-text">3.使用新式而不用旧式,新式方便辨认目的</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">31.</span> <span class="toc-text">条款28 : 避免返回handles指向对象内部成分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7%E6%9C%80%E5%A4%9A%E5%8F%AA%E7%AD%89%E4%BA%8E%E2%80%9D%E8%BF%94%E5%9B%9E%E5%85%B6reference%E2%80%9D%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB-%E5%A6%82%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AApirvate%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8-%E5%B0%86%E5%AF%BC%E8%87%B4%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E9%99%8D%E5%88%B0public"><span class="toc-number">31.0.0.1.</span> <span class="toc-text">1.成员变量的封装性最多只等于”返回其reference”的函数的访问级别,如返回一个pirvate变量的引用,将导致该变量的访问权限降到public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9Cconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%A0%E5%87%BA%E4%B8%80%E4%B8%AAreference-%EF%BC%8C%E5%90%8E%E8%80%85%E6%89%80%E6%8C%87%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%AF%B9%E8%B1%A1%E8%87%AA%E8%BA%AB%E6%9C%89%E5%85%B3%E8%81%94-%E8%80%8C%E5%AE%83%E5%8F%88%E8%A2%AB%E5%AD%98%E5%82%A8%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%96-%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%80%85%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E9%82%A3%E7%AC%94%E6%95%B0%E6%8D%AE-%E8%BF%99%E6%AD%A3%E5%BC%8Fbitwise-constness-%E7%9A%84%E9%99%84%E5%B8%A6%E7%BB%93%E6%9E%9C-%E8%A7%81%E6%9D%A1%E6%AC%BE3"><span class="toc-number">31.0.0.2.</span> <span class="toc-text">2.如果const成员函数传出一个reference ，后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个函数的调用者可以修改那笔数据, 这正式bitwise constness 的附带结果(见条款3)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8A%E8%BF%B0%E4%BA%8B%E6%83%85%E9%83%BD%E6%98%AF%E5%8F%91%E7%94%9F%E4%BA%8E%E2%80%9D%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9Ereference%E2%80%9D-%E5%A6%82%E6%9E%9C%E5%AE%83%E4%BB%AC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%BC%8F%E6%8C%87%E9%92%88%E6%88%96%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%90%8C%E6%A0%B7%E5%A6%82%E6%AD%A4"><span class="toc-number">31.0.0.3.</span> <span class="toc-text">3.上述事情都是发生于”函数返回reference”.如果它们返回的式指针或迭代器,同样如此.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reference-%E6%8C%87%E9%92%88-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E9%83%BD%E6%98%AF%E6%89%80%E8%B0%93%E7%9A%84-handles-%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%AE%83%E4%BB%AC%E5%B0%86%E5%AF%BC%E8%87%B4%E2%80%9D%E9%99%8D%E4%BD%8E%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">31.0.0.4.</span> <span class="toc-text">reference,指针,迭代器 都是所谓的 handles ，返回它们将导致”降低对象封装性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E4%BA%8E%E6%88%90%E5%91%98%E5%86%85%E9%83%A8-%E5%8F%98%E9%87%8F%E6%88%96%E5%87%BD%E6%95%B0-%E7%BB%9D%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BB%A4public-%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%AE%83%E4%BB%AC-%E8%BF%99%E6%A0%B7%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%90%8E%E8%80%85%E7%9A%84%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%E6%8F%90%E9%AB%98"><span class="toc-number">31.0.0.5.</span> <span class="toc-text">4.对于成员内部,变量或函数,绝不应该令public 中的成员函数返回一个指针指向它们,这样会导致后者的访问级别提高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BF%94%E5%9B%9Ehandles-%E6%98%93%E5%AF%BC%E8%87%B4-%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AF%B9%E8%B1%A1-%E5%8D%B3%E8%AF%A5%E6%8C%87%E9%92%88%E5%8F%98%E4%B8%BA-%E7%A9%BA%E6%82%AC-%E8%99%9A%E6%8E%89%E7%9A%84"><span class="toc-number">31.0.0.6.</span> <span class="toc-text">5.返回handles 易导致 指向一个不存在的对象,即该指针变为 空悬,虚掉的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%BF%99%E5%B9%B6%E4%B8%8D%E6%84%8F%E5%91%B3%E7%9D%80%E7%BB%9D%E5%AF%B9%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%AE%A9%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9Ehandle-operator-%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%81%E8%AE%B8%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90-%E4%BD%86%E8%BF%99%E6%98%AF%E4%BE%8B%E5%A4%96-%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%B8%B8%E6%80%81"><span class="toc-number">31.0.0.7.</span> <span class="toc-text">6.这并不意味着绝对不可以让函数返回handle, operator[] 就是一个允许返回引用的例子,但这是例外,并不是常态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-2"><span class="toc-number">31.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles-reference-pointer-iterator-%E6%8C%87%E5%90%91%E5%86%85%E9%83%A8-%E5%B0%86%E5%8F%91%E7%94%9F%E6%8C%87%E9%92%88%E6%82%AC%E5%90%8A%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E"><span class="toc-number">31.1.0.1.</span> <span class="toc-text">1.避免返回handles(reference,pointer,iterator)指向内部,将发生指针悬吊的可能性降到最低</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-29-%E4%B8%BA%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">32.</span> <span class="toc-text">条款 29 : 为”异常安全”而努力是值得的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%89%BF%E8%AF%BA%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-%E7%A8%8B%E5%BA%8F%E5%86%85%E7%9A%84%E4%BB%BB%E4%BD%95%E4%BA%8B%E7%89%A9%E4%BB%8D%E7%84%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E7%8A%B6%E6%80%81-%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%AF%B9%E8%B1%A1%E6%88%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%9A%E5%9B%A0%E6%AD%A4%E6%8D%9F%E5%9D%8F-%E4%BE%8B%E5%A6%82-%E5%AF%B9%E4%BA%8EchangeBackground-%E4%B8%80%E6%97%A6%E5%AF%B9%E8%B1%A1%E8%A2%AB%E6%8A%9B%E5%87%BA-%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%83%BD%E7%BB%A7%E7%BB%AD%E6%8B%A5%E6%9C%89%E5%8E%9F%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F-%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BC%BA%E7%9C%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F-%E4%BD%86%E5%AE%A2%E6%88%B7%E6%97%A0%E6%B3%95%E9%A2%84%E6%9C%9F%E5%93%AA%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5-%E5%A6%82%E6%9E%9C%E6%83%B3%E7%9F%A5%E9%81%93-%E4%BB%96%E4%BB%AC%E6%81%90%E6%80%95%E5%BF%85%E9%A1%BB%E8%B0%83%E7%94%A8%E6%9F%90%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BB%A5%E5%BE%97%E7%9F%A5%E5%BD%93%E6%97%B6%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">32.0.0.1.</span> <span class="toc-text">1.基本承诺：如果抛出异常,程序内的任何事物仍然保存在有效状态,没有任何对象或数据结构会因此损坏,例如 对于changeBackground 一旦对象被抛出, 对象可能继续拥有原背景图像,也可能拥有一个缺省背景图像,但客户无法预期哪一种情况,如果想知道,他们恐怕必须调用某个成员函数以得知当时的背景图像是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%BC%82%E5%B8%B8%E8%A2%AB%E6%8A%9B%E5%87%BA-%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E4%B8%8D%E6%94%B9%E5%8F%98-%E5%8D%B3%E5%A6%82%E6%9E%9C%E6%88%90%E5%8A%9F-%E5%B0%B1%E6%98%AF%E5%AE%8C%E5%85%A8%E6%88%90%E5%8A%9F-%E5%A6%82%E6%9E%9C%E5%A4%B1%E8%B4%A5-%E5%88%99%E4%BC%9A%E5%9B%9E%E5%A4%8D%E5%88%B0%E2%80%9D%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81%E2%80%9D"><span class="toc-number">32.0.0.2.</span> <span class="toc-text">2.强烈保证：如果异常被抛出,程序状态不改变,即如果成功,就是完全成功,如果失败,则会回复到”调用函数前的状态”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8D%E6%8A%9B%E6%8E%B7%E4%BF%9D%E8%AF%81-%E6%89%BF%E8%AF%BA%E7%BB%9D%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-%E6%80%BB%E6%98%AF%E8%83%BD%E5%AE%8C%E6%88%90%E5%AE%83%E4%BB%AC%E6%89%BF%E8%AF%BA%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">32.0.0.3.</span> <span class="toc-text">3.不抛掷保证,承诺绝不抛出异常,总是能完成它们承诺的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E4%BA%8E%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%80%E8%88%AC%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5%EF%BC%9Acopy-and-swap"><span class="toc-number">32.0.0.4.</span> <span class="toc-text">4.对于强烈保证的一个一般化设计策略：copy and swap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8A%E9%80%9A%E5%B8%B8%E6%98%AF%E5%B0%86%E6%89%80%E6%9C%89%E2%80%9D%E9%9A%B6%E5%B1%9E%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E2%80%9D%E4%BB%8E%E5%8E%9F%E5%AF%B9%E8%B1%A1%E6%94%BE%E8%BF%9B%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%86%85-%E7%84%B6%E5%90%8E%E8%B5%8B%E4%BA%88%E5%8E%9F%E5%AF%B9%E8%B1%A1%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88-%E6%8C%87%E5%90%91%E9%82%A3%E4%B8%AA%E6%89%80%E8%B0%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1-%E8%BF%99%E7%A7%8D%E6%89%8B%E6%B3%95%E9%80%9A%E5%B8%B8%E8%A2%AB%E7%A7%B0%E4%B8%BA-pimpl-idiom-%E6%9D%A1%E6%AC%BE31-%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%BA%86%E5%AE%83"><span class="toc-number">32.0.0.4.1.</span> <span class="toc-text">实现上通常是将所有”隶属于对象的数据”从原对象放进另一个对象内,然后赋予原对象一个指针,指向那个所谓的实现对象,这种手法通常被称为 pimpl idiom 条款31 详细描述了它</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%86%E4%B8%80%E8%88%AC%E8%80%8C%E8%A8%80%E5%AE%83%E5%B9%B6%E4%B8%8D%E4%BF%9D%E8%AF%81%E6%95%B4%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9C%89%E5%BC%BA%E7%83%88%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">32.0.0.5.</span> <span class="toc-text">5.但一般而言它并不保证整个函数有强烈的异常安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%97%AE%E9%A2%98%E5%87%BA%E5%9C%A8%E2%80%9C%E8%BF%9E%E5%B8%A6%E5%BD%B1%E5%93%8D%E2%80%9D-%E5%8F%AA%E6%93%8D%E4%BD%9C%E5%B1%80%E9%83%A8%E6%80%A7%E7%8A%B6%E6%80%81%E5%BE%88%E5%AE%B9%E6%98%93%E6%8F%90%E4%BE%9B%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81-%E4%BD%86%E6%98%AF%E5%BD%93%E5%87%BD%E6%95%B0%E5%AF%B9%E9%9D%9E%E5%B1%80%E9%83%A8%E6%80%A7%E6%95%B0%E6%8D%AE%E6%9C%89%E8%BF%9E%E5%B8%A6%E5%BD%B1%E5%93%8D%E6%97%B6%EF%BC%8C%E6%8F%90%E4%BE%9B%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81%E5%B0%B1%E5%9B%B0%E9%9A%BE%E7%9A%84%E5%A4%9A"><span class="toc-number">32.0.0.6.</span> <span class="toc-text">6.问题出在“连带影响”,只操作局部性状态很容易提供强烈保证,但是当函数对非局部性数据有连带影响时，提供强烈保证就困难的多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%8A%E8%BF%B0%E8%AE%AE%E9%A2%98%E4%BC%9A%E7%BB%84%E7%BB%87%E4%BD%A0%E4%B8%BA%E5%87%BD%E6%95%B0%E6%8F%90%E4%BE%9B%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81-%E5%8D%B3%E4%BD%BF%E4%BD%A0%E6%83%B3%E8%BF%99%E4%B9%88%E5%81%9A-%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9B%A0%E6%98%AF%E6%95%88%E7%8E%87-copy-and-swap%E7%9A%84%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%E2%80%9D%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%AF%E6%9C%AC%E2%80%9D-%E7%84%B6%E5%90%8E%E5%86%8D%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E7%BD%AE%E6%8D%A2-%E5%9B%A0%E6%AD%A4%E5%BF%85%E9%A1%BB%E4%B8%BA%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%B0%86%E8%A2%AB%E6%94%B9%E5%8A%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E5%89%AF%E6%9C%AC"><span class="toc-number">32.0.0.7.</span> <span class="toc-text">7.上述议题会组织你为函数提供强烈保证,即使你想这么做.另一个原因是效率,copy-and-swap的关键在于”修改对象数据的副本”,然后再不抛出异常的前提下置换,因此必须为每一个将被改动的对象做一个副本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%BD%93%E2%80%9D%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81%E2%80%9D%E4%B8%8D%E5%88%87%E5%AE%9E%E9%99%85%E6%97%B6-%E5%BA%94%E5%BD%93%E6%8F%90%E4%BE%9B%E2%80%9D%E5%9F%BA%E6%9C%AC%E4%BF%9D%E8%AF%81"><span class="toc-number">32.0.0.8.</span> <span class="toc-text">8.当”强烈保证”不切实际时,应当提供”基本保证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-22"><span class="toc-number">32.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0-%E5%8D%B3%E4%BD%BF%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%B9%9F%E4%B8%8D%E4%BC%9A%E6%B3%84%E6%BC%8F%E8%B5%84%E6%BA%90%E6%88%96%E5%85%81%E8%AE%B8%E4%BB%BB%E4%BD%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%B4%A5%E5%9D%8F-%E8%BF%99%E6%A0%B7%E7%9A%84%E5%87%BD%E6%95%B0%E5%88%86%E4%B8%BA%E4%B8%89%E7%A7%8D%E7%BA%A7%E5%88%AB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%9E%8B-%E5%BC%BA%E7%83%88%E5%9E%8B-%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E5%9E%8B"><span class="toc-number">32.1.0.1.</span> <span class="toc-text">1.异常安全函数(即使发生异常也不会泄漏资源或允许任何数据结构败坏):这样的函数分为三种级别：基本型,强烈型,不抛异常型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E2%80%9D%E5%BC%BA%E7%83%88%E4%BF%9D%E8%AF%81%E2%80%9D%E9%80%9A%E5%B8%B8%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E4%B8%BAcopy-and-swap-%EF%BC%8C%E4%BD%86%E5%B9%B6%E9%9D%9E%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%88%96%E5%85%B7%E5%A4%87%E5%AE%9E%E7%8E%B0%E6%84%8F%E4%B9%89"><span class="toc-number">32.1.0.2.</span> <span class="toc-text">2.”强烈保证”通常的实现策略为copy-and-swap ，但并非所有函数都可以实现或具备实现意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E6%8F%90%E4%BE%9B%E7%9A%84%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E2%80%9D%EF%BC%8C%E9%80%9A%E5%B8%B8%E5%8F%AA%E7%AD%89%E4%BA%8E%E5%85%B6%E8%B0%83%E7%94%A8%E5%90%84%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81%E2%80%9D%E4%B8%AD%E7%9A%84%E6%9C%80%E5%BC%B1%E8%80%85%EF%BC%8C%E7%9F%AD%E6%9D%BF%E6%95%88%E5%BA%94"><span class="toc-number">32.1.0.3.</span> <span class="toc-text">3.函数提供的”异常安全保证”，通常只等于其调用各个函数的”异常安全保证”中的最弱者，短板效应?</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-30-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">33.</span> <span class="toc-text">条款 30 : 透彻了解inlining的里里外外</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-inline-%E8%99%BD%E7%84%B6%E2%80%9C%E5%85%8D%E9%99%A4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%88%90%E6%9C%AC%E2%80%9D-%E4%BD%86%E5%AF%BC%E8%87%B4%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7-%E9%80%82%E7%94%A8%E4%BA%8E%E6%9C%AC%E4%BD%93%E5%BE%88%E5%B0%8F%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">33.0.0.1.</span> <span class="toc-text">1.inline  虽然“免除函数调用成本”,但导致程序体积增大,适用于本体很小的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-inline-%E6%98%AF%E5%AF%B9%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E5%87%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E7%94%B3%E8%AF%B7-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BC%BA%E5%88%B6%E5%91%BD%E4%BB%A4-%E5%8F%AF%E4%BB%A5%E9%9A%90%E5%96%BB%E6%8F%90%E5%87%BA-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%8E%E7%A1%AE%E6%8F%90%E5%87%BA"><span class="toc-number">33.0.0.2.</span> <span class="toc-text">2.inline 是对编译器提出的一个申请,而不是强制命令.可以隐喻提出,也可以明确提出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-inlining%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0C-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E8%A1%8C%E4%B8%BA"><span class="toc-number">33.0.0.3.</span> <span class="toc-text">3.inlining在大多数C++程序中是编译期行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%89%E6%97%B6%E5%80%99%E5%8D%B3%E4%BD%BFinline%E4%BD%86%E8%BF%98%E6%98%AF%E4%BC%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%9C%AC%E4%BD%93-%E6%98%AF%E5%90%A6%E6%84%8F%E5%91%B3%E7%9D%80inline%E4%BB%A3%E8%A1%A8%E7%9D%80%E6%B2%A1%E6%9C%89%E5%87%BD%E6%95%B0%E6%9C%AC%E4%BD%93-%E5%A6%82%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">33.0.0.4.</span> <span class="toc-text">4.有时候即使inline但还是会生成函数本体(是否意味着inline代表着没有函数本体?),如下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8Einline"><span class="toc-number">33.0.0.5.</span> <span class="toc-text">5.构造和析构函数不适用于inline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-inline-%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E-virtual-virtual-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A1%AE%E5%AE%9A-inline%E7%BC%96%E8%AF%91%E6%97%B6%E7%A1%AE%E5%AE%9A-%E4%BA%92%E7%9B%B8%E5%86%B2%E7%AA%81"><span class="toc-number">33.0.0.6.</span> <span class="toc-text">6.inline 不适用于 virtual ,virtual 运行时确定, inline编译时确定,互相冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-inline-%E5%87%BD%E6%95%B0%E9%9A%BE%E4%BB%A5%E8%B0%83%E8%AF%95-%E4%B8%8D%E7%9F%A5%E9%81%93%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%B2%A1"><span class="toc-number">33.0.0.7.</span> <span class="toc-text">7.inline 函数难以调试(不知道现在的编译器解决这个问题没)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-23"><span class="toc-number">33.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B0%86inline-%E9%99%90%E5%88%B6%E5%9C%A8%E5%B0%8F%E5%9E%8B-%E8%B0%83%E7%94%A8%E9%A2%91%E7%B9%81%E7%9A%84%E5%87%BD%E6%95%B0%E8%BA%AB%E4%B8%8A"><span class="toc-number">33.1.0.1.</span> <span class="toc-text">1.将inline 限制在小型,调用频繁的函数身上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E8%A6%81%E5%8F%AA%E5%9B%A0%E4%B8%BAfunction-template-%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E5%B0%B1%E5%B0%86%E5%AE%83%E4%BB%AC%E5%A3%B0%E6%98%8E%E4%B8%BA-inline"><span class="toc-number">33.1.0.2.</span> <span class="toc-text">2.不要只因为function template 出现在头文件,就将它们声明为 inline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%87%8D%E7%82%B9-inline-%E6%98%AF%E4%B8%AA%E7%94%B3%E8%AF%B7-%E6%9C%80%E7%BB%88%E6%98%AF%E5%90%A6%E4%B8%BAinlined%E5%87%BD%E6%95%B0%E5%8F%96%E5%86%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8-%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">33.1.0.3.</span> <span class="toc-text">3.重点 inline 是个申请,最终是否为inlined函数取决于编译器(自己的理解)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-31-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-number">34.</span> <span class="toc-text">条款 31 : 将文件间的编译依存关系降至最低</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E6%97%B6%E5%AE%9A%E4%B9%89-%E5%BE%80%E5%BE%80%E4%BC%9A%E5%8C%85%E5%90%AB%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BC%8F-%E5%A6%82%E6%9E%9C%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89%E8%A2%AB%E6%9B%B4%E6%94%B9-%E9%82%A3%E4%B9%88%E5%88%99%E8%AF%A5%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91-%E8%BF%99%E6%97%A2%E6%98%AF-%E2%80%9C%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E2%80%9D-%E4%B8%8D%E8%BF%87%E9%80%9A%E5%B8%B8%E5%8C%85%E5%90%AB%E6%A0%87%E5%87%86%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8D%E4%BC%9A%E9%80%A0%E6%88%90%E9%97%AE%E9%A2%98"><span class="toc-number">34.0.0.1.</span> <span class="toc-text">1.编译时定义,往往会包含其他文件中的定义式,如果其他文件中的定义被更改,那么则该文件需要重新编译,这既是 “编译依存关系” , 不过通常包含标准头文件不会造成问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%87%E7%94%A8pimpl-idiom-%E8%AE%BE%E8%AE%A1"><span class="toc-number">34.0.0.2.</span> <span class="toc-text">2.采用pimpl idiom 设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8B-Person%E7%9A%84%E5%AE%A2%E6%88%B7%E5%AE%8C%E5%85%A8%E4%B8%8EDates-Addresses%E4%BB%A5%E5%8F%8APerson%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%88%86%E7%A6%BB-%E2%80%9D%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB%E2%80%9D"><span class="toc-number">34.0.0.3.</span> <span class="toc-text">这样的设计下,Person的客户完全与Dates,Addresses以及Person的实现细节分离,”接口与实现分离”</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E5%88%86%E7%A6%BB%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E-%E2%80%9D%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BE%9D%E5%AD%98%E6%80%A7%E2%80%9D-%E6%9B%BF%E6%8D%A2-%E2%80%9C%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BE%9D%E5%AD%98%E6%80%A7%E2%80%9D-%E9%82%A3%E6%AD%A3%E6%98%AF%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9A%84%E6%9C%AC%E8%B4%A8-%E8%BF%99%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5"><span class="toc-number">34.0.0.3.0.1.</span> <span class="toc-text">这个分离关键在于,”声明的依存性” 替换 “定义的依存性”, 那正是编译依存最小化的本质,这个简单的设计策略:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8-object-references-%E6%88%96-object-pointers-%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1-%E5%88%99%E4%B8%8D%E7%94%A8%E4%BD%BF%E7%94%A8objects"><span class="toc-number">34.0.0.3.0.2.</span> <span class="toc-text">a.如果使用 object references 或 object pointers 可以完成任务,则不用使用objects</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E5%A6%82%E6%9E%9C%E8%83%BD%E5%A4%9F-%E5%B0%BD%E9%87%8F%E4%BB%A5class-%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9B%BF%E6%8D%A2class-%E5%AE%9A%E4%B9%89%E5%BC%8F"><span class="toc-number">34.0.0.3.0.3.</span> <span class="toc-text">b.如果能够,尽量以class 声明式替换class 定义式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#c-%E4%B8%BA%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%92%8C%E5%AE%9A%E4%B9%89%E5%BC%8F%E6%8F%90%E4%BE%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6-%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%88%91%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%9F%E5%B0%86%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-%E5%A3%B0%E6%98%8E%E5%8C%85%E5%90%AB%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">34.0.0.3.0.4.</span> <span class="toc-text">c.为声明式和定义式提供不同的头文件 (类似于我自己写的？将声明与定义分文件编写,声明包含定义头文件)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%99%E6%A0%B7%E7%9A%84pimpl%E8%AE%BE%E8%AE%A1-%E4%BD%BFclasses-%E5%BE%80%E5%BE%80%E8%A2%AB%E7%A7%B0%E4%B8%BAHandle-classes-%E8%BF%99%E7%A7%8D%E5%81%9A%E6%B3%95%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%AE%83%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85-%E5%8F%AA%E4%BC%9A%E6%94%B9%E5%8F%98%E5%AE%83%E5%81%9A%E4%BA%8B%E7%9A%84%E6%96%B9%E5%BC%8F-%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%88%B6%E4%BD%9CHandle-class-%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF-%E4%BB%A4Person-class-%E6%88%90%E4%B8%BAabstract-class-%EF%BC%8C%E7%A7%B0%E4%B8%BAinterface-class"><span class="toc-number">34.0.0.4.</span> <span class="toc-text">3.这样的pimpl设计,使classes 往往被称为Handle classes ,这种做法不会改变它要做的事情,只会改变它做事的方式.另一种制作Handle class 的方法是,令Person class 成为abstract class ，称为interface class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E7%84%B6%E6%94%AF%E6%8C%81interface-class-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%87%BA%E6%9D%A5-p147"><span class="toc-number">34.0.0.5.</span> <span class="toc-text">当然支持interface class 接口的具象类必须被定义出来(p147)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Handle-classes-%E5%92%8C-Interface-classes-%E8%A7%A3%E9%99%A4%E4%BA%86%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%80%A6%E5%90%88%E5%85%B3%E7%B3%BB-%E4%BB%8E%E8%80%8C%E9%99%8D%E4%BD%8E%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7"><span class="toc-number">34.0.0.6.</span> <span class="toc-text">4.Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系,从而降低文件间的编译依存性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-24"><span class="toc-number">34.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%94%AF%E6%8C%81%E2%80%9D%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96%E2%80%9D%E7%9A%84%E4%B8%80%E8%88%AC%E6%9E%84%E6%83%B3%E6%98%AF-%E7%9B%B8%E4%BE%9D%E4%BA%8E%E5%A3%B0%E6%98%8E%E5%BC%8F-%E4%B8%8D%E8%A6%81%E7%9B%B8%E4%BE%9D%E4%BA%8E%E5%AE%9A%E4%B9%89%E5%BC%8F"><span class="toc-number">34.1.0.1.</span> <span class="toc-text">1.支持”编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6-%E5%BA%94%E8%AF%A5%E4%BB%A5%E2%80%9D%E5%AE%8C%E5%85%A8%E4%B8%94%E4%BB%85%E6%9C%89%E5%A3%B0%E6%98%8E%E5%BC%8F%E2%80%9D-%E7%B1%BB%E4%BC%BC%E4%BA%8Emain-gt-%E5%A3%B0%E6%98%8E-h-gt-%E5%AE%9E%E7%8E%B0-cpp"><span class="toc-number">34.1.0.2.</span> <span class="toc-text">2.程序库头文件,应该以”完全且仅有声明式”,(类似于main-&gt;声明.h-&gt;实现.cpp ?)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-32-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">35.</span> <span class="toc-text">条款 32 : 确定你的public 继承塑模出 is-a 关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-25"><span class="toc-number">35.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E2%80%9Dpublic%E2%80%9D%E7%BB%A7%E6%89%BF-%E6%84%8F%E5%91%B3%E7%9D%80-is-a-%E5%85%B3%E7%B3%BB-%E9%80%82%E7%94%A8%E4%BA%8Ebase-class-%E8%BA%AB%E4%B8%8A%E7%9A%84%E6%AF%8F%E4%B8%80%E4%BB%B6%E4%BA%8B%E6%83%85%E4%B9%9F%E4%B8%80%E5%AE%9A%E9%80%82%E7%94%A8%E4%BA%8Ederived-class-%E8%BA%AB%E4%B8%8A"><span class="toc-number">35.1.0.1.</span> <span class="toc-text">1.”public”继承,意味着 is-a 关系,适用于base class 身上的每一件事情也一定适用于derived class 身上</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">36.</span> <span class="toc-text">条款 33 : 避免遮掩继承而来的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8C%E5%90%8D%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%9A%90%E8%97%8F"><span class="toc-number">36.0.0.1.</span> <span class="toc-text">1.同名的函数会导致隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A6%86%E7%9B%96-x2F-%E9%9A%90%E8%97%8F"><span class="toc-number">36.0.0.2.</span> <span class="toc-text">2.覆盖    &#x2F;    隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87using-%E5%A3%B0%E6%98%8E%E5%8F%96%E6%B6%88%E9%9A%90%E8%97%8F"><span class="toc-number">36.0.0.3.</span> <span class="toc-text">3.通过using 声明取消隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BD%AC%E4%BA%A4%E5%87%BD%E6%95%B0-forwarding-funciton"><span class="toc-number">36.0.0.4.</span> <span class="toc-text">4.转交函数 forwarding funciton</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-26"><span class="toc-number">36.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-deirved-class-%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0%E4%BC%9A%E9%9A%90%E8%97%8Fbase-class-%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">36.1.0.1.</span> <span class="toc-text">1.deirved class 内的名称会隐藏base class 内的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E7%94%A8using-%E5%A3%B0%E6%98%8E%E6%88%96%E8%BD%AC%E4%BA%A4%E5%87%BD%E6%95%B0%E6%9D%A5%E8%AE%A9%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E5%86%8D%E8%A7%81%E5%A4%A9%E6%97%A5"><span class="toc-number">36.1.0.2.</span> <span class="toc-text">2.可用using 声明或转交函数来让被隐藏的名称再见天日</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">37.</span> <span class="toc-text">条款 34 : 区分接口继承和实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E6%97%B6%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%B8%89%E7%A7%8D%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E7%9A%84%E6%83%85%E5%86%B5-%E2%80%9D%E5%8F%AA%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E2%80%9D-%E2%80%9D%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0-%E4%BD%86%E5%B8%8C%E6%9C%9B%E8%83%BDoverride%E2%80%9D-%E2%80%9D%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0-%E4%BD%86%E4%B8%8D%E5%85%81%E8%AE%B8override%E2%80%9D"><span class="toc-number">37.0.0.1.</span> <span class="toc-text">1.继承时可能出现三种我们希望的情况,”只继承接口”,”同时继承接口和实现,但希望能override”,”继承接口和实现,但不允许override”.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%80%BB%E4%BC%9A%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-number">37.0.0.2.</span> <span class="toc-text">2.成员函数的接口总会被继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-pure-virtual%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5-%E5%8F%AA%E7%BB%A7%E6%89%BF%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3-Interface-class-%E7%B1%BB%E4%BC%BC%E6%9D%A1%E6%AC%BE31"><span class="toc-number">37.0.0.3.</span> <span class="toc-text">3.pure virtual函数的目的是为了第一种情况,只继承函数接口(Interface class 类似条款31?)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-impure-virtua%E5%87%BD%E6%95%B0%E7%9B%AE%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5-%E7%BB%A7%E6%89%BF%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.0.0.4.</span> <span class="toc-text">4.impure virtua函数目的是为了第二种情况,继承函数的接口和默认实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%86%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E5%8D%B1%E9%99%A9"><span class="toc-number">37.0.0.5.</span> <span class="toc-text">但这种情况可能出现危险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%BF%98%E8%AE%B0override-%E5%88%99%E9%87%87%E7%94%A8%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0-%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AF-%E9%97%AE%E9%A2%98%E4%B8%8D%E5%9C%A8%E4%BA%8E%E9%87%87%E7%94%A8%E4%BA%86%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0-%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8EModelC%E5%9C%A8%E6%B2%A1%E6%9C%89override%E7%9A%84%E6%97%B6%E5%80%99-%E7%BB%A7%E6%89%BF%E4%BA%86fly-%E8%8E%B7%E5%BE%97%E4%BA%86%E4%B8%80%E4%B8%AA%E5%AE%83%E6%B2%A1%E6%9C%89%E7%9A%84%E8%A1%8C%E4%B8%BA-%E5%88%87%E6%96%ADvirtual%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB-%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E8%BF%99%E7%A7%8D%E9%97%AE%E9%A2%98"><span class="toc-number">37.0.0.6.</span> <span class="toc-text">如果忘记override,则采用默认实现,可能导致错误,问题不在于采用了默认实现,关键在于ModelC在没有override的时候,继承了fly,获得了一个它没有的行为,切断virtual接口和其默认实现之间的联系,可以解决这种问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E4%BA%8Epure-virtual%E5%87%BD%E6%95%B0%E4%B8%80%E5%AE%9A%E8%A6%81%E8%A2%ABoverride-%E5%88%99%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">37.0.0.7.</span> <span class="toc-text">由于pure-virtual函数一定要被override,则可以采用另一种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%A6%86%E7%9B%96-%E5%88%99%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B9%9F%E4%BC%9A%E7%94%B1%E4%BA%8E%E7%BB%A7%E6%89%BF%E4%BA%86%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%98%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E2%80%93%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="toc-number">37.0.0.8.</span> <span class="toc-text">（如果不覆盖,则派生类也会由于继承了纯虚函数变为抽象类–个人理解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-non-virtual%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E4%BB%A4derived-classes-%E7%BB%A7%E6%89%BF%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BB%BD%E5%BC%BA%E5%88%B6%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.0.0.9.</span> <span class="toc-text">5.non-virtual函数用于令derived classes 继承函数的接口以及一份强制性实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-pure-virtual-simple-impure-virtual-non-virtual-%E2%80%9D%E5%8F%AA%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E2%80%9D-%E2%80%9C%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E4%B8%80%E4%BB%BD%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E2%80%9D-%E2%80%9D%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E4%B8%80%E4%BB%BD%E5%BC%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E2%80%9D"><span class="toc-number">37.0.0.10.</span> <span class="toc-text">6.pure-virtual , simple(impure)virtual , non-virtual :”只继承接口”, “继承接口和一份默认实现” ,”继承接口和一份强制实现”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-3"><span class="toc-number">37.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%9C%A8public%E7%BB%A7%E6%89%BF%E4%B8%8B-derived-class-%E6%80%BB%E6%98%AF%E7%BB%A7%E6%89%BFbase-class%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">37.1.0.1.</span> <span class="toc-text">1.接口继承和实现继承的区别,在public继承下,derived class 总是继承base class的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-pure-virtual-%E5%8F%AA%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">37.1.0.2.</span> <span class="toc-text">2.pure-virtual 只继承接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-impure-virutal-%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.1.0.3.</span> <span class="toc-text">3.impure-virutal 继承接口和默认实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-non-virtual-%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%BC%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.1.0.4.</span> <span class="toc-text">4.non-virtual 继承接口和强制实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-35-%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">38.</span> <span class="toc-text">条款 35 : 考虑virtual函数以外的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-%E9%80%9A%E5%B8%B8%E4%BC%9A%E7%94%A8virtual-%E6%9D%A5overred%E5%AE%83-%E4%B8%8D%E5%A6%A8%E8%80%83%E8%99%91%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">38.0.0.1.</span> <span class="toc-text">对于下述例子 , 通常会用virtual 来overred它,不妨考虑其他设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%8D%E7%94%B1non-virtual-Interface-%E5%AE%9E%E7%8E%B0-Template-Method"><span class="toc-number">38.0.0.2.</span> <span class="toc-text">1.籍由non-virtual-Interface 实现 Template Method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%B8%80%E8%AE%BE%E8%AE%A1%E2%80%9D%E4%BB%A4%E5%AE%A2%E6%88%B7%E9%80%9A%E8%BF%87public-non-virtual%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8-private-virtual-%E5%87%BD%E6%95%B0%E2%80%9D-%E7%A7%B0%E4%B8%BAnon-virtual-interface-NVI-%E6%89%8B%E6%B3%95-%E5%AE%83%E6%98%AF%E6%89%80%E8%B0%93Template-Method-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%8Ec-templa"><span class="toc-number">38.0.0.3.</span> <span class="toc-text">这一设计”令客户通过public non-virtual成员函数间接调用 private virtual 函数”,称为non-virtual interface (NVI)手法.  它是所谓Template Method 设计模式(与c++templa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#es%E5%B9%B6%E6%97%A0%E5%85%B3%E8%81%94-%E7%9A%84%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%89%B9%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F-%E8%BF%99%E4%B8%AAnon-virtual-%E8%A2%AB%E7%A7%B0%E4%B8%BA-virtual-%E7%9A%84%E5%A4%96%E8%A6%86%E5%99%A8"><span class="toc-number">38.0.0.4.</span> <span class="toc-text">es并无关联),的一个独特表现形式,这个non-virtual 被称为 virtual 的外覆器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A4%E6%89%8B%E6%B3%95%E4%BC%98%E7%82%B9%EF%BC%9A-%E2%80%9C%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%89%8D%E5%B7%A5%E4%BD%9C%E2%80%9D%E5%92%8C%E2%80%9D%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%90%8E%E5%B7%A5%E4%BD%9C%E2%80%9D-gt-%E7%A1%AE%E4%BF%9D%E5%BE%97%E4%BB%A5%E5%9C%A8%E4%B8%80%E4%B8%AAvirtual%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E5%89%8D%E8%AE%BE%E5%AE%9A%E5%A5%BD%E9%80%82%E5%BD%93%E5%9C%BA%E6%99%AF-%E5%B9%B6%E5%9C%A8%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%90%8E%E6%B8%85%E7%90%86%E5%9C%BA%E6%99%AF"><span class="toc-number">38.0.0.4.0.1.</span> <span class="toc-text">此手法优点： “做一些事前工作”和”做一些事后工作”, -&gt; 确保得以在一个virtual函数被调用前设定好适当场景,并在调用结束之后清理场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%8D%E7%94%B1Function-Pointer-%E5%AE%9E%E7%8E%B0-Strategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">38.0.0.5.</span> <span class="toc-text">2.籍由Function Pointer 实现 Strategy模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%A6%82%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A6%81%E6%B1%82%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%89%A9%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88-%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E5%81%A5%E5%BA%B7%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">38.0.0.5.1.</span> <span class="toc-text">例如我们可能会要求每个人物的构造函数接受一个指针,指向一个健康计算函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Evirtual-%E5%81%9A%E6%B3%95%E7%9B%B8%E6%AF%94-%E5%AE%83%E6%8F%90%E4%BE%9B%E4%BA%86%E5%BC%B9%E6%80%A7"><span class="toc-number">38.0.0.6.</span> <span class="toc-text">与virtual 做法相比,它提供了弹性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E5%90%8C%E4%B8%80%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BD%93-%E5%8F%AF%E4%BB%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">38.0.0.6.1.</span> <span class="toc-text">a.同一类型不同实体,可以有不同的计算函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%B7%B2%E7%9F%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8F%98%E6%9B%B4-%E4%BE%8B%E5%A6%82%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0setHealthCalculator-%E6%9B%BF%E6%8D%A2%E5%BD%93%E5%89%8D%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">38.0.0.6.2.</span> <span class="toc-text">b.已知类型的计算函数可以在运行期变更,例如提供一个成员函数setHealthCalculator,替换当前计算函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%8D%E7%94%B1tr1-function-%E5%AE%8C%E6%88%90Strategy%E6%A8%A1%E5%BC%8F"><span class="toc-number">38.0.0.7.</span> <span class="toc-text">3.籍由tr1::function 完成Strategy模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E5%89%8D%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E7%9B%B8%E6%AF%94-%E5%87%A0%E4%B9%8E%E7%9B%B8%E5%90%8C-%E4%BD%86%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E6%9B%B4%E6%83%8A%E4%BA%BA%E7%9A%84%E5%BC%B9%E6%80%A7"><span class="toc-number">38.0.0.8.</span> <span class="toc-text">和前一个设计相比,几乎相同.但如果需要更惊人的弹性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E4%B8%A4%E4%B8%AA%E9%83%BD%E5%BE%88%E5%A5%BD%E7%90%86%E8%A7%A3-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%B8%89%E4%B8%AA%E7%9A%84%E7%90%86%E8%A7%A3%E5%9B%A0%E4%B8%BA%E6%AD%A4%E5%A4%84%E7%9A%84%E6%9E%84%E9%80%A0%E5%8F%AA%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%86%E6%AD%A4%E5%A4%84%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E7%94%A8tr1-bind-%E5%B0%86currentLevel%E7%BB%91%E5%AE%9A%E4%B8%BAGameLevel%E5%AF%B9%E8%B1%A1-%E8%AE%A9%E5%AE%83%E5%9C%A8%E2%80%9D%E6%AF%8F%E6%AC%A1GameLevel%E8%A2%AB%E8%B0%83%E7%94%A8%E8%AE%A1%E7%AE%97ebg2%E7%9A%84%E5%81%A5%E5%BA%B7%E2%80%9D%E6%97%B6%E8%A2%AB%E4%BD%BF%E7%94%A8-%E9%82%A3%E6%AD%A3%E6%98%AFtr1-bind%E7%9A%84%E4%BD%9C%E4%B8%BA%EF%BC%9A%E5%AE%83%E6%8C%87%E5%87%BAebg2%E7%9A%84%E5%81%A5%E5%BA%B7%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E6%80%BB%E6%98%AF%E4%BB%A5currentLevel%E4%BD%9C%E4%B8%BAGameLevel%E5%AF%B9%E8%B1%A1"><span class="toc-number">38.0.0.9.</span> <span class="toc-text">前两个都很好理解,对于第三个的理解因为此处的构造只接受一个参数，但此处有两个参数，所以用tr1::bind 将currentLevel绑定为GameLevel对象,让它在”每次GameLevel被调用计算ebg2的健康”时被使用,那正是tr1::bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%A4%E5%85%B8%E7%9A%84Strategy"><span class="toc-number">38.0.0.10.</span> <span class="toc-text">4.古典的Strategy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%81%A5%E5%BA%B7%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E5%81%9A%E6%88%90%E4%B8%80%E4%B8%AA%E5%88%86%E7%A6%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84virtual%E5%87%BD%E6%95%B0-%E5%AF%B9%E4%BA%8E%E4%B8%8A%E8%BF%B0%E4%BE%8B%E5%AD%90-GameCharacter-%E6%98%AF%E6%9F%90%E4%B8%AA%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E7%9A%84%E6%A0%B9%E7%B1%BB-%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84EvilBadGuy-%E5%92%8C-EyeCandyCharacter-%E9%83%BD%E6%98%AFderived-class-HealthCalcFunc%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E7%9A%84%E6%A0%B9%E7%B1%BB-%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84SlowHealthLoser-%E5%92%8C-FastHealthLoser-%E9%83%BD%E6%98%AFderived-class-%E6%AF%8F%E4%B8%80%E4%B8%AAGameCharacter%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%86%85%E5%90%AB%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88-%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AAHealthCalcFunc%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E7%9A%84%E5%AF%B9%E8%B1%A1-%E5%8F%82%E8%80%83p176%E5%9B%BE"><span class="toc-number">38.0.0.10.1.</span> <span class="toc-text">将健康计算函数做成一个分离的继承体系中的virtual函数.  对于上述例子,GameCharacter 是某个继承体系的根类,体系中的EvilBadGuy 和 EyeCandyCharacter 都是derived class;HealthCalcFunc是另一个继承体系的根类,体系中的SlowHealthLoser 和 FastHealthLoser 都是derived class, 每一个GameCharacter对象都内含一个指针,指向一个来自HealthCalcFunc继承体系的对象(参考p176图)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%91%98%E8%A6%81"><span class="toc-number">38.0.0.11.</span> <span class="toc-text">5.摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E4%BD%BF%E7%94%A8non-virtual-interface-NVI-%E6%89%8B%E6%B3%95-%E8%BF%99%E6%98%AF-Template-Method-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F"><span class="toc-number">38.0.0.11.1.</span> <span class="toc-text">a.使用non-virtual interface (NVI)手法,这是 Template Method 设计模式的一种特殊形式.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E5%B0%86virtual%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E2%80%9D%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E2%80%9D-%E8%BF%99%E6%98%AFStrategy%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E5%88%86%E8%A7%A3%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">38.0.0.11.2.</span> <span class="toc-text">b.将virtual函数替换为”函数指针成员变量”,这是Strategy设计模式的一种分解表现形式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E4%BB%A5tr1-function%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2virtual%E5%87%BD%E6%95%B0-%E8%BF%99%E4%B9%9F%E6%98%AFStrategy%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9F%90%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">38.0.0.11.3.</span> <span class="toc-text">c.以tr1::function成员变量替换virtual函数,这也是Strategy设计模式的某种形式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#d-%E5%B0%86%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84virtual%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E5%86%85%E7%9A%84virtual%E5%87%BD%E6%95%B0-%E8%BF%99%E6%98%AFStrategy%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%B3%95"><span class="toc-number">38.0.0.11.4.</span> <span class="toc-text">d.将继承体系中的virtual函数替换为另一个继承体系内的virtual函数,这是Strategy设计模式的传统实现手法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-27"><span class="toc-number">38.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-virtual%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E5%8C%85%E6%8B%ACNVI%E6%89%8B%E6%B3%95%E5%8F%8AStrategy%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">38.1.0.1.</span> <span class="toc-text">1.virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%86%E6%9C%BA%E8%83%BD%E4%BB%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%A7%BB%E5%88%B0class%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-number">38.1.0.2.</span> <span class="toc-text">2.将机能从成员函数移到class外部函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-tr1-function%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%B0%B1%E5%83%8F%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">38.1.0.3.</span> <span class="toc-text">3.tr1::function对象的行为就像一般函数指针</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">39.</span> <span class="toc-text">条款 36 : 绝不重新定义继承而来的non-virtual函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-non-virtual%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8%E4%B8%BA%E2%80%9D%E4%B8%8D%E5%8F%98%E6%80%A7%E5%87%8C%E9%A9%BE%E4%BA%8E%E7%89%B9%E5%BC%82%E6%80%A7%E2%80%9D-%E5%A6%82%E6%9E%9C%E6%89%93%E7%AE%97%E9%87%8D%E5%AE%9A%E4%B9%89-%E5%88%99%E5%BA%94%E5%BD%93%E4%BD%BF%E7%94%A8virtual%E5%87%BD%E6%95%B0-%E5%BD%93%E4%BD%BF%E7%94%A8non-virtual%E5%87%BD%E6%95%B0%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%AE%9A%E4%B9%89-%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%8C%87%E9%92%88-x2F-%E5%BC%95%E7%94%A8-%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E7%9A%84%E7%B1%BB%E6%97%B6-%E6%89%80%E6%8C%87%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E6%9C%89%E5%AE%9E%E9%99%85%E7%9A%84%E7%B1%BB%E5%86%B3%E5%AE%9A-%E8%80%8C%E6%98%AF%E7%94%B1%E6%8C%87%E9%92%88-x2F-%E5%BC%95%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%86%B3%E5%AE%9A"><span class="toc-number">39.0.0.1.</span> <span class="toc-text">1.non-virtual函数的性质为”不变性凌驾于特异性”,如果打算重定义,则应当使用virtual函数,当使用non-virtual函数并进行重定义,会导致指针&#x2F;引用 指向一个实际的类时,所指的函数不是有实际的类决定,而是由指针&#x2F;引用的类型决定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-28"><span class="toc-number">39.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%9D%E5%AF%B9%E4%B8%8D%E8%A6%81%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">39.1.0.1.</span> <span class="toc-text">1.绝对不要重新定义继承而来的non-virtual函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">40.</span> <span class="toc-text">条款 37 : 绝不重新定义继承而来的缺省参数值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-virtual%E5%87%BD%E6%95%B0%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-dynamically-bound-%E8%80%8C%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC%E5%8D%B4%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-statically"><span class="toc-number">40.0.0.1.</span> <span class="toc-text">1.virtual函数是动态绑定(dynamically bound),而缺省参数值却是静态绑定(statically)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%80%83%E8%99%91%E4%BB%A5%E4%B8%8B%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">40.0.0.2.</span> <span class="toc-text">2.考虑以下继承体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtual%E5%87%BD%E6%95%B0%E7%B3%BB%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E8%80%8C%E6%9D%A5-%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%80%E4%BB%BD%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-%E5%8F%96%E5%86%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">40.0.0.3.</span> <span class="toc-text">virtual函数系动态绑定而来,调用哪一份实现代码,取决于动态类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%86%E5%AF%B9%E4%BA%8E%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC-%E7%94%B1%E4%BA%8E%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-%E6%89%80%E6%9C%89derived%E7%B1%BB%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC%E5%85%A8%E9%83%A8%E5%8F%96%E5%86%B3%E4%BA%8Ebase%E4%B8%AD%E7%9A%84"><span class="toc-number">40.0.0.4.</span> <span class="toc-text">但对于缺省参数值,由于是静态绑定,所有derived类的缺省参数值全部取决于base中的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98-%E5%BD%93%E4%BD%A0%E6%83%B3%E4%BB%A4virtual%E5%87%BD%E6%95%B0%E8%A1%A8%E7%8E%B0%E5%87%BA%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%BD%86%E5%8D%B4%E9%81%AD%E9%81%87%E9%BA%BB%E7%83%A6-%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%AE%BE%E8%AE%A1-%E6%9D%A1%E6%AC%BE35"><span class="toc-number">40.0.0.5.</span> <span class="toc-text">3.对于这些问题,当你想令virtual函数表现出你想要的行为但却遭遇麻烦,可以考虑virtual函数的替代设计(条款35)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-29"><span class="toc-number">40.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%9D%E4%B8%8D%E8%A6%81%E9%87%8D%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC-%E5%9B%A0%E4%B8%BA%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-%E8%80%8Cvirtual%E5%87%BD%E6%95%B0%E5%8D%B4%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">40.1.0.1.</span> <span class="toc-text">1.绝不要重定义一个继承而来的缺省参数值,因为缺省参数值是静态绑定,而virtual函数却是动态绑定</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-38-%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9D%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-number">41.</span> <span class="toc-text">条款 38 : 通过复合塑模出has-a或”根据某物实现出”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%8D%E5%90%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E7%A7%8D%E5%85%B3%E7%B3%BB-%E5%BD%93%E6%9F%90%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%90%AB%E6%9C%89%E5%AE%83%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1-%E4%BE%BF%E6%98%AF%E8%BF%99%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="toc-number">41.0.0.1.</span> <span class="toc-text">1.复合是类型之间的一种关系,当某种类型的对象含有它种类型的对象,便是这种关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9D%A1%E6%AC%BE32%E6%9B%BE%E8%AF%B4-%E2%80%9Dpublic%E7%BB%A7%E6%89%BF%E2%80%9D%E5%B8%A6%E6%9C%89-is-a%E7%9A%84%E6%84%8F%E4%B9%89-%E5%A4%8D%E5%90%88%E4%B9%9F%E6%9C%89%E5%AE%83%E7%9A%84%E6%84%8F%E4%B9%89%E5%8D%B3"><span class="toc-number">41.0.0.2.</span> <span class="toc-text">2.条款32曾说,”public继承”带有 is-a的意义. 复合也有它的意义即:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-has-a"><span class="toc-number">41.0.0.2.1.</span> <span class="toc-text">a.has-a</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA-%E2%80%9Cis-implemented-in-terms-of%E2%80%9D"><span class="toc-number">41.0.0.2.2.</span> <span class="toc-text">b.根据某物实现出(“is-implemented-in-terms-of”)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%A4%8D%E5%90%88%E5%8F%91%E7%94%9F%E4%BA%8E%E5%BA%94%E7%94%A8%E5%9F%9F%EF%BC%88%E4%BA%BA-%E6%B1%BD%E8%BD%A6-%E4%B8%80%E5%BC%A0%E5%BC%A0%E8%A7%86%E9%A2%91%E7%94%BB%E9%9D%A2%E7%AD%89%EF%BC%89%E5%86%85%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4-%E8%A1%A8%E7%8E%B0%E5%87%BAhas-a%E5%85%B3%E7%B3%BB-%E5%BD%93%E5%AE%83%E5%8F%91%E7%94%9F%E4%BA%8E%E5%AE%9E%E7%8E%B0%E5%9F%9F%EF%BC%88%E7%BC%93%E5%86%B2%E5%8C%BA-%E4%BA%92%E6%96%A5%E5%99%A8-%E6%9F%A5%E6%89%BE%E6%A0%91%E7%AD%89%EF%BC%89%E5%88%99%E6%98%AF%E8%A1%A8%E7%8E%B0%E5%87%BA-%E2%80%9Cis-implemented-in-terms-of%E2%80%9D%E5%85%B3%E7%B3%BB"><span class="toc-number">41.0.0.3.</span> <span class="toc-text">当复合发生于应用域（人,汽车,一张张视频画面等）内的对象之间,表现出has-a关系;当它发生于实现域（缓冲区,互斥器,查找树等）则是表现出 “is implemented-in-terms-of”关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-has-a-%E5%92%8C-is-a-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%BE%88%E5%A5%BD%E5%8C%BA%E5%88%86-%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8Eis-a-%E5%92%8C-is-implemented-in-terms-of-%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA-%E4%B9%A6%E4%B8%AD%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%94%B1list-%E5%AE%9E%E7%8E%B0-set-%E7%9A%84%E4%BE%8B%E5%AD%90-%E7%94%B1%E4%BA%8Eset%E5%B9%B6%E4%B8%8D%E6%98%AFlist-%E5%8F%AA%E6%98%AF%E5%80%9F%E7%94%B1list%E7%9A%84%E6%9C%BA%E8%83%BD%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0set-%E6%89%80%E4%BB%A5%E4%B8%8D%E7%AC%A6%E5%90%88is-a%E5%85%B3%E7%B3%BB-%E9%87%87%E7%94%A8-is-implemented-in-terms-of%E5%85%B3%E7%B3%BB"><span class="toc-number">41.0.0.4.</span> <span class="toc-text">3.has-a 和 is-a 的区别很好区分,关键在于is-a 和 is-implemented-in-terms-of(根据某物实现出),书中给出一个由list 实现 set 的例子,由于set并不是list,只是借由list的机能复用代码实现set,所以不符合is-a关系,采用 is-implemented-in-terms-of关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-30"><span class="toc-number">41.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%8D%E5%90%88-composition-%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8Cpublic%E7%BB%A7%E6%89%BF%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%90%8C"><span class="toc-number">41.1.0.1.</span> <span class="toc-text">1.复合(composition)的意义和public继承完全不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%BA%94%E7%94%A8%E5%9F%9F-%E5%A4%8D%E5%90%88%E6%84%8F%E5%91%B3%E7%9D%80-has-a%EF%BC%8C%E5%9C%A8%E5%AE%9E%E7%8E%B0%E5%9F%9F-%E5%A4%8D%E5%90%88%E6%84%8F%E5%91%B3%E7%9D%80-is-implemented-in-terms-of"><span class="toc-number">41.1.0.2.</span> <span class="toc-text">2.在应用域,复合意味着 has-a，在实现域,复合意味着 is-implemented-in-terms-of</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-39-%E6%98%8E%E6%99%BA%E8%BF%98%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF"><span class="toc-number">42.</span> <span class="toc-text">条款 39 : 明智还审慎地使用private继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-private%E7%BB%A7%E6%89%BF%E4%B8%8B-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E4%B8%80%E4%B8%AAderived-class-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%80%E4%B8%AA-base-class-%E5%AF%B9%E8%B1%A1"><span class="toc-number">42.0.0.1.</span> <span class="toc-text">1.private继承下,编译器不会自动将一个derived class 对象转换成一个 base class 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-private%E7%BB%A7%E6%89%BF%E6%84%8F%E5%91%B3%E8%BF%99implemented-in-terms-o-%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA-%E5%A6%82%E6%9E%9CD%E4%BB%A5private%E5%BD%A2%E5%BC%8F%E7%BB%A7%E6%89%BFB-%E6%84%8F%E6%80%9D%E6%98%AFD%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AEB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E8%80%8C%E5%BE%97-%E5%86%8D%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E6%84%8F%E6%B6%B5%E4%BA%86"><span class="toc-number">42.0.0.2.</span> <span class="toc-text">2.private继承意味这implemented-in-terms-o(根据某物实现出),如果D以private形式继承B,意思是D对象根据B对象实现而得,再没有其他意涵了</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#private%E5%9C%A8%E8%AE%BE%E8%AE%A1%E5%B1%82%E9%9D%A2%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89-%E5%85%B6%E6%84%8F%E4%B9%89%E5%8F%AA%E5%AD%98%E5%9C%A8%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%B1%82%E9%9D%A2"><span class="toc-number">42.0.0.2.0.1.</span> <span class="toc-text">private在设计层面上没有意义,其意义只存在软件实现层面</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%80%83%E8%99%91%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-%E8%AE%BE%E5%AE%9A%E6%9F%90%E7%A7%8D%E8%AE%A1%E6%97%B6%E5%99%A8-%E8%AE%B0%E5%BD%95Widget%E6%AF%8F%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">42.0.0.3.</span> <span class="toc-text">3.考虑下述例子,设定某种计时器,记录Widget每个成员函数被调用的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E4%B8%AA%E5%A5%BD%E8%AE%BE%E8%AE%A1-%E4%BD%86private%E7%BB%A7%E6%89%BF%E7%BB%9D%E9%9D%9E%E5%BF%85%E8%A6%81-%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E4%BB%A5%E5%A4%8D%E5%90%88%E5%8F%96%E8%80%8C%E4%BB%A3%E4%B9%8B"><span class="toc-number">42.0.0.4.</span> <span class="toc-text">这是个好设计,但private继承绝非必要,另一种做法是以复合取而代之</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E8%80%83%E8%99%91%E5%B0%86Widget%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E-%E5%8F%AF%E4%BB%A5%E5%B0%86class-WidgetTimer%E5%88%86%E7%A6%BB%E5%87%BA%E5%8E%BB-Widget%E5%86%85%E5%8F%AA%E7%95%99%E4%B8%80%E4%B8%AAWidgetTimer-%E6%8C%87%E9%92%88"><span class="toc-number">42.0.0.5.</span> <span class="toc-text">4.如果考虑将Widget的编译依存性降至最低,可以将class WidgetTimer分离出去,Widget内只留一个WidgetTimer* 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%95%E6%97%B6%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E2%80%9Dprivate%E7%BB%A7%E6%89%BF%E2%80%9D%E8%80%8C%E4%B8%8D%E6%98%AF%E2%80%9D%E7%BB%A7%E6%89%BF%E5%8A%A0%E5%A4%8D%E5%90%88%E2%80%9D-%E8%BF%99%E4%B8%80%E7%A7%8D%E6%BF%80%E8%BF%9B%E6%83%85%E5%86%B5%E6%B6%89%E5%8F%8A%E7%A9%BA%E9%97%B4%E6%9C%80%E4%BC%98%E5%8C%96"><span class="toc-number">42.0.0.6.</span> <span class="toc-text">5.何时优先选择”private继承”而不是”继承加复合”?,这一种激进情况涉及空间最优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E4%BD%A0%E6%89%80%E5%A4%84%E7%90%86%E7%9A%84class%E4%B8%8D%E5%B8%A6%E4%BB%BB%E4%BD%95%E6%95%B0%E6%8D%AE%E6%98%AF-%E8%BF%99%E6%A0%B7%E7%9A%84class%E6%B2%A1%E6%9C%89non-static%E5%8F%98%E9%87%8F-%E6%B2%A1%E6%9C%89virtual%E5%87%BD%E6%95%B0-%E4%BC%9A%E5%B8%A6%E6%9D%A5vptr-%E6%9D%A1%E6%AC%BE7-%E4%B9%9F%E6%B2%A1%E6%9C%89virtual-base-classes-%E4%B9%9F%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BD%93%E7%A7%AF%E4%B8%8A%E7%9A%84%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80-%E6%9D%A1%E6%AC%BE40-%E8%BF%99%E7%A7%8D%E6%89%80%E8%B0%93%E7%9A%84-Empty-Class-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E7%A9%BA%E9%97%B4-%E4%BD%86C-%E5%AE%98%E6%96%B9%E4%BC%9A%E5%AE%89%E6%8F%92%E4%B8%80%E4%B8%AAchar%E5%88%B0%E7%A9%BA%E5%AF%B9%E8%B1%A1%E4%B8%AD-%E8%A3%81%E5%AE%9A%E5%87%A1%E6%98%AF%E7%8B%AC%E7%AB%8B-%E9%9D%9E%E9%99%84%E5%B1%9E-%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%BF%85%E9%A1%BB%E6%9C%89%E9%9D%9E%E9%9B%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">42.0.0.6.0.1.</span> <span class="toc-text">只适用于你所处理的class不带任何数据是.这样的class没有non-static变量,没有virtual函数(会带来vptr,条款7),也没有virtual base classes(也会导致体积上的额外开销,条款40), 这种所谓的 Empty Class 不使用任何空间,但C++官方会安插一个char到空对象中,裁定凡是独立(非附属)对象都必须有非零大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A4%E6%97%B6%E9%87%87%E7%94%A8%E5%A4%8D%E5%90%88%E7%9A%84%E8%AF%9D-HoldAnInt%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%BB%85%E4%BB%85%E5%8F%98%E5%A4%A7-%E8%BF%98%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%AD%A2%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AAchar%E7%9A%84%E5%A4%A7%E5%B0%8F-%E7%94%B1%E4%BA%8E%E9%BD%90%E4%BD%8D%E9%9C%80%E6%B1%82-%E6%9D%A1%E6%AC%BE50-%E5%A6%82%E5%9C%A8clion%E4%B8%8B-HoldAnInt%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%98%E4%B8%BA-8"><span class="toc-number">42.0.0.7.</span> <span class="toc-text">此时采用复合的话,HoldAnInt的对象不仅仅变大,还可能不止获得一个char的大小,由于齐位需求(条款50),如在clion下,HoldAnInt的大小变为 8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E8%BE%83%E5%B0%91-%E6%89%80%E4%BB%A5%E9%80%9A%E5%B8%B8%E9%87%87%E7%94%A8%E5%A4%8D%E5%90%88"><span class="toc-number">42.0.0.8.</span> <span class="toc-text">这种情况较少,所以通常采用复合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-31"><span class="toc-number">42.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-private-%E6%84%8F%E5%91%B3%E7%9D%80-%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA-%E5%AE%83%E9%80%9A%E5%B8%B8%E6%AF%94%E5%A4%8D%E5%90%88%E7%9A%84%E7%BA%A7%E5%88%AB%E4%BD%8E"><span class="toc-number">42.1.0.1.</span> <span class="toc-text">1.private 意味着 根据某物实现出.它通常比复合的级别低.</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%86%E6%98%AF%E5%BD%93derived-class-%E9%9C%80%E8%A6%81%E8%AE%BF%E9%97%AE-protected-base-class-%E7%9A%84%E6%88%90%E5%91%98-%E6%88%96%E9%9C%80%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84virtual-%E5%87%BD%E6%95%B0%E6%97%B6-%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7"><span class="toc-number">42.1.0.1.0.1.</span> <span class="toc-text">但是当derived class 需要访问 protected base class 的成员,或需重新定义继承而来的virtual 函数时,可以这样</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-private%E7%BB%A7%E6%89%BF%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0-EBO-%E7%A9%BA%E7%99%BD%E5%9F%BA%E7%B1%BB%E6%9C%80%E4%BC%98%E5%8C%96-%EF%BC%8C%E8%BF%99%E5%AF%B9%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%BC%80%E5%8F%91%E8%80%85%E5%8F%AF%E8%83%BD%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-number">42.1.0.2.</span> <span class="toc-text">2.private继承可以实现,EBO(空白基类最优化)，这对于程序库开发者可能很重要</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">43.</span> <span class="toc-text">条款 40 : 明智而审慎地使用多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8Cbase-class-%E4%B8%AD%E5%90%AB%E6%9C%89%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%B0%83%E7%94%A8%E5%8F%91%E7%94%9F%E6%AD%A7%E4%B9%89-p192"><span class="toc-number">43.0.0.1.</span> <span class="toc-text">1.不同base class 中含有同名函数会导致调用发生歧义 p192</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E6%97%B6-%E5%BA%94%E9%87%87%E7%94%A8virtual-%E7%BB%A7%E6%89%BF-%E9%98%B2%E6%AD%A2%E5%90%AB%E6%9C%89%E5%A4%9A%E4%BB%BD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">43.0.0.2.</span> <span class="toc-text">2.菱形继承时,应采用virtual 继承 防止含有多份成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-virtual-%E7%BB%A7%E6%89%BF%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%A2%9D%E5%A4%96%E7%9A%84%E5%BC%80%E9%94%80%E4%BB%A3%E4%BB%B7"><span class="toc-number">43.0.0.3.</span> <span class="toc-text">3.virtual 继承会导致额外的开销代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-p195%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%89%AF%E5%A5%BD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%BE%8B%E5%AD%90"><span class="toc-number">43.0.0.4.</span> <span class="toc-text">4.p195给出一个良好的多重继承例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7-%E6%98%AF%E5%90%A6%E9%87%87%E7%94%A8%E5%8F%96%E5%86%B3%E4%BA%8E%E4%BD%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88-%E9%87%87%E7%94%A8%E5%A4%9A%E9%87%8D%E8%BF%98%E6%98%AF%E5%8D%95%E4%B8%80%E5%93%AA%E7%A7%8D%E6%95%88%E6%9E%9C%E6%9B%B4%E5%A5%BD"><span class="toc-number">43.0.0.5.</span> <span class="toc-text">5.多重继承只是一个工具,是否采用取决于你的设计方案,采用多重还是单一哪种效果更好</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-32"><span class="toc-number">43.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%AF%94%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E5%A4%8D%E6%9D%82%EF%BC%8C%E4%BB%96%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E6%96%B0%E7%9A%84%E6%AD%A7%E4%B9%89%E6%80%A7-%E4%BB%A5%E5%8F%8A%E5%AF%B9virtual%E5%87%BD%E6%95%B0%E7%9A%84%E9%9C%80%E8%A6%81"><span class="toc-number">43.1.0.1.</span> <span class="toc-text">1.多重继承比单一继承复杂，他可能导致新的歧义性,以及对virtual函数的需要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-virtual%E7%BB%A7%E6%89%BF%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%A4%A7%E5%B0%8F-%E9%80%9F%E5%BA%A6-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%AD%89%E6%88%90%E6%9C%AC"><span class="toc-number">43.1.0.2.</span> <span class="toc-text">2.virtual继承会增加大小,速度,初始化复杂度等成本.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E7%A1%AE%E6%9C%89%E6%AD%A3%E5%BD%93%E7%94%A8%E9%80%94-%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%83%85%E8%8A%82%E6%B6%89%E5%8F%8A%E2%80%9Dpublic%E7%BB%A7%E6%89%BF%E6%9F%90%E4%B8%AAInterface-class%E2%80%9D-%E5%92%8C-%E2%80%9Cprivate-%E7%BB%A7%E6%89%BF%E6%9F%90%E4%B8%AA%E5%8D%8F%E5%8A%A9%E5%AE%9E%E7%8E%B0%E7%9A%84class%E2%80%9D%E7%9A%84%E4%B8%A4%E8%80%85%E7%BB%84%E5%90%88-%E5%8F%82%E8%80%83-4-%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">43.1.0.3.</span> <span class="toc-text">3.多重继承的确有正当用途. 其中一个情节涉及”public继承某个Interface class” 和 “private 继承某个协助实现的class”的两者组合,参考 4 中的例子</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-number">44.</span> <span class="toc-text">条款 41 : 了解隐式接口和编译期多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8Eoop-%E4%B8%80%E8%88%AC%E4%BB%A5%E6%98%BE%E7%A4%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E5%A6%82%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">44.0.0.1.</span> <span class="toc-text">1.对于oop 一般以显示接口和运行期多态解决问题,如下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8ETemplate%E5%8F%8A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%BB%8D%E5%AD%98%E5%9C%A8-%E4%BD%86%E9%87%8D%E8%A6%81%E6%80%A7%E5%8F%98%E4%BD%8E-%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81%E7%A7%BB%E5%88%B0%E5%89%8D%E5%A4%B4"><span class="toc-number">44.0.0.2.</span> <span class="toc-text">2.对于Template及泛型编程,显式接口和运行期多态仍存在,但重要性变低,隐式接口和编译期多态移到前头</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-33"><span class="toc-number">44.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-classes-%E5%92%8C-templates-%E9%83%BD%E6%94%AF%E6%8C%81%E6%8E%A5%E5%8F%A3-interfaces-%E5%92%8C-%E5%A4%9A%E6%80%81-ploymorphism"><span class="toc-number">44.1.0.1.</span> <span class="toc-text">1.classes 和 templates 都支持接口(interfaces) 和 多态(ploymorphism)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9class-%E6%8E%A5%E5%8F%A3%E6%98%AF%E6%98%BE%E5%BC%8F%E7%9A%84-%E5%A4%9A%E6%80%81%E5%88%99%E6%98%AF%E9%80%9A%E8%BF%87virtual%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%9C%9F"><span class="toc-number">44.1.0.2.</span> <span class="toc-text">2.对class,接口是显式的,多态则是通过virtual函数发生于运行期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9template-%E6%8E%A5%E5%8F%A3%E6%98%AF%E9%9A%90%E5%BC%8F%E7%9A%84-%E5%A5%A0%E5%9F%BA%E4%BA%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%A4%9A%E6%80%81%E5%88%99%E6%98%AF%E9%80%9A%E8%BF%87template%E5%85%B7%E7%8E%B0%E5%8C%96%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90%E5%8F%91%E7%94%9F%E4%BA%8E%E7%BC%96%E8%AF%91%E6%9C%9F"><span class="toc-number">44.1.0.3.</span> <span class="toc-text">3.对template,接口是隐式的,奠基于表达式.多态则是通过template具现化和函数重载解析发生于编译期.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">45.</span> <span class="toc-text">条款 42 : 了解typename的双重意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E8%80%83%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">45.0.0.1.</span> <span class="toc-text">1.参考下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E4%BE%8B%E5%AD%90%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F-iter-%E5%92%8C-value-iter%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFC-const-iterator-%E5%AE%9E%E9%99%85%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%96%E5%86%B3%E4%BA%8Etemplate%E5%8F%82%E6%95%B0C-template%E5%86%85%E5%87%BA%E7%8E%B0%E7%9A%84%E5%90%8D%E7%A7%B0%E5%A6%82%E6%9E%9C%E7%9B%B8%E4%BE%9D%E4%BA%8E%E6%9F%90%E4%B8%AAtemplate%E5%8F%82%E6%95%B0-%E7%A7%B0%E4%B9%8B%E4%B8%BA%E4%BB%8E%E5%B1%9E%E5%90%8D%E7%A7%B0-%E5%A6%82%E6%9E%9C%E4%BB%8E%E5%B1%9E%E5%90%8D%E7%A7%B0%E5%9C%A8class%E5%86%85%E5%91%88%E5%B5%8C%E5%A5%97%E7%8A%B6-%E7%A7%B0%E5%AE%83%E4%B8%BA%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E5%90%8D%E7%A7%B0-%E6%AD%A4%E5%A4%84%E7%9A%84C-const-iterator%E5%B0%B1%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E5%90%8D%E7%A7%B0-%E5%AE%9E%E9%99%85%E4%B8%8A%E5%AE%83%E8%BF%98%E6%98%AF%E4%B8%AA%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0"><span class="toc-number">45.0.0.2.</span> <span class="toc-text">上述例子中出现的两个变量, iter 和 value. iter的类型是C::const_iterator , 实际是什么取决于template参数C. template内出现的名称如果相依于某个template参数,称之为从属名称.如果从属名称在class内呈嵌套状,称它为嵌套从属名称,此处的C::const_iterator就是这样的名称,实际上它还是个嵌套从属类型名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E5%90%8D%E7%A7%B0%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E8%A7%A3%E6%9E%90%E5%9B%B0%E9%9A%BE"><span class="toc-number">45.0.0.3.</span> <span class="toc-text">2.嵌套从属名称可能导致解析困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%9C%A8template%E4%B8%AD%E9%81%AD%E9%81%87%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E5%90%8D%E7%A7%B0-%E5%AE%83%E4%BE%BF%E5%81%87%E8%AE%BE%E8%BF%99%E4%B8%AA%E5%90%8D%E7%A7%B0%E4%B8%8D%E6%98%AF%E7%B1%BB%E5%9E%8B-%E9%99%A4%E9%9D%9E%E4%BD%A0%E5%91%8A%E8%AF%89%E5%AE%83%E6%98%AF-%E6%89%80%E4%BB%A5%E7%BC%BA%E7%9C%81%E6%83%85%E5%86%B5%E4%B8%8B-%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E5%90%8D%E7%A7%B0%E4%B8%8D%E6%98%AF%E7%B1%BB%E5%9E%8B-%E4%BD%86%E6%9C%89%E4%BE%8B%E5%A4%96"><span class="toc-number">45.0.0.4.</span> <span class="toc-text">3.解析器在template中遭遇一个嵌套从属名称,它便假设这个名称不是类型,除非你告诉它是.所以缺省情况下,嵌套从属名称不是类型,但有例外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%83%B3%E8%A6%81%E5%91%8A%E8%AF%89%E8%A7%A3%E6%9E%90%E5%99%A8%E6%98%AF-%E9%9C%80%E8%A6%81%E5%9C%A8%E5%89%8D%E9%9D%A2%E5%8A%A0%E4%B8%8A%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">45.0.0.5.</span> <span class="toc-text">4.想要告诉解析器是,需要在前面加上关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BE%8B%E5%A4%96%E6%98%AF-typename%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%87%BA%E7%8E%B0%E5%9C%A8base-classes-list%E5%86%85%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0%E4%B9%8B%E5%89%8D-%E4%B9%9F%E4%B8%8D%E5%8F%AF%E5%9C%A8member-initialization-list-%E4%B8%AD%E4%BD%9C%E4%B8%BAbase-class-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">45.0.0.6.</span> <span class="toc-text">5.例外是,typename不可以出现在base classes list内的嵌套从属类型名称之前,也不可在member initialization list 中作为base class 修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-34"><span class="toc-number">45.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8Etemplate-%E5%8F%82%E6%95%B0%E6%97%B6-%E5%89%8D%E7%BC%80%E5%85%B3%E9%94%AE%E5%AD%97class-%E5%92%8C-typename-%E5%8F%AF%E4%BB%A5%E5%91%BC%E5%94%A4"><span class="toc-number">45.1.0.1.</span> <span class="toc-text">1.声明template 参数时,前缀关键字class 和 typename 可以呼唤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97typename%E6%A0%87%E8%AF%86%E5%B5%8C%E5%A5%97%E4%BB%8E%E5%B1%9E%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0-%E4%BD%86%E4%B8%8D%E5%BE%97%E5%9C%A8base-class-lists-%E5%9F%BA%E7%B1%BB%E5%88%97-%E6%88%96-member-initialization-list-%E6%88%90%E5%91%98%E5%88%9D%E5%80%BC%E5%88%97-%E5%86%85%E4%BB%A5%E5%AE%83%E4%BD%9C%E4%B8%BAbase-class-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">45.1.0.2.</span> <span class="toc-text">2.请使用关键字typename标识嵌套从属类型名称,但不得在base class lists(基类列) 或 member initialization list(成员初值列)内以它作为base class 修饰符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-43-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">46.</span> <span class="toc-text">条款 43 : 学习处理模板化基类的名称</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-4"><span class="toc-number">46.0.0.1.</span> <span class="toc-text">1.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">46.0.0.2.</span> <span class="toc-text">2.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%B3%A8%E9%87%8A%E6%89%80%E8%A8%80-base-class-%E8%A2%AB%E6%8C%87%E5%AE%9A%E4%B8%BAMsgSender-lt-CompanyZ-gt-%E4%B8%8D%E5%90%88%E7%90%86-%E4%BB%A5%E4%B8%BA%E9%82%A3%E4%B8%AA%E7%89%B9%E5%8C%96%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9BsendClear%E5%87%BD%E6%95%B0-%E8%BF%99%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%92%E7%BB%9D%E8%B0%83%E7%94%A8"><span class="toc-number">46.0.0.3.</span> <span class="toc-text">如注释所言,base class 被指定为MsgSender&lt;.CompanyZ&gt;不合理.以为那个特化中没有提供sendClear函数,这就是为什么拒绝调用.</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3-%E4%B9%9F%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%81%AD%E9%81%87class-template%E6%97%B6%E4%B8%8D%E6%B8%85%E6%A5%9A%E5%AE%83%E7%BB%A7%E6%89%BF%E4%BA%86%E4%BB%80%E4%B9%88-%E5%9B%A0%E4%B8%BA%E5%AE%83%E7%9F%A5%E9%81%93base-class-templates%E5%8F%AF%E8%83%BD%E8%A2%AB%E7%89%B9%E5%8C%96-%E8%80%8C%E9%82%A3%E4%B8%AA%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC%E4%B8%8D%E6%8F%90%E4%BE%9B%E5%92%8C%E4%B8%80%E8%88%AC%E6%80%A7template%E7%9B%B8%E5%90%8C%E7%9A%84%E6%8E%A5%E5%8F%A3-%E5%9B%A0%E6%AD%A4%E5%AE%83%E5%BE%80%E5%BE%80%E6%8B%92%E7%BB%9D%E5%9C%A8-templatized-base-classes-%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB-%E5%86%85%E5%AF%BB%E6%89%BE%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">46.0.0.3.1.</span> <span class="toc-text">个人理解:也是为什么会出现遭遇class template时不清楚它继承了什么,因为它知道base class templates可能被特化,而那个特化版本不提供和一般性template相同的接口. 因此它往往拒绝在 templatized base classes(模板化基类)内寻找继承而来的名称</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E6%AD%A4%E6%9C%89%E4%B8%89%E7%A7%8D%E5%8A%9E%E6%B3%95%E4%BD%BF%E5%BE%97C-%E2%80%9D%E4%B8%8D%E8%BF%9B%E5%85%A5-templatized-base-classes%E8%A7%82%E5%AF%9F%E2%80%9D%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%A4%B1%E6%95%88"><span class="toc-number">46.0.0.4.</span> <span class="toc-text">3.对此有三种办法使得C++”不进入 templatized base classes观察”的行为失效</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-%E4%BD%BF%E7%94%A8this-gt"><span class="toc-number">46.0.0.4.1.</span> <span class="toc-text">a.使用this-&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-%E4%BD%BF%E7%94%A8using-%E5%A3%B0%E6%98%8E%E5%BC%8F%EF%BC%88%E6%9D%A1%E6%AC%BE33"><span class="toc-number">46.0.0.4.2.</span> <span class="toc-text">b.使用using 声明式（条款33)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%BD%E7%84%B6%E4%BD%BF%E7%94%A8using%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E9%87%8C%E6%9C%89%E6%95%88%E8%BF%90%E4%BD%9C-%E4%BD%86%E4%B8%A4%E5%A4%84%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8D%E7%9B%B8%E5%90%8C-%E8%BF%99%E9%87%8C%E7%9A%84%E6%83%85%E5%86%B5%E5%B9%B6%E4%B8%8D%E6%98%AFbase-class%E5%90%8D%E7%A7%B0%E8%A2%AB%E9%81%AE%E6%8E%A9-%E8%80%8C%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E8%BF%9B%E5%85%A5base-class%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9F%A5%E6%89%BE-%E4%BA%8E%E6%98%AF%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87using%E5%91%8A%E8%AF%89%E5%AE%83-%E8%AE%A9%E5%AE%83%E8%BF%99%E4%B9%88%E5%81%9A"><span class="toc-number">46.0.0.4.3.</span> <span class="toc-text">虽然使用using也可以在这里有效运作,但两处解决的问题不相同,这里的情况并不是base class名称被遮掩,而是编译器不进入base class作用域查找,于是我们通过using告诉它,让它这么做</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E6%98%8E%E7%99%BD%E6%8C%87%E5%87%BA%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%8D%E4%BA%8Ebase-class-%E5%86%85"><span class="toc-number">46.0.0.4.4.</span> <span class="toc-text">c.明白指出被调用的函数位于base class 内</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8A%E8%BF%B0%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%A7%A3%E6%B3%95%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E9%83%BD%E7%9B%B8%E5%90%8C-%E5%AF%B9%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%BF%E8%AF%BA-%E2%80%9Cbase-class-templates%E7%9A%84%E4%BB%BB%E4%BD%95%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC%E9%83%BD%E5%B0%86%E6%94%AF%E6%8C%81%E5%85%B6%E4%B8%80%E8%88%AC-%E6%B3%9B%E5%8C%96-%E7%89%88%E6%9C%AC%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%A5%E5%8F%A3%E2%80%9D"><span class="toc-number">46.0.0.5.</span> <span class="toc-text">4.上述的每个解法做的事情都相同,对编译器承诺: “base class templates的任何特化版本都将支持其一般(泛化)版本所提供的接口”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-35"><span class="toc-number">46.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E5%9C%A8derived-class-templates-%E5%86%85%E9%80%9A%E8%BF%87-%E2%80%9Cthis-gt-%E2%80%9D%E6%8C%87%E6%B6%89base-class-templates-%E5%86%85%E7%9A%84%E6%88%90%E5%91%98%E5%90%8D%E7%A7%B0-%E6%88%96%E7%B1%8D%E7%94%B1%E4%B8%80%E4%B8%AA%E6%98%8E%E7%99%BD%E5%86%99%E5%87%BA%E7%9A%84%E2%80%9Dbase-class-%E8%B5%84%E6%A0%BC%E4%BF%AE%E9%A5%B0%E7%AC%A6%E2%80%9D%E5%AE%8C%E6%88%90"><span class="toc-number">46.1.0.1.</span> <span class="toc-text">1.可在derived class templates 内通过 “this-&gt;”指涉base class templates 内的成员名称,或籍由一个明白写出的”base class 资格修饰符”完成</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-44-%E5%B0%86%E4%BA%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplates"><span class="toc-number">47.</span> <span class="toc-text">条款 44 : 将于参数无关的代码抽离templates</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8Enon-template%E4%BB%A3%E7%A0%81%E4%B8%AD-%E9%87%8D%E5%A4%8D%E5%8D%81%E5%88%86%E6%98%8E%E7%A1%AE-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E2%80%9D%E7%9C%8B%E2%80%9D%E5%88%B0%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E4%B8%A4%E4%B8%AAclasses%E4%B9%8B%E9%97%B4%E6%9C%89%E9%87%8D%E5%A4%8D-%E4%BD%86%E5%9C%A8template%E4%BB%A3%E7%A0%81%E4%B8%AD-%E9%87%8D%E5%A4%8D%E5%BE%88%E9%9A%90%E6%99%A6"><span class="toc-number">47.0.0.1.</span> <span class="toc-text">1.对于non-template代码中,重复十分明确:你可以”看”到两个函数或两个classes之间有重复,但在template代码中,重复很隐晦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E5%AF%BC%E8%87%B4%E5%85%B7%E7%8E%B0%E5%8C%96%E4%BA%86%E4%B8%A4%E6%AC%A1invert%E5%87%BD%E6%95%B0"><span class="toc-number">47.0.0.2.</span> <span class="toc-text">这导致具现化了两次invert函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%AD%A4%E5%8F%AF%E4%BB%A5%E5%B0%86%E9%87%8D%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB%E5%87%BA-%E5%85%B1%E4%BA%AB%E4%B8%80%E4%BB%BD"><span class="toc-number">47.0.0.3.</span> <span class="toc-text">2.对此可以将重复的代码抽离出,共享一份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A4%E5%A4%84%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82"><span class="toc-number">47.0.0.4.</span> <span class="toc-text">此处的几个细节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-private%E7%BB%A7%E6%89%BF-%E5%9B%A0%E4%B8%BA%E8%BF%99%E9%87%8C%E7%9A%84base-class-%E5%8F%AA%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B8%AE%E5%8A%A9%E5%AE%9E%E7%8E%B0derived-class-%EF%BC%8C%E4%B8%8D%E6%98%AFis-a%E5%85%B3%E7%B3%BB"><span class="toc-number">47.0.0.4.1.</span> <span class="toc-text">a.private继承,因为这里的base class 只是用来帮助实现derived class ，不是is-a关系</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E5%87%A0%E7%82%B9%E7%9A%84%E7%90%86%E8%A7%A3%E6%88%91%E7%9A%84%E5%92%8C%E4%B9%A6%E4%B8%8A%E7%9A%84%E6%9C%89%E5%87%BA%E5%85%A5"><span class="toc-number">47.0.0.4.1.1.</span> <span class="toc-text">另外几点的理解我的和书上的有出入</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A-%E6%AD%A4%E5%A4%84%E7%9A%84using%E5%A3%B0%E6%98%8E%E7%94%A8%E6%9D%A5%E9%81%BF%E5%85%8D%E9%9A%90%E8%97%8F-%E5%AF%B9%E4%BA%8Ethis-gt-%E8%8B%A5%E4%B8%8D%E7%94%A8-%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BC%9A%E8%A2%ABderived-classes%E9%81%AE%E7%9B%96"><span class="toc-number">47.0.0.4.2.</span> <span class="toc-text">书上:此处的using声明用来避免隐藏, 对于this-&gt;若不用,模板化基类的函数名会被derived classes遮盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84-%E6%AD%A4%E5%A4%84%E7%9A%84using%E5%A3%B0%E6%98%8E%E9%81%BF%E5%85%8D%E9%9A%90%E8%97%8F%E7%9A%84%E5%90%8C%E6%97%B6-%E8%AE%A9%E4%B8%8D%E8%BF%9B%E5%85%A5%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%A4%B1%E6%95%88-this-gt-%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%9C%89%E7%82%B9%E5%A4%9A%E4%BD%99%E4%BA%86-%E4%B8%94%E6%97%A0%E6%B3%95%E5%81%9A%E5%88%B0%E6%8E%92%E9%99%A4derived%E7%9A%84%E9%81%AE%E7%9B%96-%E6%AD%A4%E5%A4%84%E7%9A%84%E4%BE%8B%E5%AD%90%E5%88%9A%E5%A5%BD%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E4%BA%86%E9%87%8D%E8%BD%BD-%E8%8B%A5%E5%8F%98%E4%B8%BA%E6%97%A0%E5%8F%82-%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%98%E6%98%AFderived-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">47.0.0.4.3.</span> <span class="toc-text">我的:此处的using声明避免隐藏的同时,让不进入模板化基类的行为失效,this-&gt;在此处有点多余了,且无法做到排除derived的遮盖,此处的例子刚好参数不同导致了重载,若变为无参,调用的还是derived 中的函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SquareMatrixBase-invert%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E8%AF%A5%E6%93%8D%E4%BD%9C%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE-%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B"><span class="toc-number">47.0.0.5.</span> <span class="toc-text">3.SquareMatrixBase::invert如何知道该操作什么数据,完整的实现如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-p216%E9%9D%A2%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86%E6%9C%AA%E7%90%86%E8%A7%A3-%E5%A4%A7%E6%A6%82%E6%84%8F%E6%80%9D%E6%98%AF1-%E6%8A%BD%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E5%88%B0%E6%96%B0%E7%9A%84%E7%B1%BB%E5%AF%BC%E8%87%B4%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%A2%9E%E5%8A%A0-%E6%AD%A4%E5%A4%84%E5%B0%B1%E6%98%AF%E5%A4%9A%E4%BA%86%E4%B8%80%E4%B8%AAdata%E6%8C%87%E9%92%882-%E6%AD%A4%E5%A4%84%E7%9A%84n%E5%9C%A8%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E8%AF%9D%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%9C%89%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BC%98%E5%8C%96-%E4%BD%86%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%AF%9D%E5%B0%B1%E5%A4%B1%E5%8E%BB%E4%BA%86%E8%BF%99%E4%BA%9B%E4%BC%98%E5%8C%96-%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E6%8A%BD%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81-%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E5%81%9A%E5%87%BA%E9%80%89%E6%8B%A9"><span class="toc-number">47.0.0.6.</span> <span class="toc-text">4.p216面下半部分未理解 大概意思是1.抽取公共代码到新的类导致对象大小的增加,此处就是多了一个data指针2.此处的n在模板参数中的话可能会有更多的优化,但作为函数参数的话就失去了这些优化  是否应该抽取公共代码,需要根据实际做出选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%9B%AE%E5%89%8D%E8%BF%99%E4%B8%AA%E6%9D%A1%E6%AC%BE%E5%8F%AA%E8%AE%A8%E8%AE%BA%E4%BA%86non-type-template-parameters-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0-%E5%B8%A6%E6%9D%A5%E7%9A%84%E8%86%A8%E8%83%80-%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E8%86%A8%E8%83%80%E6%98%AF%E7%94%B1%E4%BA%8E%E7%9B%B8%E5%90%8C%E7%AE%97%E6%B3%95%E5%A4%9A%E6%AC%A1%E5%85%B7%E7%8E%B0%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84-%E5%9C%A8%E6%9C%AC%E4%BE%8B%E5%B0%B1%E6%98%AF%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86%E8%BF%90%E7%AE%97%E7%AE%97%E6%B3%95%E5%B8%A6%E6%9D%A5%E7%9A%84-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-type-parameters-%E4%B9%9F%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%86%A8%E8%83%80-%E4%BE%8B%E5%A6%82%E8%AE%B8%E5%A4%9A%E5%B9%B3%E5%8F%B0%E4%B8%8A-int-%E5%92%8C-long-%E6%9C%89%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E8%BF%B0-%E6%89%80%E4%BB%A5%E5%83%8Fvector-lt-int-gt-%E5%92%8Cvector-lt-long-gt-%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9C%89%E5%8F%AF%E8%83%BD%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C-%E8%BF%99%E5%B0%B1%E5%AF%BC%E8%87%B4%E4%BA%86%E8%86%A8%E8%83%80"><span class="toc-number">47.0.0.7.</span> <span class="toc-text">5.目前这个条款只讨论了non-type template parameters (非类型模板参数)带来的膨胀,也就是代码的膨胀是由于相同算法多次具现化导致的,在本例就是矩阵的逆运算算法带来的.类型参数(type parameters)也会导致膨胀,例如许多平台上 int 和 long 有完全相同的二进制表述, 所以像vector&lt;int.&gt;和vector&lt;long.&gt;的成员函数有可能完全相同,这就导致了膨胀</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-36"><span class="toc-number">47.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Templates%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AAclasses%E5%92%8C%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0-%E6%89%80%E4%BB%A5%E4%BB%BB%E4%BD%95template%E4%BB%A3%E7%A0%81%E9%83%BD%E4%B8%8D%E8%AF%A5%E4%BA%8E%E6%9F%90%E4%B8%AA%E9%80%A0%E6%88%90%E8%86%A8%E8%83%80%E7%9A%84template%E5%8F%82%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9B%B8%E4%BE%9D%E5%85%B3%E7%B3%BB-%E7%90%86%E8%A7%A3-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%97%B6%E5%BA%94%E9%81%BF%E5%85%8D%E4%BA%A7%E7%94%9F%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80"><span class="toc-number">47.1.0.1.</span> <span class="toc-text">1.Templates生成多个classes和多个函数,所以任何template代码都不该于某个造成膨胀的template参数产生相依关系(理解:使用模板时应避免产生代码膨胀)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9B%A0%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%80%8C%E9%80%A0%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80-%E5%BE%80%E5%BE%80%E5%8F%AF%E4%BB%A5%E6%B6%88%E9%99%A4-%E5%81%9A%E6%B3%95%E6%98%AF%E4%BB%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%88%96class%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2template%E5%8F%82%E6%95%B0"><span class="toc-number">47.1.0.2.</span> <span class="toc-text">2.因非类型模板参数而造成的代码膨胀,往往可以消除,做法是以函数参数或class成员变量替换template参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9B%A0%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E8%80%8C%E9%80%A0%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80-%E5%BE%80%E5%BE%80%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E-%E5%81%9A%E6%B3%95%E6%98%AF%E5%B8%A6%E6%9C%89%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E8%BF%B0%E7%9A%84%E5%85%B7%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E7%A0%81"><span class="toc-number">47.1.0.3.</span> <span class="toc-text">3.因类型参数而造成的代码膨胀,往往可以降低,做法是带有完全相同的二进制表述的具现类型共享实现码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">48.</span> <span class="toc-text">条款 45 : 运用成员函数模板接受所有兼容类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%AC%E6%9D%A1%E6%AC%BE%E7%BB%99%E5%87%BA%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E6%8C%87%E5%90%91%E6%9F%90%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">48.0.0.1.</span> <span class="toc-text">1.本条款给出下述例子,定义智能指针,指向某继承体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%8A%E8%BF%B0%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%90%8C%E4%B8%80%E4%B8%AAtemplate%E7%9A%84%E4%B8%8D%E5%90%8C%E5%85%B7%E7%8E%B0%E4%BD%93%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">48.0.0.2.</span> <span class="toc-text">对于上述例子，同一个template的不同具现体之间不存在什么关系</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E6%84%8F%E6%8C%87%E5%A6%82%E6%9E%9C%E4%BB%A5%E5%B8%A6%E6%9C%89base-derived-%E5%85%B3%E7%B3%BB%E7%9A%84B-D%E4%B8%A4%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E5%85%B7%E7%8E%B0%E5%8C%96%E6%9F%90%E4%B8%AAtemplate-%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B7%E7%8E%B0%E4%BD%93-%E5%B9%B6%E4%B8%8D%E5%B8%A6%E6%9C%89base"><span class="toc-number">48.0.0.2.0.1.</span> <span class="toc-text">这里意指如果以带有base-derived 关系的B,D两类型分别具现化某个template,产生的两个具现体,并不带有base</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#derived%E5%85%B3%E7%B3%BB-%E6%89%80%E4%BB%A5%E5%AE%8C%E5%85%A8%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%A4%E4%B8%AAclasses"><span class="toc-number">48.0.0.2.0.2.</span> <span class="toc-text">derived关系,所以完全为不同的两个classes</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%AD%A4%E9%9C%80%E8%A6%81%E7%9A%84%E5%BA%94%E8%AF%A5%E6%98%AFmember-function-template-%EF%BC%8C%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%A8%A1%E6%9D%BF"><span class="toc-number">48.0.0.3.</span> <span class="toc-text">2.对此需要的应该是member function template ，需要一个构造模板</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E4%BE%8B%E5%AD%90%E7%9A%84%E6%84%8F%E6%80%9D-%E5%AF%B9%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8BT%E5%92%8C%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8BU-%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AESmartPtr-lt-U-gt-%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AASmart-lt-T-gt"><span class="toc-number">48.0.0.3.1.</span> <span class="toc-text">上述例子的意思,对任何类型T和任何类型U,这里可以根据SmartPtr&lt;.U&gt;生成一个Smart&lt;T.&gt;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%B1%E6%AD%A4%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E7%9A%84"><span class="toc-number">48.0.0.4.</span> <span class="toc-text">3.由此可以实现我们想要的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5%E5%88%9D%E5%80%BC%E5%88%97%E6%A0%87%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96-%E8%BF%99%E4%B8%AA%E8%A1%8C%E4%B8%BA%E4%BB%85%E5%BD%93U%E6%8C%87%E9%92%88%E8%BD%AC%E4%B8%BA%E4%B8%80%E4%B8%AAT%E6%8C%87%E9%92%88%E6%97%B6%E6%89%8D%E8%83%BD%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91"><span class="toc-number">48.0.0.4.1.</span> <span class="toc-text">以初值列标来初始化,这个行为仅当U指针转为一个T指针时才能通过编译</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%9B%E5%8C%96copyi%E6%9E%84%E9%80%A0%E5%B9%B6%E4%B8%8D%E9%98%BB%E6%AD%A2%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84copy%E6%9E%84%E9%80%A0-%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%90%8C%E6%97%B6%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%8C%96%E7%89%88%E6%9C%AC%E5%92%8C%E6%AD%A3%E5%B8%B8%E7%89%88%E6%9C%AC"><span class="toc-number">48.0.0.5.</span> <span class="toc-text">4.泛化copyi构造并不阻止编译器生成自己的copy构造,你必须同时声明泛化版本和正常版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-4"><span class="toc-number">48.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%BF%E7%94%A8member-function-templates-%E7%94%9F%E6%88%90-%E2%80%9C%E5%8F%AF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B%E2%80%9D%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">48.1.0.1.</span> <span class="toc-text">1.请使用member function templates 生成 “可接受所有兼容类型”的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%A3%B0%E6%98%8E%E7%9A%84member-template-%E7%94%A8%E4%BA%8E%E2%80%9D%E6%B3%9B%E5%8C%96copy%E6%9E%84%E9%80%A0%E2%80%9D%E6%88%96%E2%80%9D%E6%B3%9B%E5%8C%96assignment%E2%80%9D%E6%93%8D%E4%BD%9C-%E4%BD%A0%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E5%A3%B0%E6%98%8E%E6%AD%A3%E5%B8%B8%E7%9A%84copy%E6%9E%84%E9%80%A0%E5%92%8Ccopyassignment%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">48.1.0.2.</span> <span class="toc-text">2.如果你声明的member template 用于”泛化copy构造”或”泛化assignment”操作,你还是需要声明正常的copy构造和copyassignment操作符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">49.</span> <span class="toc-text">条款 46 : 需要类型转换时请为模板定义非成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-5"><span class="toc-number">49.0.0.1.</span> <span class="toc-text">1.对于下述例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BA%E5%9C%A8template%E5%AE%9E%E5%8F%82%E6%8E%A8%E5%88%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BB%8E%E4%B8%8D%E5%B0%86%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E7%BA%B3%E5%85%A5%E8%80%83%E8%99%91"><span class="toc-number">49.0.0.2.</span> <span class="toc-text">因为在template实参推到过程中从不将隐式类型转换函数纳入考虑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-e-g"><span class="toc-number">49.0.0.3.</span> <span class="toc-text">2. e.g</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%86%E6%AD%A4%E5%A4%84-%E6%97%A0%E6%B3%95%E9%93%BE%E6%8E%A5-%E5%9B%A0%E4%B8%BA%E5%85%B7%E7%8E%B0%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99class%E5%86%85%E5%8F%AA%E6%98%AF%E5%A3%B0%E6%98%8E%E4%BA%86-%E4%BD%86%E6%B2%A1%E6%9C%89%E5%AE%9A%E4%B9%89-%E7%B1%BB%E5%A4%96%E9%82%A3%E4%B8%AAtemplate%E5%92%8C%E5%AE%83%E5%85%B3%E7%B3%BB%E4%B8%8D%E5%A4%A7-%E6%89%80%E4%BB%A5%E8%BF%9E%E6%8E%A5%E5%99%A8%E9%93%BE%E6%8E%A5%E4%B8%8D%E4%B8%8A"><span class="toc-number">49.0.0.3.0.1.</span> <span class="toc-text">但此处,无法链接,因为具现化的时候class内只是声明了,但没有定义,类外那个template和它关系不大,所以连接器链接不上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E6%AD%A4%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">49.0.0.4.</span> <span class="toc-text">3.对此最简单的解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E4%B8%BA%E4%BA%86%E5%87%8F%E5%B0%8Finline%E7%9A%84%E5%BD%B1%E5%93%8D-%E9%87%87%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">49.0.0.5.</span> <span class="toc-text">4.另一种做法是为了减小inline的影响,采用辅助函数的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BF%98%E6%9C%89%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95-%E6%95%99%E5%AE%98%E6%8F%90%E5%87%BA%E6%9D%A5%E7%9A%84-%E4%BD%86%E6%88%91%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%9C%89%E9%97%AE%E9%A2%98"><span class="toc-number">49.0.0.6.</span> <span class="toc-text">5.还有一种做法,教官提出来的,但我的编译器上实现有问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-37"><span class="toc-number">49.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%93%E7%BC%96%E5%86%99%E7%9A%84class-template-%E8%80%8C%E5%AE%83%E6%8F%90%E4%BE%9B%E7%9A%84template%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%E6%94%AF%E6%8C%81%E2%80%9D%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E2%80%9D%E6%97%B6%EF%BC%8C%E8%AF%B7%E5%B0%86%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%BAclass-template-%E5%86%85%E7%9A%84-friend%E5%87%BD%E6%95%B0"><span class="toc-number">49.1.0.1.</span> <span class="toc-text">1.当编写的class template , 而它提供的template相关的函数支持”所有参数的隐式转换”时，请将那些函数定义为class template 内的 friend函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-47-%E8%AF%B7%E8%AF%95%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">50.</span> <span class="toc-text">条款 47 : 请试用traits classes表现类型信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8B%E8%BF%B0%E4%BE%8B%E5%AD%90-%E7%BB%99%E5%87%BA%E4%B8%8D%E5%90%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">50.0.0.0.1.</span> <span class="toc-text">首先为更好的理解下述例子,给出不同迭代器的定义:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B7%E6%9C%89%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">50.0.0.0.2.</span> <span class="toc-text">它们之间具有一系列的继承关系:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%B8%AD%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AAadvance%E5%87%BD%E6%95%B0-%E7%94%A8%E6%9D%A5%E5%AF%B9%E6%9F%90%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A7%BB%E5%8A%A8%E6%9F%90%E4%B8%AA%E7%BB%99%E5%AE%9A%E8%B7%9D%E7%A6%BB-%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">50.0.0.1.</span> <span class="toc-text">1.文中给出一个advance函数,用来对某个迭代器移动某个给定距离,代码如下</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E8%BF%99%E6%AE%B5%E8%AF%9D%E7%9A%84%E7%90%86%E8%A7%A3-%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0traits%E6%8A%80%E6%9C%AF%E6%97%B6-%E6%98%AF%E5%9C%A8%E6%AF%8F%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%B8%AD-%E6%AD%A4%E4%BE%8B%E5%AD%90%E4%B8%AD%E5%B0%B1%E6%98%AF%E6%AF%8F%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAtypedef%E8%BF%99%E4%B9%9F%E5%B0%B1%E6%98%AF%E2%80%9D%E7%B1%BB%E5%9E%8B%E5%86%85%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BF%A1%E6%81%AF%E2%80%9D-%E8%80%8C%E6%8C%87%E9%92%88%E4%B9%9F%E7%9B%B8%E5%BD%93%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8-%E4%BD%86%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E4%B8%8D%E6%98%AF%E7%B1%BB-%E4%B9%9F%E5%B0%B1%E4%B8%8D%E5%AD%98%E5%9C%A8%E2%80%9D%E7%B1%BB%E5%9E%8B%E5%86%85%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BF%A1%E6%81%AF%E2%80%9D-%E5%AF%B9%E4%BA%8E%E8%BF%99%E7%A7%8D%E7%B1%BB%E5%9E%8B-tratis%E5%B0%B1%E9%9C%80%E8%A6%81%E6%8F%90%E4%BE%9B%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">50.0.0.1.1.</span> <span class="toc-text">对于这段话的理解,一般实现traits技术时,是在每个类型中,此例子中就是每个迭代器类型中,声明一个typedef这也就是”类型内的嵌套信息”,而指针也相当于迭代器,但普通指针不是类,也就不存在”类型内的嵌套信息”,对于这种类型,tratis就需要提供特化版本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-iterator-traits%E7%9A%84%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F-%E9%92%88%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8BIterT-%E5%9C%A8struct-iterator-traits-lt-IterT-gt-%E5%86%85%E4%B8%80%E5%AE%9A%E5%A3%B0%E6%98%8E%E6%9F%90%E4%B8%AAtypedef%E5%90%8D%E4%B8%BAiterator-category-%E8%BF%99%E4%B8%AAtypedef%E7%94%A8%E6%9D%A5%E7%A1%AE%E8%AE%A4IterT%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">50.0.0.2.</span> <span class="toc-text">2.iterator_traits的运作方式,针对每一个类型IterT,在struct iterator_traits&lt;IterT.&gt;内一定声明某个typedef名为iterator_category,这个typedef用来确认IterT的迭代器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6Iterator-traits%E4%BB%A5%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%E6%9D%A5%E5%AE%9E%E7%8E%B0-%E9%A6%96%E5%85%88%E5%AE%83%E8%A6%81%E6%B1%82%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%BF%85%E9%A1%BB%E5%B5%8C%E5%A5%97%E4%B8%80%E4%B8%AAtypedef-%E5%90%8D%E4%B8%BAiterator-category"><span class="toc-number">50.0.0.2.1.</span> <span class="toc-text">同时Iterator_traits以两个部分来实现,首先它要求自定义的迭代器类型必须嵌套一个typedef ,名为iterator_ category</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%8C%E5%AF%B9%E4%BA%8Eiterator-traits%E7%9A%84%E5%8F%A6%E4%B8%80%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B"><span class="toc-number">50.0.0.3.</span> <span class="toc-text">而对于iterator_traits的另一部分实现如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%99%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0traits-class"><span class="toc-number">50.0.0.4.</span> <span class="toc-text">3.这就是如何实现traits class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tratis-class%E4%BA%86-%E5%AF%B9%E4%BA%8E%E5%85%88%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E5%A6%82%E4%B8%8B%E6%94%B9%E5%86%99"><span class="toc-number">50.0.0.5.</span> <span class="toc-text">4.接下来就是如何使用tratis class了,对于先前的代码可以如下改写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%98%AF-IterT%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E7%A1%AE%E5%AE%9A-%E4%BD%86if%E8%A6%81%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E6%89%8D%E8%A2%AB%E6%A0%B8%E5%AE%9A-%E4%B8%BA%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98-%E5%BC%95%E5%87%BA%E6%9D%A5%E5%8F%A6%E4%B8%80%E5%81%9A%E6%B3%95-%E9%80%9A%E8%BF%87%E9%87%8D%E8%BD%BD%E6%9D%A5%E5%86%B3%E5%AE%9A-%E5%9B%A0%E4%B8%BA%E9%87%8D%E8%BD%BD%E4%BC%9A%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9%E6%9C%80%E5%8C%B9%E9%85%8D%E7%9A%84%E9%87%8D%E8%BD%BD%E4%BB%B6"><span class="toc-number">50.0.0.6.</span> <span class="toc-text">5.还有一个问题是,IterT类型可以在编译期确定,但if要在运行期才被核定,为解决这个问题,引出来另一做法,通过重载来决定,因为重载会优先选择最匹配的重载件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E5%8D%B3%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8traits-class"><span class="toc-number">50.0.0.6.1.</span> <span class="toc-text">上述即是怎么使用traits class</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-38"><span class="toc-number">50.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Tratis-classes%E4%BD%BF%E5%BE%97%E2%80%9D%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E2%80%9D%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%AF%E7%94%A8-%E5%AE%83%E4%BB%AC%E4%BB%A5templates%E5%92%8C-%E2%80%9Ctemplates-%E7%89%B9%E5%8C%96%E2%80%9D-%E5%AE%8C%E6%88%90%E5%AE%9E%E7%8E%B0"><span class="toc-number">50.1.0.1.</span> <span class="toc-text">1.Tratis classes使得”类型相关信息”在编译期可用.它们以templates和 “templates 特化” 完成实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B4%E5%90%88%E9%87%8D%E8%BD%BD%E6%8A%80%E6%9C%AF%E5%90%8E-tratis-classes%E5%8F%AF%E8%83%BD%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E5%AF%B9%E7%B1%BB%E5%9E%8B%E6%89%A7%E8%A1%8Cif%E2%80%A6else%E6%B5%8B%E8%AF%95-%E5%A6%82%E5%90%8C%E4%B9%A6%E4%B8%AD%E4%B8%8A%E8%BF%B0%E4%BE%8B%E5%AD%90"><span class="toc-number">50.1.0.2.</span> <span class="toc-text">2.整合重载技术后,tratis classes可能在编译期对类型执行if…else测试,如同书中上述例子</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-48-%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">51.</span> <span class="toc-text">条款 48 : 认识template元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A5C-%E5%86%99%E6%88%90-%E6%89%A7%E8%A1%8C%E4%B8%8EC-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%86%85%E7%9A%84%E7%A8%8B%E5%BA%8F-%E4%B8%80%E6%97%A6TMP%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9D%9F%E6%89%A7%E8%A1%8C-%E5%85%B6%E8%BE%93%E5%87%BA-%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%BB%8Etemplate%E5%85%B7%E7%8E%B0%E5%87%BA%E6%9D%A5%E7%9A%84%E8%8B%A5%E5%B9%B2C-%E6%BA%90%E7%A0%81-%E4%BE%BF%E4%BC%9A%E4%B8%80%E5%A6%82%E6%97%A2%E5%BE%80%E5%9C%B0%E8%A2%AB%E7%BC%96%E8%AF%91"><span class="toc-number">51.0.0.1.</span> <span class="toc-text">1.以C++写成,执行与C++编译期内的程序.一旦TMP程序结束执行,其输出,也就是从template具现出来的若干C++源码,便会一如既往地被编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TMP%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BC%98%E5%8A%BF-a-%E8%AE%A9%E6%9F%90%E4%BA%9B%E4%BA%8B%E6%83%85%E6%9B%B4%E5%AE%B9%E6%98%93-%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%94%A8TMP%E7%94%9A%E8%87%B3%E4%B8%8D%E5%8F%AF%E8%83%BD-b-TMP%E6%89%A7%E8%A1%8C%E4%BA%8E%E7%BC%96%E8%AF%91%E6%9C%9F-%E7%BC%96%E8%AF%91%E6%9C%9F%E6%89%A7%E8%A1%8C%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84-%E8%BE%83%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6-%E8%BE%83%E7%9F%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%9F-%E8%BE%83%E5%B0%91%E7%9A%84%E5%86%85%E5%AD%98%E9%9C%80%E6%B1%82-%E4%BD%86%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E5%8F%98%E9%95%BF"><span class="toc-number">51.0.0.2.</span> <span class="toc-text">2.TMP的两个优势 a.让某些事情更容易,如果不用TMP甚至不可能 b.TMP执行于编译期,编译期执行带来的好处,较小的文件,较短的运行期,较少的内存需求,但是编译时间变长.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9D%A1%E6%AC%BE47%E6%9B%BE%E8%AF%B4%E8%BF%87%E4%B8%8B%E5%B1%9E%E4%BE%8B%E5%AD%90-%E4%BC%9A%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF"><span class="toc-number">51.0.0.3.</span> <span class="toc-text">3.条款47曾说过下属例子,会编译错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AATMP%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BE%8B%E5%AD%90-%E9%AD%94%E6%B3%95"><span class="toc-number">51.0.0.4.</span> <span class="toc-text">4.一个TMP程序的例子(魔法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8TMP%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%9B%A0%EF%BC%88p237%EF%BC%89"><span class="toc-number">51.0.0.5.</span> <span class="toc-text">为何使用TMP的三个原因（p237）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-39"><span class="toc-number">51.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-TMP-%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B-%E5%8F%AF%E8%AE%B2%E5%B7%A5%E4%BD%9C%E7%94%B1%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%A7%BB%E8%87%B3%E7%BC%96%E8%AF%91%E6%9C%9F-%E7%94%B1%E6%AD%A4%E5%8F%AF%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%97%A9%E6%9C%9F%E9%94%99%E8%AF%AF%E4%BE%A6%E6%B5%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9B%B4%E9%AB%98%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">51.1.0.1.</span> <span class="toc-text">1.TMP (模板元编程)可讲工作由运行期移至编译期,由此可用实现早期错误侦测，以及更高的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TMP%E5%8F%AF%E8%A2%AB%E7%94%A8%E6%9D%A5%E7%94%9F%E6%88%90%E2%80%9D%E5%9F%BA%E4%BA%8E%E6%94%BF%E7%AD%96%E9%80%89%E6%8B%A9%E7%BB%84%E5%90%88%E2%80%9D%E7%9A%84%E5%AE%A2%E6%88%B7%E5%AE%9A%E5%88%B6%E4%BB%A3%E7%A0%81-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E7%94%9F%E6%88%90%E5%AF%B9%E6%9F%90%E4%BA%9B%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%B9%B6%E4%B8%8D%E9%80%82%E5%90%88%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">51.1.0.2.</span> <span class="toc-text">2.TMP可被用来生成”基于政策选择组合”的客户定制代码,也可以避免生成对某些特殊类型并不适合的代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">52.</span> <span class="toc-text">条款 49 : 了解new-handler的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8E%E4%BA%8E-lt-new-gt-%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">52.0.0.1.</span> <span class="toc-text">1.这是一个声明于&lt;new.&gt;的标准程序库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">52.0.0.2.</span> <span class="toc-text">2.下面是一些简单的使用例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AD%A4%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E4%BC%98%E7%A7%80%E7%9A%84new-handler%E5%87%BD%E6%95%B0-%E5%BF%85%E9%A1%BB%E5%81%9A%E4%BB%A5%E4%B8%8B%E4%BA%8B%E6%83%85"><span class="toc-number">52.0.0.3.</span> <span class="toc-text">对此一个设计优秀的new_handler函数,必须做以下事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-C-%E5%B9%B6%E4%B8%8D%E6%94%AF%E6%8C%81class%E4%B8%93%E5%B1%9E%E7%9A%84new-handler-%E4%BD%86%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0-%E5%8F%AA%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E6%8F%90%E4%BE%9Bset-new-handler%E5%92%8Coperator-new%E5%8D%B3%E5%8F%AF"><span class="toc-number">52.0.0.4.</span> <span class="toc-text">3.C++并不支持class专属的new_handler,但你可以自己实现,只需要自己提供set_new_handler和operator new即可</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95%E6%98%AF%E9%87%87%E7%94%A8%E7%BB%A7%E6%89%BF%E5%92%8C%E6%A8%A1%E6%9D%BF"><span class="toc-number">52.0.0.5.</span> <span class="toc-text">4.另一种做法是采用继承和模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A5%E6%8A%80%E6%9C%AF%E8%A2%AB%E7%A7%B0%E4%B8%BA-%E2%80%9C%E6%80%AA%E5%BC%82%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E2%80%9D-CRTP"><span class="toc-number">52.0.0.6.</span> <span class="toc-text">该技术被称为 “怪异的循环模板模式” CRTP</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9Dmixin%E2%80%9D%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%BB%A7%E6%89%BF%E8%82%AF%E5%AE%9A%E5%AF%BC%E8%87%B4%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BA%89%E8%AE%AE-%E8%A7%81%E6%9D%A1%E6%AC%BE40"><span class="toc-number">52.0.0.6.0.1.</span> <span class="toc-text">使用”mixin”风格的继承肯定导致多重继承的争议,见条款40</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-nothrow-new-%E5%92%8C-%E6%99%AE%E9%80%9A%E7%9A%84new-nothrow-new%E5%9C%A8%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5%E6%97%B6%E8%BF%94%E5%9B%9Enull"><span class="toc-number">52.0.0.7.</span> <span class="toc-text">5.nothrow new 和 普通的new , nothrow-new在分配失败时返回null</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#nothrow-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%E8%A7%81p247%E6%9C%80%E4%B8%8A%E9%9D%A2%E4%B8%80%E6%AE%B5"><span class="toc-number">52.0.0.7.0.1.</span> <span class="toc-text">nothrow 的一些理解见p247最上面一段</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-40"><span class="toc-number">52.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-set-new-handler%E5%85%81%E8%AE%B8%E5%AE%A2%E6%88%B7%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-%E5%9C%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5%E6%97%B6%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="toc-number">52.1.0.1.</span> <span class="toc-text">1.set_new_handler允许客户指定一个函数,在内存分配失败时被调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Nothrow-new-%E6%98%AF%E4%B8%80%E4%B8%AA%E9%A2%87%E4%B8%BA%E5%B1%80%E9%99%90%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">52.1.0.2.</span> <span class="toc-text">2.Nothrow new 是一个颇为局限的工具.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-50-%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">53.</span> <span class="toc-text">条款 50 : 了解 new 和 delete的合理替换时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E6%98%AF%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%94%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E8%80%8C%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89"><span class="toc-number">53.0.0.1.</span> <span class="toc-text">就是为啥不用编译期提供的而要自己定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-g-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90-%E4%BF%83%E8%BF%9B%E5%B9%B6%E5%8D%8F%E5%8A%A9%E6%A3%80%E6%B5%8B%E2%80%9Doverruns%E2%80%9D-%E5%86%99%E5%85%A5%E7%82%B9%E5%9C%A8%E5%88%86%E9%85%8D%E5%8C%BA%E5%9D%97%E5%B0%BE%E7%AB%AF%E4%B9%8B%E5%90%8E-%E6%88%96%E2%80%9Dunderruns%E2%80%9D-%E5%86%99%E5%85%A5%E7%82%B9%E5%9C%A8%E5%88%86%E9%85%8D%E5%8C%BA%E5%9D%97%E8%B5%B7%E7%82%B9%E4%B9%8B%E5%89%8D-%E7%9A%84%E5%AE%9A%E5%88%B6-operator-new"><span class="toc-number">53.0.0.2.</span> <span class="toc-text">e.g 是一个例子,促进并协助检测”overruns”(写入点在分配区块尾端之后)或”underruns”(写入点在分配区块起点之前)的定制 operator new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">53.0.0.3.</span> <span class="toc-text">摘要:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-41"><span class="toc-number">53.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%A0%E6%9C%89%E8%AE%B8%E5%A4%9A%E7%90%86%E7%94%B1%E9%9C%80%E8%A6%81%E5%86%99%E4%B8%AA%E8%87%AA%E5%AE%9A%E7%9A%84new%E5%92%8Cdelte-%E6%9C%AC%E6%9D%A1%E6%AC%BE%E5%B0%B1%E6%98%AF%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">53.1.0.1.</span> <span class="toc-text">1.你有许多理由需要写个自定的new和delte,本条款就是介绍了一些使用的理由</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-51-%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="toc-number">54.</span> <span class="toc-text">条款 51 : 编写new和delete时需固守常规</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%BA%9B%E4%BC%AA%E7%A0%81"><span class="toc-number">54.0.0.1.</span> <span class="toc-text">1.下面是一些伪码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8set-new-handler%E6%89%BE%E5%87%BAnew-handler%E6%8C%87%E9%92%88-%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%9C%89%E5%88%AB%E7%9A%84%E5%A5%BD%E6%96%B9%E6%B3%95-%E8%BF%99%E6%A0%B7%E8%99%BD%E7%84%B6%E6%8B%99%E5%8A%A3-%E4%BD%86%E6%9C%89%E6%95%88"><span class="toc-number">54.0.0.2.</span> <span class="toc-text">用set_new_handler找出new_handler指针,因为没有别的好方法,这样虽然拙劣,但有效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%87%BA%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">54.0.0.3.</span> <span class="toc-text">2.在出现继承时的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E-new-%E8%AF%A6%E7%BB%86%E8%A7%81-p254%E4%B8%8B%E9%9D%A2%E6%AE%B5%E8%90%BD"><span class="toc-number">54.0.0.4.</span> <span class="toc-text">对于 new [] 详细见 p254下面段落</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E4%BA%8Edelete%E6%83%85%E5%86%B5"><span class="toc-number">54.0.0.5.</span> <span class="toc-text">3.对于delete情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E4%BA%8Eclass%E6%83%85%E5%86%B5"><span class="toc-number">54.0.0.6.</span> <span class="toc-text">4.对于class情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-42"><span class="toc-number">54.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-operator-new-%E5%BA%94%E8%AF%A5%E5%86%85%E5%90%AB%E4%B8%80%E4%B8%AA%E6%97%A0%E7%A9%B7%E5%BE%AA%E7%8E%AF-%E4%B8%8D%E6%96%AD%E5%B0%9D%E8%AF%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98-%E8%8B%A5%E5%A4%B1%E8%B4%A5%E5%88%99%E8%B0%83%E7%94%A8new-handler-%E6%9C%89%E8%83%BD%E5%8A%9B%E5%A4%84%E7%90%860-byte%E7%94%B3%E8%AF%B7-class%E7%89%88%E6%9C%AC%E8%BF%98%E5%BA%94%E8%AF%A5%E5%A4%84%E7%90%86%E2%80%9D%E5%B9%B6%E6%AD%A3%E7%A1%AE%E5%A4%A7%E5%B0%8F%E6%9B%B4%E5%A4%A7%E7%9A%84%E7%94%B3%E8%AF%B7%E2%80%9D"><span class="toc-number">54.1.0.1.</span> <span class="toc-text">1.operator new 应该内含一个无穷循环,不断尝试分配内存,若失败则调用new_handler,有能力处理0 byte申请,class版本还应该处理”并正确大小更大的申请”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-operator-delete-%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%94%B6%E5%88%B0null%E6%97%B6%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E4%BA%8B%E6%83%85-class%E7%89%88%E6%9C%AC%E8%BF%98%E5%BA%94%E8%AF%A5%E5%A4%84%E7%90%86%E2%80%9D%E5%B9%B6%E6%AD%A3%E7%A1%AE%E5%A4%A7%E5%B0%8F%E6%9B%B4%E5%A4%A7%E7%9A%84%E7%94%B3%E8%AF%B7%E2%80%9D"><span class="toc-number">54.1.0.2.</span> <span class="toc-text">3.operator delete 应该在收到null时不做任何事情,class版本还应该处理”并正确大小更大的申请”</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-52-%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete"><span class="toc-number">55.</span> <span class="toc-text">条款 52 : 写了placement new也要写placement delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9D%A1%E6%AC%BE%E9%A6%96%E5%85%88%E5%BC%95%E5%85%A5%E4%B8%80%E6%9D%A1%E4%BE%8B%E5%AD%90-%E5%91%8A%E8%AF%89%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A6%82%E6%AD%A4%E5%81%9A"><span class="toc-number">55.0.0.1.</span> <span class="toc-text">1.条款首先引入一条例子,告诉我们为什么要如此做</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A6%96%E5%85%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AF%E8%AF%ADplacement-new"><span class="toc-number">55.0.0.2.</span> <span class="toc-text">2.首先简单介绍一下术语placement new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E9%9D%9E%E6%AD%A3%E5%B8%B8-operator-new-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">55.0.0.3.</span> <span class="toc-text">3.一个非正常 operator new 的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E6%AD%A4%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%BA%94%E7%9A%84operator-delete"><span class="toc-number">55.0.0.4.</span> <span class="toc-text">4.对此应该提供对应的operator delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E5%90%8D%E7%A7%B0%E9%81%AE%E7%9B%96%E9%97%AE%E9%A2%98-%E6%AF%94%E8%BE%83%E5%A5%BD%E7%90%86%E8%A7%A3%E5%B0%B1%E6%98%AF%E5%A6%82%E6%9E%9Cclass%E5%8F%AA%E5%A3%B0%E6%98%8E%E4%BA%86%E4%B8%80%E7%A7%8D%E5%88%99%E4%BC%9A%E9%81%AE%E6%8E%A9%E5%85%B6%E4%BB%96%E7%9A%84-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%B0%B1%E6%98%AF%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAbase-class-%E5%82%A8%E5%AD%98%E6%AD%A3%E5%B8%B8%E7%9A%84-%E8%AE%A9derivde%E7%BB%A7%E6%89%BF-%E5%B9%B6using-%E4%BD%BF%E5%85%B6%E5%9C%A8derived%E4%B8%AD%E5%8F%AF%E8%A7%81"><span class="toc-number">55.0.0.5.</span> <span class="toc-text">5.注意名称遮盖问题,比较好理解就是如果class只声明了一种则会遮掩其他的,解决方法就是声明一个base class 储存正常的,让derivde继承,并using 使其在derived中可见</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-43"><span class="toc-number">55.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%93%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AAplacement-new-%E8%AF%B7%E7%A1%AE%E5%AE%9A%E5%86%99%E5%87%BAplacement-operator-delete-%E5%90%A6%E5%88%99%E5%9B%9E%E5%AF%BC%E8%87%B4%E9%9A%90%E5%BE%AE%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">55.1.0.1.</span> <span class="toc-text">1.当你写一个placement new 请确定写出placement operator delete,否则回导致隐微的内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%93%E4%BD%A0%E5%A3%B0%E6%98%8Eplacement-new-%E5%92%8C-placement-delete%E6%97%B6-%E6%B3%A8%E6%84%8F%E4%B8%8D%E8%A6%81%E9%81%AE%E6%8E%A9%E5%AE%83%E4%BB%AC%E7%9A%84%E6%AD%A3%E5%B8%B8%E7%89%88%E6%9C%AC"><span class="toc-number">55.1.0.2.</span> <span class="toc-text">2.当你声明placement new 和 placement delete时,注意不要遮掩它们的正常版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-53-%E4%B8%8D%E8%A6%81%E8%BD%BB%E5%BF%BD%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-number">56.</span> <span class="toc-text">条款 53 : 不要轻忽编译器的警告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-5"><span class="toc-number">56.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%A5%E8%82%83%E5%AF%B9%E5%BE%85%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%91%E5%87%BA%E7%9A%84%E8%AD%A6%E5%91%8A-%E5%B0%BD%E9%87%8F%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E7%9A%84%E6%9C%80%E9%AB%98%E8%AD%A6%E5%91%8A%E7%BA%A7%E5%88%AB%E4%B8%8B%E4%BA%89%E5%8F%96%E2%80%9Dno-warming%E2%80%9D"><span class="toc-number">56.1.0.1.</span> <span class="toc-text">1.严肃对待编译器发出的警告,尽量在编译期的最高警告级别下争取”no-warming”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A-%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E5%BE%85%E4%BA%8B%E6%83%85%E7%9A%84%E6%80%81%E5%BA%A6%E5%B9%B6%E4%B8%8D%E7%9B%B8%E5%90%8C"><span class="toc-number">56.1.0.2.</span> <span class="toc-text">2.不要过度依赖编译器的警告,因为不同的编译器对待事情的态度并不相同</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-54-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%ACTR1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-number">57.</span> <span class="toc-text">条款 54 : 让自己熟悉包括TR1在内的标准程序库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-6"><span class="toc-number">57.1.</span> <span class="toc-text">注意事项：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93%E4%B8%BB%E8%A6%81%E7%94%B1STL-iostreams-locales%E7%BB%84%E6%88%90-%E5%B9%B6%E5%8C%85%E6%8B%ACc99%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-number">57.1.0.1.</span> <span class="toc-text">1.C++标准程序库主要由STL,iostreams,locales组成.并包括c99标准程序库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TR1%E6%B7%BB%E5%8A%A0%E4%BA%86%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E4%B8%80%E8%88%AC%E5%8C%96%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-tr1-function-%E5%8C%85%E8%A3%85%E5%99%A8-hash-based%E5%AE%B9%E5%99%A8-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regular-expression-%E4%BB%A5%E5%8F%8A%E5%8F%A6%E5%A4%9610%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">57.1.0.2.</span> <span class="toc-text">2.TR1添加了智能指针,一般化函数指针(tr1::function 包装器),hash-based容器,正则表达式(regular expression)以及另外10个组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-TR1%E8%87%AA%E8%BA%AB%E5%8F%AA%E6%98%AF%E4%B8%80%E4%BB%BD%E8%A7%84%E8%8C%83-%E4%B8%BA%E8%8E%B7%E5%BE%97TR1%E6%8F%90%E4%BE%9B%E7%9A%84%E5%A5%BD%E5%A4%84-%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%BB%BD%E5%AE%9E%E7%89%A9-%E6%9D%A5%E8%87%AABoost"><span class="toc-number">57.1.0.3.</span> <span class="toc-text">3.TR1自身只是一份规范.为获得TR1提供的好处,你需要一份实物,来自Boost</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-55-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89Boost"><span class="toc-number">58.</span> <span class="toc-text">条款 55 : 让自己熟悉Boost</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-44"><span class="toc-number">58.1.</span> <span class="toc-text">注意事项:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Boost%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A4%BE%E7%BE%A4-%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99-%E6%8F%90%E4%BE%9B%E5%85%8D%E8%B4%B9-%E5%BC%80%E6%BA%90%E7%9A%84C-%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-number">58.1.0.1.</span> <span class="toc-text">1.Boost是一个社群,也是一个网站,提供免费,开源的C++程序库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Boost%E6%8F%90%E4%BE%9B%E8%AE%B8%E5%A4%9ATR1%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%93%81"><span class="toc-number">58.1.0.2.</span> <span class="toc-text">2.Boost提供许多TR1组件实现品</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note/" title="算法笔记 Note"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记 Note"/></a><div class="content"><a class="title" href="/2022/04/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note/" title="算法笔记 Note">算法笔记 Note</a><time datetime="2022-04-18T02:35:55.000Z" title="发表于 2022-04-18 10:35:55">2022-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/17/Effective%20note/" title="Effective C++ 笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective C++ 笔记"/></a><div class="content"><a class="title" href="/2022/04/17/Effective%20note/" title="Effective C++ 笔记">Effective C++ 笔记</a><time datetime="2022-04-17T10:10:55.000Z" title="发表于 2022-04-17 18:10:55">2022-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/hello-world/" title="hello,world"><img src="/./img/rise.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hello,world"/></a><div class="content"><a class="title" href="/2022/04/16/hello-world/" title="hello,world">hello,world</a><time datetime="2022-04-16T11:10:55.000Z" title="发表于 2022-04-16 19:10:55">2022-04-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: 颜色(white)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By AuroraFish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">饿死了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>