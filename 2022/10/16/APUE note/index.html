<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>APUE 学习笔记 | Aurora</title><meta name="author" content="AuroraFish"><meta name="copyright" content="AuroraFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频和书籍的一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="APUE 学习笔记">
<meta property="og:url" content="http://example.com/2022/10/16/APUE%20note/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="视频和书籍的一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/background.png">
<meta property="article:published_time" content="2022-10-16T13:00:55.000Z">
<meta property="article:modified_time" content="2022-10-18T17:44:18.674Z">
<meta property="article:author" content="AuroraFish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/background.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/16/APUE%20note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'APUE 学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-19 01:44:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/headd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/background.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aurora</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">APUE 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-18T17:44:18.674Z" title="更新于 2022-10-19 01:44:18">2022-10-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="APUE 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Unix-环境高级编程"><a href="#Unix-环境高级编程" class="headerlink" title="Unix 环境高级编程"></a>Unix 环境高级编程</h1><h2 id="linux-一些零散的基础知识-视频系统编程部分"><a href="#linux-一些零散的基础知识-视频系统编程部分" class="headerlink" title="linux 一些零散的基础知识(视频系统编程部分)"></a>linux 一些零散的基础知识(视频系统编程部分)</h2><h5 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令:"></a>快捷命令:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">history 查看历史命令</span><br><span class="line">ctrl + p 在历史命令中向上滚动</span><br><span class="line">ctrl + n 在历史命令中向下滚动</span><br><span class="line">ctrl + b 光标向前移动</span><br><span class="line">ctrl + f 光标向后移动</span><br><span class="line">ctrl + a 光标移动行首</span><br><span class="line">ctrl + e 光标移动行尾</span><br><span class="line">ctrl + h 删除光标前</span><br><span class="line">ctrl + d 删除光标后</span><br><span class="line">ctrl + u 删除光标前所有</span><br><span class="line">tap 智能提示</span><br></pre></td></tr></table></figure>

<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ls / 查看目录</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       -a 显示隐藏文件  -l 显示详细信息  -la 组合使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">cd /xxx 进入xx文件</span><br><span class="line">pwd 查看当前路径</span><br><span class="line">mkdir 创建目录</span><br><span class="line">mkdir dir/dir1/dir2 -p 创建符合目录 ，就是一层套一层</span><br><span class="line">rmdir 删除空目录</span><br><span class="line">rm aa -r -r代表递归，删除非空目录   -i 提示</span><br><span class="line">touch 创建文件</span><br><span class="line">cp xxxx ttt 将xxxx拷贝到ttt文件,不存在就创建ttt文件</span><br><span class="line">cp 目录时需要加 -r 递归拷贝   和 rm 类似</span><br><span class="line">cat 查看文件</span><br><span class="line">more 查看文件 空格翻一页 回车翻一行 q退出</span><br><span class="line">less 比more好一点 但后面已vi为主</span><br><span class="line">head 显示文件前十行 可以加参数 head <span class="number">-5</span></span><br><span class="line">tail 反之</span><br><span class="line">mv xxx ttt 重命名</span><br><span class="line">ln -s xxx ttt 创建ttt的软链接为xxx  用绝对路径 </span><br><span class="line">    </span><br><span class="line"><span class="comment">//修改文件权限 </span></span><br><span class="line"><span class="comment">//1.文字设定法</span></span><br><span class="line">chmod [who] [+|-|=] [mode] 修改文件权限</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       + 添加权限 = 覆盖权限 - 减少权限</span></span><br><span class="line"><span class="comment">       u 文件所有者 g 文件所属组 o 其他人 a 所有的人</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       chmod a=w xxx 将xxx所有人的权限覆盖为 w</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//2.数字设定法</span></span><br><span class="line">     chmod <span class="number">777</span> xxx    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       -:没有权限 r:4 w:2 x:1</span></span><br><span class="line"><span class="comment">       如765 对应</span></span><br><span class="line"><span class="comment">       7 rwx   文件所属者</span></span><br><span class="line"><span class="comment">       6 rw    文件所属组</span></span><br><span class="line"><span class="comment">       5 rx    其他人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改所属组</span></span><br><span class="line">chown xxx ttt 将ttt的所属者改为xxx</span><br><span class="line">chown xxx:yyy ttt 将ttt的所属者和所属组改为 xxx yyy </span><br><span class="line">chgrp 修改所属组</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       注意需要root权限</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按文件属性查找</span></span><br><span class="line">find /home/itcast/ -name <span class="string">&quot;hel?&quot;</span>     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       问号代表一个符号 , * 代表多个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//按大小</span></span><br><span class="line">find 查找目录 -size +<span class="number">10</span>k</span><br><span class="line"><span class="comment">//按类型</span></span><br><span class="line">find 查找目录 -type d/f/b/c/s/p/l</span><br><span class="line">    </span><br><span class="line"><span class="comment">//按文件内容查找</span></span><br><span class="line">grep -r <span class="string">&quot;查找内容&quot;</span> 查找路径</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取网络接口信息</span></span><br><span class="line">ficonfig</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看服务器域名对应ip</span></span><br><span class="line">Nslookup</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20220928125002199.png" alt="image-20220928125002199"></p>
<p>上图为 <strong>-l</strong> 详细显示的信息的解释图</p>
<h5 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/bin 命令</span><br><span class="line">/dev 设备文件 </span><br><span class="line">/etc 配置文件信息</span><br><span class="line">/home 所有用户的目录 </span><br><span class="line">/lib 存的一些动态库</span><br><span class="line">/media 自动挂载库</span><br><span class="line">/mnt 手动挂载</span><br><span class="line">/root 管理员目录</span><br><span class="line">/usr 当前用户软件安装目录</span><br></pre></td></tr></table></figure>

<h5 id="文件或目录熟悉"><a href="#文件或目录熟悉" class="headerlink" title="文件或目录熟悉"></a>文件或目录熟悉</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc</span><br><span class="line">od</span><br><span class="line">du</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20220929093226636.png" alt="image-20220929093226636"></p>
<h5 id="安装和卸载"><a href="#安装和卸载" class="headerlink" title="安装和卸载"></a>安装和卸载</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xxx 在线下载安装</span><br><span class="line">sudo apt-get remove xxx 移除</span><br><span class="line">sudo apt-get update 更新软件列表</span><br><span class="line">sudo apt-get clean 清除所有软件包</span><br><span class="line">    </span><br><span class="line"><span class="comment">//deb包安装</span></span><br><span class="line">sudo dpkg -i xxx.deb</span><br><span class="line">sudo dpkg -r xxx</span><br></pre></td></tr></table></figure>

<h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认功能较少的两种</span></span><br><span class="line">gzip bzip2</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20220929211522449.png" alt="image-20220929211522449"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解压缩</span></span><br><span class="line">tar jxvf 压缩包名字(解压到当前目录)</span><br><span class="line">tar jxvf 压缩包名字 -C 压缩的目录</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20220929212619740.png" alt="image-20220929212619740"></p>
<p><strong>zip压缩目录需要-r</strong></p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20220930143055851.png" alt="image-20220930143055851"></p>
<h5 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001143600239.png" alt="image-20221001143600239"></p>
<h5 id="三种服务器搭建"><a href="#三种服务器搭建" class="headerlink" title="三种服务器搭建"></a>三种服务器搭建</h5><h6 id="ftp服务器"><a href="#ftp服务器" class="headerlink" title="ftp服务器"></a>ftp服务器</h6><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001143903737.png" alt="image-20221001143903737"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001144100899.png" alt="image-20221001144100899"></p>
<h6 id="nfs服务器-（共享文件夹"><a href="#nfs服务器-（共享文件夹" class="headerlink" title="nfs服务器 （共享文件夹)"></a>nfs服务器 （共享文件夹)</h6><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001144305890.png" alt="image-20221001144305890"></p>
<h6 id="ssh服务器"><a href="#ssh服务器" class="headerlink" title="ssh服务器"></a>ssh服务器</h6><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001144736655.png" alt="image-20221001144736655"></p>
<h5 id="vim-操作"><a href="#vim-操作" class="headerlink" title="vim 操作"></a>vim 操作</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001151454701.png" alt="image-20221001151454701"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001153419355.png" alt="image-20221001153419355"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001161348299.png" alt="image-20221001161348299"></p>
<p>分屏: vsp sp   <strong>!</strong></p>
<h5 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h5><p>1.预处理 gcc -E 2.编译 gcc -S 3.汇编 gcc -c 4.链接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-o    生成目标文件</span><br><span class="line">-I    指定头文件目录</span><br><span class="line">-D    编译时定义宏</span><br><span class="line">-Wall 更多警告信息</span><br><span class="line">-c    只编译子程序</span><br><span class="line">-E    生成预处理文件</span><br><span class="line">-g    包含调试信息</span><br><span class="line"><span class="number">-0</span>n (n=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  编译优化</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)命名规则</span><br><span class="line">  a) lib + 库名 + .a</span><br><span class="line">  b) libmytest.a</span><br><span class="line"><span class="number">2</span>)制作步骤</span><br><span class="line">  a) 生成对应的.o文件</span><br><span class="line">  b) 将生成的.o文件打包 ar rcs + 静态库名字(libmytest.a) + 生成的.o</span><br><span class="line"><span class="number">3</span>)发布和使用静态库</span><br><span class="line">  a) 发布静态库</span><br><span class="line">  b) 头文件</span><br><span class="line"><span class="number">4</span>）使用静态库的例子</span><br><span class="line">    gcc main.c lib/libMyCalc.a -o calc -Iinclude</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002144945691.png" alt="image-20221002144945691"></p>
<h5 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)命名规则</span><br><span class="line">  a) lib + 库名 + .so</span><br><span class="line"><span class="number">2</span>)制作步骤</span><br><span class="line">  a) 生成与位置无关的代码(生成与位置无关的.o)</span><br><span class="line">    gcc -fPIC -c *.c -I../include  <span class="comment">//多-fPIC参数</span></span><br><span class="line">  b) 将.o打包成共享库(动态库)</span><br><span class="line">    gcc -shared -o libMyCalc.so *.o -Iinclude</span><br><span class="line"><span class="number">3</span>)发布和使用动态库</span><br><span class="line">    gcc main.c lib/libMyCalc.so -o calc -Iinclude</span><br><span class="line"><span class="number">4</span>)动态库链接不到的原因</span><br><span class="line">    链接器找不到动态库.</span><br><span class="line">    a)设置LD_LIBRARY_PATH 临时导入</span><br><span class="line">    b)将<span class="keyword">export</span> 写入.bashrc文件中</span><br><span class="line">    c)更改动态链接器的配置文件</span><br><span class="line">      ldconfig用于vi完后,更新配置</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002152423010.png" alt="image-20221002152423010"></p>
<p>c)</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002153741139.png" alt="image-20221002153741139"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002153809834.png" alt="image-20221002153809834"></p>
<h5 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)启动gdb</span><br><span class="line">  a) start -- 执行一步</span><br><span class="line">  b) n -- next</span><br><span class="line">  c) s -- step</span><br><span class="line">  c) c -- <span class="keyword">continue</span> 直接停到断点位置</span><br><span class="line"><span class="number">2</span>)查看代码</span><br><span class="line">  a) l -- list</span><br><span class="line">  b) l + 行号</span><br><span class="line">  c) l + 文件名 或 函数名</span><br><span class="line"><span class="number">3</span>)设置断点</span><br><span class="line">  a) 设置当前文件断点 : b ; b + 行号</span><br><span class="line">  b) 设置指定文件断点 : b filename 行号</span><br><span class="line">  c) 设置条件断点 : b 行号 <span class="keyword">if</span> value == <span class="number">19</span></span><br><span class="line">  d) 删除断 : <span class="keyword">delete</span> + 断点编号</span><br><span class="line">  e) 获取编号 : info b</span><br><span class="line"><span class="number">4</span>)单步调试</span><br><span class="line">  a) 进入函数体内部 : s</span><br><span class="line">  b) 从函数体内部跳出 : finish</span><br><span class="line">  c) 退出当前循环 : u</span><br><span class="line"><span class="number">5</span>)查看变量的值</span><br><span class="line">  p</span><br><span class="line"><span class="number">6</span>)查看变量类型</span><br><span class="line">  ptype 变量名</span><br><span class="line"><span class="number">7</span>)设置变量的值</span><br><span class="line">  set var = xx</span><br><span class="line"><span class="number">8</span>)设置追踪变量</span><br><span class="line">  display</span><br><span class="line"><span class="number">9</span>)取消设置追踪变量</span><br><span class="line">  undisplay 编号   获取编号 : info display</span><br><span class="line"><span class="number">10</span>)退出gdb</span><br><span class="line">  quit</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">//进程GBD时 利用循环创建子进程的架构 利用条件断点来切入子进程调试或父进程调试</span></span><br><span class="line">      <span class="number">1</span>) set follow-fork-mode child  <span class="comment">//在fork之后追踪子进程</span></span><br><span class="line">      <span class="number">2</span>) set follow-fork-mode parent <span class="comment">//追踪父进程</span></span><br></pre></td></tr></table></figure>

<h5 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002195517567.png" alt="image-20221002195517567"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002195535550.png" alt="image-20221002195535550"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002202536556.png" alt="image-20221002202536556"></p>
<h5 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h5><p>本质上类似虚拟地址到实际内存地址的映射，方便将零散的空间，构成一个连续的整体，和deque的状态有点像</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221003112740912.png" alt="image-20221003112740912"></p>
<h5 id="stat-lstat区别，穿透和不穿透"><a href="#stat-lstat区别，穿透和不穿透" class="headerlink" title="stat lstat区别，穿透和不穿透"></a>stat lstat区别，穿透和不穿透</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221004110828607.png" alt="image-20221004110828607"></p>
<h5 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h5><h5 id="CPU基本运作方式"><a href="#CPU基本运作方式" class="headerlink" title="CPU基本运作方式"></a>CPU基本运作方式</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221004200102729.png" alt="image-20221004200102729"></p>
<h5 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221004200200806.png" alt="image-20221004200200806"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221004202340296.png" alt="image-20221004202340296"></p>
<h5 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221004203527280.png" alt="image-20221004203527280"></p>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221004203151277.png" alt="image-20221004203151277"></p>
<h5 id="环境变量函数"><a href="#环境变量函数" class="headerlink" title="环境变量函数"></a>环境变量函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getenv</span><br><span class="line">unsetenv</span><br><span class="line">setenv</span><br></pre></td></tr></table></figure>

<h5 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建子进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进程共享</strong> 特点：读时共享,写时复制</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221005205933042.png" alt="image-20221005205933042"></p>
<h5 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h5><p>加载一个进程,替换当前进程的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execlp   - p - path </span><br><span class="line">execl    - l - list</span><br><span class="line">execv    - v - argv[]</span><br><span class="line">execvp</span><br><span class="line">execve   - e - enviroment</span><br><span class="line">只有失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回收进程，防止出现孤儿进程，僵尸进程情况</span></span><br><span class="line"><span class="comment">//孤儿进程: 父进程提前结束  </span></span><br><span class="line"><span class="comment">//僵尸进程: 子进程结束没回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1)</span></span><br><span class="line"><span class="built_in">wait</span>(status) : 返回   成功:pid    失败:<span class="number">-1</span></span><br><span class="line">    status: 传出参数</span><br><span class="line">        <span class="number">1.</span>阻塞等待子进程</span><br><span class="line">        <span class="number">2.</span>回收子进程资源</span><br><span class="line">        <span class="number">3.</span>获取子进程结束状态</span><br><span class="line">利用宏获取状态:</span><br><span class="line"><span class="number">1.</span><span class="function"><span class="keyword">if</span> <span class="title">WIFEXITED</span><span class="params">(status)</span> <span class="params">(真)</span> <span class="comment">// 获取正常退出状态</span></span></span><br><span class="line"><span class="function">     <span class="title">WEXITSTATUS</span><span class="params">(status)</span></span>;   </span><br><span class="line"><span class="number">2.</span><span class="function"><span class="keyword">if</span> <span class="title">WIFSIGNALED</span><span class="params">(status)</span><span class="params">(真)</span><span class="comment">//获取异常的</span></span></span><br><span class="line"><span class="function">     <span class="title">WTERMSIG</span><span class="params">(status)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2)</span></span><br><span class="line">waitpid</span><br><span class="line">    <span class="number">1</span>)参<span class="number">1</span>:  pid &gt;<span class="number">0</span>    指定进程id回收</span><br><span class="line">            pid = <span class="number">-1</span>  回收任意子进程(wait)</span><br><span class="line">            pid = <span class="number">0</span>   回收本组任意子进程</span><br><span class="line">            pid &lt; <span class="number">-1</span>  回收该进程组的任意资产基础</span><br><span class="line">    <span class="number">2</span>)参<span class="number">2</span>:  status 同上</span><br><span class="line">    <span class="number">3</span>)参<span class="number">3</span>:  <span class="number">0</span>: (等价于wait) 阻塞回收</span><br><span class="line">            WNOHANG: 非阻塞回收(轮询)</span><br><span class="line">              成功: pid 失败:<span class="number">-1</span> 返回<span class="number">0</span>值: 非阻塞回收时，子进程还没结束</span><br></pre></td></tr></table></figure>

<h5 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h5><ol>
<li>管道:使用简单</li>
<li>FIFO:非血缘关系间</li>
<li>信号:开销小</li>
<li>共享内存:非血缘关系间</li>
<li>本地套接字</li>
</ol>
<h6 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a><strong>管道</strong></h6><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221006200819169.png" alt="image-20221006200819169"></p>
<p>获取管道缓冲区大小 : 函数:fpathconf2  参2: __PC_PIPE_BUF  命令 : ulimit -a</p>
<p>管道优劣: 优 : 实现简单   缺 : 单向通信   血缘关系only</p>
<h6 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h6><p>mkfifo函数和命令</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221006202009432.png" alt="image-20221006202009432"></p>
<h6 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h6><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221006203233785.png" alt="image-20221006203233785"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* p ;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;temp&quot;</span>,O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除临时文件目录项, 使之具备被释放条件, 所有使用该文件的进程结束后就被删除</span></span><br><span class="line">    <span class="built_in">unlink</span>(<span class="string">&quot;temp&quot;</span>);</span><br><span class="line">    <span class="built_in">ftruncate</span>(fd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="comment">//映射区创建完毕</span></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        *p = <span class="number">2000</span>;</span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child , *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">munmap</span>(p, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上图可以看出temp只是作为一个临时的映射区, 进程结束就rm掉了，实际上并不需要这个文件，由此引出匿名映射</p>
<p><strong>匿名映射</strong> (加入额外宏参数即可，原来传入文件的参数换位-1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//该宏只在linux系统下可用, 其他类unix系统不可用, 解决方法 借助/dev/zero</span></span><br><span class="line"><span class="comment">//大小可以随意指定, 本质仍是虚拟内存</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221006224421349.png" alt="image-20221006224421349"></p>
<h5 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h5><p>strace + 可执行文件， 追踪程序执行过去中使用的系统调用，就比如利用程序进行进程通信时，底层其实还是使用mmap实现的通信</p>
<h5 id="小实验-利用fifo实现简单的本地聊天室"><a href="#小实验-利用fifo实现简单的本地聊天室" class="headerlink" title="小实验 利用fifo实现简单的本地聊天室"></a>小实验 利用fifo实现简单的本地聊天室</h5><p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221009212823313.png" alt="image-20221009212823313"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_FIFO <span class="string">&quot;/home/aurora/learning/Day1007/test3/SERVER_FIFO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="comment">//客户端名字</span></span><br><span class="line">    <span class="type">char</span> client_name[<span class="number">20</span>];  </span><br><span class="line">    <span class="comment">//私有管道描述符 </span></span><br><span class="line">    <span class="type">int</span> fifo_clifd;           </span><br><span class="line">&#125; CL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录客户端连接的数量</span></span><br><span class="line"><span class="type">int</span> client_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用数组存储客户端队列</span></span><br><span class="line">CL client_deque[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">message_pack</span> &#123;</span><br><span class="line">    <span class="comment">//消息编号</span></span><br><span class="line">    <span class="type">int</span> message_num;</span><br><span class="line">    <span class="comment">//消息发送方</span></span><br><span class="line">    <span class="type">char</span> sender_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//消息接收方</span></span><br><span class="line">    <span class="type">char</span> receiver_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">&#125; MSP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共管道</span></span><br><span class="line"><span class="type">int</span> ser_fifo;</span><br><span class="line"><span class="comment">//服务器启动标志</span></span><br><span class="line"><span class="type">int</span> start_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_server</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//接受客户端信息包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_pack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//解析客户端的包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parsing_pack</span><span class="params">(MSP *msp)</span></span>;</span><br><span class="line"><span class="comment">//处理客户端登录, 插入客户队列, 创建私有管道</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_login</span><span class="params">(<span class="type">char</span> *login_name)</span></span>;</span><br><span class="line"><span class="comment">//处理消息发送给对应的客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_send</span><span class="params">(MSP *pMsp)</span></span>;</span><br><span class="line"><span class="comment">//处理客户端退出, 移出客户队列, 关闭私有管道</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_quit</span><span class="params">(<span class="type">char</span> *quit_name)</span></span>;</span><br><span class="line"><span class="comment">//关闭服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_server</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//处理输入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1068</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将STDIN_FILENO改为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(STDIN_FILENO, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非阻塞的方式打开管道</span></span><br><span class="line">    ser_fifo = <span class="built_in">open</span>(SERVER_FIFO, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (ser_fifo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SERVER OPEN:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器已启动\n&quot;</span>);</span><br><span class="line">    start_flag = <span class="number">1</span>-start_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    MSP *msp;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(ser_fifo, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        msp = (MSP*)buf;</span><br><span class="line">        <span class="built_in">parsing_pack</span>(msp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parsing_pack</span><span class="params">(MSP *msp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msp-&gt;message_num) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">client_login</span>(msp-&gt;sender_name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">message_send</span>(msp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">client_quit</span>(msp-&gt;sender_name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_login</span><span class="params">(<span class="type">char</span> *login_name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(client_deque[client_len].client_name, login_name);</span><br><span class="line">    <span class="type">char</span> path[<span class="number">23</span>] = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(path, login_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保创建的文件的权限为分配权限</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mkfifo</span>(path, <span class="number">0777</span>);</span><br><span class="line">    <span class="comment">//将管道的文件描述符存入数组</span></span><br><span class="line">    client_deque[client_len].fifo_clifd = <span class="built_in">open</span>(path, O_WRONLY);</span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;您和服务器的连接已经成功建立, 可以开始通讯了\n&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(client_deque[client_len].fifo_clifd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将管道创建为临时的, 设置管道文件符合删除条件, 即程序结束后自动清楚</span></span><br><span class="line">    <span class="built_in">unlink</span>(path);</span><br><span class="line"></span><br><span class="line">    ++client_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_send</span><span class="params">(MSP *pMsp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">void</span>*)pMsp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(pMsp-&gt;receiver_name) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//单发</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; client_len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pMsp-&gt;receiver_name, client_deque[i].client_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">write</span>(client_deque[i].fifo_clifd, buf, BUFSIZE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//群发</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; client_len; ++i) &#123;</span><br><span class="line">            <span class="built_in">write</span>(client_deque[i].fifo_clifd, buf, BUFSIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_quit</span><span class="params">(<span class="type">char</span> *quit_name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;client_len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(quit_name, client_deque[i].client_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//关闭对应的私有管道</span></span><br><span class="line">            <span class="built_in">close</span>(client_deque[i].fifo_clifd);</span><br><span class="line">            client_deque[i].fifo_clifd = <span class="number">-1</span>;</span><br><span class="line">            client_deque[i].client_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s已退出\n&quot;</span>, quit_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pMes, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close_server</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;服务器维护中, 请稍后登录.&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; client_len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client_deque[i].fifo_clifd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">write</span>(client_deque[i].fifo_clifd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">close</span>(client_deque[i].fifo_clifd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(ser_fifo);</span><br><span class="line">    start_flag = <span class="number">1</span>-start_flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已关闭所有管道, 服务器安全退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_server</span>();</span><br><span class="line">    <span class="type">char</span> mes[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start_flag) &#123;</span><br><span class="line">        <span class="built_in">receiver_pack</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mes) != EOF) &#123;</span><br><span class="line">            <span class="built_in">message_handle</span>(mes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_FIFO <span class="string">&quot;/home/aurora/learning/Day1007/test3/SERVER_FIFO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接标志</span></span><br><span class="line"><span class="type">int</span> link_flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//公共管道描述符</span></span><br><span class="line"><span class="type">int</span> ser_fifo;</span><br><span class="line"><span class="comment">//私有管道描述符</span></span><br><span class="line"><span class="type">int</span> cli_fifo;</span><br><span class="line"><span class="comment">//客户端名称</span></span><br><span class="line"><span class="type">char</span> client_name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">message_pack</span> &#123;</span><br><span class="line">    <span class="comment">//消息编号</span></span><br><span class="line">    <span class="type">int</span> message_num;</span><br><span class="line">    <span class="comment">//消息发送方</span></span><br><span class="line">    <span class="type">char</span> sender_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//消息接收方</span></span><br><span class="line">    <span class="type">char</span> receiver_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">&#125; MSP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_client</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//登录服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">login_server</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//处理用户输入的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span></span>;</span><br><span class="line"><span class="comment">//向服务器发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_ser_mes</span><span class="params">(<span class="type">int</span> mes_num)</span></span>;</span><br><span class="line"><span class="comment">//向其他用户发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_oth_mes</span><span class="params">(<span class="type">char</span> *receiver, <span class="type">char</span> *data)</span></span>;</span><br><span class="line"><span class="comment">//接收消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_mes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_client</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1068</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">login_server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置连接标志</span></span><br><span class="line">    link_flag = <span class="number">1</span>-link_flag;</span><br><span class="line">    <span class="comment">//将STDIN文件属性修改为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(STDIN_FILENO, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">login_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入客户端名称:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, client_name);</span><br><span class="line"></span><br><span class="line">    ser_fifo = <span class="built_in">open</span>(SERVER_FIFO, O_WRONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (ser_fifo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open server fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_ser_mes</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> path[<span class="number">23</span>] = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(path, client_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试管道是否创建成功,成功返回0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">access</span>(path, F_OK) != <span class="number">0</span>) ;</span><br><span class="line">    cli_fifo = <span class="built_in">open</span>(path, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (cli_fifo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open client fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;私有管道创建成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_ser_mes</span><span class="params">(<span class="type">int</span> mes_num)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    MSP msp;</span><br><span class="line">    <span class="type">char</span> * buf;</span><br><span class="line">    msp.message_num = mes_num;</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.sender_name, client_name);</span><br><span class="line">    buf = (<span class="type">void</span>*)&amp;msp;</span><br><span class="line">    <span class="built_in">write</span>(ser_fifo, buf, <span class="built_in">sizeof</span>(msp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pMes, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">send_ser_mes</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">close_client</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据格式为 接收者姓名:消息内容</span></span><br><span class="line">    <span class="comment">//如果不符合格式 消息改为群发</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> receiver_name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pMes[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; pMes[i] != <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        receiver_name[i] = pMes[i];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver_name[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pMes[i] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        receiver_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pMes[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        data[j++] = pMes[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    data[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_oth_mes</span>(receiver_name, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    link_flag = <span class="number">1</span>-link_flag;</span><br><span class="line">    <span class="comment">//关闭管道</span></span><br><span class="line">    <span class="built_in">close</span>(cli_fifo);</span><br><span class="line">    <span class="built_in">close</span>(ser_fifo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已关闭所有管道, 客户端端退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_mes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(cli_fifo, buf, <span class="built_in">sizeof</span>(MSP));</span><br><span class="line">    MSP * pMes = <span class="literal">NULL</span>;</span><br><span class="line">    pMes = (<span class="type">void</span>*)buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; pMes-&gt;message_num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:%s\n&quot;</span>, pMes-&gt;sender_name, pMes-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;系统提示:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_oth_mes</span><span class="params">(<span class="type">char</span> *receiver, <span class="type">char</span> *data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    MSP msp;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    msp.message_num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.sender_name, client_name);</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.receiver_name, receiver);</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.data, data);</span><br><span class="line">    buf = (<span class="type">void</span>*)&amp;msp;</span><br><span class="line">    <span class="built_in">write</span>(ser_fifo, buf, <span class="built_in">sizeof</span>(msp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_client</span>();</span><br><span class="line">    <span class="type">char</span> mes_buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (link_flag) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mes_buf) != EOF) &#123;</span><br><span class="line">            <span class="built_in">message_handle</span>(mes_buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">receiver_mes</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>内核发送， 内核处理</p>
<p>发送 ——- 过程 ——— 抵达</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">阻塞信号集合 使信号无法抵达，被阻塞</span><br><span class="line">未决信号集合 由阻塞信号集影响</span><br><span class="line">    </span><br><span class="line"><span class="comment">//信号产生</span></span><br><span class="line">    <span class="number">1.</span>终端按键产生信号(ctrl +c/z/\)</span><br><span class="line">    <span class="number">2.</span>硬件异常产生信号(除<span class="number">0</span>操作,非法内存访问,总线错误)</span><br><span class="line">    <span class="number">3.</span>kill函数/命令产生信号( <span class="type">int</span> <span class="built_in">kill</span>(<span class="type">pid_t</span> pid, <span class="type">int</span> sig); )</span><br><span class="line">        pid &gt; <span class="number">0</span> : 发送给指定进程</span><br><span class="line">        pid = <span class="number">0</span> : 发送给<span class="built_in">kill</span>(函数)同进程组进程</span><br><span class="line">        pid &lt; <span class="number">0</span> : 取|pid|发给对应进程组</span><br><span class="line">        pid = <span class="number">-1</span>: 发送给有权发送的所有进程</span><br><span class="line">    <span class="number">4.</span><span class="type">int</span> <span class="built_in">raise</span>(<span class="type">int</span> sig) 和 <span class="type">void</span> <span class="built_in">abort</span>(<span class="type">void</span>) </span><br><span class="line">        raise发送给自己, abort发送自己异常信号</span><br><span class="line">    <span class="number">5.</span>软件条件产生信号(alarm函数/setitimer)</span><br><span class="line">        每个进程有且只有唯一一个定时器</span><br><span class="line">        <span class="comment">//setitimer</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221012153510031.png" alt="image-20221012153510031"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号集操作函数</span></span><br><span class="line"><span class="type">sigset_t</span> set;   <span class="comment">//信号集合的类型, 以位来进行操作的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;   <span class="comment">//将信号集清0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;    <span class="comment">//将信号集置1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sidaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">//将某信号加入集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdeleset</span><span class="params">(sigset_T *set,<span class="type">int</span> signum)</span></span>; <span class="comment">//将某信号清出集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismemeber</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set,<span class="type">int</span> signum)</span></span>; <span class="comment">//判断某信号是否在信号集合中, 1在, 0不在, -1出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sigprocmask  用来屏蔽信号, 解除屏蔽 本质:读取修改进程的信号屏蔽字(pcb中)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> *oldset)</span></span>;</span><br><span class="line">set:传入参数    oldset:传出参数</span><br><span class="line">how:<span class="number">1.</span>SIG_BLOCK:   此时set表示需要屏蔽的信号     mask = mask | set</span><br><span class="line">    <span class="number">2.</span>SIG_UNBLOCK: 此时set表示需要解除屏蔽的信号 mask = mask &amp; ~set</span><br><span class="line">    <span class="number">3.</span>SIG_SETMAKS: 用set直接覆盖原有mask       mask = set</span><br><span class="line">        </span><br><span class="line"><span class="comment">//sigpending 读取当前进程的未决信号集</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">sigpending</span>(<span class="type">sigset_t</span> *set); set传出参数 成功:<span class="number">0</span>  失败:<span class="number">-1</span> 设置error</span><br></pre></td></tr></table></figure>

<h5 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal 注册一个信号捕捉函数 优点简洁, 但不统一, 避免使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sigaction</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span></span>;  act传入参数, oldact传出参数</span><br><span class="line"><span class="comment">//struct sigaction的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">        <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>,<span class="type">siginfo_t</span>*,<span class="type">void</span>*);</span><br><span class="line">        <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">        <span class="type">int</span> sa_flags;</span><br><span class="line">        <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//各成员详细</span></span><br><span class="line">    <span class="number">1.</span>sa_restorer 已废除</span><br><span class="line">    <span class="number">2.</span>sigaction 当sa_flags指定为SA_SIGINFO时使用该函数,另外实际上的结构和sa_handler组成<span class="keyword">union</span></span><br><span class="line">    <span class="title class_">3</span>.sa_handler 信号捕捉后的处理函数名 赋值为SIG_IGN表忽略,SIG_DFL默认</span><br><span class="line">    <span class="number">4.</span>sa_mask 信号屏蔽集合, 表示调用处理函数时, 屏蔽的信号</span><br><span class="line">    <span class="number">5.</span>sa_flags 通常为<span class="number">0</span>, 默认属性</span><br><span class="line">        </span><br><span class="line"><span class="comment">//信号捕捉的特性</span></span><br><span class="line"><span class="number">1.</span>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</span><br><span class="line"><span class="number">2.</span>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</span><br><span class="line"><span class="number">3.</span>阻塞的常规信号不支持排队，产生多次只记录一次。（后<span class="number">32</span>个实时信号支持排队）</span><br></pre></td></tr></table></figure>

<h5 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程:"></a>内核实现信号捕捉过程:</h5><p>**1.**在执行主控制流程时,由于中断,异常,系统调用(<strong>user</strong>)进入内核区 **-&gt; 2.**内核处理完异常准备回用户区之前,处理当前进程中的可抵达信号(<strong>kernel</strong>) **-&gt; 3.**如果设置了处理函数回到用户区,执行处理函数,但不是回到主控流程(<strong>kernel</strong>) **-&gt; 4.**执行信号处理函数,然后调用特殊的系统调用sigretum再次进入内核区(<strong>user</strong>) **-&gt; 5.**sys_sigreturn() 然后返回用户区,之前终端的主控流程(<strong>user</strong>)</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221012160530748.png" alt="image-20221012160530748"></p>
<h5 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act, oldact;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = catch_sigalrm;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">sigaction</span>(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(seconds);</span><br><span class="line">    <span class="comment">//屏蔽</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">pause</span>();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pause sucess\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">alarm</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">mysleep</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的问题在于alarm和pause之间,如果此时cpu的调度切出去了,在此期间alarm信号发送完了,并且抵达了,pause由于收不到信号,被永久阻塞, 首先想到的解决思路, 对alarm信号设置屏蔽,在pause之前再解除, 但无论怎么解决, 屏蔽和pause之间同样可能cpu切出去,导致信号已经处理完了, pause收不到信号永久阻塞，解决方法采用系统函数,由于系统函数是原子操作,pause的功能和解除屏蔽同时发生,不可再分,不会出现cpu突然抢走调度的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.解决示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> newact, oldact;</span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.为SIGALRM设置捕捉函数</span></span><br><span class="line">    newact.sa_handler = catch_sigalrm;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置阻塞信号集, 阻塞SIGALRM信号</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newmask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGALRM);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.定时n秒</span></span><br><span class="line">    <span class="built_in">alarm</span>(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.构造一个临时有效的阻塞信号集</span></span><br><span class="line">    <span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">    suspmask = oldmask;</span><br><span class="line">    <span class="built_in">sigdelset</span>(&amp;suspmask, SIGALRM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.调用sigsupspend 系统函数原子操作, 将pause的阻塞和解除屏蔽同时进行</span></span><br><span class="line">    <span class="comment">//不会发生解除屏蔽和阻塞操作直接, cpu切出去</span></span><br><span class="line">    <span class="built_in">sigsuspend</span>(&amp;suspmask);</span><br><span class="line"></span><br><span class="line">    unslept = <span class="built_in">alarm</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">mysleep</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>   不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>​     这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h5 id="全局变量异步I-x2F-O"><a href="#全局变量异步I-x2F-O" class="headerlink" title="全局变量异步I&#x2F;O"></a>全局变量异步I&#x2F;O</h5><p>和时序竞态有点类似,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am child  %d\t%d\n&quot;</span>, <span class="built_in">getpid</span>(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am parent %d\t%d\n&quot;</span>, <span class="built_in">getpid</span>(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sys_err</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;     </span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        act.sa_handler = do_sig_parent;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGUSR2, &amp;act, <span class="literal">NULL</span>);             <span class="comment">//注册自己的信号捕捉函数  父使用SIGUSR2信号</span></span><br><span class="line">        <span class="built_in">do_sig_parent</span>(<span class="number">0</span>);						  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* wait for signal */</span>;</span><br><span class="line">           <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;                         <span class="comment">//父进程数数完成</span></span><br><span class="line">                <span class="built_in">kill</span>(pid, SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;                        <span class="comment">//标志已经给子进程发送完信号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;       </span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* waiting for a signal */</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">kill</span>(<span class="built_in">getppid</span>(), SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。现阶段，我们在编程期间如若使用全局变量，应在主观上注意全局变量的异步IO可能造成的问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="可重入函数-x2F-不可重入函数"><a href="#可重入函数-x2F-不可重入函数" class="headerlink" title="可重入函数&#x2F;不可重入函数"></a>可重入函数&#x2F;不可重入函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	定义可重入函数，函数内不能含有全局变量及<span class="type">static</span>变量，不能使用malloc、free</span><br><span class="line"><span class="number">2.</span>	信号捕捉函数应设计为可重入函数</span><br><span class="line"><span class="number">3.</span>	信号处理程序可以调用的可重入函数可参阅man <span class="number">7</span> signal </span><br><span class="line"><span class="number">4.</span>	没有包含在上述列表中的函数大多是不可重入的，其原因为：</span><br><span class="line">    a)	使用静态数据结构</span><br><span class="line">    b)	调用了malloc或free</span><br><span class="line">    c)	是标准I/O函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="SIGCHILD信号"><a href="#SIGCHILD信号" class="headerlink" title="SIGCHILD信号"></a>SIGCHILD信号</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生条件</span></span><br><span class="line">	<span class="number">1.</span>子进程终止时</span><br><span class="line">    <span class="number">2.</span>子进程收到SIGSTOP信号停止时</span><br><span class="line">    <span class="number">3.</span>子进程处于停止态,收到SIGCONT后唤醒时</span><br><span class="line"><span class="comment">//借助SIGCHILD信号回收子进程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> status; <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">0</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit %d\n&quot;</span>, pid, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d cancel signal %d\n&quot;</span>, pid, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid; <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">sys_err</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child ID %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> sigaction act;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent ID %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGCHLD信号注意问题</span></span><br><span class="line"><span class="number">1.</span>子进程继承了父进程的信号屏蔽字和信号处理动作,但子进程没有继承未决信号集</span><br><span class="line"><span class="number">2.</span>注意注册信号捕捉函数的位置</span><br><span class="line"><span class="number">3.</span>应该在fork之前, 阻塞SIGCHLD信号, 注册完捕捉函数后解除阻塞</span><br></pre></td></tr></table></figure>

<h5 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.发送信号传参</span></span><br><span class="line"><span class="comment">//sigqueue函数对应kill函数,但可以携带参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意传地址时,不同进程之间虚拟地址空间独立,将当前进程地址传递给另一进程没有意义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.捕捉信号传参</span></span><br><span class="line"><span class="comment">//sigaction</span></span><br><span class="line">就是上述sigaction 中与sa_handler组成<span class="keyword">union</span>的另一成员</span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span> , <span class="type">siginfo_t</span>*.<span class="type">void</span>*);</span><br></pre></td></tr></table></figure>

<h5 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要分为慢速系统调用和其他系统调用</span></span><br><span class="line"><span class="comment">//慢速即可能会造成进程永久阻塞的哪一类</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221013000057549.png" alt="image-20221013000057549"></p>
<h5 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">终端即输入输出设备的总称</span><br><span class="line">    </span><br><span class="line"><span class="comment">//一个linxu系统启动的大致步骤</span></span><br><span class="line">    init --&gt; fork --&gt; exec --&gt; getty --&gt; 用户输入帐号 --&gt; login --&gt; 输入密码 --&gt; exec --&gt; bash</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么组合键不会被读到,存在一个特殊处理,线路规程</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221013000454257.png" alt="image-20221013000454257"></p>
<h5 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程组操作函数</span></span><br><span class="line"><span class="comment">//1.getpgrp</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="type">void</span>)</span></span>;      <span class="comment">//返回调用者的进程组id</span></span><br><span class="line"><span class="comment">//2.getpgid</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>; <span class="comment">//获取指定进程的进程组id</span></span><br><span class="line">	成功:<span class="number">0</span> 失败:<span class="number">-1</span>,设置errno</span><br><span class="line"><span class="comment">//3.setpgid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, pid_tgpid)</span> <span class="comment">//改变进程默认所属的进程组</span></span></span><br><span class="line"><span class="function">	非root进程只能改变自己创建的子进程,或有权操作的进程</span></span><br></pre></td></tr></table></figure>

<h5 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会话主要用来创建守护进程</span></span><br><span class="line"><span class="comment">//创建会话, 6点注意事项</span></span><br><span class="line">    <span class="number">1.</span>调用进程不能是进程组组长，该进程变成新会话首进程(session header)</span><br><span class="line">    <span class="number">2.</span>该进程成为一个新进程组的组长进程。</span><br><span class="line">    <span class="number">3.</span>需有root权限(ubuntu不需要)</span><br><span class="line">    <span class="number">4.</span>新会话丢弃原有的控制终端，该会话没有控制终端</span><br><span class="line">    <span class="number">5.</span>该调用进程是组长进程，则出错返回</span><br><span class="line">    <span class="number">6.</span>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</span><br><span class="line">       </span><br><span class="line"><span class="comment">//getsid 获取进程所属会话ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getisid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function">        成功：返回调用进程的会话ID；失败：-1，设置errno</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"><span class="comment">//setsid 创建一个会话,并以自己的ID设置进程组ID，同时也是新会话的ID</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">		成功：返回调用进程的会话ID；失败：<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>

<h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模型</span></span><br><span class="line"><span class="number">1.</span>创建子进程，父进程退出</span><br><span class="line">		 <span class="comment">//所有工作在子进程中进行形式上脱离了控制终端</span></span><br><span class="line"><span class="number">2.</span>在子进程中创建新会话</span><br><span class="line">　　	<span class="built_in">setsid</span>()函数</span><br><span class="line">　　	   <span class="comment">//使子进程完全独立出来，脱离控制</span></span><br><span class="line"><span class="number">3.</span>改变当前目录为根目录</span><br><span class="line">　　	<span class="built_in">chdir</span>()函数</span><br><span class="line">        <span class="comment">//防止占用可卸载的文件系统</span></span><br><span class="line">        <span class="comment">//也可以换成其它路径</span></span><br><span class="line"><span class="number">4.</span>重设文件权限掩码</span><br><span class="line">　　	<span class="built_in">umask</span>()函数</span><br><span class="line">        <span class="comment">//防止继承的文件创建屏蔽字拒绝某些权限</span></span><br><span class="line">        <span class="comment">//增加守护进程灵活性</span></span><br><span class="line"><span class="number">5.</span>关闭文件描述符</span><br><span class="line">　　	  <span class="comment">//继承的打开文件不会用到，浪费系统资源，无法卸载</span></span><br><span class="line"><span class="number">6.</span>开始执行守护进程核心工作</span><br><span class="line"><span class="number">7.</span>守护进程退出处理程序模型			</span><br><span class="line">    </span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mydaemond</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid, sid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sid = <span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">chdir</span>(<span class="string">&quot;/home/aurora/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">dup2</span>(<span class="number">0</span>, STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">dup2</span>(<span class="number">0</span>, STDERR_FILENO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mydaemond</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linux 中线程是后期加入的, 过度的不是很完善, 和windos的实现可能有区别, 本质仍是进程</span></span><br><span class="line"><span class="comment">//LWP : light weight process 轻量级的进程(本质)</span></span><br><span class="line"><span class="comment">//进程: 独立地址空间,拥有PCB</span></span><br><span class="line"><span class="comment">//线程: 也有PCB, 但没有独立的地址空间(共享)</span></span><br><span class="line"><span class="comment">//区别:是否共享地址空间</span></span><br><span class="line"><span class="comment">//Linux下: 线程是最小的执行单位, 进程最小的分配资源单位,可以看作一个线程的进程</span></span><br></pre></td></tr></table></figure>

<h5 id="Linxu内核线程的实现原理"><a href="#Linxu内核线程的实现原理" class="headerlink" title="Linxu内核线程的实现原理"></a>Linxu内核线程的实现原理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</span><br><span class="line"><span class="number">2.</span> 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</span><br><span class="line"><span class="number">3.</span> 进程可以蜕变成线程</span><br><span class="line"><span class="number">4.</span> 线程可看做寄存器和栈的集合</span><br><span class="line"><span class="number">5.</span> 在linux下，线程最是小的执行单位；进程是最小的分配资源单位</span><br><span class="line"><span class="comment">//察看LWP号：ps –Lf pid 查看指定线程的lwp号。</span></span><br><span class="line"><span class="comment">//三级映射：进程PCB --&gt; 页目录(可看成数组，首地址位于PCB中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元</span></span><br></pre></td></tr></table></figure>

<h5 id="线程共享-x2F-非共享资源"><a href="#线程共享-x2F-非共享资源" class="headerlink" title="线程共享&#x2F;非共享资源"></a>线程共享&#x2F;非共享资源</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享</span></span><br><span class="line"><span class="number">1.</span>文件描述符表</span><br><span class="line"><span class="number">2.</span>每种信号的处理方式</span><br><span class="line"><span class="number">3.</span>当前工作目录</span><br><span class="line"><span class="number">4.</span>用户ID和组ID</span><br><span class="line"><span class="number">5.</span>内存地址空间(.text/.data/.bss/heap/共享库)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//非共享</span></span><br><span class="line"><span class="number">1.</span>线程ID</span><br><span class="line"><span class="number">2.</span>处理器现场和栈指针(内核栈)</span><br><span class="line"><span class="number">3.</span>独立的栈空间(用户空间栈)</span><br><span class="line"><span class="number">4.</span>errno变量</span><br><span class="line"><span class="number">5.</span>信号屏蔽字</span><br><span class="line"><span class="number">6.</span>调度优先级</span><br><span class="line">    </span><br><span class="line"><span class="comment">//线程优,缺点</span></span><br><span class="line">    优点: <span class="number">1.</span>提高程序并发性 <span class="number">2.</span>开销小 <span class="number">3.</span>数据通信,共享数据方便</span><br><span class="line">    缺点: <span class="number">1.</span>库函数不稳定 <span class="number">2.</span>调式困难 <span class="number">3.</span>对信号支持不好</span><br></pre></td></tr></table></figure>

<h5 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.pthread_self  对应进程 getpid()</span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//alaways success</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.pthread_create 对应进程 fork()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span>*(*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">//返回值: 0成功, 失败错误号</span></span><br><span class="line"><span class="number">1.</span>参数一:传出参数,传出分配的线程ID</span><br><span class="line"><span class="number">2.</span>参数二:通常传<span class="literal">NULL</span>,表示线程使用默认属性, 想用具体属性可以修改该参数</span><br><span class="line"><span class="number">3.</span>参数三:函数指针,指向线程的主函数,函数运行结束,即线程结束</span><br><span class="line"><span class="number">4.</span>线程主函数执行期间,使用的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.pthread_exit  将单个线程退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;  <span class="comment">//参数: 表示线程退出状态, 通常传NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.ptherad_join 对应进程 waitpid()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br><span class="line">对比</span><br><span class="line">    进程: main返回值, exit参数-&gt;<span class="type">int</span>, 等待子进程结束 wait函数参数-&gt;<span class="type">int</span>*</span><br><span class="line">    线程: 线程主函数返回值, pthread_exit-&gt;<span class="type">void</span>*, 等待线程结束 pthread_join 参数-&gt;<span class="type">void</span>**</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.pthread_detach  实现线程分离 线程结束后自动释放, 不会产生僵尸进程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.pthread_cancel 对应进程 kill()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="string">&quot;注意&quot;</span>:线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</span><br><span class="line">	类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</span><br><span class="line">	取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man <span class="number">7</span> pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE<span class="number">.12</span><span class="number">.7</span> 取消选项小节。</span><br><span class="line">可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</span><br><span class="line">被取消的线程，	退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是<span class="number">-1</span>。可在头文件pthread.h中找到它的定义：<span class="meta">#<span class="keyword">define</span> PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//7.pthread_equal 比较两个线程id是否相等  可能未来线程id可能被修改为结构体实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终止线程的方式</span></span><br><span class="line"><span class="number">1.</span>线程主函数<span class="keyword">return</span></span><br><span class="line"><span class="number">2.</span>调用pthread_cancel</span><br><span class="line"><span class="number">3.</span>调用pthread_exit</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制原语对比</span></span><br><span class="line">进程		线程</span><br><span class="line">fork	 pthread_create</span><br><span class="line">exit	 pthread_exit</span><br><span class="line">wait     pthread_join</span><br><span class="line">kill     pthread_cancel</span><br><span class="line">getpid   pthread_self</span><br></pre></td></tr></table></figure>

<h5 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> 					etachstate; 	<span class="comment">//线程的分离状态</span></span><br><span class="line"><span class="type">int</span> 					schedpolicy; 	<span class="comment">//线程调度策略</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sched_param</span>		schedparam; 	<span class="comment">//线程的调度参数</span></span><br><span class="line"><span class="type">int</span> 					inheritsched; 	<span class="comment">//线程的继承性</span></span><br><span class="line"><span class="type">int</span> 					scope; 		    <span class="comment">//线程的作用域</span></span><br><span class="line"><span class="type">size_t</span> 					guardsize; 	    <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line"><span class="type">int</span>						stackaddr_set;  <span class="comment">//线程的栈设置</span></span><br><span class="line"><span class="type">void</span>* 					stackaddr; 	    <span class="comment">//线程栈的位置</span></span><br><span class="line"><span class="type">size_t</span> 					stacksize; 	    <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="type">pthread_attr_t</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的</span></span><br><span class="line"><span class="number">1.</span>线程分离状态</span><br><span class="line"><span class="number">2.</span>线程栈大小</span><br><span class="line"><span class="number">3.</span>线程栈警戒缓冲区大小</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;注意&quot;</span>: 应先初始化线程属性, 再由pthread_create创建线程</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程属性初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//销毁线程属性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的分离状态</span></span><br><span class="line"><span class="comment">//设置线程属性:分离 or 非分离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">//获取线程属性:分离 or 非分离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span>*detachstate)</span></span>;</span><br><span class="line"><span class="comment">//参数 attr: 已初始化线程</span></span><br><span class="line"><span class="comment">//detachstate: PTHREAD_CREATE_DETACHED(分离线程)</span></span><br><span class="line"><span class="comment">//             PTHREAD_CREATE_JOINABLE(非分离线程)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的栈地址</span></span><br><span class="line">POSIX<span class="number">.1</span>定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。</span><br><span class="line">当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr, <span class="type">size_t</span> *stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line">参数：	attr：指向一个线程属性的指针</span><br><span class="line">stackaddr：返回获取的栈地址</span><br><span class="line">stacksize：返回获取的栈大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的栈大小</span></span><br><span class="line">线程的栈大小</span><br><span class="line">当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</span><br><span class="line">函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line">参数：	attr：指向一个线程属性的指针</span><br><span class="line">stacksize：返回线程的堆栈大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 0x100000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">th_fun</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err, detachstate, i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">void</span> * stackaddr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_getstack</span>(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line">    <span class="built_in">pthread_attr_getdetachstate</span>(&amp;attr,&amp;detachstate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_DETACHED) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread detached\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_JOINABLE) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread join\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread unknown\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        stackaddr = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        <span class="keyword">if</span> (stackaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stacksize = SIZE;</span><br><span class="line">        <span class="built_in">pthread_attr_setstack</span>(&amp;attr, stackaddr, stacksize);</span><br><span class="line">        err = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, th_fun, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程使用注意事项</span></span><br><span class="line"><span class="number">1.</span>主线程推出其他线程不退出,主线程应调用pthread_exit</span><br><span class="line"><span class="number">2.</span>避免僵尸线程</span><br><span class="line">    pthread_join</span><br><span class="line">    pthread_detach</span><br></pre></td></tr></table></figure>

<h5 id="小实验-多线程拷贝并实现进度条"><a href="#小实验-多线程拷贝并实现进度条" class="headerlink" title="小实验 多线程拷贝并实现进度条"></a>小实验 多线程拷贝并实现进度条</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ITEMS 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_sys</span><span class="params">(<span class="type">void</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">perror</span>(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_usr</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(str, stderr);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> off, size, t_no;</span><br><span class="line">&#125;<span class="type">arg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *s, *d;</span><br><span class="line"><span class="type">int</span> *done;</span><br><span class="line"><span class="type">int</span> n = T_NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg&#123;off, size, t_no;&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">arg_t</span> *arg_p; <span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> *p, *q;</span><br><span class="line"></span><br><span class="line">	arg_p = (<span class="type">arg_t</span> *)arg;</span><br><span class="line">	p = s + arg_p-&gt;off, q = d + arg_p-&gt;off;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arg_p-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 逗号表达式的使用技巧*/</span></span><br><span class="line">		*q++ = *p++, done[arg_p-&gt;t_no]++;</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">display</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> size, interval, draw, sum, i, j;</span><br><span class="line"></span><br><span class="line">	size = (<span class="type">int</span>)arg;</span><br><span class="line">	interval = size / (ITEMS - <span class="number">1</span>);</span><br><span class="line">	draw = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(draw &lt; ITEMS)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			sum += done[i];</span><br><span class="line">		j = sum / interval + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(; j &gt; draw; draw++)&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>); <span class="built_in">fflush</span>(stdout);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> src, dst, i, len, off;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span> statbuf;</span><br><span class="line">	<span class="type">pthread_t</span> *tid;</span><br><span class="line">	<span class="type">arg_t</span> *arr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span> &amp;&amp; argc != <span class="number">4</span>)</span><br><span class="line">		<span class="built_in">err_usr</span>(<span class="string">&quot;usage : cp src dst [thread_no]\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">4</span>)</span><br><span class="line">		n = <span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	src = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(src == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to open&quot;</span>);</span><br><span class="line">	dst = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(dst == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to open&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fstat</span>(src, &amp;statbuf) == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to stat&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">lseek</span>(dst, statbuf.st_size - <span class="number">1</span>, SEEK_SET);</span><br><span class="line">	<span class="built_in">write</span>(dst, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);                          <span class="comment">//IO操作拓展文件大小,也可以使用truncate</span></span><br><span class="line"></span><br><span class="line">	s = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, statbuf.st_size, PROT_READ, MAP_PRIVATE, src, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(s == MAP_FAILED)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to mmap&quot;</span>);</span><br><span class="line">	d = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, statbuf.st_size, PROT_WRITE , MAP_SHARED, dst, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(d == MAP_FAILED)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(src); <span class="built_in">close</span>(dst);</span><br><span class="line">    <span class="comment">//pthread_t tid[n+1];</span></span><br><span class="line">	tid = (<span class="type">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * (n + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span>(tid == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to malloc&quot;</span>);</span><br><span class="line">    <span class="comment">//int done[n]  每个线程完成任务字节数</span></span><br><span class="line">	done = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>), n);</span><br><span class="line">	<span class="keyword">if</span>(done == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to malloc&quot;</span>);</span><br><span class="line">    <span class="comment">//arr[n] 每个线程的任务</span></span><br><span class="line">	arr = (<span class="type">arg_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">arg_t</span>) * n);</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to malloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建线程任务数组，分配任务</span></span><br><span class="line">	len = statbuf.st_size / n, off = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++, off += len) </span><br><span class="line">		arr[i].off = off, arr[i].size = len, arr[i].t_no = i; </span><br><span class="line">	arr[n - <span class="number">1</span>].size += (statbuf.st_size % n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建执行拷贝任务线程</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="type">void</span> *)&amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建进度线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid[n], <span class="literal">NULL</span>, display, (<span class="type">void</span> *)statbuf.st_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">pthread_join</span>(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1 </span></span><br><span class="line">	<span class="built_in">munmap</span>(s, statbuf.st_size);</span><br><span class="line">	<span class="built_in">munmap</span>(d, statbuf.st_size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">free</span>(tid); <span class="built_in">free</span>(done); <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>大概意思就是, 多线程对一个共享资源操作是, 由于竞争关系, 导致数据混乱, 用于解决这个问题, 就是线程同步</p>
<h5 id="互斥量-Mutex-初始值1"><a href="#互斥量-Mutex-初始值1" class="headerlink" title="互斥量 Mutex (初始值1)"></a>互斥量 Mutex (初始值1)</h5><p>互斥锁实质上是”建议锁”, 即使有了互斥锁, 如果有线程不按规则访问, 仍然数据混乱</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_mutex_init()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"><span class="comment">//restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</span></span><br><span class="line">	参<span class="number">1</span>:&amp;mutex	参<span class="number">2</span>:互斥量属性 通常传null</span><br><span class="line">	静态初始化: <span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_mutex_destroy()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_lock()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_trylock()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_unlock()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_t类型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a>加锁与解锁</h5><p><strong>lock 和 unlock :</strong></p>
<p>lock尝试加锁, 如果失败, 线程阻塞, 阻塞到该互斥量的其他线程解锁为止</p>
<p>unlock主动解锁, 同时将阻塞再该锁上的所有线程唤醒</p>
<p><strong>lock 和 trylock :</strong></p>
<p>lock加锁失败会阻塞, 等待锁释放</p>
<p>trylock加锁失败直接返回错误号, 不阻塞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutex使用例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">tfn</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>锁的不正确使用造成线程永久阻塞</p>
<p>1.线程试图对同一个互斥量A加锁两次</p>
<p>2.线程1拥有A锁, 请求获得B锁, 线程2拥有B锁, 请求获得A锁</p>
<p>第二种解决: 两线程按同一顺序获取锁; 或者第二把锁请求失败时, 主动解锁自己掌握的锁</p>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>读写锁一般具有三种状态：写锁, 读锁, 不加锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</span><br><span class="line"><span class="number">2.</span>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</span><br><span class="line"><span class="number">3.</span>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</span><br><span class="line"><span class="string">&quot;写独占 , 读共享&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_rwlock_init函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *restrict rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *restrict attr)</span></span>;</span><br><span class="line">	参<span class="number">2</span>:读写锁属性, 默认Null </span><br><span class="line"><span class="comment">//pthread_rwlock_destroy函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//pthread_rwlock_rdlock函数  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	读锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_wrlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	写锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_tryrdlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	非阻塞读锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_trywrlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	非阻塞写锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_unlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//pthread_rwlock_t 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁使用例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">th_write</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        t = counter;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=======write %d: %lu: counter=%d ++ counter= %d\n&quot;</span>,i, <span class="built_in">pthread_self</span>(), t, ++counter);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">th_read</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======read %d: %lu: %d\n&quot;</span>,i ,<span class="built_in">pthread_self</span>(), counter);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid[i], <span class="literal">NULL</span>, th_write, (<span class="type">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid[i+<span class="number">3</span>], <span class="literal">NULL</span>, th_read, (<span class="type">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_cond_init函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict attr)</span></span>;</span><br><span class="line">	参<span class="number">2</span>:条件变量属性, 通常传<span class="literal">NULL</span></span><br><span class="line">    静态初始化: <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">//pthread_cond_destroy函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//pthread_cond_wait函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex)</span></span>;</span><br><span class="line">	函数作用:</span><br><span class="line">	<span class="number">1.</span>阻塞等待条件变量cond满足</span><br><span class="line">    <span class="number">2.</span>释放已掌握的互斥锁, 相当于<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">		<span class="number">1</span>,<span class="number">2</span>步为一个原子操作</span><br><span class="line">    <span class="number">3.</span>当被唤醒, pthread_cond_wait返回时, 解除阻塞并重新申请互斥锁</span><br><span class="line"><span class="comment">//pthread_cond_timedwait函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *restrict abstime)</span></span>;</span><br><span class="line">参<span class="number">3</span>：	参看man sem_timedwait函数，查看<span class="keyword">struct</span> <span class="title class_">timespec</span>结构体。</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">			<span class="type">time_t</span> tv_sec;		<span class="comment">/* seconds */</span> 秒</span><br><span class="line">			<span class="type">long</span>   tv_nsec;	<span class="comment">/* nanosecondes*/</span> 纳秒</span><br><span class="line">		&#125;								</span><br><span class="line">形参abstime：绝对时间。										</span><br><span class="line">如：<span class="built_in">time</span>(<span class="literal">NULL</span>)返回的就是绝对时间。而<span class="built_in">alarm</span>(<span class="number">1</span>)是相对时间，相对当前时间定时<span class="number">1</span>秒钟。	</span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			<span class="built_in">pthread_cond_timedwait</span> (&amp;cond, &amp;mutex, &amp;t); 只能定时到 <span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>秒(早已经过去) </span><br><span class="line">		正确用法：</span><br><span class="line">			<span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> t;	定义timespec 结构体变量t</span><br><span class="line">			t.tv_sec = cur+<span class="number">1</span>; 定时<span class="number">1</span>秒</span><br><span class="line"><span class="built_in">pthread_cond_timedwait</span> (&amp;cond, &amp;mutex, &amp;t); 传参				参APUE<span class="number">.11</span><span class="number">.6</span>线程同步条件变量小节</span><br><span class="line">		在讲解setitimer函数时我们还提到另外一种时间类型：</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">             <span class="type">time_t</span>      tv_sec;  <span class="comment">/* seconds */</span> 秒</span><br><span class="line">             <span class="type">suseconds_t</span> tv_usec; 	<span class="comment">/* microseconds */</span> 微秒</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_cond_signal函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">	唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line"><span class="comment">//pthread_cond_broadcast函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">	唤醒所有</span><br><span class="line"><span class="comment">//pthread_cond_t 类型</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="comment">//生产者-消费者模型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表作为共享数据,被mutex保护*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msg</span> *next;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> *head;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> *mp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态初始化 一个条件变量 一个互斥量*/</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume ---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">productor</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        mp-&gt;num = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Produce ---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;has_product);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid, <span class="literal">NULL</span>, productor, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>互斥量初始值1, 到0 阻塞, 信号量初始值n, 到0阻塞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量基本操作</span></span><br><span class="line">sem_wait : 信号量大于<span class="number">0</span> ，信号量-- ; 信号量等于<span class="number">0</span> ，线程阻塞</span><br><span class="line">	类比pthread_mutex_lock</span><br><span class="line">sem_post : 信号量++，同时唤醒所有阻塞的线程</span><br><span class="line">    类比pthread_mutex_unlock</span><br><span class="line">信号量的初值决定了占用信号量线程的个数, 与mutex类似, <span class="type">sem_t</span> 实现对用户隐藏, +--通过函数实现</span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_init函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">	参<span class="number">1</span>:sem信号量  </span><br><span class="line">    参<span class="number">2</span>:取<span class="number">0</span>用于线程间, 取非<span class="number">0</span>用于进程间</span><br><span class="line">    参<span class="number">3</span>:value指定信号量初值</span><br><span class="line"><span class="comment">//sem_destroy函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//sem_wait函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">	加锁lock</span><br><span class="line"><span class="comment">//sem_trywait函数	</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">	类比trylock</span><br><span class="line"><span class="comment">//sem_timedwait函数	</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span></span>;</span><br><span class="line">	参<span class="number">2</span>：abs_timeout采用的是绝对时间。			</span><br><span class="line">	定时<span class="number">1</span>秒：</span><br><span class="line">		<span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> t;	定义timespec 结构体变量t</span><br><span class="line">		t.tv_sec = cur+<span class="number">1</span>; 定时<span class="number">1</span>秒</span><br><span class="line">		t.tv_nsec = t.tv_sec +<span class="number">100</span>; </span><br><span class="line"><span class="built_in">sem_timedwait</span>(&amp;sem, &amp;t); 传参</span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_post函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;	</span><br><span class="line">	解锁unlock</span><br><span class="line"><span class="comment">//sem_t 类型     头文件&lt;semaphore.h&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//生产者消费者模型, 思路上会和前面的几种锁有一定不同, 前面都是对一个资源进行上锁,信号量虽然也是对一个资源,但是两把锁影响互相影响达到目的</span></span><br><span class="line"><span class="comment">/*信号量实现生产者消费者模型*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> queue[NUM];</span><br><span class="line"><span class="type">sem_t</span> blank_number , product_number; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;blank_number);</span><br><span class="line">        queue[i] = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----Produce---%d\n&quot;</span>, queue[i]);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;product_number);</span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() %<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;product_number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume---%d\n&quot;</span>, queue[i]);</span><br><span class="line">        queue[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;blank_number);</span><br><span class="line"></span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() %<span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;blank_number, <span class="number">0</span>, NUM);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;product_number, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;blank_number);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><p>进程间同步也可以使用互斥锁,但应该在初始化之前将其属性修改为进程间共享</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mattr 类型：		用于定义mutex锁的【属性】</span><br><span class="line">pthread_mutexattr_init函数：			初始化一个mutex属性对象</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line">pthread_mutexattr_destroy函数：		销毁mutex属性对象 (而非销毁锁)</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line">pthread_mutexattr_setpshared函数：	修改mutex属性。</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line">	参<span class="number">2</span>：pshared取值：</span><br><span class="line">		线程锁：<span class="built_in">PTHREAD_PROCESS_PRIVATE</span> (mutex的默认属性即为线程锁，进程间私有)</span><br><span class="line">		进程锁：PTHREAD_PROCESS_SHARED</span><br><span class="line"></span><br><span class="line"><span class="comment">//ps:进程间的全局变量, 读时共享, 写时复制, 所以应该创建一块映射区</span></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mt</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mt</span> *mm;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    mm = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(*mm), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mm, <span class="number">0</span>, <span class="built_in">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutexattr_init</span>(&amp;mm-&gt;mutexattr);</span><br><span class="line">    <span class="built_in">pthread_mutexattr_setpshared</span>(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-child-------------num++     %d\n&quot;</span>, mm-&gt;num);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">            mm-&gt;num += <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;------parent------num+=2     %d\n&quot;</span>, mm-&gt;num);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutexattr_destroy</span>(&amp;mm-&gt;mutexattr);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mm-&gt;mutex);</span><br><span class="line">    <span class="built_in">munmap</span>(mm, <span class="built_in">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h5><p>借助fcntl函数实现锁机制,操作文件的进程没有获得锁时,可以打开,但无法执行read,write</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效果上和线程同步的读写锁类似, 用于实现进程的间的读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...<span class="comment">/*arg*/</span>)</span></span>;</span><br><span class="line">	参<span class="number">2</span>:</span><br><span class="line">		<span class="built_in">F_SETLK</span>(<span class="keyword">struct</span> flock*) 设置文件锁(trylock)</span><br><span class="line">        <span class="built_in">F_SETLKW</span>(<span class="keyword">struct</span> flock*)设置文件锁(lock) W-&gt;<span class="function">wait</span></span><br><span class="line"><span class="function">        <span class="title">F_GETLK</span><span class="params">(<span class="keyword">struct</span> flock*)</span> 获取文件锁</span></span><br><span class="line"><span class="function">    参3:</span></span><br><span class="line"><span class="function">        struct flock &#123;</span></span><br><span class="line">              ...</span><br><span class="line">              <span class="type">short</span> l_type;    	锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span><br><span class="line">              <span class="type">short</span> l_whence;  	偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span><br><span class="line">              <span class="type">off_t</span> l_start;   	起始偏移：<span class="number">1000</span></span><br><span class="line">              <span class="type">off_t</span> l_len;     	长度：<span class="number">0</span>表示整个文件加锁</span><br><span class="line">              <span class="type">pid_t</span> l_pid;     	持有该锁的进程ID：(F_GETLK only)</span><br><span class="line">              ...</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">flock</span> f_lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">sys_err</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_WRLCK;  <span class="comment">/*写锁*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// f_lock.l_type = F_RDLCK; /*读锁*/</span></span><br><span class="line"></span><br><span class="line">    f_lock.l_whence = SEEK_SET;</span><br><span class="line">    f_lock.l_start = <span class="number">0</span>;</span><br><span class="line">    f_lock.l_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get flock\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;un lock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="APUE书籍部分笔记"><a href="#APUE书籍部分笔记" class="headerlink" title="APUE书籍部分笔记"></a>APUE书籍部分笔记</h2><p><strong>重点章节:3,4,5,7,8,10,11,12 优先看</strong></p>
<h3 id="第3章-文件I-x2F-O"><a href="#第3章-文件I-x2F-O" class="headerlink" title="第3章 文件I&#x2F;O"></a>第3章 文件I&#x2F;O</h3><h4 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h4><p>本章描述的函数被称为 <strong>不带缓冲的I&#x2F;O</strong>, <strong>不带缓冲</strong>指的是每个read和write都调用内核中的一个系统调用</p>
<h4 id="3-2-文件描述符"><a href="#3-2-文件描述符" class="headerlink" title="3.2 文件描述符"></a>3.2 文件描述符</h4><p>对于内核而言,所有打开的文件都通过文件描述符引用,0 ,1, 2 文件描述符本别于标准输入, 标准输出, 标准错误关联</p>
<h4 id="3-3-函数open-和-openat"><a href="#3-3-函数open-和-openat" class="headerlink" title="3.3 函数open 和 openat"></a>3.3 函数open 和 openat</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件描述符, 失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//path 打开或创建的文件名， oflag 参数, 此函数的多个选项</span></span><br><span class="line"><span class="comment">//下列5个常量中必须指定一个且只能指定一个</span></span><br><span class="line">O_RDONLY 只读打开  O_WRONLY 只写打开  O_RDWR 读写打开  O_EXEC 只执行打开  O_SEARCH 只搜索打开</span><br><span class="line"><span class="comment">//下列常量是可选的</span></span><br><span class="line">O_APPEND 每次写时追加到文件的尾端  O_CLOEXEC 把FD_CLOEXEC设置为文件描述符标志  O_CREATE 若文件不存在则创建它,使用此选项时需要指定<span class="type">mode_t</span>参数  O_DIRECTORY 如果path引用的不是目录则出错  O_EXCL 如果同时指定了O_CREATE文件已经存在则出错,用此可以测试一个文件是否存在,不存在则创建此文件,测试和创建文件为一个原子操作  O_NOCTTY 如果path引用的是终端设备,则不将该设备分配为此进程的控制终端  O_NOFOLLOW 如果path引用的是一个符号链接则出错  	O_NONBLOCK 设置非阻塞  O_SYNC 使每次write等待物理I/O操作完成  O_TRUNC 如果此文件存在,而且为只写或读写成功打开,将其长度截断为<span class="number">0</span>  O_TTY_INIT 如果打开一个还未打开的终端设备,设置非标准termios参数值  O_DSYNC   O_RSYNC </span><br></pre></td></tr></table></figure>

<p>可以看到open和openat在参数上,openat多了一个fd</p>
<p>fd把open和openat区分开来,三种可能性:</p>
<pre><code>1. path参数指定的是绝对路径名, 此时fd参数被忽略, openat相当于open
1. path参数指定的是相对路径名, fd参数指出相对路径名在文件系统中的开始地址, fd参数是通过打开相对路径名所在的目录来获取
1. path参数指定相对路径名, fd参数具有AT_FDCWD, 此时路径名在当前工作目录中获得, 也类似于open
</code></pre>
<p>目的：</p>
<ol>
<li>让线程使用相对路径打开目录的文件, 同一进程中的所有线程共享相同的当前工作目录, 因此很难让同一进程的多个不同线程在同一时间工作在不同的目录</li>
<li>可以避免time-of-check-to-time-of-use问题</li>
</ol>
<p><strong>文件名和路径名截断</strong></p>
<p>就是说以前的文件名上限小的时候比如14，此时文件名过长会截断, 也可能会返回错误值, 这样就出现了很大的风险, 系统也不知道到底截断过还是返回错误值, 现在不用考虑这个问题了, 现在的文件名上限大多255</p>
<h4 id="3-4-函数create"><a href="#3-4-函数create" class="headerlink" title="3.4 函数create"></a>3.4 函数create</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回只写打开的文件描述符, 失败返回-1</span></span><br><span class="line"><span class="comment">//此函数等效于</span></span><br><span class="line"><span class="built_in">open</span>(path, O_WRONLY | O_CREATE | O_TRUNC, mode);</span><br><span class="line">	<span class="comment">//create出现的原因在于早期,open不支持O_CREATE</span></span><br></pre></td></tr></table></figure>

<p>另一个不足之处, 在于create只能创建只写打开的文件</p>
<h4 id="3-5-函数close"><a href="#3-5-函数close" class="headerlink" title="3.5 函数close"></a>3.5 函数close</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0, 失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁，当一个进程终止时, 内核自动关闭所有它打开的文件</p>
<h4 id="3-6-函数lseek"><a href="#3-6-函数lseek" class="headerlink" title="3.6 函数lseek"></a>3.6 函数lseek</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件偏移量, 失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>对参数<strong>offset</strong>的解释与参数<strong>whence</strong>的值有关:</p>
<ol>
<li>若whence是SEEK_SET, 将文件的偏移量设置为距文件开始offset个字节</li>
<li>若whence是seek_cur, 将文件的偏移量设置为当前值加offset, offset可正可负</li>
<li>若whence是SEEK_END, 将文件的偏移量设置为文件长度加offset, 可正可负</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前偏移量</span></span><br><span class="line"><span class="type">off_t</span> currpos;</span><br><span class="line">currpos = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="comment">//这种方法也可以用来确定涉及文件是否可以设置偏移量, 如果文件描述符是管道, fifo 或套接字, lseek返回-1, 并将errno设置为ESPITE</span></span><br></pre></td></tr></table></figure>

<p>文件偏移量可以大于文件的当前长度, 这种情况下会形成空洞文件，但位于文件中没有写过的字节都被读成0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空洞文件示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf1[] = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf2[] = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">create</span>(<span class="string">&quot;file.hole&quot;</span>, FILE_MODE)) &lt; <span class="number">0</span>)	</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;create error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    <span class="comment">/* offset now = 10*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line">    <span class="comment">/* offset noew = 16384 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;buf2 write error&quot;</span>);</span><br><span class="line">    <span class="comment">/* offset noew = 16394 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-7-函数read"><a href="#3-7-函数read" class="headerlink" title="3.7 函数read"></a>3.7 函数read</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line">	<span class="comment">//读到的字节数,若已到文件尾,返回0,  失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>有多种情况可使实际读到的字节数少于要求读的字节数:</p>
<ol>
<li>读普通文件时, 在读到要求的字数之前已到达文件尾端, 例如文件30字节, 而要求读100字节, 则read返回30, 下一次调用返回0</li>
<li>从终端设备读时,通常一次最多读一行</li>
<li>从网络读时, 取决于网络中的缓冲机制</li>
<li>从管道和FIFO读时, 返回实际读到的可用字节数</li>
<li>从某些面向记录的设备时(如磁带), 一次最多返回一个记录</li>
<li>当一信号造成中断时, 而已读了部分数据</li>
</ol>
<h4 id="3-8-函数write"><a href="#3-8-函数write" class="headerlink" title="3.8 函数write"></a>3.8 函数write</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回已写字节数, 失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>对于普通文件, 写操作从文件的当前偏移量处开始，如果在打开文件时，指定了O_APPEND选项，每次写操作之前，将文件的偏移量设置在文件的当前结尾处，在一次成功写操作后，文件偏移量增加实际写的字节数</p>
<h4 id="3-9-I-x2F-O的效率"><a href="#3-9-I-x2F-O的效率" class="headerlink" title="3.9 I&#x2F;O的效率"></a>3.9 I&#x2F;O的效率</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[BUFFSIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n == <span class="built_in">read</span>(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不同大小的BUFFSIZE</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221018231151437.png" alt="image-20221018231151437"></p>
<p>大多数文件系统为改善性能采用某种预读技术</p>
<h4 id="3-10-文件共享"><a href="#3-10-文件共享" class="headerlink" title="3.10 文件共享"></a>3.10 文件共享</h4><p>本小节分两部分，第一部分描述了内核中文件是以何等方式打开文件</p>
<ol>
<li><p>每个进程在进程表中都有一个记录项，记录项包含一张打开的文件描述符表，每个描述符占用一项，与每个文件描述符关联的是</p>
<p>​	a.文件描述符标志(close_on_exec)</p>
<p>​	b.指向一个文件表项的指针</p>
</li>
<li><p>内核为所有打开文件维持一张表，每个表项包含:</p>
<p>​	a.文件状态标志(读，写，添加，同步和非阻塞等)</p>
<p>​	b.当前文件偏移量</p>
<p>​	c.指向该文件v节点表项的指针</p>
</li>
<li><p>每个打开文件都有一个v节点结构，v节点包含了文件类型和对此文件进行各种操作函数的指针，对于大多数文件还包含i节点，索引节点</p>
</li>
</ol>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221018235724033.png" alt="image-20221018235724033"></p>
<p>另一部分说明了，如果两个独立进程各自打开了同一文件:</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221018235917212.png" alt="image-20221018235917212"></p>
<p>我们假定第一个进程在3上打开了文件，而另一个在4上打开了文件，每个进程都会获得一份自己的文件表项，但一个文件只有一个v节点表项</p>
<p>fork后的父子进程，各自的每一个打开文件描述符共享同一个文件表项</p>
<h4 id="3-11-原子操作"><a href="#3-11-原子操作" class="headerlink" title="3.11 原子操作"></a>3.11 原子操作</h4><p>简单来说，在多进程的背景下，两次函数调用之间，可能会出现，从当前进程切到另一进程，执行另一进程的事情后，再返回当前进程继续往下执行，这期间可能会导致问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个追加文件的例子</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>)       <span class="comment">//假设设置偏移量到文件尾</span></span><br><span class="line">    <span class="built_in">err_sys</span>(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf, <span class="number">100</span>) != <span class="number">100</span>)</span><br><span class="line">   	<span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时就可能会出现这么一种情况，当前进程将偏移量设置到文件尾后，假设为1500，此时由于调度切换到另一进程，另一进程对同一文件进行了修改，使得文件变成了1600大小，此时再切会当前进程，就出现了和我没所期望的不一样的结果，而将lseek和write的作用合成一步，这就是原子操作，如UNIX系统为我们提供了一种方法，O_APPEND</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XSI扩展的原子性地定位并执行I/O</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>*buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于先lseek再调用read/write</span></span><br></pre></td></tr></table></figure>



<h4 id="3-12-函数dup和dup2"><a href="#3-12-函数dup和dup2" class="headerlink" title="3.12 函数dup和dup2"></a>3.12 函数dup和dup2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列两个函数可用来复制一个现有的文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span></span>;</span><br><span class="line">	<span class="comment">//两函数的返回值，若成功返回新的文件描述符，若出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>dup返回的新文件描述符一定是当前可用文件描述符中的最小值，对于dup2，可用用fd2指定新文件描述符的值，如果fd2已经打开，先将其关闭。如果fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清除(?不理解什么意思)</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221019002908225.png" alt="image-20221019002908225"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于dup 和 dup2 同样也有等效函数</span></span><br><span class="line"><span class="built_in">dup</span>(fd);      -----&gt;  <span class="built_in">fcntl</span>(fd, F_DUPFD, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dup2</span>(fd, fd2);-----&gt;  <span class="built_in">close</span>(fd2); <span class="built_in">fcntl</span>(fd, F_DUPFD, fd2);</span><br><span class="line"><span class="comment">//区别在于: 1.dup2是原子操作 2.errno不同</span></span><br></pre></td></tr></table></figure>



<h4 id="3-13-函数sync-fsync-和-fdatasync"><a href="#3-13-函数sync-fsync-和-fdatasync" class="headerlink" title="3.13 函数sync,fsync 和 fdatasync"></a>3.13 函数sync,fsync 和 fdatasync</h4><p>传统的UNIX系统实现在内核中没有缓冲区高速缓存或页高速缓存。写入数据时，先将数据复制到缓冲区，然后排入队列，再写入磁盘。该方式被称为延迟写。sync, fsync和fdatasync三个函数用来保证磁盘实际文件系统和缓冲区内容的一致性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsync</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fdtasync</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0， 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sync只是将修改过的块缓冲区排入写队列，然后返回，不等待实际写磁盘操作结束，被称为update的守护进程，会周期性调用该函数</p>
<p>fsync只对fd指定的文件起作用，并且等待实际写硬盘操作结束</p>
<p>fdtasync与fsync类似，但它只影响文件的数据部分，而除数据外，fsync还会同步更新文件属性</p>
<h4 id="3-14-函数fcntl"><a href="#3-14-函数fcntl" class="headerlink" title="3.14 函数fcntl"></a>3.14 函数fcntl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fcntl函数可以改变已经打开的文件属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/*int arg*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fcntl函数有以下5个功能：</p>
<ol>
<li>复制一个已有的描述符(cmd &#x3D; F_DUPFD 或 F_DUPFD_CLOEXEC)</li>
<li>获取&#x2F;设置文件描述符标志(cmd &#x3D; F_GETFD 或 F_SETFD)</li>
<li>获取&#x2F;设置文件状态标志(cmd &#x3D; F_GETFL 或 F_SETFL)</li>
<li>获取&#x2F;设置异步I&#x2F;O所有权(cmd &#x3D; F_GETOWN 或 F_SETOWN)</li>
<li>获取&#x2F;设置记录锁 (参考上面视频笔记部分的文件锁，很详细，后续也会继续补全)</li>
</ol>
<p>该小节只说明前四种，记录锁在后面章节补充：</p>
<p>**F_DUPFD:**复制文件描述符fd，新文件描述符作文函数值返回，它是尚未打开的各描述符中大于或等于第三个参数值中各值的最小值(就是从传入的fd2起，没有被使用的最小描述符)，他与fd共享同一文件表项，但它有自己的一套文件描述符标志，其FD_CLOEXEC设置为被清除(?不清楚)，第8章会讨论这一点</p>
<p>**F_DUPFD_CLOEXEC:**复制文件描述符fd，设置与新描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符</p>
<p>**F_GETFD:**对应于fd的文件描述符标志作为函数值返回，当前只定义了一个描述符标志FD_CLOEXEC(主要还不知的文件描述符标志用来干啥，后续应该会补充)</p>
<p>**F_SETFD:**对于fd设置的文件描述符标志，新标志值按第三个参数设置</p>
<p>​		”现在很多程序不使用常量FD_CLOEXEC，而是设置为0, (系统默认，在exec时不关闭), 设置为1(在exec时关闭)“</p>
<p>**F_GETFL:**对应于fd的文件状态标志作为函数值返回，open时已经描述了文件状态</p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221019005856046.png" alt="image-20221019005856046"></p>
<p>对于5个访问标志，前5个，并不各占一位，由于历史原因，前3个的值分别是0，1，2，因此首先必须使用屏蔽字O_ACCMODE取得访问方式位</p>
<p>**F_SETFL:**将文件状态的设置为第3个参数的值，可以更改的几个标志为:O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, O_ASYNC</p>
<p>**F_GETOWN:**获取当前接受SIGIO和SIGURG信号的进程ID或进程组ID，14章会作讨论</p>
<p>**F_SETOWN:**设置接收SIGIO和SIGURG信号的进程ID或进程组ID，正的arg指定一个进程ID，负的arg指定进程组ID</p>
<p>fcntl的返回值与命令有关，出错所有都返回-1，成功返回某个其他值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">err_quit</span>(<span class="string">&quot;usage: a.out &lt;descriptor#&gt;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((val = <span class="built_in">fcntl</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">        <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read only&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">            <span class="built_in">prinf</span>(<span class="string">&quot;write only&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_RDWR:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">err_dump</span>(<span class="string">&quot;unknown access mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, append&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, nonblocking&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_SYNC)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, synchronous writes&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">$./a.out <span class="number">0</span> &lt; /dev/tty</span><br><span class="line">read only</span><br><span class="line">$./a.out <span class="number">1</span> &gt; temp.foo</span><br><span class="line">$cat temp.foo</span><br><span class="line">write only</span><br><span class="line">$./a.out <span class="number">2</span> <span class="number">2</span>&gt;&gt;temp.foo</span><br><span class="line">write only, append</span><br><span class="line">$./a.out <span class="number">5</span> <span class="number">5</span>&lt;&gt;temp.foo</span><br><span class="line">read write</span><br></pre></td></tr></table></figure>

<p>修改时应该采用先获取现在的标志值，然后修改它，最后设置新的标志值，而不是之间F_SETFD或F_SETFL这样会关闭以前设置的标志值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flags are file status flags to turn on</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ((val = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl get error&quot;</span>);</span><br><span class="line">    val |= flags;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl set error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果这样就是关闭 turn off</span></span><br><span class="line">vla &amp;= ~flags;</span><br></pre></td></tr></table></figure>



<h4 id="3-15-函数ioctl"><a href="#3-15-函数ioctl" class="headerlink" title="3.15 函数ioctl"></a>3.15 函数ioctl</h4><p>ioctl函数一直是I&#x2F;O操作的杂物箱，不能用本章其他函数表示的I&#x2F;O操作通常都能用ioctl表示，终端I&#x2F;O是使用ioctl最多的地方(what? 没用过难以理解是干啥的)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>后续描述看起来ioctl是一个能自定义一些I&#x2F;O操作的函数，如磁带操作使我们可以在磁带上写一个文件结束标志，倒带，越过指定个数的文件或记录等。本章其他函数操作都难以表示这些操作，所以最容易的方法就是使用ioctl</p>
<h4 id="3-16-x2F-dev-x2F-fd"><a href="#3-16-x2F-dev-x2F-fd" class="headerlink" title="3.16 &#x2F;dev&#x2F;fd"></a>3.16 &#x2F;dev&#x2F;fd</h4><p>了解了解就行，举个例子，fd &#x3D; open(“dev&#x2F;fd&#x2F;0”, mode) 相当于fd &#x3D; dup(0);</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本章主要说明了UNXI系统提供的基本I&#x2F;O函数，原子操作，内核共享打开文件信息的数据结构，多种将数据冲洗到磁盘上的方式(sync?)，不同I&#x2F;O长度对读文件所需时间的影响，已经多种功能的fcntl函数，14章还将介绍fcntl的第5中功能，18，19章介绍ioctl函数</p>
<h3 id="第4章-文件和目录"><a href="#第4章-文件和目录" class="headerlink" title="第4章 文件和目录"></a>第4章 文件和目录</h3><h3 id="第5章-标准I-x2F-O库"><a href="#第5章-标准I-x2F-O库" class="headerlink" title="第5章 标准I&#x2F;O库"></a>第5章 标准I&#x2F;O库</h3><h3 id="第7章-进程环境"><a href="#第7章-进程环境" class="headerlink" title="第7章 进程环境"></a>第7章 进程环境</h3><h3 id="第8章-进程控制"><a href="#第8章-进程控制" class="headerlink" title="第8章 进程控制"></a>第8章 进程控制</h3><h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><h3 id="第11章-线程"><a href="#第11章-线程" class="headerlink" title="第11章 线程"></a>第11章 线程</h3><h3 id="第12章-线程控制"><a href="#第12章-线程控制" class="headerlink" title="第12章 线程控制"></a>第12章 线程控制</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AuroraFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/16/APUE%20note/">http://example.com/2022/10/16/APUE%20note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Aurora</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/background.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/"><img class="next-cover" src="/./img/suanfa.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法笔记note2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/headd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AuroraFish</div><div class="author-info__description">保持幻想</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AuroraFish"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AuroraFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:205878047@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只是睡着了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unix-%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Unix 环境高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">linux 一些零散的基础知识(视频系统编程部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.0.0.1.</span> <span class="toc-text">快捷命令:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.0.0.2.</span> <span class="toc-text">目录结构:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.0.0.3.</span> <span class="toc-text">常见文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%86%9F%E6%82%89"><span class="toc-number">1.1.0.0.4.</span> <span class="toc-text">文件或目录熟悉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.1.0.0.5.</span> <span class="toc-text">安装和卸载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.1.0.0.6.</span> <span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.0.0.7.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.0.0.8.</span> <span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.0.0.9.</span> <span class="toc-text">三种服务器搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ftp%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.0.0.9.1.</span> <span class="toc-text">ftp服务器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#nfs%E6%9C%8D%E5%8A%A1%E5%99%A8-%EF%BC%88%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">1.1.0.0.9.2.</span> <span class="toc-text">nfs服务器 （共享文件夹)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ssh%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.0.0.9.3.</span> <span class="toc-text">ssh服务器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vim-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.0.0.10.</span> <span class="toc-text">vim 操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gcc"><span class="toc-number">1.1.0.0.11.</span> <span class="toc-text">gcc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.0.0.12.</span> <span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.1.0.0.13.</span> <span class="toc-text">动态库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.0.0.14.</span> <span class="toc-text">GDB调试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Makefile"><span class="toc-number">1.1.0.0.15.</span> <span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.0.0.16.</span> <span class="toc-text">虚拟地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stat-lstat%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%A9%BF%E9%80%8F%E5%92%8C%E4%B8%8D%E7%A9%BF%E9%80%8F"><span class="toc-number">1.1.0.0.17.</span> <span class="toc-text">stat lstat区别，穿透和不穿透</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.0.0.18.</span> <span class="toc-text">程序和进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU%E5%9F%BA%E6%9C%AC%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.0.0.19.</span> <span class="toc-text">CPU基本运作方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MMU"><span class="toc-number">1.1.0.0.20.</span> <span class="toc-text">MMU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">1.1.0.0.21.</span> <span class="toc-text">进程控制块 PCB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.0.0.22.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.0.0.23.</span> <span class="toc-text">环境变量函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FORK"><span class="toc-number">1.1.0.0.24.</span> <span class="toc-text">FORK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.1.0.0.25.</span> <span class="toc-text">exec函数族</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#wait"><span class="toc-number">1.1.0.0.26.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IPC"><span class="toc-number">1.1.0.0.27.</span> <span class="toc-text">IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-1"><span class="toc-number">1.1.0.0.27.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#FIFO"><span class="toc-number">1.1.0.0.27.2.</span> <span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.0.0.27.3.</span> <span class="toc-text">共享存储映射</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#strace"><span class="toc-number">1.1.0.0.28.</span> <span class="toc-text">strace</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C-%E5%88%A9%E7%94%A8fifo%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">1.1.0.0.29.</span> <span class="toc-text">小实验 利用fifo实现简单的本地聊天室</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.0.0.30.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">1.1.0.0.31.</span> <span class="toc-text">信号捕捉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.0.0.32.</span> <span class="toc-text">内核实现信号捕捉过程:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E7%AB%9E%E6%80%81"><span class="toc-number">1.1.0.0.33.</span> <span class="toc-text">时序竞态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BC%82%E6%AD%A5I-x2F-O"><span class="toc-number">1.1.0.0.34.</span> <span class="toc-text">全局变量异步I&#x2F;O</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0-x2F-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.0.0.35.</span> <span class="toc-text">可重入函数&#x2F;不可重入函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIGCHILD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.0.0.36.</span> <span class="toc-text">SIGCHILD信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82"><span class="toc-number">1.1.0.0.37.</span> <span class="toc-text">信号传参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.0.0.38.</span> <span class="toc-text">中断系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF"><span class="toc-number">1.1.0.0.39.</span> <span class="toc-text">终端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">1.1.0.0.40.</span> <span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.1.0.0.41.</span> <span class="toc-text">会话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.0.0.42.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.0.0.43.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Linxu%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.0.0.44.</span> <span class="toc-text">Linxu内核线程的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB-x2F-%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.0.0.45.</span> <span class="toc-text">线程共享&#x2F;非共享资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.1.0.0.46.</span> <span class="toc-text">线程控制原语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.0.0.47.</span> <span class="toc-text">线程属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">1.1.0.0.48.</span> <span class="toc-text">小实验 多线程拷贝并实现进度条</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.0.0.49.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-Mutex-%E5%88%9D%E5%A7%8B%E5%80%BC1"><span class="toc-number">1.1.0.0.50.</span> <span class="toc-text">互斥量 Mutex (初始值1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E4%B8%8E%E8%A7%A3%E9%94%81"><span class="toc-number">1.1.0.0.51.</span> <span class="toc-text">加锁与解锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.1.0.0.52.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.1.0.0.53.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.0.0.54.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.1.0.0.55.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.0.0.56.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-number">1.1.0.0.57.</span> <span class="toc-text">文件锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APUE%E4%B9%A6%E7%B1%8D%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0"><span class="toc-number">1.2.</span> <span class="toc-text">APUE书籍部分笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%96%87%E4%BB%B6I-x2F-O"><span class="toc-number">1.2.1.</span> <span class="toc-text">第3章 文件I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">3.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">3.2 文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%87%BD%E6%95%B0open-%E5%92%8C-openat"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.3 函数open 和 openat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%87%BD%E6%95%B0create"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">3.4 函数create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0close"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">3.5 函数close</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%87%BD%E6%95%B0lseek"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">3.6 函数lseek</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%87%BD%E6%95%B0read"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">3.7 函数read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%87%BD%E6%95%B0write"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">3.8 函数write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-I-x2F-O%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">3.9 I&#x2F;O的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.1.10.</span> <span class="toc-text">3.10 文件共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.11.</span> <span class="toc-text">3.11 原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-%E5%87%BD%E6%95%B0dup%E5%92%8Cdup2"><span class="toc-number">1.2.1.12.</span> <span class="toc-text">3.12 函数dup和dup2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-%E5%87%BD%E6%95%B0sync-fsync-%E5%92%8C-fdatasync"><span class="toc-number">1.2.1.13.</span> <span class="toc-text">3.13 函数sync,fsync 和 fdatasync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-%E5%87%BD%E6%95%B0fcntl"><span class="toc-number">1.2.1.14.</span> <span class="toc-text">3.14 函数fcntl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-%E5%87%BD%E6%95%B0ioctl"><span class="toc-number">1.2.1.15.</span> <span class="toc-text">3.15 函数ioctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-16-x2F-dev-x2F-fd"><span class="toc-number">1.2.1.16.</span> <span class="toc-text">3.16 &#x2F;dev&#x2F;fd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.17.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">第4章 文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%A0%87%E5%87%86I-x2F-O%E5%BA%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">第5章 标准I&#x2F;O库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">第7章 进程环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">第8章 进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.6.</span> <span class="toc-text">第10章 信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">第11章 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.8.</span> <span class="toc-text">第12章 线程控制</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="APUE 学习笔记"/></a><div class="content"><a class="title" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记">APUE 学习笔记</a><time datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记note2"/></a><div class="content"><a class="title" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2">算法笔记note2</a><time datetime="2022-05-05T10:48:47.000Z" title="发表于 2022-05-05 18:48:47">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记题目"/></a><div class="content"><a class="title" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目">算法笔记题目</a><time datetime="2022-04-19T06:35:55.000Z" title="发表于 2022-04-19 14:35:55">2022-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C++11%20note/" title="深入应用C++11 note"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入应用C++11 note"/></a><div class="content"><a class="title" href="/2022/04/18/%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8C++11%20note/" title="深入应用C++11 note">深入应用C++11 note</a><time datetime="2022-04-18T10:48:47.000Z" title="发表于 2022-04-18 18:48:47">2022-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note/" title="算法笔记 Note"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记 Note"/></a><div class="content"><a class="title" href="/2022/04/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note/" title="算法笔记 Note">算法笔记 Note</a><time datetime="2022-04-18T02:35:55.000Z" title="发表于 2022-04-18 10:35:55">2022-04-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: 颜色(white)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By AuroraFish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">饿死了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>