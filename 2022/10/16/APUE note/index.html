<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>APUE 学习笔记 | Aurora</title><meta name="author" content="AuroraFish"><meta name="copyright" content="AuroraFish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视频和书籍的一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="APUE 学习笔记">
<meta property="og:url" content="http://example.com/2022/10/16/APUE%20note/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="视频和书籍的一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/background.png">
<meta property="article:published_time" content="2022-10-16T13:00:55.000Z">
<meta property="article:modified_time" content="2023-04-27T04:08:28.737Z">
<meta property="article:author" content="AuroraFish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/background.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/16/APUE%20note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'APUE 学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-27 12:08:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/headd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/background.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Aurora</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">APUE 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-27T04:08:28.737Z" title="更新于 2023-04-27 12:08:28">2023-04-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="APUE 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Unix-环境高级编程"><a href="#Unix-环境高级编程" class="headerlink" title="Unix 环境高级编程"></a>Unix 环境高级编程</h1><h2 id="linux-一些零散的基础知识-视频系统编程部分"><a href="#linux-一些零散的基础知识-视频系统编程部分" class="headerlink" title="linux 一些零散的基础知识(视频系统编程部分)"></a>linux 一些零散的基础知识(视频系统编程部分)</h2><h3 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令:"></a>快捷命令:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">history 查看历史命令</span><br><span class="line">ctrl + p 在历史命令中向上滚动</span><br><span class="line">ctrl + n 在历史命令中向下滚动</span><br><span class="line">ctrl + b 光标向前移动</span><br><span class="line">ctrl + f 光标向后移动</span><br><span class="line">ctrl + a 光标移动行首</span><br><span class="line">ctrl + e 光标移动行尾</span><br><span class="line">ctrl + h 删除光标前</span><br><span class="line">ctrl + d 删除光标后</span><br><span class="line">ctrl + u 删除光标前所有</span><br><span class="line">tap 智能提示</span><br></pre></td></tr></table></figure>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构:"></a>目录结构:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ls / 查看目录</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       -a 显示隐藏文件  -l 显示详细信息  -la 组合使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">cd /xxx 进入xx文件</span><br><span class="line">pwd 查看当前路径</span><br><span class="line">mkdir 创建目录</span><br><span class="line">mkdir dir/dir1/dir2 -p 创建符合目录 ，就是一层套一层</span><br><span class="line">rmdir 删除空目录</span><br><span class="line">rm aa -r -r代表递归，删除非空目录   -i 提示</span><br><span class="line">touch 创建文件</span><br><span class="line">cp xxxx ttt 将xxxx拷贝到ttt文件,不存在就创建ttt文件</span><br><span class="line">cp 目录时需要加 -r 递归拷贝   和 rm 类似</span><br><span class="line">cat 查看文件</span><br><span class="line">more 查看文件 空格翻一页 回车翻一行 q退出</span><br><span class="line">less 比more好一点 但后面已vi为主</span><br><span class="line">head 显示文件前十行 可以加参数 head <span class="number">-5</span></span><br><span class="line">tail 反之</span><br><span class="line">mv xxx ttt 重命名</span><br><span class="line">ln -s xxx ttt 创建ttt的软链接为xxx  用绝对路径 </span><br><span class="line">    </span><br><span class="line"><span class="comment">//修改文件权限 </span></span><br><span class="line"><span class="comment">//1.文字设定法</span></span><br><span class="line">chmod [who] [+|-|=] [mode] 修改文件权限</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       + 添加权限 = 覆盖权限 - 减少权限</span></span><br><span class="line"><span class="comment">       u 文件所有者 g 文件所属组 o 其他人 a 所有的人</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       chmod a=w xxx 将xxx所有人的权限覆盖为 w</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//2.数字设定法</span></span><br><span class="line">     chmod <span class="number">777</span> xxx    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       -:没有权限 r:4 w:2 x:1</span></span><br><span class="line"><span class="comment">       如765 对应</span></span><br><span class="line"><span class="comment">       7 rwx   文件所属者</span></span><br><span class="line"><span class="comment">       6 rw    文件所属组</span></span><br><span class="line"><span class="comment">       5 rx    其他人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改所属组</span></span><br><span class="line">chown xxx ttt 将ttt的所属者改为xxx</span><br><span class="line">chown xxx:yyy ttt 将ttt的所属者和所属组改为 xxx yyy </span><br><span class="line">chgrp 修改所属组</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       注意需要root权限</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按文件属性查找</span></span><br><span class="line">find /home/itcast/ -name <span class="string">&quot;hel?&quot;</span>     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       问号代表一个符号 , * 代表多个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//按大小</span></span><br><span class="line">find 查找目录 -size +<span class="number">10</span>k</span><br><span class="line"><span class="comment">//按类型</span></span><br><span class="line">find 查找目录 -type d/f/b/c/s/p/l</span><br><span class="line">    </span><br><span class="line"><span class="comment">//按文件内容查找</span></span><br><span class="line">grep -r <span class="string">&quot;查找内容&quot;</span> 查找路径</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取网络接口信息</span></span><br><span class="line">ficonfig</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看服务器域名对应ip</span></span><br><span class="line">Nslookup</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20220928125002199.png" alt="image-20220928125002199"></p>
<p>上图为 <strong>-l</strong> 详细显示的信息的解释图</p>
<h3 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/bin 命令</span><br><span class="line">/dev 设备文件 </span><br><span class="line">/etc 配置文件信息</span><br><span class="line">/home 所有用户的目录 </span><br><span class="line">/lib 存的一些动态库</span><br><span class="line">/media 自动挂载库</span><br><span class="line">/mnt 手动挂载</span><br><span class="line">/root 管理员目录</span><br><span class="line">/usr 当前用户软件安装目录</span><br></pre></td></tr></table></figure>

<h3 id="文件或目录熟悉"><a href="#文件或目录熟悉" class="headerlink" title="文件或目录熟悉"></a>文件或目录熟悉</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc</span><br><span class="line">od</span><br><span class="line">du</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20220929093226636.png" alt="image-20220929093226636"></p>
<h3 id="安装和卸载"><a href="#安装和卸载" class="headerlink" title="安装和卸载"></a>安装和卸载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install xxx 在线下载安装</span><br><span class="line">sudo apt-get remove xxx 移除</span><br><span class="line">sudo apt-get update 更新软件列表</span><br><span class="line">sudo apt-get clean 清除所有软件包</span><br><span class="line">    </span><br><span class="line"><span class="comment">//deb包安装</span></span><br><span class="line">sudo dpkg -i xxx.deb</span><br><span class="line">sudo dpkg -r xxx</span><br></pre></td></tr></table></figure>

<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认功能较少的两种</span></span><br><span class="line">gzip bzip2</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20220929211522449.png" alt="image-20220929211522449"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解压缩</span></span><br><span class="line">tar jxvf 压缩包名字(解压到当前目录)</span><br><span class="line">tar jxvf 压缩包名字 -C 压缩的目录</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20220929212619740.png" alt="image-20220929212619740"></p>
<p><strong>zip压缩目录需要-r</strong></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><img src="/./../pic/image-20220930143055851.png" alt="image-20220930143055851"></p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><img src="/./../pic/image-20221001143600239.png" alt="image-20221001143600239"></p>
<h3 id="三种服务器搭建"><a href="#三种服务器搭建" class="headerlink" title="三种服务器搭建"></a>三种服务器搭建</h3><h4 id="ftp服务器"><a href="#ftp服务器" class="headerlink" title="ftp服务器"></a>ftp服务器</h4><p><img src="/./../pic/image-20221001143903737.png" alt="image-20221001143903737"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001144100899.png" alt="image-20221001144100899"></p>
<h4 id="nfs服务器-（共享文件夹"><a href="#nfs服务器-（共享文件夹" class="headerlink" title="nfs服务器 （共享文件夹)"></a>nfs服务器 （共享文件夹)</h4><p><img src="/./../pic/image-20221001144305890.png" alt="image-20221001144305890"></p>
<h4 id="ssh服务器"><a href="#ssh服务器" class="headerlink" title="ssh服务器"></a>ssh服务器</h4><p><img src="/./../pic/image-20221001144736655.png" alt="image-20221001144736655"></p>
<h3 id="vim-操作"><a href="#vim-操作" class="headerlink" title="vim 操作"></a>vim 操作</h3><p><img src="/./../pic/image-20221001151454701.png" alt="image-20221001151454701"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001153419355.png" alt="image-20221001153419355"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221001161348299.png" alt="image-20221001161348299"></p>
<p>分屏: vsp sp   <strong>!</strong></p>
<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>1.预处理 gcc -E 2.编译 gcc -S 3.汇编 gcc -c 4.链接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-o    生成目标文件</span><br><span class="line">-I    指定头文件目录</span><br><span class="line">-D    编译时定义宏</span><br><span class="line">-Wall 更多警告信息</span><br><span class="line">-c    只编译子程序</span><br><span class="line">-E    生成预处理文件</span><br><span class="line">-g    包含调试信息</span><br><span class="line"><span class="number">-0</span>n (n=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  编译优化</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)命名规则</span><br><span class="line">  a) lib + 库名 + .a</span><br><span class="line">  b) libmytest.a</span><br><span class="line"><span class="number">2</span>)制作步骤</span><br><span class="line">  a) 生成对应的.o文件</span><br><span class="line">  b) 将生成的.o文件打包 ar rcs + 静态库名字(libmytest.a) + 生成的.o</span><br><span class="line"><span class="number">3</span>)发布和使用静态库</span><br><span class="line">  a) 发布静态库</span><br><span class="line">  b) 头文件</span><br><span class="line"><span class="number">4</span>）使用静态库的例子</span><br><span class="line">    gcc main.c lib/libMyCalc.a -o calc -Iinclude</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221002144945691.png" alt="image-20221002144945691"></p>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)命名规则</span><br><span class="line">  a) lib + 库名 + .so</span><br><span class="line"><span class="number">2</span>)制作步骤</span><br><span class="line">  a) 生成与位置无关的代码(生成与位置无关的.o)</span><br><span class="line">    gcc -fPIC -c *.c -I../include  <span class="comment">//多-fPIC参数</span></span><br><span class="line">  b) 将.o打包成共享库(动态库)</span><br><span class="line">    gcc -shared -o libMyCalc.so *.o -Iinclude</span><br><span class="line"><span class="number">3</span>)发布和使用动态库</span><br><span class="line">    gcc main.c lib/libMyCalc.so -o calc -Iinclude</span><br><span class="line"><span class="number">4</span>)动态库链接不到的原因</span><br><span class="line">    链接器找不到动态库.</span><br><span class="line">    a)设置LD_LIBRARY_PATH 临时导入</span><br><span class="line">    b)将<span class="keyword">export</span> 写入.bashrc文件中</span><br><span class="line">    c)更改动态链接器的配置文件</span><br><span class="line">      ldconfig用于vi完后,更新配置</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221002152423010.png" alt="image-20221002152423010"></p>
<p>c)</p>
<p><img src="/./../pic/image-20221002153741139.png" alt="image-20221002153741139"></p>
<p><img src="C:\Users\20587\AppData\Roaming\Typora\typora-user-images\image-20221002153809834.png" alt="image-20221002153809834"></p>
<h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)启动gdb</span><br><span class="line">  a) start -- 执行一步</span><br><span class="line">  b) n -- next</span><br><span class="line">  c) s -- step</span><br><span class="line">  c) c -- <span class="keyword">continue</span> 直接停到断点位置</span><br><span class="line"><span class="number">2</span>)查看代码</span><br><span class="line">  a) l -- list</span><br><span class="line">  b) l + 行号</span><br><span class="line">  c) l + 文件名 或 函数名</span><br><span class="line"><span class="number">3</span>)设置断点</span><br><span class="line">  a) 设置当前文件断点 : b ; b + 行号</span><br><span class="line">  b) 设置指定文件断点 : b filename 行号</span><br><span class="line">  c) 设置条件断点 : b 行号 <span class="keyword">if</span> value == <span class="number">19</span></span><br><span class="line">  d) 删除断 : <span class="keyword">delete</span> + 断点编号</span><br><span class="line">  e) 获取编号 : info b</span><br><span class="line"><span class="number">4</span>)单步调试</span><br><span class="line">  a) 进入函数体内部 : s</span><br><span class="line">  b) 从函数体内部跳出 : finish</span><br><span class="line">  c) 退出当前循环 : u</span><br><span class="line"><span class="number">5</span>)查看变量的值</span><br><span class="line">  p</span><br><span class="line"><span class="number">6</span>)查看变量类型</span><br><span class="line">  ptype 变量名</span><br><span class="line"><span class="number">7</span>)设置变量的值</span><br><span class="line">  set var = xx</span><br><span class="line"><span class="number">8</span>)设置追踪变量</span><br><span class="line">  display</span><br><span class="line"><span class="number">9</span>)取消设置追踪变量</span><br><span class="line">  undisplay 编号   获取编号 : info display</span><br><span class="line"><span class="number">10</span>)退出gdb</span><br><span class="line">  quit</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">//进程GBD时 利用循环创建子进程的架构 利用条件断点来切入子进程调试或父进程调试</span></span><br><span class="line">      <span class="number">1</span>) set follow-fork-mode child  <span class="comment">//在fork之后追踪子进程</span></span><br><span class="line">      <span class="number">2</span>) set follow-fork-mode parent <span class="comment">//追踪父进程</span></span><br></pre></td></tr></table></figure>

<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p><img src="/./../pic/image-20221002195517567.png" alt="image-20221002195517567"></p>
<p><img src="/./../pic/image-20221002195535550.png" alt="image-20221002195535550"></p>
<p><img src="/./../pic/image-20221002202536556.png" alt="image-20221002202536556"></p>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>本质上类似虚拟地址到实际内存地址的映射，方便将零散的空间，构成一个连续的整体，和deque的状态有点像</p>
<p><img src="/./../pic/image-20221003112740912.png" alt="image-20221003112740912"></p>
<h3 id="stat-lstat区别，穿透和不穿透"><a href="#stat-lstat区别，穿透和不穿透" class="headerlink" title="stat lstat区别，穿透和不穿透"></a>stat lstat区别，穿透和不穿透</h3><p><img src="/./../pic/image-20221004110828607.png" alt="image-20221004110828607"></p>
<h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><h3 id="CPU基本运作方式"><a href="#CPU基本运作方式" class="headerlink" title="CPU基本运作方式"></a>CPU基本运作方式</h3><p><img src="/./../pic/image-20221004200102729.png" alt="image-20221004200102729"></p>
<h3 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h3><p><img src="/./../pic/image-20221004200200806.png" alt="image-20221004200200806"></p>
<p><img src="/./../pic/image-20221004202340296.png" alt="image-20221004202340296"></p>
<h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p><img src="/./../pic/image-20221004203527280.png" alt="image-20221004203527280"></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><img src="/./../pic/image-20221004203151277.png" alt="image-20221004203151277"></p>
<h3 id="环境变量函数"><a href="#环境变量函数" class="headerlink" title="环境变量函数"></a>环境变量函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getenv</span><br><span class="line">unsetenv</span><br><span class="line">setenv</span><br></pre></td></tr></table></figure>

<h3 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建子进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进程共享</strong> 特点：读时共享,写时复制</p>
<p><img src="/./../pic/image-20221005205933042.png" alt="image-20221005205933042"></p>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p>加载一个进程,替换当前进程的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execlp   - p - path </span><br><span class="line">execl    - l - list</span><br><span class="line">execv    - v - argv[]</span><br><span class="line">execvp</span><br><span class="line">execve   - e - enviroment</span><br><span class="line">只有失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回收进程，防止出现孤儿进程，僵尸进程情况</span></span><br><span class="line"><span class="comment">//孤儿进程: 父进程提前结束  </span></span><br><span class="line"><span class="comment">//僵尸进程: 子进程结束没回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1)</span></span><br><span class="line"><span class="built_in">wait</span>(status) : 返回   成功:pid    失败:<span class="number">-1</span></span><br><span class="line">    status: 传出参数</span><br><span class="line">        <span class="number">1.</span>阻塞等待子进程</span><br><span class="line">        <span class="number">2.</span>回收子进程资源</span><br><span class="line">        <span class="number">3.</span>获取子进程结束状态</span><br><span class="line">利用宏获取状态:</span><br><span class="line"><span class="number">1.</span><span class="function"><span class="keyword">if</span> <span class="title">WIFEXITED</span><span class="params">(status)</span> <span class="params">(真)</span> <span class="comment">// 获取正常退出状态</span></span></span><br><span class="line"><span class="function">     <span class="title">WEXITSTATUS</span><span class="params">(status)</span></span>;   </span><br><span class="line"><span class="number">2.</span><span class="function"><span class="keyword">if</span> <span class="title">WIFSIGNALED</span><span class="params">(status)</span><span class="params">(真)</span><span class="comment">//获取异常的</span></span></span><br><span class="line"><span class="function">     <span class="title">WTERMSIG</span><span class="params">(status)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//2)</span></span><br><span class="line">waitpid</span><br><span class="line">    <span class="number">1</span>)参<span class="number">1</span>:  pid &gt;<span class="number">0</span>    指定进程id回收</span><br><span class="line">            pid = <span class="number">-1</span>  回收任意子进程(wait)</span><br><span class="line">            pid = <span class="number">0</span>   回收本组任意子进程</span><br><span class="line">            pid &lt; <span class="number">-1</span>  回收该进程组的任意资产基础</span><br><span class="line">    <span class="number">2</span>)参<span class="number">2</span>:  status 同上</span><br><span class="line">    <span class="number">3</span>)参<span class="number">3</span>:  <span class="number">0</span>: (等价于wait) 阻塞回收</span><br><span class="line">            WNOHANG: 非阻塞回收(轮询)</span><br><span class="line">              成功: pid 失败:<span class="number">-1</span> 返回<span class="number">0</span>值: 非阻塞回收时，子进程还没结束</span><br></pre></td></tr></table></figure>

<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><ol>
<li>管道:使用简单</li>
<li>FIFO:非血缘关系间</li>
<li>信号:开销小</li>
<li>共享内存:非血缘关系间</li>
<li>本地套接字</li>
</ol>
<h4 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a><strong>管道</strong></h4><p><img src="/./../pic/image-20221006200819169.png" alt="image-20221006200819169"></p>
<p>获取管道缓冲区大小 : 函数:fpathconf2  参2: __PC_PIPE_BUF  命令 : ulimit -a</p>
<p>管道优劣: 优 : 实现简单   缺 : 单向通信   血缘关系only</p>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h4><h4 id="mkfifo函数和命令"><a href="#mkfifo函数和命令" class="headerlink" title="mkfifo函数和命令"></a>mkfifo函数和命令</h4><p><img src="/./../pic/image-20221006202009432.png" alt="image-20221006202009432"></p>
<h4 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h4><p><img src="/./../pic/image-20221006203233785.png" alt="image-20221006203233785"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* p ;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;temp&quot;</span>,O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除临时文件目录项, 使之具备被释放条件, 所有使用该文件的进程结束后就被删除</span></span><br><span class="line">    <span class="built_in">unlink</span>(<span class="string">&quot;temp&quot;</span>);</span><br><span class="line">    <span class="built_in">ftruncate</span>(fd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="comment">//映射区创建完毕</span></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        *p = <span class="number">2000</span>;</span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child , *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">munmap</span>(p, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上图可以看出temp只是作为一个临时的映射区, 进程结束就rm掉了，实际上并不需要这个文件，由此引出匿名映射</p>
<p><strong>匿名映射</strong> (加入额外宏参数即可，原来传入文件的参数换位-1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//该宏只在linux系统下可用, 其他类unix系统不可用, 解决方法 借助/dev/zero</span></span><br><span class="line"><span class="comment">//大小可以随意指定, 本质仍是虚拟内存</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221006224421349.png" alt="image-20221006224421349"></p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>strace + 可执行文件， 追踪程序执行过去中使用的系统调用，就比如利用程序进行进程通信时，底层其实还是使用mmap实现的通信</p>
<h3 id="小实验-利用fifo实现简单的本地聊天室"><a href="#小实验-利用fifo实现简单的本地聊天室" class="headerlink" title="小实验 利用fifo实现简单的本地聊天室"></a>小实验 利用fifo实现简单的本地聊天室</h3><p><img src="/./../pic/image-20221009212823313.png" alt="image-20221009212823313"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_FIFO <span class="string">&quot;/home/aurora/learning/Day1007/test3/SERVER_FIFO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="comment">//客户端名字</span></span><br><span class="line">    <span class="type">char</span> client_name[<span class="number">20</span>];  </span><br><span class="line">    <span class="comment">//私有管道描述符 </span></span><br><span class="line">    <span class="type">int</span> fifo_clifd;           </span><br><span class="line">&#125; CL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录客户端连接的数量</span></span><br><span class="line"><span class="type">int</span> client_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用数组存储客户端队列</span></span><br><span class="line">CL client_deque[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">message_pack</span> &#123;</span><br><span class="line">    <span class="comment">//消息编号</span></span><br><span class="line">    <span class="type">int</span> message_num;</span><br><span class="line">    <span class="comment">//消息发送方</span></span><br><span class="line">    <span class="type">char</span> sender_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//消息接收方</span></span><br><span class="line">    <span class="type">char</span> receiver_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">&#125; MSP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共管道</span></span><br><span class="line"><span class="type">int</span> ser_fifo;</span><br><span class="line"><span class="comment">//服务器启动标志</span></span><br><span class="line"><span class="type">int</span> start_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_server</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//接受客户端信息包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_pack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//解析客户端的包</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parsing_pack</span><span class="params">(MSP *msp)</span></span>;</span><br><span class="line"><span class="comment">//处理客户端登录, 插入客户队列, 创建私有管道</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_login</span><span class="params">(<span class="type">char</span> *login_name)</span></span>;</span><br><span class="line"><span class="comment">//处理消息发送给对应的客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_send</span><span class="params">(MSP *pMsp)</span></span>;</span><br><span class="line"><span class="comment">//处理客户端退出, 移出客户队列, 关闭私有管道</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_quit</span><span class="params">(<span class="type">char</span> *quit_name)</span></span>;</span><br><span class="line"><span class="comment">//关闭服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_server</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//处理输入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1068</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将STDIN_FILENO改为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(STDIN_FILENO, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非阻塞的方式打开管道</span></span><br><span class="line">    ser_fifo = <span class="built_in">open</span>(SERVER_FIFO, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (ser_fifo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;SERVER OPEN:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;服务器已启动\n&quot;</span>);</span><br><span class="line">    start_flag = <span class="number">1</span>-start_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    MSP *msp;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(ser_fifo, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        msp = (MSP*)buf;</span><br><span class="line">        <span class="built_in">parsing_pack</span>(msp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parsing_pack</span><span class="params">(MSP *msp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msp-&gt;message_num) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">client_login</span>(msp-&gt;sender_name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">message_send</span>(msp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">client_quit</span>(msp-&gt;sender_name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_login</span><span class="params">(<span class="type">char</span> *login_name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(client_deque[client_len].client_name, login_name);</span><br><span class="line">    <span class="type">char</span> path[<span class="number">23</span>] = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(path, login_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保创建的文件的权限为分配权限</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mkfifo</span>(path, <span class="number">0777</span>);</span><br><span class="line">    <span class="comment">//将管道的文件描述符存入数组</span></span><br><span class="line">    client_deque[client_len].fifo_clifd = <span class="built_in">open</span>(path, O_WRONLY);</span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;您和服务器的连接已经成功建立, 可以开始通讯了\n&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(client_deque[client_len].fifo_clifd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将管道创建为临时的, 设置管道文件符合删除条件, 即程序结束后自动清楚</span></span><br><span class="line">    <span class="built_in">unlink</span>(path);</span><br><span class="line"></span><br><span class="line">    ++client_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_send</span><span class="params">(MSP *pMsp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">void</span>*)pMsp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(pMsp-&gt;receiver_name) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//单发</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; client_len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pMsp-&gt;receiver_name, client_deque[i].client_name) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">write</span>(client_deque[i].fifo_clifd, buf, BUFSIZE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//群发</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; client_len; ++i) &#123;</span><br><span class="line">            <span class="built_in">write</span>(client_deque[i].fifo_clifd, buf, BUFSIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_quit</span><span class="params">(<span class="type">char</span> *quit_name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;client_len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(quit_name, client_deque[i].client_name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//关闭对应的私有管道</span></span><br><span class="line">            <span class="built_in">close</span>(client_deque[i].fifo_clifd);</span><br><span class="line">            client_deque[i].fifo_clifd = <span class="number">-1</span>;</span><br><span class="line">            client_deque[i].client_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s已退出\n&quot;</span>, quit_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pMes, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close_server</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;服务器维护中, 请稍后登录.&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; client_len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client_deque[i].fifo_clifd != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">write</span>(client_deque[i].fifo_clifd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">close</span>(client_deque[i].fifo_clifd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(ser_fifo);</span><br><span class="line">    start_flag = <span class="number">1</span>-start_flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已关闭所有管道, 服务器安全退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_server</span>();</span><br><span class="line">    <span class="type">char</span> mes[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start_flag) &#123;</span><br><span class="line">        <span class="built_in">receiver_pack</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mes) != EOF) &#123;</span><br><span class="line">            <span class="built_in">message_handle</span>(mes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_FIFO <span class="string">&quot;/home/aurora/learning/Day1007/test3/SERVER_FIFO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接标志</span></span><br><span class="line"><span class="type">int</span> link_flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//公共管道描述符</span></span><br><span class="line"><span class="type">int</span> ser_fifo;</span><br><span class="line"><span class="comment">//私有管道描述符</span></span><br><span class="line"><span class="type">int</span> cli_fifo;</span><br><span class="line"><span class="comment">//客户端名称</span></span><br><span class="line"><span class="type">char</span> client_name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">message_pack</span> &#123;</span><br><span class="line">    <span class="comment">//消息编号</span></span><br><span class="line">    <span class="type">int</span> message_num;</span><br><span class="line">    <span class="comment">//消息发送方</span></span><br><span class="line">    <span class="type">char</span> sender_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//消息接收方</span></span><br><span class="line">    <span class="type">char</span> receiver_name[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">&#125; MSP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_client</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//登录服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">login_server</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//处理用户输入的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span></span>;</span><br><span class="line"><span class="comment">//向服务器发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_ser_mes</span><span class="params">(<span class="type">int</span> mes_num)</span></span>;</span><br><span class="line"><span class="comment">//向其他用户发送消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_oth_mes</span><span class="params">(<span class="type">char</span> *receiver, <span class="type">char</span> *data)</span></span>;</span><br><span class="line"><span class="comment">//接收消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_mes</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_client</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1068</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">login_server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置连接标志</span></span><br><span class="line">    link_flag = <span class="number">1</span>-link_flag;</span><br><span class="line">    <span class="comment">//将STDIN文件属性修改为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(STDIN_FILENO, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">login_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入客户端名称:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, client_name);</span><br><span class="line"></span><br><span class="line">    ser_fifo = <span class="built_in">open</span>(SERVER_FIFO, O_WRONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (ser_fifo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open server fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_ser_mes</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> path[<span class="number">23</span>] = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(path, client_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试管道是否创建成功,成功返回0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">access</span>(path, F_OK) != <span class="number">0</span>) ;</span><br><span class="line">    cli_fifo = <span class="built_in">open</span>(path, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (cli_fifo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open client fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;私有管道创建成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_ser_mes</span><span class="params">(<span class="type">int</span> mes_num)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    MSP msp;</span><br><span class="line">    <span class="type">char</span> * buf;</span><br><span class="line">    msp.message_num = mes_num;</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.sender_name, client_name);</span><br><span class="line">    buf = (<span class="type">void</span>*)&amp;msp;</span><br><span class="line">    <span class="built_in">write</span>(ser_fifo, buf, <span class="built_in">sizeof</span>(msp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_handle</span><span class="params">(<span class="type">char</span> *pMes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pMes, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">send_ser_mes</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">close_client</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据格式为 接收者姓名:消息内容</span></span><br><span class="line">    <span class="comment">//如果不符合格式 消息改为群发</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> receiver_name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pMes[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; pMes[i] != <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        receiver_name[i] = pMes[i];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver_name[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pMes[i] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        receiver_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pMes[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        data[j++] = pMes[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    data[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_oth_mes</span>(receiver_name, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_client</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    link_flag = <span class="number">1</span>-link_flag;</span><br><span class="line">    <span class="comment">//关闭管道</span></span><br><span class="line">    <span class="built_in">close</span>(cli_fifo);</span><br><span class="line">    <span class="built_in">close</span>(ser_fifo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已关闭所有管道, 客户端端退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiver_mes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">read</span>(cli_fifo, buf, <span class="built_in">sizeof</span>(MSP));</span><br><span class="line">    MSP * pMes = <span class="literal">NULL</span>;</span><br><span class="line">    pMes = (<span class="type">void</span>*)buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; pMes-&gt;message_num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:%s\n&quot;</span>, pMes-&gt;sender_name, pMes-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;系统提示:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_oth_mes</span><span class="params">(<span class="type">char</span> *receiver, <span class="type">char</span> *data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    MSP msp;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    msp.message_num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.sender_name, client_name);</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.receiver_name, receiver);</span><br><span class="line">    <span class="built_in">strcpy</span>(msp.data, data);</span><br><span class="line">    buf = (<span class="type">void</span>*)&amp;msp;</span><br><span class="line">    <span class="built_in">write</span>(ser_fifo, buf, <span class="built_in">sizeof</span>(msp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_client</span>();</span><br><span class="line">    <span class="type">char</span> mes_buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (link_flag) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mes_buf) != EOF) &#123;</span><br><span class="line">            <span class="built_in">message_handle</span>(mes_buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">receiver_mes</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>内核发送， 内核处理</p>
<p>发送 ——- 过程 ——— 抵达</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">阻塞信号集合 使信号无法抵达，被阻塞</span><br><span class="line">未决信号集合 由阻塞信号集影响</span><br><span class="line">    </span><br><span class="line"><span class="comment">//信号产生</span></span><br><span class="line">    <span class="number">1.</span>终端按键产生信号(ctrl +c/z/\)</span><br><span class="line">    <span class="number">2.</span>硬件异常产生信号(除<span class="number">0</span>操作,非法内存访问,总线错误)</span><br><span class="line">    <span class="number">3.</span>kill函数/命令产生信号( <span class="type">int</span> <span class="built_in">kill</span>(<span class="type">pid_t</span> pid, <span class="type">int</span> sig); )</span><br><span class="line">        pid &gt; <span class="number">0</span> : 发送给指定进程</span><br><span class="line">        pid = <span class="number">0</span> : 发送给<span class="built_in">kill</span>(函数)同进程组进程</span><br><span class="line">        pid &lt; <span class="number">0</span> : 取|pid|发给对应进程组</span><br><span class="line">        pid = <span class="number">-1</span>: 发送给有权发送的所有进程</span><br><span class="line">    <span class="number">4.</span><span class="type">int</span> <span class="built_in">raise</span>(<span class="type">int</span> sig) 和 <span class="type">void</span> <span class="built_in">abort</span>(<span class="type">void</span>) </span><br><span class="line">        raise发送给自己, abort发送自己异常信号</span><br><span class="line">    <span class="number">5.</span>软件条件产生信号(alarm函数/setitimer)</span><br><span class="line">        每个进程有且只有唯一一个定时器</span><br><span class="line">        <span class="comment">//setitimer</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221012153510031.png" alt="image-20221012153510031"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号集操作函数</span></span><br><span class="line"><span class="type">sigset_t</span> set;   <span class="comment">//信号集合的类型, 以位来进行操作的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;   <span class="comment">//将信号集清0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;    <span class="comment">//将信号集置1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sidaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">//将某信号加入集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdeleset</span><span class="params">(sigset_T *set,<span class="type">int</span> signum)</span></span>; <span class="comment">//将某信号清出集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismemeber</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set,<span class="type">int</span> signum)</span></span>; <span class="comment">//判断某信号是否在信号集合中, 1在, 0不在, -1出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sigprocmask  用来屏蔽信号, 解除屏蔽 本质:读取修改进程的信号屏蔽字(pcb中)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">sigset_t</span> *oldset)</span></span>;</span><br><span class="line">set:传入参数    oldset:传出参数</span><br><span class="line">how:<span class="number">1.</span>SIG_BLOCK:   此时set表示需要屏蔽的信号     mask = mask | set</span><br><span class="line">    <span class="number">2.</span>SIG_UNBLOCK: 此时set表示需要解除屏蔽的信号 mask = mask &amp; ~set</span><br><span class="line">    <span class="number">3.</span>SIG_SETMAKS: 用set直接覆盖原有mask       mask = set</span><br><span class="line">        </span><br><span class="line"><span class="comment">//sigpending 读取当前进程的未决信号集</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">sigpending</span>(<span class="type">sigset_t</span> *set); set传出参数 成功:<span class="number">0</span>  失败:<span class="number">-1</span> 设置error</span><br></pre></td></tr></table></figure>

<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//signal 注册一个信号捕捉函数 优点简洁, 但不统一, 避免使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sigaction</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span></span>;  act传入参数, oldact传出参数</span><br><span class="line"><span class="comment">//struct sigaction的结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">        <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>,<span class="type">siginfo_t</span>*,<span class="type">void</span>*);</span><br><span class="line">        <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">        <span class="type">int</span> sa_flags;</span><br><span class="line">        <span class="built_in">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//各成员详细</span></span><br><span class="line">    <span class="number">1.</span>sa_restorer 已废除</span><br><span class="line">    <span class="number">2.</span>sigaction 当sa_flags指定为SA_SIGINFO时使用该函数,另外实际上的结构和sa_handler组成<span class="keyword">union</span></span><br><span class="line">    <span class="title class_">3</span>.sa_handler 信号捕捉后的处理函数名 赋值为SIG_IGN表忽略,SIG_DFL默认</span><br><span class="line">    <span class="number">4.</span>sa_mask 信号屏蔽集合, 表示调用处理函数时, 屏蔽的信号</span><br><span class="line">    <span class="number">5.</span>sa_flags 通常为<span class="number">0</span>, 默认属性</span><br><span class="line">        </span><br><span class="line"><span class="comment">//信号捕捉的特性</span></span><br><span class="line"><span class="number">1.</span>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</span><br><span class="line"><span class="number">2.</span>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</span><br><span class="line"><span class="number">3.</span>阻塞的常规信号不支持排队，产生多次只记录一次。（后<span class="number">32</span>个实时信号支持排队）</span><br></pre></td></tr></table></figure>

<h3 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程:"></a>内核实现信号捕捉过程:</h3><p>**1.**在执行主控制流程时,由于中断,异常,系统调用(<strong>user</strong>)进入内核区 **-&gt; 2.**内核处理完异常准备回用户区之前,处理当前进程中的可抵达信号(<strong>kernel</strong>) **-&gt; 3.**如果设置了处理函数回到用户区,执行处理函数,但不是回到主控流程(<strong>kernel</strong>) **-&gt; 4.**执行信号处理函数,然后调用特殊的系统调用sigretum再次进入内核区(<strong>user</strong>) **-&gt; 5.**sys_sigreturn() 然后返回用户区,之前终端的主控流程(<strong>user</strong>)</p>
<p><img src="/./../pic/image-20221012160530748.png" alt="image-20221012160530748"></p>
<h3 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act, oldact;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = catch_sigalrm;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">sigaction</span>(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(seconds);</span><br><span class="line">    <span class="comment">//屏蔽</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">pause</span>();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pause sucess\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">alarm</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">mysleep</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的问题在于alarm和pause之间,如果此时cpu的调度切出去了,在此期间alarm信号发送完了,并且抵达了,pause由于收不到信号,被永久阻塞, 首先想到的解决思路, 对alarm信号设置屏蔽,在pause之前再解除, 但无论怎么解决, 屏蔽和pause之间同样可能cpu切出去,导致信号已经处理完了, pause收不到信号永久阻塞，解决方法采用系统函数,由于系统函数是原子操作,pause的功能和解除屏蔽同时发生,不可再分,不会出现cpu突然抢走调度的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.解决示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_sigalrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> newact, oldact;</span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, suspmask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.为SIGALRM设置捕捉函数</span></span><br><span class="line">    newact.sa_handler = catch_sigalrm;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置阻塞信号集, 阻塞SIGALRM信号</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newmask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGALRM);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.定时n秒</span></span><br><span class="line">    <span class="built_in">alarm</span>(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.构造一个临时有效的阻塞信号集</span></span><br><span class="line">    <span class="comment">//在临时阻塞信号集里解除SIGALRM的阻塞</span></span><br><span class="line">    suspmask = oldmask;</span><br><span class="line">    <span class="built_in">sigdelset</span>(&amp;suspmask, SIGALRM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.调用sigsupspend 系统函数原子操作, 将pause的阻塞和解除屏蔽同时进行</span></span><br><span class="line">    <span class="comment">//不会发生解除屏蔽和阻塞操作直接, cpu切出去</span></span><br><span class="line">    <span class="built_in">sigsuspend</span>(&amp;suspmask);</span><br><span class="line"></span><br><span class="line">    unslept = <span class="built_in">alarm</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">mysleep</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>   不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>​     这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h3 id="全局变量异步I-x2F-O"><a href="#全局变量异步I-x2F-O" class="headerlink" title="全局变量异步I&#x2F;O"></a>全局变量异步I&#x2F;O</h3><p>和时序竞态有点类似,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am child  %d\t%d\n&quot;</span>, <span class="built_in">getpid</span>(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am parent %d\t%d\n&quot;</span>, <span class="built_in">getpid</span>(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sys_err</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;     </span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        act.sa_handler = do_sig_parent;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGUSR2, &amp;act, <span class="literal">NULL</span>);             <span class="comment">//注册自己的信号捕捉函数  父使用SIGUSR2信号</span></span><br><span class="line">        <span class="built_in">do_sig_parent</span>(<span class="number">0</span>);						  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* wait for signal */</span>;</span><br><span class="line">           <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;                         <span class="comment">//父进程数数完成</span></span><br><span class="line">                <span class="built_in">kill</span>(pid, SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;                        <span class="comment">//标志已经给子进程发送完信号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;       </span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* waiting for a signal */</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">kill</span>(<span class="built_in">getppid</span>(), SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。现阶段，我们在编程期间如若使用全局变量，应在主观上注意全局变量的异步IO可能造成的问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="可重入函数-x2F-不可重入函数"><a href="#可重入函数-x2F-不可重入函数" class="headerlink" title="可重入函数&#x2F;不可重入函数"></a>可重入函数&#x2F;不可重入函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	定义可重入函数，函数内不能含有全局变量及<span class="type">static</span>变量，不能使用malloc、free</span><br><span class="line"><span class="number">2.</span>	信号捕捉函数应设计为可重入函数</span><br><span class="line"><span class="number">3.</span>	信号处理程序可以调用的可重入函数可参阅man <span class="number">7</span> signal </span><br><span class="line"><span class="number">4.</span>	没有包含在上述列表中的函数大多是不可重入的，其原因为：</span><br><span class="line">    a)	使用静态数据结构</span><br><span class="line">    b)	调用了malloc或free</span><br><span class="line">    c)	是标准I/O函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SIGCHILD信号"><a href="#SIGCHILD信号" class="headerlink" title="SIGCHILD信号"></a>SIGCHILD信号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生条件</span></span><br><span class="line">	<span class="number">1.</span>子进程终止时</span><br><span class="line">    <span class="number">2.</span>子进程收到SIGSTOP信号停止时</span><br><span class="line">    <span class="number">3.</span>子进程处于停止态,收到SIGCONT后唤醒时</span><br><span class="line"><span class="comment">//借助SIGCHILD信号回收子进程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> status; <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">0</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit %d\n&quot;</span>, pid, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d cancel signal %d\n&quot;</span>, pid, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid; <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">sys_err</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child ID %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> sigaction act;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent ID %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGCHLD信号注意问题</span></span><br><span class="line"><span class="number">1.</span>子进程继承了父进程的信号屏蔽字和信号处理动作,但子进程没有继承未决信号集</span><br><span class="line"><span class="number">2.</span>注意注册信号捕捉函数的位置</span><br><span class="line"><span class="number">3.</span>应该在fork之前, 阻塞SIGCHLD信号, 注册完捕捉函数后解除阻塞</span><br></pre></td></tr></table></figure>

<h3 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.发送信号传参</span></span><br><span class="line"><span class="comment">//sigqueue函数对应kill函数,但可以携带参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意传地址时,不同进程之间虚拟地址空间独立,将当前进程地址传递给另一进程没有意义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.捕捉信号传参</span></span><br><span class="line"><span class="comment">//sigaction</span></span><br><span class="line">就是上述sigaction 中与sa_handler组成<span class="keyword">union</span>的另一成员</span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span> , <span class="type">siginfo_t</span>*.<span class="type">void</span>*);</span><br></pre></td></tr></table></figure>

<h3 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要分为慢速系统调用和其他系统调用</span></span><br><span class="line"><span class="comment">//慢速即可能会造成进程永久阻塞的哪一类</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221013000057549.png" alt="image-20221013000057549"></p>
<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">终端即输入输出设备的总称</span><br><span class="line">    </span><br><span class="line"><span class="comment">//一个linxu系统启动的大致步骤</span></span><br><span class="line">    init --&gt; fork --&gt; exec --&gt; getty --&gt; 用户输入帐号 --&gt; login --&gt; 输入密码 --&gt; exec --&gt; bash</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么组合键不会被读到,存在一个特殊处理,线路规程</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221013000454257.png" alt="image-20221013000454257"></p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程组操作函数</span></span><br><span class="line"><span class="comment">//1.getpgrp</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="type">void</span>)</span></span>;      <span class="comment">//返回调用者的进程组id</span></span><br><span class="line"><span class="comment">//2.getpgid</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>; <span class="comment">//获取指定进程的进程组id</span></span><br><span class="line">	成功:<span class="number">0</span> 失败:<span class="number">-1</span>,设置errno</span><br><span class="line"><span class="comment">//3.setpgid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, pid_tgpid)</span> <span class="comment">//改变进程默认所属的进程组</span></span></span><br><span class="line"><span class="function">	非root进程只能改变自己创建的子进程,或有权操作的进程</span></span><br></pre></td></tr></table></figure>

<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会话主要用来创建守护进程</span></span><br><span class="line"><span class="comment">//创建会话, 6点注意事项</span></span><br><span class="line">    <span class="number">1.</span>调用进程不能是进程组组长，该进程变成新会话首进程(session header)</span><br><span class="line">    <span class="number">2.</span>该进程成为一个新进程组的组长进程。</span><br><span class="line">    <span class="number">3.</span>需有root权限(ubuntu不需要)</span><br><span class="line">    <span class="number">4.</span>新会话丢弃原有的控制终端，该会话没有控制终端</span><br><span class="line">    <span class="number">5.</span>该调用进程是组长进程，则出错返回</span><br><span class="line">    <span class="number">6.</span>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</span><br><span class="line">       </span><br><span class="line"><span class="comment">//getsid 获取进程所属会话ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getisid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function">        成功：返回调用进程的会话ID；失败：-1，设置errno</span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function"><span class="comment">//setsid 创建一个会话,并以自己的ID设置进程组ID，同时也是新会话的ID</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">		成功：返回调用进程的会话ID；失败：<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>

<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模型</span></span><br><span class="line"><span class="number">1.</span>创建子进程，父进程退出</span><br><span class="line">		 <span class="comment">//所有工作在子进程中进行形式上脱离了控制终端</span></span><br><span class="line"><span class="number">2.</span>在子进程中创建新会话</span><br><span class="line">　　	<span class="built_in">setsid</span>()函数</span><br><span class="line">　　	   <span class="comment">//使子进程完全独立出来，脱离控制</span></span><br><span class="line"><span class="number">3.</span>改变当前目录为根目录</span><br><span class="line">　　	<span class="built_in">chdir</span>()函数</span><br><span class="line">        <span class="comment">//防止占用可卸载的文件系统</span></span><br><span class="line">        <span class="comment">//也可以换成其它路径</span></span><br><span class="line"><span class="number">4.</span>重设文件权限掩码</span><br><span class="line">　　	<span class="built_in">umask</span>()函数</span><br><span class="line">        <span class="comment">//防止继承的文件创建屏蔽字拒绝某些权限</span></span><br><span class="line">        <span class="comment">//增加守护进程灵活性</span></span><br><span class="line"><span class="number">5.</span>关闭文件描述符</span><br><span class="line">　　	  <span class="comment">//继承的打开文件不会用到，浪费系统资源，无法卸载</span></span><br><span class="line"><span class="number">6.</span>开始执行守护进程核心工作</span><br><span class="line"><span class="number">7.</span>守护进程退出处理程序模型			</span><br><span class="line">    </span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mydaemond</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid, sid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sid = <span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">chdir</span>(<span class="string">&quot;/home/aurora/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">dup2</span>(<span class="number">0</span>, STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">dup2</span>(<span class="number">0</span>, STDERR_FILENO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mydaemond</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linux 中线程是后期加入的, 过度的不是很完善, 和windos的实现可能有区别, 本质仍是进程</span></span><br><span class="line"><span class="comment">//LWP : light weight process 轻量级的进程(本质)</span></span><br><span class="line"><span class="comment">//进程: 独立地址空间,拥有PCB</span></span><br><span class="line"><span class="comment">//线程: 也有PCB, 但没有独立的地址空间(共享)</span></span><br><span class="line"><span class="comment">//区别:是否共享地址空间</span></span><br><span class="line"><span class="comment">//Linux下: 线程是最小的执行单位, 进程最小的分配资源单位,可以看作一个线程的进程</span></span><br></pre></td></tr></table></figure>

<h3 id="Linxu内核线程的实现原理"><a href="#Linxu内核线程的实现原理" class="headerlink" title="Linxu内核线程的实现原理"></a>Linxu内核线程的实现原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</span><br><span class="line"><span class="number">2.</span> 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</span><br><span class="line"><span class="number">3.</span> 进程可以蜕变成线程</span><br><span class="line"><span class="number">4.</span> 线程可看做寄存器和栈的集合</span><br><span class="line"><span class="number">5.</span> 在linux下，线程最是小的执行单位；进程是最小的分配资源单位</span><br><span class="line"><span class="comment">//察看LWP号：ps –Lf pid 查看指定线程的lwp号。</span></span><br><span class="line"><span class="comment">//三级映射：进程PCB --&gt; 页目录(可看成数组，首地址位于PCB中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元</span></span><br></pre></td></tr></table></figure>

<h3 id="线程共享-x2F-非共享资源"><a href="#线程共享-x2F-非共享资源" class="headerlink" title="线程共享&#x2F;非共享资源"></a>线程共享&#x2F;非共享资源</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享</span></span><br><span class="line"><span class="number">1.</span>文件描述符表</span><br><span class="line"><span class="number">2.</span>每种信号的处理方式</span><br><span class="line"><span class="number">3.</span>当前工作目录</span><br><span class="line"><span class="number">4.</span>用户ID和组ID</span><br><span class="line"><span class="number">5.</span>内存地址空间(.text/.data/.bss/heap/共享库)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//非共享</span></span><br><span class="line"><span class="number">1.</span>线程ID</span><br><span class="line"><span class="number">2.</span>处理器现场和栈指针(内核栈)</span><br><span class="line"><span class="number">3.</span>独立的栈空间(用户空间栈)</span><br><span class="line"><span class="number">4.</span>errno变量</span><br><span class="line"><span class="number">5.</span>信号屏蔽字</span><br><span class="line"><span class="number">6.</span>调度优先级</span><br><span class="line">    </span><br><span class="line"><span class="comment">//线程优,缺点</span></span><br><span class="line">    优点: <span class="number">1.</span>提高程序并发性 <span class="number">2.</span>开销小 <span class="number">3.</span>数据通信,共享数据方便</span><br><span class="line">    缺点: <span class="number">1.</span>库函数不稳定 <span class="number">2.</span>调式困难 <span class="number">3.</span>对信号支持不好</span><br></pre></td></tr></table></figure>

<h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.pthread_self  对应进程 getpid()</span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//alaways success</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.pthread_create 对应进程 fork()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span>*(*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">//返回值: 0成功, 失败错误号</span></span><br><span class="line"><span class="number">1.</span>参数一:传出参数,传出分配的线程ID</span><br><span class="line"><span class="number">2.</span>参数二:通常传<span class="literal">NULL</span>,表示线程使用默认属性, 想用具体属性可以修改该参数</span><br><span class="line"><span class="number">3.</span>参数三:函数指针,指向线程的主函数,函数运行结束,即线程结束</span><br><span class="line"><span class="number">4.</span>线程主函数执行期间,使用的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.pthread_exit  将单个线程退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;  <span class="comment">//参数: 表示线程退出状态, 通常传NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.ptherad_join 对应进程 waitpid()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br><span class="line">对比</span><br><span class="line">    进程: main返回值, exit参数-&gt;<span class="type">int</span>, 等待子进程结束 wait函数参数-&gt;<span class="type">int</span>*</span><br><span class="line">    线程: 线程主函数返回值, pthread_exit-&gt;<span class="type">void</span>*, 等待线程结束 pthread_join 参数-&gt;<span class="type">void</span>**</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.pthread_detach  实现线程分离 线程结束后自动释放, 不会产生僵尸进程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.pthread_cancel 对应进程 kill()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="string">&quot;注意&quot;</span>:线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</span><br><span class="line">	类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</span><br><span class="line">	取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man <span class="number">7</span> pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE<span class="number">.12</span><span class="number">.7</span> 取消选项小节。</span><br><span class="line">可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</span><br><span class="line">被取消的线程，	退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是<span class="number">-1</span>。可在头文件pthread.h中找到它的定义：<span class="meta">#<span class="keyword">define</span> PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//7.pthread_equal 比较两个线程id是否相等  可能未来线程id可能被修改为结构体实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//终止线程的方式</span></span><br><span class="line"><span class="number">1.</span>线程主函数<span class="keyword">return</span></span><br><span class="line"><span class="number">2.</span>调用pthread_cancel</span><br><span class="line"><span class="number">3.</span>调用pthread_exit</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制原语对比</span></span><br><span class="line">进程		线程</span><br><span class="line">fork	 pthread_create</span><br><span class="line">exit	 pthread_exit</span><br><span class="line">wait     pthread_join</span><br><span class="line">kill     pthread_cancel</span><br><span class="line">getpid   pthread_self</span><br></pre></td></tr></table></figure>

<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> 					etachstate; 	<span class="comment">//线程的分离状态</span></span><br><span class="line"><span class="type">int</span> 					schedpolicy; 	<span class="comment">//线程调度策略</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sched_param</span>		schedparam; 	<span class="comment">//线程的调度参数</span></span><br><span class="line"><span class="type">int</span> 					inheritsched; 	<span class="comment">//线程的继承性</span></span><br><span class="line"><span class="type">int</span> 					scope; 		    <span class="comment">//线程的作用域</span></span><br><span class="line"><span class="type">size_t</span> 					guardsize; 	    <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line"><span class="type">int</span>						stackaddr_set;  <span class="comment">//线程的栈设置</span></span><br><span class="line"><span class="type">void</span>* 					stackaddr; 	    <span class="comment">//线程栈的位置</span></span><br><span class="line"><span class="type">size_t</span> 					stacksize; 	    <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="type">pthread_attr_t</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的</span></span><br><span class="line"><span class="number">1.</span>线程分离状态</span><br><span class="line"><span class="number">2.</span>线程栈大小</span><br><span class="line"><span class="number">3.</span>线程栈警戒缓冲区大小</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;注意&quot;</span>: 应先初始化线程属性, 再由pthread_create创建线程</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程属性初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//销毁线程属性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的分离状态</span></span><br><span class="line"><span class="comment">//设置线程属性:分离 or 非分离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">//获取线程属性:分离 or 非分离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span>*detachstate)</span></span>;</span><br><span class="line"><span class="comment">//参数 attr: 已初始化线程</span></span><br><span class="line"><span class="comment">//detachstate: PTHREAD_CREATE_DETACHED(分离线程)</span></span><br><span class="line"><span class="comment">//             PTHREAD_CREATE_JOINABLE(非分离线程)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的栈地址</span></span><br><span class="line">POSIX<span class="number">.1</span>定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。</span><br><span class="line">当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr, <span class="type">size_t</span> *stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line">参数：	attr：指向一个线程属性的指针</span><br><span class="line">stackaddr：返回获取的栈地址</span><br><span class="line">stacksize：返回获取的栈大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的栈大小</span></span><br><span class="line">线程的栈大小</span><br><span class="line">当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</span><br><span class="line">函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span></span>; 成功：<span class="number">0</span>；失败：错误号</span><br><span class="line">参数：	attr：指向一个线程属性的指针</span><br><span class="line">stacksize：返回线程的堆栈大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 0x100000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">th_fun</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err, detachstate, i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">void</span> * stackaddr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_attr_getstack</span>(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line">    <span class="built_in">pthread_attr_getdetachstate</span>(&amp;attr,&amp;detachstate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_DETACHED) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread detached\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_JOINABLE) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread join\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread unknown\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        stackaddr = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        <span class="keyword">if</span> (stackaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stacksize = SIZE;</span><br><span class="line">        <span class="built_in">pthread_attr_setstack</span>(&amp;attr, stackaddr, stacksize);</span><br><span class="line">        err = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, th_fun, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strerror</span>(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程使用注意事项</span></span><br><span class="line"><span class="number">1.</span>主线程推出其他线程不退出,主线程应调用pthread_exit</span><br><span class="line"><span class="number">2.</span>避免僵尸线程</span><br><span class="line">    pthread_join</span><br><span class="line">    pthread_detach</span><br></pre></td></tr></table></figure>

<h3 id="小实验-多线程拷贝并实现进度条"><a href="#小实验-多线程拷贝并实现进度条" class="headerlink" title="小实验 多线程拷贝并实现进度条"></a>小实验 多线程拷贝并实现进度条</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ITEMS 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_sys</span><span class="params">(<span class="type">void</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">perror</span>(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_usr</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fputs</span>(str, stderr);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> off, size, t_no;</span><br><span class="line">&#125;<span class="type">arg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *s, *d;</span><br><span class="line"><span class="type">int</span> *done;</span><br><span class="line"><span class="type">int</span> n = T_NUM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg&#123;off, size, t_no;&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">tfn</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">arg_t</span> *arg_p; <span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> *p, *q;</span><br><span class="line"></span><br><span class="line">	arg_p = (<span class="type">arg_t</span> *)arg;</span><br><span class="line">	p = s + arg_p-&gt;off, q = d + arg_p-&gt;off;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arg_p-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 逗号表达式的使用技巧*/</span></span><br><span class="line">		*q++ = *p++, done[arg_p-&gt;t_no]++;</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">display</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> size, interval, draw, sum, i, j;</span><br><span class="line"></span><br><span class="line">	size = (<span class="type">int</span>)arg;</span><br><span class="line">	interval = size / (ITEMS - <span class="number">1</span>);</span><br><span class="line">	draw = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(draw &lt; ITEMS)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			sum += done[i];</span><br><span class="line">		j = sum / interval + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(; j &gt; draw; draw++)&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>); <span class="built_in">fflush</span>(stdout);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> src, dst, i, len, off;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span> statbuf;</span><br><span class="line">	<span class="type">pthread_t</span> *tid;</span><br><span class="line">	<span class="type">arg_t</span> *arr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span> &amp;&amp; argc != <span class="number">4</span>)</span><br><span class="line">		<span class="built_in">err_usr</span>(<span class="string">&quot;usage : cp src dst [thread_no]\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">4</span>)</span><br><span class="line">		n = <span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	src = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(src == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to open&quot;</span>);</span><br><span class="line">	dst = <span class="built_in">open</span>(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(dst == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to open&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fstat</span>(src, &amp;statbuf) == <span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to stat&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">lseek</span>(dst, statbuf.st_size - <span class="number">1</span>, SEEK_SET);</span><br><span class="line">	<span class="built_in">write</span>(dst, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);                          <span class="comment">//IO操作拓展文件大小,也可以使用truncate</span></span><br><span class="line"></span><br><span class="line">	s = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, statbuf.st_size, PROT_READ, MAP_PRIVATE, src, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(s == MAP_FAILED)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to mmap&quot;</span>);</span><br><span class="line">	d = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, statbuf.st_size, PROT_WRITE , MAP_SHARED, dst, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(d == MAP_FAILED)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(src); <span class="built_in">close</span>(dst);</span><br><span class="line">    <span class="comment">//pthread_t tid[n+1];</span></span><br><span class="line">	tid = (<span class="type">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * (n + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span>(tid == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to malloc&quot;</span>);</span><br><span class="line">    <span class="comment">//int done[n]  每个线程完成任务字节数</span></span><br><span class="line">	done = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>), n);</span><br><span class="line">	<span class="keyword">if</span>(done == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to malloc&quot;</span>);</span><br><span class="line">    <span class="comment">//arr[n] 每个线程的任务</span></span><br><span class="line">	arr = (<span class="type">arg_t</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">arg_t</span>) * n);</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">err_sys</span>(<span class="string">&quot;fail to malloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建线程任务数组，分配任务</span></span><br><span class="line">	len = statbuf.st_size / n, off = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++, off += len) </span><br><span class="line">		arr[i].off = off, arr[i].size = len, arr[i].t_no = i; </span><br><span class="line">	arr[n - <span class="number">1</span>].size += (statbuf.st_size % n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建执行拷贝任务线程</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="type">void</span> *)&amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建进度线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid[n], <span class="literal">NULL</span>, display, (<span class="type">void</span> *)statbuf.st_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">pthread_join</span>(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1 </span></span><br><span class="line">	<span class="built_in">munmap</span>(s, statbuf.st_size);</span><br><span class="line">	<span class="built_in">munmap</span>(d, statbuf.st_size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">free</span>(tid); <span class="built_in">free</span>(done); <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>大概意思就是, 多线程对一个共享资源操作是, 由于竞争关系, 导致数据混乱, 用于解决这个问题, 就是线程同步</p>
<h3 id="互斥量-Mutex-初始值1"><a href="#互斥量-Mutex-初始值1" class="headerlink" title="互斥量 Mutex (初始值1)"></a>互斥量 Mutex (初始值1)</h3><p>互斥锁实质上是”建议锁”, 即使有了互斥锁, 如果有线程不按规则访问, 仍然数据混乱</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_mutex_init()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"><span class="comment">//restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</span></span><br><span class="line">	参<span class="number">1</span>:&amp;mutex	参<span class="number">2</span>:互斥量属性 通常传null</span><br><span class="line">	静态初始化: <span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_mutex_destroy()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_lock()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_trylock()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_unlock()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//pthread_mutex_t类型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a>加锁与解锁</h3><p><strong>lock 和 unlock :</strong></p>
<p>lock尝试加锁, 如果失败, 线程阻塞, 阻塞到该互斥量的其他线程解锁为止</p>
<p>unlock主动解锁, 同时将阻塞再该锁上的所有线程唤醒</p>
<p><strong>lock 和 trylock :</strong></p>
<p>lock加锁失败会阻塞, 等待锁释放</p>
<p>trylock加锁失败直接返回错误号, 不阻塞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutex使用例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">tfn</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>锁的不正确使用造成线程永久阻塞</p>
<p>1.线程试图对同一个互斥量A加锁两次</p>
<p>2.线程1拥有A锁, 请求获得B锁, 线程2拥有B锁, 请求获得A锁</p>
<p>第二种解决: 两线程按同一顺序获取锁; 或者第二把锁请求失败时, 主动解锁自己掌握的锁</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁一般具有三种状态：写锁, 读锁, 不加锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</span><br><span class="line"><span class="number">2.</span>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</span><br><span class="line"><span class="number">3.</span>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</span><br><span class="line"><span class="string">&quot;写独占 , 读共享&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_rwlock_init函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *restrict rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *restrict attr)</span></span>;</span><br><span class="line">	参<span class="number">2</span>:读写锁属性, 默认Null </span><br><span class="line"><span class="comment">//pthread_rwlock_destroy函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//pthread_rwlock_rdlock函数  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	读锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_wrlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	写锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_tryrdlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	非阻塞读锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_trywrlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">	非阻塞写锁lock</span><br><span class="line"><span class="comment">//pthread_rwlock_unlock函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//pthread_rwlock_t 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁使用例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">th_write</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        t = counter;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=======write %d: %lu: counter=%d ++ counter= %d\n&quot;</span>,i, <span class="built_in">pthread_self</span>(), t, ++counter);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">th_read</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======read %d: %lu: %d\n&quot;</span>,i ,<span class="built_in">pthread_self</span>(), counter);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid[i], <span class="literal">NULL</span>, th_write, (<span class="type">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid[i+<span class="number">3</span>], <span class="literal">NULL</span>, th_read, (<span class="type">void</span>*)i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">pthread_join</span>(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_cond_init函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict attr)</span></span>;</span><br><span class="line">	参<span class="number">2</span>:条件变量属性, 通常传<span class="literal">NULL</span></span><br><span class="line">    静态初始化: <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">//pthread_cond_destroy函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//pthread_cond_wait函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex)</span></span>;</span><br><span class="line">	函数作用:</span><br><span class="line">	<span class="number">1.</span>阻塞等待条件变量cond满足</span><br><span class="line">    <span class="number">2.</span>释放已掌握的互斥锁, 相当于<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">		<span class="number">1</span>,<span class="number">2</span>步为一个原子操作</span><br><span class="line">    <span class="number">3.</span>当被唤醒, pthread_cond_wait返回时, 解除阻塞并重新申请互斥锁</span><br><span class="line"><span class="comment">//pthread_cond_timedwait函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *restrict abstime)</span></span>;</span><br><span class="line">参<span class="number">3</span>：	参看man sem_timedwait函数，查看<span class="keyword">struct</span> <span class="title class_">timespec</span>结构体。</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">			<span class="type">time_t</span> tv_sec;		<span class="comment">/* seconds */</span> 秒</span><br><span class="line">			<span class="type">long</span>   tv_nsec;	<span class="comment">/* nanosecondes*/</span> 纳秒</span><br><span class="line">		&#125;								</span><br><span class="line">形参abstime：绝对时间。										</span><br><span class="line">如：<span class="built_in">time</span>(<span class="literal">NULL</span>)返回的就是绝对时间。而<span class="built_in">alarm</span>(<span class="number">1</span>)是相对时间，相对当前时间定时<span class="number">1</span>秒钟。	</span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			<span class="built_in">pthread_cond_timedwait</span> (&amp;cond, &amp;mutex, &amp;t); 只能定时到 <span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>秒(早已经过去) </span><br><span class="line">		正确用法：</span><br><span class="line">			<span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> t;	定义timespec 结构体变量t</span><br><span class="line">			t.tv_sec = cur+<span class="number">1</span>; 定时<span class="number">1</span>秒</span><br><span class="line"><span class="built_in">pthread_cond_timedwait</span> (&amp;cond, &amp;mutex, &amp;t); 传参				参APUE<span class="number">.11</span><span class="number">.6</span>线程同步条件变量小节</span><br><span class="line">		在讲解setitimer函数时我们还提到另外一种时间类型：</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">             <span class="type">time_t</span>      tv_sec;  <span class="comment">/* seconds */</span> 秒</span><br><span class="line">             <span class="type">suseconds_t</span> tv_usec; 	<span class="comment">/* microseconds */</span> 微秒</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_cond_signal函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">	唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line"><span class="comment">//pthread_cond_broadcast函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">	唤醒所有</span><br><span class="line"><span class="comment">//pthread_cond_t 类型</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="comment">//生产者-消费者模型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表作为共享数据,被mutex保护*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msg</span> *next;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> *head;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> *mp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态初始化 一个条件变量 一个互斥量*/</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume ---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">productor</span><span class="params">(<span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        mp-&gt;num = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Produce ---%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;has_product);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid, <span class="literal">NULL</span>, productor, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>互斥量初始值1, 到0 阻塞, 信号量初始值n, 到0阻塞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量基本操作</span></span><br><span class="line">sem_wait : 信号量大于<span class="number">0</span> ，信号量-- ; 信号量等于<span class="number">0</span> ，线程阻塞</span><br><span class="line">	类比pthread_mutex_lock</span><br><span class="line">sem_post : 信号量++，同时唤醒所有阻塞的线程</span><br><span class="line">    类比pthread_mutex_unlock</span><br><span class="line">信号量的初值决定了占用信号量线程的个数, 与mutex类似, <span class="type">sem_t</span> 实现对用户隐藏, +--通过函数实现</span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_init函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">	参<span class="number">1</span>:sem信号量  </span><br><span class="line">    参<span class="number">2</span>:取<span class="number">0</span>用于线程间, 取非<span class="number">0</span>用于进程间</span><br><span class="line">    参<span class="number">3</span>:value指定信号量初值</span><br><span class="line"><span class="comment">//sem_destroy函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//sem_wait函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">	加锁lock</span><br><span class="line"><span class="comment">//sem_trywait函数	</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">	类比trylock</span><br><span class="line"><span class="comment">//sem_timedwait函数	</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span></span>;</span><br><span class="line">	参<span class="number">2</span>：abs_timeout采用的是绝对时间。			</span><br><span class="line">	定时<span class="number">1</span>秒：</span><br><span class="line">		<span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> t;	定义timespec 结构体变量t</span><br><span class="line">		t.tv_sec = cur+<span class="number">1</span>; 定时<span class="number">1</span>秒</span><br><span class="line">		t.tv_nsec = t.tv_sec +<span class="number">100</span>; </span><br><span class="line"><span class="built_in">sem_timedwait</span>(&amp;sem, &amp;t); 传参</span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_post函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;	</span><br><span class="line">	解锁unlock</span><br><span class="line"><span class="comment">//sem_t 类型     头文件&lt;semaphore.h&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//生产者消费者模型, 思路上会和前面的几种锁有一定不同, 前面都是对一个资源进行上锁,信号量虽然也是对一个资源,但是两把锁影响互相影响达到目的</span></span><br><span class="line"><span class="comment">/*信号量实现生产者消费者模型*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> queue[NUM];</span><br><span class="line"><span class="type">sem_t</span> blank_number , product_number; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;blank_number);</span><br><span class="line">        queue[i] = <span class="built_in">rand</span>() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----Produce---%d\n&quot;</span>, queue[i]);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;product_number);</span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() %<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;product_number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume---%d\n&quot;</span>, queue[i]);</span><br><span class="line">        queue[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;blank_number);</span><br><span class="line"></span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() %<span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;blank_number, <span class="number">0</span>, NUM);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;product_number, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(pid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;blank_number);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;product_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程间同步也可以使用互斥锁,但应该在初始化之前将其属性修改为进程间共享</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mattr 类型：		用于定义mutex锁的【属性】</span><br><span class="line">pthread_mutexattr_init函数：			初始化一个mutex属性对象</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line">pthread_mutexattr_destroy函数：		销毁mutex属性对象 (而非销毁锁)</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line">pthread_mutexattr_setpshared函数：	修改mutex属性。</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line">	参<span class="number">2</span>：pshared取值：</span><br><span class="line">		线程锁：<span class="built_in">PTHREAD_PROCESS_PRIVATE</span> (mutex的默认属性即为线程锁，进程间私有)</span><br><span class="line">		进程锁：PTHREAD_PROCESS_SHARED</span><br><span class="line"></span><br><span class="line"><span class="comment">//ps:进程间的全局变量, 读时共享, 写时复制, 所以应该创建一块映射区</span></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mt</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mt</span> *mm;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    mm = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(*mm), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mm, <span class="number">0</span>, <span class="built_in">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutexattr_init</span>(&amp;mm-&gt;mutexattr);</span><br><span class="line">    <span class="built_in">pthread_mutexattr_setpshared</span>(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-child-------------num++     %d\n&quot;</span>, mm-&gt;num);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">            mm-&gt;num += <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;------parent------num+=2     %d\n&quot;</span>, mm-&gt;num);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutexattr_destroy</span>(&amp;mm-&gt;mutexattr);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mm-&gt;mutex);</span><br><span class="line">    <span class="built_in">munmap</span>(mm, <span class="built_in">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><p>借助fcntl函数实现锁机制,操作文件的进程没有获得锁时,可以打开,但无法执行read,write</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效果上和线程同步的读写锁类似, 用于实现进程的间的读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...<span class="comment">/*arg*/</span>)</span></span>;</span><br><span class="line">	参<span class="number">2</span>:</span><br><span class="line">		<span class="built_in">F_SETLK</span>(<span class="keyword">struct</span> flock*) 设置文件锁(trylock)</span><br><span class="line">        <span class="built_in">F_SETLKW</span>(<span class="keyword">struct</span> flock*)设置文件锁(lock) W-&gt;<span class="function">wait</span></span><br><span class="line"><span class="function">        <span class="title">F_GETLK</span><span class="params">(<span class="keyword">struct</span> flock*)</span> 获取文件锁</span></span><br><span class="line"><span class="function">    参3:</span></span><br><span class="line"><span class="function">        struct flock &#123;</span></span><br><span class="line">              ...</span><br><span class="line">              <span class="type">short</span> l_type;    	锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span><br><span class="line">              <span class="type">short</span> l_whence;  	偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span><br><span class="line">              <span class="type">off_t</span> l_start;   	起始偏移：<span class="number">1000</span></span><br><span class="line">              <span class="type">off_t</span> l_len;     	长度：<span class="number">0</span>表示整个文件加锁</span><br><span class="line">              <span class="type">pid_t</span> l_pid;     	持有该锁的进程ID：(F_GETLK only)</span><br><span class="line">              ...</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">perror</span>(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">flock</span> f_lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">sys_err</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_WRLCK;  <span class="comment">/*写锁*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// f_lock.l_type = F_RDLCK; /*读锁*/</span></span><br><span class="line"></span><br><span class="line">    f_lock.l_whence = SEEK_SET;</span><br><span class="line">    f_lock.l_start = <span class="number">0</span>;</span><br><span class="line">    f_lock.l_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get flock\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    f_lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;un lock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="APUE书籍部分笔记"><a href="#APUE书籍部分笔记" class="headerlink" title="APUE书籍部分笔记"></a>APUE书籍部分笔记</h2><p><strong>重点章节:3,4,5,7,8,10,11,12 优先看</strong></p>
<h3 id="第3章-文件I-x2F-O"><a href="#第3章-文件I-x2F-O" class="headerlink" title="第3章 文件I&#x2F;O"></a>第3章 文件I&#x2F;O</h3><h4 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h4><p>本章描述的函数被称为 <strong>不带缓冲的I&#x2F;O</strong>, <strong>不带缓冲</strong>指的是每个read和write都调用内核中的一个系统调用</p>
<h4 id="3-2-文件描述符"><a href="#3-2-文件描述符" class="headerlink" title="3.2 文件描述符"></a>3.2 文件描述符</h4><p>对于内核而言,所有打开的文件都通过文件描述符引用,0 ,1, 2 文件描述符本别于标准输入, 标准输出, 标准错误关联</p>
<h4 id="3-3-函数open-和-openat"><a href="#3-3-函数open-和-openat" class="headerlink" title="3.3 函数open 和 openat"></a>3.3 函数open 和 openat</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件描述符, 失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//path 打开或创建的文件名， oflag 参数, 此函数的多个选项</span></span><br><span class="line"><span class="comment">//下列5个常量中必须指定一个且只能指定一个</span></span><br><span class="line">O_RDONLY 只读打开  O_WRONLY 只写打开  O_RDWR 读写打开  O_EXEC 只执行打开  O_SEARCH 只搜索打开</span><br><span class="line"><span class="comment">//下列常量是可选的</span></span><br><span class="line">O_APPEND 每次写时追加到文件的尾端  O_CLOEXEC 把FD_CLOEXEC设置为文件描述符标志  O_CREATE 若文件不存在则创建它,使用此选项时需要指定<span class="type">mode_t</span>参数  O_DIRECTORY 如果path引用的不是目录则出错  O_EXCL 如果同时指定了O_CREATE文件已经存在则出错,用此可以测试一个文件是否存在,不存在则创建此文件,测试和创建文件为一个原子操作  O_NOCTTY 如果path引用的是终端设备,则不将该设备分配为此进程的控制终端  O_NOFOLLOW 如果path引用的是一个符号链接则出错  	O_NONBLOCK 设置非阻塞  O_SYNC 使每次write等待物理I/O操作完成  O_TRUNC 如果此文件存在,而且为只写或读写成功打开,将其长度截断为<span class="number">0</span>  O_TTY_INIT 如果打开一个还未打开的终端设备,设置非标准termios参数值  O_DSYNC   O_RSYNC </span><br></pre></td></tr></table></figure>

<p>可以看到open和openat在参数上,openat多了一个fd</p>
<p>fd把open和openat区分开来,三种可能性:</p>
<pre><code>1. path参数指定的是绝对路径名, 此时fd参数被忽略, openat相当于open
1. path参数指定的是相对路径名, fd参数指出相对路径名在文件系统中的开始地址, fd参数是通过打开相对路径名所在的目录来获取
1. path参数指定相对路径名, fd参数具有AT_FDCWD, 此时路径名在当前工作目录中获得, 也类似于open
</code></pre>
<p>目的：</p>
<ol>
<li>让线程使用相对路径打开目录的文件, 同一进程中的所有线程共享相同的当前工作目录, 因此很难让同一进程的多个不同线程在同一时间工作在不同的目录</li>
<li>可以避免time-of-check-to-time-of-use问题</li>
</ol>
<p><strong>文件名和路径名截断</strong></p>
<p>就是说以前的文件名上限小的时候比如14，此时文件名过长会截断, 也可能会返回错误值, 这样就出现了很大的风险, 系统也不知道到底截断过还是返回错误值, 现在不用考虑这个问题了, 现在的文件名上限大多255</p>
<h4 id="3-4-函数create"><a href="#3-4-函数create" class="headerlink" title="3.4 函数create"></a>3.4 函数create</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回只写打开的文件描述符, 失败返回-1</span></span><br><span class="line"><span class="comment">//此函数等效于</span></span><br><span class="line"><span class="built_in">open</span>(path, O_WRONLY | O_CREATE | O_TRUNC, mode);</span><br><span class="line">	<span class="comment">//create出现的原因在于早期,open不支持O_CREATE</span></span><br></pre></td></tr></table></figure>

<p>另一个不足之处, 在于create只能创建只写打开的文件</p>
<h4 id="3-5-函数close"><a href="#3-5-函数close" class="headerlink" title="3.5 函数close"></a>3.5 函数close</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0, 失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁，当一个进程终止时, 内核自动关闭所有它打开的文件</p>
<h4 id="3-6-函数lseek"><a href="#3-6-函数lseek" class="headerlink" title="3.6 函数lseek"></a>3.6 函数lseek</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件偏移量, 失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>对参数<strong>offset</strong>的解释与参数<strong>whence</strong>的值有关:</p>
<ol>
<li>若whence是SEEK_SET, 将文件的偏移量设置为距文件开始offset个字节</li>
<li>若whence是seek_cur, 将文件的偏移量设置为当前值加offset, offset可正可负</li>
<li>若whence是SEEK_END, 将文件的偏移量设置为文件长度加offset, 可正可负</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前偏移量</span></span><br><span class="line"><span class="type">off_t</span> currpos;</span><br><span class="line">currpos = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="comment">//这种方法也可以用来确定涉及文件是否可以设置偏移量, 如果文件描述符是管道, fifo 或套接字, lseek返回-1, 并将errno设置为ESPITE</span></span><br></pre></td></tr></table></figure>

<p>文件偏移量可以大于文件的当前长度, 这种情况下会形成空洞文件，但位于文件中没有写过的字节都被读成0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空洞文件示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf1[] = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf2[] = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">create</span>(<span class="string">&quot;file.hole&quot;</span>, FILE_MODE)) &lt; <span class="number">0</span>)	</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;create error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    <span class="comment">/* offset now = 10*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line">    <span class="comment">/* offset noew = 16384 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;buf2 write error&quot;</span>);</span><br><span class="line">    <span class="comment">/* offset noew = 16394 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-7-函数read"><a href="#3-7-函数read" class="headerlink" title="3.7 函数read"></a>3.7 函数read</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line">	<span class="comment">//读到的字节数,若已到文件尾,返回0,  失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>有多种情况可使实际读到的字节数少于要求读的字节数:</p>
<ol>
<li>读普通文件时, 在读到要求的字数之前已到达文件尾端, 例如文件30字节, 而要求读100字节, 则read返回30, 下一次调用返回0</li>
<li>从终端设备读时,通常一次最多读一行</li>
<li>从网络读时, 取决于网络中的缓冲机制</li>
<li>从管道和FIFO读时, 返回实际读到的可用字节数</li>
<li>从某些面向记录的设备时(如磁带), 一次最多返回一个记录</li>
<li>当一信号造成中断时, 而已读了部分数据</li>
</ol>
<h4 id="3-8-函数write"><a href="#3-8-函数write" class="headerlink" title="3.8 函数write"></a>3.8 函数write</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回已写字节数, 失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>对于普通文件, 写操作从文件的当前偏移量处开始，如果在打开文件时，指定了O_APPEND选项，每次写操作之前，将文件的偏移量设置在文件的当前结尾处，在一次成功写操作后，文件偏移量增加实际写的字节数</p>
<h4 id="3-9-I-x2F-O的效率"><a href="#3-9-I-x2F-O的效率" class="headerlink" title="3.9 I&#x2F;O的效率"></a>3.9 I&#x2F;O的效率</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[BUFFSIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n == <span class="built_in">read</span>(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不同大小的BUFFSIZE</p>
<p><img src="/./../pic/image-20221018231151437.png" alt="image-20221018231151437"></p>
<p>大多数文件系统为改善性能采用某种预读技术</p>
<h4 id="3-10-文件共享"><a href="#3-10-文件共享" class="headerlink" title="3.10 文件共享"></a>3.10 文件共享</h4><p>本小节分两部分，第一部分描述了内核中文件是以何等方式打开文件</p>
<ol>
<li><p>每个进程在进程表中都有一个记录项，记录项包含一张打开的文件描述符表，每个描述符占用一项，与每个文件描述符关联的是</p>
<p>​	a.文件描述符标志(close_on_exec)</p>
<p>​	b.指向一个文件表项的指针</p>
</li>
<li><p>内核为所有打开文件维持一张表，每个表项包含:</p>
<p>​	a.文件状态标志(读，写，添加，同步和非阻塞等)</p>
<p>​	b.当前文件偏移量</p>
<p>​	c.指向该文件v节点表项的指针</p>
</li>
<li><p>每个打开文件都有一个v节点结构，v节点包含了文件类型和对此文件进行各种操作函数的指针，对于大多数文件还包含i节点，索引节点</p>
</li>
</ol>
<p><img src="/./../pic/image-20221018235724033.png" alt="image-20221018235724033"></p>
<p>另一部分说明了，如果两个独立进程各自打开了同一文件:</p>
<p><img src="/./../pic/image-20221018235917212.png" alt="image-20221018235917212"></p>
<p>我们假定第一个进程在3上打开了文件，而另一个在4上打开了文件，每个进程都会获得一份自己的文件表项，但一个文件只有一个v节点表项</p>
<p>fork后的父子进程，各自的每一个打开文件描述符共享同一个文件表项</p>
<h4 id="3-11-原子操作"><a href="#3-11-原子操作" class="headerlink" title="3.11 原子操作"></a>3.11 原子操作</h4><p>简单来说，在多进程的背景下，两次函数调用之间，可能会出现，从当前进程切到另一进程，执行另一进程的事情后，再返回当前进程继续往下执行，这期间可能会导致问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个追加文件的例子</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, OL, <span class="number">2</span>) &lt; <span class="number">0</span>)       <span class="comment">//假设设置偏移量到文件尾</span></span><br><span class="line">    <span class="built_in">err_sys</span>(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf, <span class="number">100</span>) != <span class="number">100</span>)</span><br><span class="line">   	<span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时就可能会出现这么一种情况，当前进程将偏移量设置到文件尾后，假设为1500，此时由于调度切换到另一进程，另一进程对同一文件进行了修改，使得文件变成了1600大小，此时再切会当前进程，就出现了和我没所期望的不一样的结果，而将lseek和write的作用合成一步，这就是原子操作，如UNIX系统为我们提供了一种方法，O_APPEND</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XSI扩展的原子性地定位并执行I/O</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>*buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于先lseek再调用read/write</span></span><br></pre></td></tr></table></figure>



<h4 id="3-12-函数dup和dup2"><a href="#3-12-函数dup和dup2" class="headerlink" title="3.12 函数dup和dup2"></a>3.12 函数dup和dup2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列两个函数可用来复制一个现有的文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span></span>;</span><br><span class="line">	<span class="comment">//两函数的返回值，若成功返回新的文件描述符，若出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>dup返回的新文件描述符一定是当前可用文件描述符中的最小值，对于dup2，可用用fd2指定新文件描述符的值，如果fd2已经打开，先将其关闭。如果fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的FD_CLOEXEC文件描述符标志就被清除(?不理解什么意思)</p>
<p><img src="/./../pic/image-20221019002908225.png" alt="image-20221019002908225"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于dup 和 dup2 同样也有等效函数</span></span><br><span class="line"><span class="built_in">dup</span>(fd);      -----&gt;  <span class="built_in">fcntl</span>(fd, F_DUPFD, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dup2</span>(fd, fd2);-----&gt;  <span class="built_in">close</span>(fd2); <span class="built_in">fcntl</span>(fd, F_DUPFD, fd2);</span><br><span class="line"><span class="comment">//区别在于: 1.dup2是原子操作 2.errno不同</span></span><br></pre></td></tr></table></figure>



<h4 id="3-13-函数sync-fsync-和-fdatasync"><a href="#3-13-函数sync-fsync-和-fdatasync" class="headerlink" title="3.13 函数sync,fsync 和 fdatasync"></a>3.13 函数sync,fsync 和 fdatasync</h4><p>传统的UNIX系统实现在内核中没有缓冲区高速缓存或页高速缓存。写入数据时，先将数据复制到缓冲区，然后排入队列，再写入磁盘。该方式被称为延迟写。sync, fsync和fdatasync三个函数用来保证磁盘实际文件系统和缓冲区内容的一致性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsync</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fdtasync</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0， 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sync只是将修改过的块缓冲区排入写队列，然后返回，不等待实际写磁盘操作结束，被称为update的守护进程，会周期性调用该函数</p>
<p>fsync只对fd指定的文件起作用，并且等待实际写硬盘操作结束</p>
<p>fdtasync与fsync类似，但它只影响文件的数据部分，而除数据外，fsync还会同步更新文件属性</p>
<h4 id="3-14-函数fcntl"><a href="#3-14-函数fcntl" class="headerlink" title="3.14 函数fcntl"></a>3.14 函数fcntl</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fcntl函数可以改变已经打开的文件属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/*int arg*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fcntl函数有以下5个功能：</p>
<ol>
<li>复制一个已有的描述符(cmd &#x3D; F_DUPFD 或 F_DUPFD_CLOEXEC)</li>
<li>获取&#x2F;设置文件描述符标志(cmd &#x3D; F_GETFD 或 F_SETFD)</li>
<li>获取&#x2F;设置文件状态标志(cmd &#x3D; F_GETFL 或 F_SETFL)</li>
<li>获取&#x2F;设置异步I&#x2F;O所有权(cmd &#x3D; F_GETOWN 或 F_SETOWN)</li>
<li>获取&#x2F;设置记录锁 (参考上面视频笔记部分的文件锁，很详细，后续也会继续补全)</li>
</ol>
<p>该小节只说明前四种，记录锁在后面章节补充：</p>
<p>**F_DUPFD:**复制文件描述符fd，新文件描述符作文函数值返回，它是尚未打开的各描述符中大于或等于第三个参数值中各值的最小值(就是从传入的fd2起，没有被使用的最小描述符)，他与fd共享同一文件表项，但它有自己的一套文件描述符标志，其FD_CLOEXEC设置为被清除(?不清楚)，第8章会讨论这一点</p>
<p>**F_DUPFD_CLOEXEC:**复制文件描述符fd，设置与新描述符关联的FD_CLOEXEC文件描述符标志的值，返回新文件描述符</p>
<p>**F_GETFD:**对应于fd的文件描述符标志作为函数值返回，当前只定义了一个描述符标志FD_CLOEXEC(主要还不知的文件描述符标志用来干啥，后续应该会补充)</p>
<p>**F_SETFD:**对于fd设置的文件描述符标志，新标志值按第三个参数设置</p>
<p>​		”现在很多程序不使用常量FD_CLOEXEC，而是设置为0, (系统默认，在exec时不关闭), 设置为1(在exec时关闭)“</p>
<p>**F_GETFL:**对应于fd的文件状态标志作为函数值返回，open时已经描述了文件状态</p>
<p><img src="/./../pic/image-20221019005856046.png" alt="image-20221019005856046"></p>
<p>对于5个访问标志，前5个，并不各占一位，由于历史原因，前3个的值分别是0，1，2，因此首先必须使用屏蔽字O_ACCMODE取得访问方式位</p>
<p>**F_SETFL:**将文件状态的设置为第3个参数的值，可以更改的几个标志为:O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, O_ASYNC</p>
<p>**F_GETOWN:**获取当前接受SIGIO和SIGURG信号的进程ID或进程组ID，14章会作讨论</p>
<p>**F_SETOWN:**设置接收SIGIO和SIGURG信号的进程ID或进程组ID，正的arg指定一个进程ID，负的arg指定进程组ID</p>
<p>fcntl的返回值与命令有关，出错所有都返回-1，成功返回某个其他值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">err_quit</span>(<span class="string">&quot;usage: a.out &lt;descriptor#&gt;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((val = <span class="built_in">fcntl</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">        <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read only&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">            <span class="built_in">prinf</span>(<span class="string">&quot;write only&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_RDWR:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">err_dump</span>(<span class="string">&quot;unknown access mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, append&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, nonblocking&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (val &amp; O_SYNC)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;, synchronous writes&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">$./a.out <span class="number">0</span> &lt; /dev/tty</span><br><span class="line">read only</span><br><span class="line">$./a.out <span class="number">1</span> &gt; temp.foo</span><br><span class="line">$cat temp.foo</span><br><span class="line">write only</span><br><span class="line">$./a.out <span class="number">2</span> <span class="number">2</span>&gt;&gt;temp.foo</span><br><span class="line">write only, append</span><br><span class="line">$./a.out <span class="number">5</span> <span class="number">5</span>&lt;&gt;temp.foo</span><br><span class="line">read write</span><br></pre></td></tr></table></figure>

<p>修改时应该采用先获取现在的标志值，然后修改它，最后设置新的标志值，而不是之间F_SETFD或F_SETFL这样会关闭以前设置的标志值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flags are file status flags to turn on</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ((val = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl get error&quot;</span>);</span><br><span class="line">    val |= flags;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fcntl set error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果这样就是关闭 turn off</span></span><br><span class="line">vla &amp;= ~flags;</span><br></pre></td></tr></table></figure>



<h4 id="3-15-函数ioctl"><a href="#3-15-函数ioctl" class="headerlink" title="3.15 函数ioctl"></a>3.15 函数ioctl</h4><p>ioctl函数一直是I&#x2F;O操作的杂物箱，不能用本章其他函数表示的I&#x2F;O操作通常都能用ioctl表示，终端I&#x2F;O是使用ioctl最多的地方(what? 没用过难以理解是干啥的)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>后续描述看起来ioctl是一个能自定义一些I&#x2F;O操作的函数，如磁带操作使我们可以在磁带上写一个文件结束标志，倒带，越过指定个数的文件或记录等。本章其他函数操作都难以表示这些操作，所以最容易的方法就是使用ioctl</p>
<h4 id="3-16-x2F-dev-x2F-fd"><a href="#3-16-x2F-dev-x2F-fd" class="headerlink" title="3.16 &#x2F;dev&#x2F;fd"></a>3.16 &#x2F;dev&#x2F;fd</h4><p>了解了解就行，举个例子，fd &#x3D; open(“dev&#x2F;fd&#x2F;0”, mode) 相当于fd &#x3D; dup(0);</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本章主要说明了UNXI系统提供的基本I&#x2F;O函数，原子操作，内核共享打开文件信息的数据结构，多种将数据冲洗到磁盘上的方式(sync?)，不同I&#x2F;O长度对读文件所需时间的影响，已经多种功能的fcntl函数，14章还将介绍fcntl的第5中功能，18，19章介绍ioctl函数</p>
<h3 id="第4章-文件和目录"><a href="#第4章-文件和目录" class="headerlink" title="第4章 文件和目录"></a>第4章 文件和目录</h3><h4 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h4><p>本章进一步阐述文件系统的一些相关内容</p>
<h4 id="4-2-函数stat、fstat、fstatat和lstat"><a href="#4-2-函数stat、fstat、fstatat和lstat" class="headerlink" title="4.2 函数stat、fstat、fstatat和lstat"></a>4.2 函数stat、fstat、fstatat和lstat</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="keyword">struct</span> stat *restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="keyword">struct</span> stat *restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstatat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="keyword">struct</span> stat *restrict buf, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">	<span class="comment">//所有4个函数，成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>四个函数功能基本一样，stat和fstat的区别在于使用文件名还是文件描述符，lstat的区别在于是否穿透，即是返回符号链接的信息还是符号链接所指文件的信息(lstat返回符号链接本身的信息，stat返回所指文件的信息)，fstatat更像是一个集合体，fd为打开目录，pathname为文件名，当pathname为绝对路径时，fd被忽略，flag的取值绝对是否追踪符号链接，默认追踪，当被设置为AT_SYMLINK_NOFOLLOW时不追涨。  buf为一个传出参数，实际结构是一个包含了文件个信息的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct stat 的结构各实现可能不同，但大体内容基本如下</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> &#123;</span><br><span class="line">    <span class="type">mode_t</span>			 st_mode;	 <span class="comment">/*file type &amp; mode (permissions) */</span></span><br><span class="line">    <span class="type">ino_t</span> 			 st_ino;	 <span class="comment">/*i_node number (serial number) */</span></span><br><span class="line">    <span class="type">dev_t</span>  			 st_dev;     <span class="comment">/*device number (file system) */</span></span><br><span class="line">    <span class="type">dev_t</span>			 st_rdev;	 <span class="comment">/*device number for special files */</span></span><br><span class="line">    <span class="type">nlink_t</span>			 st_nlink;	 <span class="comment">/*number of links */</span></span><br><span class="line">    <span class="type">uid_t</span>			 st_uid;	 <span class="comment">/*user ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>			 st_gid;	 <span class="comment">/*group ID of owner */</span></span><br><span class="line">    <span class="type">off_t</span>			 st_size;    <span class="comment">/*size in bytes, for regular files */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>  st_atime;   <span class="comment">/*time of last access */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>  st_mtime;   <span class="comment">/*time of last modification */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>  st_ctime;   <span class="comment">/*time of last file status change */</span></span><br><span class="line">    <span class="type">blksize_t</span> 		 st_blksize; <span class="comment">/*best I/O block size */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>		 st_blocks;  <span class="comment">/*number of disk blocks allocated */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;  <span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;   <span class="comment">//纳秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-文件类型"><a href="#4-3-文件类型" class="headerlink" title="4.3 文件类型"></a>4.3 文件类型</h4><p>UNXI系统中文件的七种类型</p>
<p>**普通文件:**最常用的文件，包含某种形式的数据，至于是文本还是二进制，对于UNXI内核并无区别</p>
<p><strong>目录文件：</strong>只有内核可以之间写目录，进程必须使用当前章节的介绍的函数才可以更改目录</p>
<p>**块特殊文件:**这种类型的文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行</p>
<p>**字符特殊文件:**这种类型的年纪提供对设备不带缓冲的访问，每次访问长度可变，系统中的所有设备要么是块特殊文件，要么是字符特殊文件</p>
<p>**FIFO:**命名管道，用于进程间通信，上面视频笔记小实验聊天室用到了</p>
<p>**套接字:**用于进程间的网络通信，也可以用于在一台宿主机上的非网络通信，16章</p>
<p>**符号链接:**这种类型文件指向另一个文件，类似快捷方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件类型信息包含在stat结构体的st_mode成员中，可以用宏来确定</span></span><br><span class="line"><span class="comment">//宏          文件类型</span></span><br><span class="line"><span class="built_in">S_ISREG</span>()	  普通文件</span><br><span class="line"><span class="built_in">S_ISDIR</span>()	  目录文件		 </span><br><span class="line"><span class="built_in">S_ISCHR</span>()	  字符特殊文件</span><br><span class="line"><span class="built_in">S_ISBLK</span>()	  块特殊文件</span><br><span class="line"><span class="built_in">S_ISFIFO</span>()	  管道或<span class="function">FIFO</span></span><br><span class="line"><span class="function"><span class="title">S_ISLNK</span><span class="params">()</span>	  符号链接</span></span><br><span class="line"><span class="function"><span class="title">S_ISSOCK</span><span class="params">()</span>	  套接字</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例，命令行参数打印其文件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> buf;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, argv[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstat</span>(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">err_ret</span>(<span class="string">&quot;lstat error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">S_ISREG</span>(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">        		.</span><br><span class="line">                .</span><br><span class="line">                .</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISSOCK</span>(buf.st_mode))</span><br><span class="line">            ptr = <span class="string">&quot;socket&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ptr = <span class="string">&quot;** unknown mode **&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-设置用户ID和设置组ID"><a href="#4-4-设置用户ID和设置组ID" class="headerlink" title="4.4 设置用户ID和设置组ID"></a>4.4 设置用户ID和设置组ID</h4><p>与一个进程相关联的ID有6各或更多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实际用户ID	              <span class="comment">//我们实际上是谁</span></span><br><span class="line">实际组ID</span><br><span class="line">    </span><br><span class="line">有效用户ID</span><br><span class="line">有效组ID         		   <span class="comment">//用于文件访问权限检查</span></span><br><span class="line">附属组ID</span><br><span class="line">    </span><br><span class="line">保存的设置用户ID			<span class="comment">//由exec函数保存</span></span><br><span class="line">保存的设置组ID</span><br></pre></td></tr></table></figure>

<p>通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID。每个文件有一个所有者和所有组，所有者由stat结构中的st_uid指定，组所有者则由st_gid指定</p>
<p>当执行一个程序文件时，进程的有效ID通常就是实际用户的ID，有效组ID通常是实际用户的ID，但可以在文件模式字(st_mode)中设置一个特殊标志，含义是“当执行此文件时，进程的有效用户ID设置为文件所有者的用户ID”，同理还有另一位设置组ID是否是文件所有组，这两位被称为 <strong>设置用户ID位和设置组ID位</strong></p>
<h4 id="4-5-文件访问权限"><a href="#4-5-文件访问权限" class="headerlink" title="4.5 文件访问权限"></a>4.5 文件访问权限</h4><p>每个文件有9个访问位权限：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户</span></span><br><span class="line">S_IRUSR 用户读  S_IWUSR 用户写  S_IXUSR 用户执行</span><br><span class="line"><span class="comment">//组</span></span><br><span class="line">S_IRGRP 组读  S_IWGRP 组写  S_IXGRP 组执行</span><br><span class="line"><span class="comment">//其他人</span></span><br><span class="line">S_IROTH 其他读  S_IWOTH 其他写  S_IXOTH 其他执行</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221019140753392.png" alt="image-20221019140753392"></p>
<p>由ls-l 得到的某文件的权限设置 prw-rw-r-x 第一个符号为文件类型，后面三个一组分别为用户，组，其他人，rwx对应读写执行权限，-说明没有权限</p>
<h4 id="4-6-新文件和目录的所有权"><a href="#4-6-新文件和目录的所有权" class="headerlink" title="4.6 新文件和目录的所有权"></a>4.6 新文件和目录的所有权</h4><p>新文件:</p>
<ol>
<li>新文件的用户ID设置为进程的有效ID</li>
<li>新文件的组id</li>
</ol>
<p>​		a.新文件的组ID可以是进程的有效组ID</p>
<p>​		b.新文件的组ID可以是它所在目录的组ID</p>
<h4 id="4-7-函数access和faccessat"><a href="#4-7-函数access和faccessat" class="headerlink" title="4.7 函数access和faccessat"></a>4.7 函数access和faccessat</h4><p>按实际对应的用户ID和实际组ID进行访问权限测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">faccessat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">	<span class="comment">//两个函数的返回值，成功返回0，失败返回-1</span></span><br><span class="line">mode: <span class="built_in">R_OK</span>(读) <span class="built_in">W_OK</span>(写) <span class="built_in">X_OK</span>(执行)</span><br></pre></td></tr></table></figure>

<p>access和faccessat在以下两种情况是相同的：</p>
<ol>
<li>pathname取绝对路径</li>
<li>fd参数取值AT_FDCWD，pathname取相对路径(大部分类似参数的两种函数都类似)</li>
</ol>
<p>flag参数用于改变faccessat的行为，设置为AT_EACCESS访问调用进程的有效ID和有效组ID而不是实际的，例如设置当前进程用户超级用户权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) 	</span><br><span class="line">        <span class="built_in">err_quit</span>(<span class="string">&quot;usage: a.out&lt;pathname&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">access</span>(argv[<span class="number">1</span>], R_OK) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ret</span>(<span class="string">&quot;access error for %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read access OK\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_ret</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open for reading OK\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-8-函数umask"><a href="#4-8-函数umask" class="headerlink" title="4.8 函数umask"></a>4.8 函数umask</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">mode_t</span> <span class="title">umask</span><span class="params">(<span class="type">mode_t</span> cmask)</span></span>;</span><br><span class="line">	<span class="comment">//返回之前文件模式创建的屏蔽字</span></span><br></pre></td></tr></table></figure>

<p>简单来说，你创建的文件实际权限会受到umask掩码的影响，算是一种保护文件权限的预防措施，举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RWRWRW (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">create</span>(<span class="string">&quot;foo&quot;</span>, RWRWRW) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>();</span><br><span class="line">    <span class="built_in">umask</span>(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">create</span>(<span class="string">&quot;bar&quot;</span>m RWRWRW) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ umask     打印之前的屏蔽字</span><br><span class="line"><span class="number">002</span></span><br><span class="line">$ ./a.out</span><br><span class="line">$ ls-l foo bar</span><br><span class="line">-rw------- <span class="number">1</span> sar <span class="number">0</span> Dec <span class="number">7</span> <span class="number">21</span>:<span class="number">20</span> bar</span><br><span class="line">-rw-rw-rw- <span class="number">1</span> sar <span class="number">0</span> Dec <span class="number">7</span> <span class="number">21</span>:<span class="number">20</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以不用宏，直接用八进制格式来指定,但注意rwx分别对应的值是4，2，1</span></span><br><span class="line">$ umask</span><br><span class="line"><span class="number">002</span></span><br><span class="line">$ umask -s   <span class="comment">//打印符号格式</span></span><br><span class="line">u = rwx, g = rwx, o = rx</span><br><span class="line">$ umask <span class="number">027</span></span><br><span class="line">$ umask -s</span><br><span class="line">u = rwx, g = rx, o =</span><br></pre></td></tr></table></figure>



<h4 id="4-9-函数chmod、fchmod和fchmodat"><a href="#4-9-函数chmod、fchmod和fchmodat" class="headerlink" title="4.9 函数chmod、fchmod和fchmodat"></a>4.9 函数chmod、fchmod和fchmodat</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchmodat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pahtname, <span class="type">mode_t</span> mode, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，返回-1</span></span><br></pre></td></tr></table></figure>

<p>fchmodat，对于flag参数，设置为AT_SYMLINK_NOFOLLOW标志时，fchmodat不会跟随符号链接</p>
<p><img src="/./../pic/image-20221019180705396.png" alt="image-20221019180705396"></p>
<p>对于S_ISUID、S_ISGID、这两个是强制为权限，以s表示，如果在user权限组中设置了s位,则当文件被执行时,该文件是以文件所有者UID而不是用户UID执行程序;如果在group权限组中设置了s位,当文件被执行时,该文件是以文件所有者GID而不是用户GID执行程序。s权限位是一个敏感的权限位,容易造成系统的安全问题。黏着位下章介绍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> statbuf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stat</span>(<span class="string">&quot;foo&quot;</span>, &amp;statbuf);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chmod</span>(<span class="string">&quot;foo&quot;</span>,(statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt;<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chmod 1 error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">chmod</span>(<span class="string">&quot;bar&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行前</span></span><br><span class="line">aurora@LAPTOP<span class="number">-1</span>GSU2G27:~/learning/Day1019$ ls -l bar foo</span><br><span class="line">-rw------- <span class="number">1</span> aurora aurora <span class="number">0</span> Oct <span class="number">19</span> <span class="number">17</span>:<span class="number">44</span> bar</span><br><span class="line">-rw-rw-rw- <span class="number">1</span> aurora aurora <span class="number">0</span> Oct <span class="number">19</span> <span class="number">17</span>:<span class="number">44</span> foo</span><br><span class="line"><span class="comment">//运行后</span></span><br><span class="line">aurora@LAPTOP<span class="number">-1</span>GSU2G27:~/learning/Day1019$ ls -l bar foo</span><br><span class="line">-rw-r--r-- <span class="number">1</span> aurora aurora <span class="number">0</span> Oct <span class="number">19</span> <span class="number">17</span>:<span class="number">44</span> bar</span><br><span class="line">-rw-rwSrw- <span class="number">1</span> aurora aurora <span class="number">0</span> Oct <span class="number">19</span> <span class="number">17</span>:<span class="number">44</span> foo</span><br></pre></td></tr></table></figure>

<p>chmod函数还会自动清楚两个权限位(p86)</p>
<h4 id="4-10-粘着位"><a href="#4-10-粘着位" class="headerlink" title="4.10 粘着位"></a>4.10 粘着位</h4><p>早期的一种技术，用于将文件存放在交换区，这样下次执行的时候就能更快的装载如内存，现在不太需要这种技术了</p>
<p>现今系统扩展了黏着位的适用范围，Single UNIX Specification允许针对目录设置黏着位。如果对一个目录设置了黏着位，只有对该目录具有写权限，并且满足下列条件之一，才能删除或重命名该目录下的文件</p>
<ol>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ol>
<p>例如目录&#x2F;tmp 和 目录&#x2F;var&#x2F;tmp</p>
<h4 id="4-11-函数chown、fchown、fchownat和lchown"><a href="#4-11-函数chown、fchown、fchownat和lchown" class="headerlink" title="4.11 函数chown、fchown、fchownat和lchown"></a>4.11 函数chown、fchown、fchownat和lchown</h4><p>下面几个chown函数可用于更改文件的用户ID和组ID，如果两个参数任意一个是-1，则对应的ID不变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchownat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br><span class="line">	<span class="comment">//4个函数的返回值 成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>4个函数基本一样，主要区别也就是fd和pathname的取舍，是否穿透符号链接，和前面类似形参的不同函数区别基本一样p88</p>
<h4 id="4-12-文件长度"><a href="#4-12-文件长度" class="headerlink" title="4.12 文件长度"></a>4.12 文件长度</h4><p>对于普通文件，长度可以是0，对于目录文件，文件长度通常是一个数(如16或512)的整数倍，对于符号链接，文件长度是文件名的字节数</p>
<p><strong>文件中的空洞:</strong></p>
<p>形成的原因，偏移量超过实际长度，并且继续写入了部分数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//考虑以下情况</span></span><br><span class="line">$ ls -l core</span><br><span class="line">-rw-r--r-- <span class="number">1</span> sar		<span class="number">8483248</span> Nov <span class="number">18</span> <span class="number">12</span>:<span class="number">18</span> core</span><br><span class="line">$ du -s core</span><br><span class="line"><span class="number">272</span>    core</span><br></pre></td></tr></table></figure>

<p>文件的长度超过8mb，但使用的磁盘空间总量272个512字节块(139264字节)，很明显该文件有很多空洞</p>
<h4 id="4-13-文件截断"><a href="#4-13-文件截断" class="headerlink" title="4.13 文件截断"></a>4.13 文件截断</h4><p>有时我们需要在文件尾端截去一些数据以缩短文件，将一个文件截断为0，可以在打开时通过O_TRUNC标志做到。为了截断文件可以调用truncate和ftruncate</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span></span>;</span><br><span class="line">	<span class="comment">//两个函数的返回值，成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>如果长度大于length，截断，如果小于length，文件长度增加，相当于增加的部分创建了空洞文件</p>
<h4 id="4-14-文件系统"><a href="#4-14-文件系统" class="headerlink" title="4.14 文件系统"></a>4.14 文件系统</h4><p>本小节简单讲了下，UNIX系统的经典文件系统格式，重点在于i节点和数据块，数据块由目录块和数据块组成，由此可以看出文件真正位置与目录无关，目录的每个目录项储存的是文件的i节点编号和文件名，通过i节点编号来找到实际的数据块，目录块会根据类型字段判断目录项里是否还是一个目录，对于一个没有包含其他目录的叶目录的链接计数总是2（理解：每个目录中都存在一个. 目录，指向当前目录，然后又有创建这个也目录的目录也能指向当前目录，所以链接计数为2），这里的一点疑惑，这个叶目录，在创建它目录的目录项中的i 节点编号(貌似是指向它自己的实际目录块，所以因为没创建文件所以只有. 和 ..目录项)</p>
<p><img src="/./../pic/image-20221020135343695.png" alt="image-20221020135343695"></p>
<p><img src="/./../pic/image-20221020135409469.png" alt="image-20221020135409469"></p>
<p><img src="/./../pic/image-20221020135422426.png" alt="image-20221020135422426"></p>
<h4 id="4-15-函数link、linkat、unlink、unlinkat和remove"><a href="#4-15-函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="4.15 函数link、linkat、unlink、unlinkat和remove"></a>4.15 函数link、linkat、unlink、unlinkat和remove</h4><p>创建一个指向现有文件的链接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *existingpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linkat</span><span class="params">(<span class="type">int</span> efd, <span class="type">const</span> <span class="type">char</span> *existingpath, <span class="type">int</span> nfd, <span class="type">const</span> <span class="type">char</span> *newpath, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>两函数差不多，差别仍然是pathname 和 fd + pathname 的区别, flag用来区别是否追踪符号链接，如果设置AT_SYMLINK_FOLLOW创建指向符号链接目录的链接，如果忽略，创建一个指向符号链接本身的链接，创建目录项和增加链接计数为原子操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unlinkat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>这两个函数删除目录项，并将链接计数-1，类似share_ptr 只有计数为1的时候，文件内容才被删除，不为0时仍可通过其他链接访问，如果目录被设置为黏着位了，必须满足黏着位的要求才能操作(参考前面)，flag参数给出一种方法，可以改变unlinkat函数的默认行为，当AT_REMOVEDIR标志被设置时，unlinkat可以类似于rmdir一样删除目录，如果标志被清除，unlinkat和unlink执行同样的操作</p>
<p>unlink的一种特性，在程序运行中，对打开的unlink文件不会被立马清除，只有在进程结束的时候才会将其删除，利用这种特性，对打开的临时文件unlink可以防止程序崩溃时，遗留临时文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">//对于文件，remove的功能与unlink相同， 对于目录，与rmdir相同</span></span><br></pre></td></tr></table></figure>



<h4 id="4-16-函数rename和renameat"><a href="#4-16-函数rename和renameat" class="headerlink" title="4.16 函数rename和renameat"></a>4.16 函数rename和renameat</h4><p>文件或目录可以用rename和renameat重命名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldname, <span class="type">const</span> <span class="type">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">renameat</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">const</span> <span class="type">char</span> *oldname, <span class="type">int</span> newfd, <span class="type">const</span> <span class="type">char</span> *newname)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>一些注意点见p96</p>
<h4 id="4-17-符号链接"><a href="#4-17-符号链接" class="headerlink" title="4.17 符号链接"></a>4.17 符号链接</h4><p>引入符号是对一个文件的间接指针，引入符号链接的原因，为了避免硬链接的限制</p>
<ol>
<li>硬链接通常要求链接和文件位于同一文件系统中</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)</li>
</ol>
<p>不过要注意函数是否能处理符号链接，就像之前讲过的通过flag的参数来设置是否追踪</p>
<p><img src="/./../pic/image-20221020144528852.png" alt="image-20221020144528852"></p>
<p>上图的一个例外是，open函数同时调用O_CREATE和O_EXCL时，如果引用符号链接，open将出错返回，errno设置为EEXIST，目的是为了堵塞一个安全漏洞，防止特权进程被诱骗写错误文件</p>
<p>后续讲了一个软连接导致文件系统中引入循环的例子，就目录里创建一个软连接，然后这个软链接又指向目录，这样的循环可以用unlink消除，但硬链接很难消除，所以不允许普通用户构造指向目录的硬链接</p>
<h4 id="4-18-创建和读取符号链接"><a href="#4-18-创建和读取符号链接" class="headerlink" title="4.18 创建和读取符号链接"></a>4.18 创建和读取符号链接</h4><p>可以用symlink或symlinkat创建符号链接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *actualpath, <span class="type">const</span> <span class="type">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">symlinkat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *actualpath, <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *sympath)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>因为open函数跟随符号链接，所以须有一种方法打开符号链接本身，读取该链接的名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unitstd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="type">char</span> *restrict buf, <span class="type">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="type">char</span> *restrict buf, <span class="type">size_t</span> bufsize)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回读取的字节数，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>这两个函数组合了open、read和close的所有功能，一气呵成嗷</p>
<h4 id="4-19-文件的时间"><a href="#4-19-文件的时间" class="headerlink" title="4.19 文件的时间"></a>4.19 文件的时间</h4><p>文件的时间类型有三种</p>
<ol>
<li>st_atime 文件数据的最后访问时间 例如: read</li>
<li>st_mtime 文件数据的最后修改时间 例如:write</li>
<li>st_ctime i节点状态的最后更改时间 例如:chmod chown</li>
</ol>
<p><img src="/./../pic/image-20221020151050415.png" alt="image-20221020151050415"></p>
<h4 id="4-20-函数futimens、utimensat和utimes"><a href="#4-20-函数futimens、utimensat和utimes" class="headerlink" title="4.20 函数futimens、utimensat和utimes"></a>4.20 函数futimens、utimensat和utimes</h4><p>一个文件的访问和修改时间可以用以下几个函数更改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">utimensat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="type">int</span> flag)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>times数组的第一个元素包含访问时间，第二个元素包含修改时间</p>
<p>时间戳按以下方式指定:</p>
<ol>
<li>如果times参数是空指针，访问和修改时间设置为当前时间</li>
<li>如果非空，任一数组元素的tv_nsec字段的值为UTIME_NOW，相应的时间戳设置为当前时间，忽略tv_sec</li>
<li>如果非空，任意数组元素的值为UTIME_OMIT，相应时间戳保持不变，忽略tv_sec</li>
<li>如果非空，且tv_nsec字段既不是UTIME_NOW，也不是UTIME_OMIT，按相应的设置</li>
</ol>
<p>执行这些函数所要求的优先权取决于times参数的值</p>
<ol>
<li>如果是空指针，或者任一tv_nsec字段设为UTIME_NOW，则进程的有效用户ID必须等于该文件的所有者ID；进程对该文件必须具有写权限，或者超级用户进程</li>
<li>如果非空，且既不是UTIME_NOW也不是UTIME_OMIT，进程的有效用户ID必须等于文件所有者ID，或者是超级用户进程，只有写权限是不够的</li>
<li>如果非空，两个字段的值都为UTIME_OMIT，不执行任何权限检查</li>
</ol>
<p>flag同样用来对于符号链接进行区分，设置AT_SYMLINK_NOFOLLOW，只修改符号链接本身，默认行为是跟随符号链接，并把文件的的时间改成符号链接的时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec; <span class="comment">//秒 </span></span><br><span class="line">    <span class="type">long</span> tv_usec;  <span class="comment">//微秒   timespec是纳秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例:p102</p>
<h4 id="4-21-函数mkdir、mkdirat和rmdir"><a href="#4-21-函数mkdir、mkdirat和rmdir" class="headerlink" title="4.21 函数mkdir、mkdirat和rmdir"></a>4.21 函数mkdir、mkdirat和rmdir</h4><p>用mkdir和mkdirat来创建目录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function">itn <span class="title">mkdirat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>注意目录mode至少需要拥有执行权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unitstd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>如果有进程打开目录，不会立马删除，但也不允许创建新文件，</p>
<h4 id="4-22-读目录"><a href="#4-22-读目录" class="headerlink" title="4.22 读目录"></a>4.22 读目录</h4><p>目录的实际格式依赖于UNIX系统实现和文件系统的设计，早期较简单的结构，每个目录项16个字节，14字节是文件名，2字节是i节点编号，就如同前面文件系统中描述的那种</p>
<p>任何具有访问权限的用户都可以读目录，但只有内核才对目录具有写权限，目录的写和执行权限决定的是能否在目录中创建和删除文件，不带表写目录本身，此外，很多实现阻止应用程序使用read函数读取目录的内容，由此进一步讲应用程序与目录格式中与实现相关的细节隔离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR* <span class="title">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR* <span class="title">fdopendir</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">//两函数成功返回指针，失败返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span>* <span class="built_in">readdir</span>(DIR *dp);</span><br><span class="line">	<span class="comment">//成功返回指针，若在目录尾或失败返回NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewinddir</span><span class="params">(DIR* dp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closedir</span><span class="params">(DIR* dp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">telldir</span><span class="params">(DIR* dp)</span></span>;</span><br><span class="line">	<span class="comment">//返回与dp关联的目录中的当前位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seekdir</span><span class="params">(DIR* dp, <span class="type">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221020154756395.png" alt="image-20221020154756395"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例 p105 有时间补充</span></span><br></pre></td></tr></table></figure>



<h4 id="4-23-函数chdir、fchdir和getcwd"><a href="#4-23-函数chdir、fchdir和getcwd" class="headerlink" title="4.23 函数chdir、fchdir和getcwd"></a>4.23 函数chdir、fchdir和getcwd</h4><p>进程调用chdir，fchdir可以修改当前工作目录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fchdir</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>从当前目录，用..找到上一级目录，，逐层上移，得到当前工作目录的完整绝对路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unitstd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回buf，失败返回NULL</span></span><br></pre></td></tr></table></figure>



<h4 id="4-24-设备特殊文件"><a href="#4-24-设备特殊文件" class="headerlink" title="4.24 设备特殊文件"></a>4.24 设备特殊文件</h4><p>st_dev和st_rdev ，在18.9节，编写ttyname函数时，需要使用这两个字段，相关规则：</p>
<ol>
<li>每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev_t。主设备号标识设备驱动程序，有时编码为与其通信的外设板；次设备号标识特定的子设备。如4-13图，一个磁盘的驱动器经常包含若干个文件系统。在同一磁盘驱动器上的各文件通常具有相同的主设备号，但是次设备号却不同</li>
<li>我们通常可以使用两个宏：major和minor来访问主、次设备号，大多数实现都定义这两个宏。这就意味着我们无需关心这两个数是如何存放在dev_t对象中的</li>
<li>系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点</li>
<li>只有字符特殊文件和块特殊文件才有st_rdev值，此值包含实际设备的设备号</li>
</ol>
<p>p112有个示例，但还不明白设备特殊文件是啥，先跳过</p>
<h4 id="4-25-文件访问权限小结"><a href="#4-25-文件访问权限小结" class="headerlink" title="4.25 文件访问权限小结"></a>4.25 文件访问权限小结</h4><p>所有的文件访问权限位总结</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSR</span><br><span class="line">S_IRWXG = S_IRGRP | S_IWGRP | S_IXGRP</span><br><span class="line">S_IRWXO = S_IROTH | S_IWOTH | S_IXOTH</span><br><span class="line"><span class="comment">//剩下的太多直接放图</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221020160917814.png" alt="image-20221020160917814"></p>
<h4 id="4-26-小结"><a href="#4-26-小结" class="headerlink" title="4.26 小结"></a>4.26 小结</h4><p>本章围绕stat函数，介绍了stat中的每一个成员，以及各种对文件目录操作的函数，和文件系统的基本结构实现</p>
<h3 id="第5章-标准I-x2F-O库"><a href="#第5章-标准I-x2F-O库" class="headerlink" title="第5章 标准I&#x2F;O库"></a>第5章 标准I&#x2F;O库</h3><h4 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h4><p>标准I&#x2F;O库处理很多细节，如缓冲区分配，以优化的块长度执行I&#x2F;O等。这些处理使用户不用担心如何选择使用正确的块长度(如3.9节所)。这使得它便于用户使用，但是如果不深入地了解I&#x2F;O库函数的操作，也会带来问题</p>
<h4 id="5-2-流和FILE对象"><a href="#5-2-流和FILE对象" class="headerlink" title="5.2 流和FILE对象"></a>5.2 流和FILE对象</h4><p>在第三章时的I&#x2F;O函数围绕文件描述符来进行。而对于标准I&#x2F;O库，它们的操作是围绕流进行的(勿讲标准I&#x2F;O库的术语流与System V的STREAMS I&#x2F;O 系统混淆)。当我们使用标准I&#x2F;O库打开或创建一个文件的时候，我们已使一个流与一个文件相关联。</p>
<p>对于不同字符，可能用不同字节来表示，<strong>流的定向</strong>决定了所读、写的字符是单字节还是多字节。当一个流被创建的时候，它并没有定向，根据使用多字节I&#x2F;O函数还是单字节I&#x2F;O函数来设定定向。只有两个函数可以改变流的定向，<strong>freopen函数</strong>清除一个流的定向；<strong>fwide函数</strong>设置流的定向</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="type">int</span> mode)</span></span>;</span><br><span class="line">	<span class="comment">//若流是宽定向，返回正值；字节定向，返回负值；未定向返回0</span></span><br></pre></td></tr></table></figure>

<p>根据mode参数的不同值，执行不同工作：</p>
<ol>
<li>若mode参数为负值，fwide试图指定流是字节定向</li>
<li>若为正，试图指定宽定向</li>
<li>若为0，不试图设置，但返回标识该流定向的值</li>
</ol>
<h4 id="5-3-标准输入、标准输出和标准错误"><a href="#5-3-标准输入、标准输出和标准错误" class="headerlink" title="5.3 标准输入、标准输出和标准错误"></a>5.3 标准输入、标准输出和标准错误</h4><p>每一个进程预定义了3个流，并且自动地被使用，引用的文件就是之前提到过的STDIN_FILENO、STDOUT_FILENO、STDERR_FILLNO。这3个标准I&#x2F;O流通过预定义文件指针来引用</p>
<h4 id="5-4-缓冲"><a href="#5-4-缓冲" class="headerlink" title="5.4 缓冲"></a>5.4 缓冲</h4><p>目的和之前3.9节差不多，尽可能减少read和write的调用次数。标准I&#x2F;O库的缓冲是自动地进行缓冲管理，避免用户需要考虑怎么设置</p>
<p>标准I&#x2F;O提供了以下3种类型的缓冲:</p>
<ol>
<li><p>全缓冲。在这种情况下，填满标准I&#x2F;O缓冲区后才进行实际I&#x2F;O操作，通常在一个流执行第一次I&#x2F;O操作时，相关函数调用malloc获取所需的缓冲区</p>
<p>术语冲洗(flush)说明标准I&#x2F;O缓冲区的写操作，注意在UNIX环境中，flush可能有两种意思，标准I&#x2F;O库方面意味着将缓冲区内容写入磁盘；在终端驱动程序表示丢弃已存储在缓冲区中的数据</p>
</li>
<li><p>行缓冲。在输入和输出中遇到换行符时，标准I&#x2F;O库执行I&#x2F;O操作，当流涉及一个终端(标准输入和标准输出)时，通常使用行缓冲</p>
<p>行缓冲的两个限制：a.行缓冲区的长度是固定的，只要填满了，不管有米有换行符，也进行I&#x2F;O操作 b.标准I&#x2F;O库要求从一个不带缓冲的流或一个行缓冲的流中获取数据时，也会立刻flush</p>
</li>
<li><p>不带缓冲。标准I&#x2F;O库不对字符进行缓冲储存，例如，若用标准I&#x2F;O函数fputs写15个字符到不带缓冲的流，我们期望这15个字符能立刻输出，很可能使用3.8节的write函数将其写到相关文件</p>
</li>
</ol>
<p>通常标准错误流不带缓冲，使得报错信息立刻输出。ISO C要求下列缓冲特征：</p>
<ol>
<li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的</li>
<li>标准错误绝对不会是全缓冲</li>
</ol>
<p>很多系统默认下列类型缓冲：</p>
<ol>
<li>标准错误是不带缓冲的</li>
<li>若是指向终端设备的流，则是行缓冲，否则是全缓冲</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列函数用来更改系统默认缓冲类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuf</span><span class="params">(FILE *restrict fp, <span class="type">char</span> *restrict buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setvbuf</span><span class="params">(FILE *restrict fp, <span class="type">char</span> *restrict buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>setbuf用来简单设定，全缓冲还是不带缓冲，buf的大小由常量BUFSIZ决定，关闭传NULL，如果与终端设备相关，则可能将其设置为行缓冲。</p>
<p>setvbuf用来精确设定，借用mode参数实现: 1._IOFBF(全缓冲)  2. _IOLBF(行缓冲) 3. _IONBF(不带缓冲)</p>
<p><img src="/./../pic/image-20221020201531890.png" alt="image-20221020201531890"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//强制冲洗一个流，若fp == NULL， 冲刷所有输出流</span></span><br></pre></td></tr></table></figure>



<h4 id="5-5-打开流"><a href="#5-5-打开流" class="headerlink" title="5.5 打开流"></a>5.5 打开流</h4><p>下列三个函数用来打开一个标准I&#x2F;O流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict pathname, <span class="type">const</span> <span class="type">char</span> *restrict type)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * restrict pathname, <span class="type">const</span> <span class="type">char</span> *restrict type, FILE *restrict fp)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *type)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件指针，失败返回NULL</span></span><br></pre></td></tr></table></figure>

<p>三函数的区别：</p>
<ol>
<li>fopen打开pathname的一个指定文件，type为打开方式</li>
<li>freopen在一个指定的流上打开一个指定的文件，若流已打开，则先关闭流。若该流已定向，清除其定向，此函数一般用于将一个指定文件打开为预定义的流:标准输入，标准输出或标准错误</li>
<li>fdopen根据文件描述符打开一个流，通常用于创建管道和网络通信通道函数返回的描述符，因为这种特殊类型不能用标准I&#x2F;O函数fopen打开</li>
</ol>
<p><img src="/./../pic/image-20221020204317293.png" alt="image-20221020204317293"></p>
<p>字符b在UNIX环境下无意义，因为UNIX内核不区分文本文件和二进制文件。对于fdopen,type的参数稍有区别，因为该描述符已经被打开了，区别主要在于截断和创建都不会起作用，因为已经打开，文件已经存在了</p>
<p>当以读和写类型打开一个文件时，具有以下限制: (不太理解什么意思？)</p>
<ol>
<li>如果中间没有fflush, fseek, fsetpos或rewind，则在输入之后不能直接根输入</li>
<li>如果中间没有fseek, fsetpos或rewind，或者输入操作没有到达文件尾端，输入操作后不能跟输出</li>
</ol>
<p><img src="/./../pic/image-20221020204820635.png" alt="image-20221020204820635"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fclose关闭一个流</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>



<h4 id="5-6-读和写流"><a href="#5-6-读和写流" class="headerlink" title="5.6 读和写流"></a>5.6 读和写流</h4><p>对于打开的流，有三种非格式化I&#x2F;O：</p>
<ol>
<li>每次一个字符的I&#x2F;O 。一次读写一个字符，如果流带缓冲，标准I&#x2F;O处理所有缓冲</li>
<li>每次一行的I&#x2F;O。使用fgets和fputs，每行都以一个换行符终止。</li>
<li>直接I&#x2F;O。fread和fwrite函数支持这种类型的I&#x2F;O，每次I&#x2F;O读取某种数量的对象，比如从二进制文件中每次读写一个结构</li>
</ol>
<p><strong>输入函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下3个函数用于一次读一个字符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getchar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回下一个字符，到达文件尾或出错返回EOF</span></span><br></pre></td></tr></table></figure>

<p>getchar等同于getc(stdin)。getc和fgetc的区别，getc可以被实现成宏(c写的少不太了解，意思貌似是getc的实现可能完全是宏实现的，不是一个函数，而fgetc一定是函数)</p>
<p>由于到达文件尾和出错都返回EOF所以需要一组函数来判断到底是哪种情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//两个函数的返回值，为真返回非0，否则返回0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>大多数实现，流会在FILE对象中维护两个标志:</p>
<ol>
<li>出错标志</li>
<li>文件结束标志</li>
</ol>
<p>调用clearerr可以清除这两个标志</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从流中读取数据以后，再将其压送回流中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回c，失败返回EOF</span></span><br></pre></td></tr></table></figure>

<p>cpp primer标准I&#x2F;O也提过这函数，不过没实际用过这东西，大概运用场景就是，要借助下一个字符来进行判断的时候，不用这函数的话，就需要单独再设置一个临时变量</p>
<p><strong>输出函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putchar</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回c，失败返回EOF</span></span><br></pre></td></tr></table></figure>

<p>与前面输入的区别类似</p>
<h4 id="5-7-每次一行I-x2F-O"><a href="#5-7-每次一行I-x2F-O" class="headerlink" title="5.7 每次一行I&#x2F;O"></a>5.7 每次一行I&#x2F;O</h4><p>以下两个函数提供每次输入一行的功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *restrict buf, <span class="type">int</span> n, FILE *restrict fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回buf，到达文件尾或出错返回NULL</span></span><br></pre></td></tr></table></figure>

<p>gets从标准输入读，fgets从指定流读，fgets需要指定长度，且对于fgets必须指定缓冲区长度，且每次读的字符数不超过n-1，否则读的是不完整的行，最后一个字符以NULL字节结尾。gets函数不推荐使用，不能指定缓冲区长度，存在缓冲区溢出问题，另一个区别gets不将换行符存入缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fputs和puts提供输出一行的功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict str, FILE *restrict fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回非负值，出错返回EOF</span></span><br></pre></td></tr></table></figure>

<p>区别puts会在每次输出后添加一个换行符？</p>
<h4 id="5-8-标准I-x2F-O的效率"><a href="#5-8-标准I-x2F-O的效率" class="headerlink" title="5.8 标准I&#x2F;O的效率"></a>5.8 标准I&#x2F;O的效率</h4><p>对同一文件，采取不同的I&#x2F;O函数，结论是，在系统cpu上占用的时间基本一样，时间差别主要在用户cpu上，由于标准I&#x2F;O中读的时候存在的循环比read长很多(搞不懂这个循环是干啥的，一亿次的循环就离谱)，差别主要也是由于这个导致的</p>
<p><img src="/./../pic/image-20221020232321872.png" alt="image-20221020232321872"></p>
<h4 id="5-9-二进制I-x2F-O"><a href="#5-9-二进制I-x2F-O" class="headerlink" title="5.9 二进制I&#x2F;O"></a>5.9 二进制I&#x2F;O</h4><p>读写一个完整结构的时候通常用到二进制I&#x2F;O操作，因为这种情况下，其他的I&#x2F;O操作处理起来会非常麻烦，例如收到null或换行符的影响直接停止了，不能正确工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *restrict ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nobj, FILE *restrict fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *restrict ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nobj, FILE *restrict fp)</span></span>;</span><br><span class="line">	<span class="comment">//两个函数的返回值，读写的对象数</span></span><br></pre></td></tr></table></figure>

<p><strong>常见用法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1)读写一个二进制数组。例如，将一个浮点数组的第2-5个元素写入文件</span></span><br><span class="line"><span class="type">float</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fwrite</span>(&amp;data[<span class="number">2</span>], <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">4</span>, fp) != <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">err_sys</span>(<span class="string">&quot;fwrite error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2)读写一个结构。例如</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">short</span> count;</span><br><span class="line">    <span class="type">long</span> total;</span><br><span class="line">    <span class="type">char</span> name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fwrite</span>(&amp;item, <span class="built_in">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">err_sys</span>(<span class="string">&quot;fwrite error&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>二进制I&#x2F;O的问题，只能用于同一系统上已写的数据，另一个系统可能由于以下原因不能正常工作：</p>
<ol>
<li>在一个结构中，同一成员的偏移量可能随编译程序和系统的不同而不同</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同系统结构下也可能不同</li>
</ol>
<h4 id="5-10-定位流"><a href="#5-10-定位流" class="headerlink" title="5.10 定位流"></a>5.10 定位流</h4><p>三组不同的，区别不大主要在于偏移量的数据类型的不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回当前文件位置指示，出错返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="type">long</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于二进制文件以字节为单位度量，whence参数与lseek一样，SEEK_SET，SEEK_CUR，SEEK_END。对于文本文件，由于可能存在不同的格式来存放，所以当前位置不能以简单的字节偏移量来度量，所以要定位文本文件，whence一定要是SEEK_SET，offset只能有两种值，0或ftell返回的值。使用rewind函数设置到起始位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">ftello</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回当前文件位置，失败返回(off_t) -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">(FILE *restrict fp, <span class="type">fpos_t</span> *restirct pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，失败返回非0</span></span><br></pre></td></tr></table></figure>



<h4 id="5-11-格式化I-x2F-O"><a href="#5-11-格式化I-x2F-O" class="headerlink" title="5.11 格式化I&#x2F;O"></a>5.11 格式化I&#x2F;O</h4><p><strong>格式化输出:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *restrict fp, <span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line">	<span class="comment">//3个函数成功返回字符输出数，失败返回负值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *restrict buf, <span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回存入数组字符数，编码出错返回负值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *restrict buf, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line">	<span class="comment">//若缓冲区够大，返回存入数组的字符数，编码出错返回负值</span></span><br></pre></td></tr></table></figure>

<p>printf向标准输出，fprintf向指定流，dprintf向指定文件，sprintf将格式化字符送入数组（就类似于字符串拼接之后再输出），snprintf就是指定明确长度缓冲区的sprintf防止缓冲区溢出</p>
<p>格式化字符串: %[flags] [fldwidth] [precision] [lenmodifier] convtype</p>
<p>flags:各种标志     fldwidth:最小字段宽度	precision:小数点后最小位数	lenmodifier:参数长度	convtype:必选的，它控制如何解释参数 	，这一页有各种详细的参数，起始没啥注意的，就平时写的那种%3.2d这种，只不过更详细，有需求的时候看一下 P128</p>
<p><img src="/./../pic/image-20221021002541816.png" alt="image-20221021002541816"></p>
<p><img src="/./../pic/image-20221021002557774.png" alt="image-20221021002557774"></p>
<p><img src="/./../pic/image-20221021002607999.png" alt="image-20221021002607999"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五种类似于上面的变体，可变参数... 替换成了arg</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfprintf</span><span class="params">(FILE *restrict fp, <span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vdprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回输出字符数，出错返回负值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *restrict buf, <span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回存入数组的字符数，编码出错返回负值</span></span><br><span class="line"><span class="function">itn <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *restrict buf, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line">	<span class="comment">//缓冲区够大返回存入数组字符数，编码出错返回负值</span></span><br></pre></td></tr></table></figure>

<p><strong>格式化输入:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restirct format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE *restrict fp, <span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict buf, <span class="type">const</span> <span class="type">char</span> *restrict format, ...)</span></span>;</span><br><span class="line">	<span class="comment">//3个函数的返回值，赋值的输入项数，出错或到文件尾端返回EOF</span></span><br></pre></td></tr></table></figure>

<p>和前面类似: %[*] [fldwidth] [m] [lenmodifier] convtype</p>
<p>用到的时候再细看，P130页</p>
<p><img src="/./../pic/image-20221021003306627.png" alt="image-20221021003306627"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一样也有一组，变体</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfscanf</span><span class="params">(FILE *restrict fp, <span class="type">const</span> <span class="type">char</span> *restrict format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *restrict buf, <span class="type">const</span> <span class="type">char</span> *restrict )</span></span></span><br></pre></td></tr></table></figure>



<h4 id="5-12-实现细节"><a href="#5-12-实现细节" class="headerlink" title="5.12 实现细节"></a>5.12 实现细节</h4><p>标准I&#x2F;O库最终都要调用第3章中说明的I&#x2F;O例程。每个标准I&#x2F;O流都有一个与其相关联的文件描述符，可以对流调用fileno获取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line">	<span class="comment">//返回与流关联的文件描述符</span></span><br></pre></td></tr></table></figure>

<p>可以查看stdio.h源文件，观察实现</p>
<h4 id="5-13-临时文件"><a href="#5-13-临时文件" class="headerlink" title="5.13 临时文件"></a>5.13 临时文件</h4><p>IOS C 标准I&#x2F;O库提供两个函数来帮助创建临时文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="type">char</span> *ptr)</span></span>;</span><br><span class="line">	<span class="comment">//返回指向唯一路径名的指针</span></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件指针，出错返回NULL</span></span><br></pre></td></tr></table></figure>

<p>tmpnam产生一个与现有文件名不同的有效路径字符串，ptr是NULL时，产生的路径名放在一个静态区中，指向该静态区的指针作为函数值返回，若ptr不是NULL，则认为它指向的是一个长度至少是L_tmpnam的字符数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> name[L_tmpnam], line[MAXLINE];</span><br><span class="line">    FILE *fp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">tmpnam</span>(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tmpnam</span>(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">tmpfile</span>()) == <span class="literal">NULL</span>) 	</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;tmpfile error&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;one line of output:&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">rewind</span>(fp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fgets</span>(line, <span class="built_in">sizeof</span>(line), fp) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(line, stdout);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">/tmp/fileT0Hsu6</span><br><span class="line">/tmp/filekmAsYQ</span><br><span class="line">one line of output:</span><br></pre></td></tr></table></figure>

<p>mkdtemp和mkstemp函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="type">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回指向目录名的指针，出错返回NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkstemp</span><span class="params">(<span class="type">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回文件描述符，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>mkdtemp创建目录，mkstemp创建文件，名字通过template字符串进行选择，这个字符串后六位设置为xxxxxx，函数会将这些占位符替换成唯一且有效的，mkdtemp创建的权限：S_IRUSR | S_IWUSR | S_IXUSR，可以通过掩码来影响；mkstemp创建的权限：S_IRUSR，S_IWUSR，mkstemp创建的临时文件不会自动删除，需要手动unlink，与tempfile相比的优点是，获取文件名和创建文件之间没有时间间隔，做到了类似原子操作的功效，具体是不是没说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_temp</span><span class="params">(<span class="type">char</span>* <span class="keyword">template</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> good_template[] = <span class="string">&quot;/tmp/dirXXXXXX&quot;</span>; <span class="comment">//right way</span></span><br><span class="line">    <span class="type">char</span>* bad_template = <span class="string">&quot;/tmp/dirXXXXXX&quot;</span>;   <span class="comment">//wrong way</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;trying to create first temp file...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">make_temp</span>(good_template);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;trying to create second temp file...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">make_temp</span>(bad_template);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_temp</span><span class="params">(<span class="type">char</span>* <span class="keyword">template</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">mkstemp</span>(<span class="keyword">template</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;mkstemp error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temp name = %s\n&quot;</span>, <span class="keyword">template</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(<span class="keyword">template</span>, &amp;sbuf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;file dosen&#x27;t exist\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file exists\n&quot;</span>);</span><br><span class="line">        <span class="built_in">unlink</span>(<span class="keyword">template</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-14-内存流"><a href="#5-14-内存流" class="headerlink" title="5.14 内存流"></a>5.14 内存流</h4><p>标准I&#x2F;O库把数据缓存在内存中，通过调用setbuf和setvbuf函数可以让I&#x2F;O库使用我们自己的缓冲区。</p>
<p>内存流的创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">fmemopen</span><span class="params">(<span class="type">void</span>* restrict buf, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span>* restrict type)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回流指针，错误返回NULL</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221021163311747.png" alt="image-20221021163311747"></p>
<p>与标准I&#x2F;O流有一定的区别:</p>
<ol>
<li>无论何时以追加写方式打开内存流，当前文件位置设为缓冲区的第一个null字节，如果缓冲区中不存在null字节，则当前位置就设为缓冲区结尾的后一个字节。当流不是以追加写方式打开，当前位置设置为缓冲区的开始位置。</li>
<li>如果buf参数是一个NULL指针，读写都没有意义，因为没有办法找到缓冲区的位置，就无法读取已写入的内容</li>
<li>任何时候需要增加流缓冲区中的数据量以及调用fclose、fflush、fseek、fseeko和fsetpos时都会在当前位置写入一个null字节</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSZ 48</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="type">char</span> buf[BSZ];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">    buf[BSZ<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf[BSZ<span class="number">-1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">fmemopen</span>(buf, BSZ, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fmemopen failed&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;initial buffer contents: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before flush: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">fflush</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fflush: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>,(<span class="type">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;b&#x27;</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">    buf[BSZ<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf[BSZ<span class="number">-1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fseek: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;c&#x27;</span>, BSZ<span class="number">-2</span>);</span><br><span class="line">    buf[BSZ<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf[BSZ<span class="number">-1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fclose: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">p139</span><br><span class="line">简单来说，就是通过I/O函数向一个自己的缓冲区写数据，而不是向文件里写了，当前位置的变化只会受到上面第<span class="number">3</span>点里那几个函数的影响</span><br></pre></td></tr></table></figure>

<p>另外两个创建内存流的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">open_memstream</span><span class="params">(<span class="type">char</span>** bufp, <span class="type">size_t</span>* sizep)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function">FILE* <span class="title">open_wmemstream</span><span class="params">(<span class="type">wchar_t</span>** bufp, <span class="type">size_t</span>* sizep)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回流指针，出错返回NULL</span></span><br></pre></td></tr></table></figure>

<p>与fmemopen的区别：</p>
<ol>
<li>创建的流只能写打开</li>
<li>不能指定自己的缓冲区，但可以分别通过bufp和sizep参数访问地址和大小</li>
<li>关闭流后需自行释放缓冲区</li>
<li>对流添加字节会增加缓冲区大小</li>
</ol>
<p>用法感觉会想到stringstream是不是类似实现的</p>
<h4 id="5-15-标准I-x2F-O的替代软件"><a href="#5-15-标准I-x2F-O的替代软件" class="headerlink" title="5.15 标准I&#x2F;O的替代软件"></a>5.15 标准I&#x2F;O的替代软件</h4><p>p140, 提了一些替代软件，有需要再看吧，暂时应该很难用到这么深入的I&#x2F;O操作</p>
<h4 id="5-16-小结"><a href="#5-16-小结" class="headerlink" title="5.16 小结"></a>5.16 小结</h4><p>本章就深入的介绍了I&#x2F;O库的细节，缓冲技术的细节</p>
<h3 id="第7章-进程环境"><a href="#第7章-进程环境" class="headerlink" title="第7章 进程环境"></a>第7章 进程环境</h3><h4 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h4><p>下一章开始进程控制，这一章介绍一些前置知识，以及程序如何运行的</p>
<h4 id="7-2-main函数"><a href="#7-2-main函数" class="headerlink" title="7.2 main函数"></a>7.2 main函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mian函数的原型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核执行C程序时(使用一个exec函数)，在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址(创建虚拟内存？)——-这是由连接编辑器设置的，而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后按上述方式调用main函数做好安排</p>
<h4 id="7-3-进程终止"><a href="#7-3-进程终止" class="headerlink" title="7.3 进程终止"></a>7.3 进程终止</h4><p><strong>有8种方式使进程终止，其中5种为正常终止:</strong></p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或 _Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用pthread_exit</li>
</ol>
<p><strong>异常终止有3种方式:</strong></p>
<ol>
<li>调用abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p><strong>退出函数:</strong></p>
<p>exit和_Exit立即进入内核，exit先执行一些清理工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span>;</span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>

<p><strong>函数atexit:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span>;	</span><br><span class="line">	<span class="comment">//成功返回0，出错返回非0</span></span><br></pre></td></tr></table></figure>

<p>ISOC规定一个进程可以登记至多32个函数，这些函数由exit自动调用，称这些为<strong>进程终止函数</strong>，调用atexit函数来登记这些函数</p>
<p><img src="/./../pic/image-20221023153958629.png" alt="image-20221023153958629"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_exit1</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_exit2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atexit</span>(my_exit2) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t register my_exit2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atexit</span>(my_exit1) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t register my_exit1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atexit</span>(my_exit1) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t register my_exit1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main is done\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_exit1</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;firstt exit handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">my_exit2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;second exit handler\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ ./a,out</span><br><span class="line">main is done</span><br><span class="line">first exit handler</span><br><span class="line">first exit handler</span><br><span class="line">seconde exit handler</span><br></pre></td></tr></table></figure>



<h4 id="7-4-命令行参数"><a href="#7-4-命令行参数" class="headerlink" title="7.4 命令行参数"></a>7.4 命令行参数</h4><p>执行一个程序的时候，调用exec的进程可将命令行参数传递给新程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例   假设可执行程序名为echoarg</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ ./echoarg arg1 TEST foo</span><br><span class="line">argv[<span class="number">0</span>]: ./echoarg</span><br><span class="line">argv[<span class="number">1</span>]: arg1</span><br><span class="line">argv[<span class="number">2</span>]: TEST</span><br><span class="line">argv[<span class="number">3</span>]: foo</span><br></pre></td></tr></table></figure>



<h4 id="7-5-环境表"><a href="#7-5-环境表" class="headerlink" title="7.5 环境表"></a>7.5 环境表</h4><p>每个程序会接收到一张环境表，与参数表一样，同样是字符指针数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br></pre></td></tr></table></figure>

<p>环境字符串的一般命名惯例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* name=value 并且以null结尾*/</span></span><br><span class="line">HOME=/home/sar\<span class="number">0</span></span><br><span class="line">PATH=:/bin:/bash\<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221023155150712.png" alt="image-20221023155150712"></p>
<h4 id="7-6-C程序的存储空间布局"><a href="#7-6-C程序的存储空间布局" class="headerlink" title="7.6 C程序的存储空间布局"></a>7.6 C程序的存储空间布局</h4><p><strong>正文段:</strong></p>
<p>CPU执行的机器指令部分。通常，正文段是可共享的，且只读，防止程序意外修改</p>
<p><strong>初始化数据段:</strong></p>
<p>包含了程序种需明确地赋初值的变量。例如 int maxcount &#x3D; 99(任何函数之外的声明);</p>
<p><strong>未初始化数据段:</strong></p>
<p>通常被称为bss段，例如 long sum[1000]；程序开始执行前，将此段中的数据初始化为0或空指针</p>
<p><strong>栈:</strong></p>
<p>自动变量，以及每次函数调用时所需保存的信息存放在此段。每次函数调用时，其返回地址以及调用者的环境信息。最近被调用的函数在栈上为其自动和临时变量分配存储空间</p>
<p><strong>堆:</strong></p>
<p>通常在堆中进行动态存储分配，一般位于栈和未初始化数据段之间</p>
<p><img src="/./../pic/image-20221023155904977.png" alt="image-20221023155904977"></p>
<p>这个图只是一个比较简单的，实际上还存在一些段，动态库那些，视频笔记部分的虚拟内存图比较完整</p>
<h4 id="7-7-共享库"><a href="#7-7-共享库" class="headerlink" title="7.7 共享库"></a>7.7 共享库</h4><p>应该就是动态库，减少可执行文件大小，可以查看上面视频部分笔记</p>
<h4 id="7-8-存储空间分配"><a href="#7-8-存储空间分配" class="headerlink" title="7.8 存储空间分配"></a>7.8 存储空间分配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nobj, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> newsize)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回非空指针，出错返回NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>基本就是熟悉的那一套</p>
<p><strong>替代的存储空间分配程序:</strong></p>
<ol>
<li>libmalloc</li>
<li>vmalloc</li>
<li>quick_fit</li>
<li>jemalloc</li>
<li>TCMalloc</li>
<li>alloca</li>
</ol>
<p>以后学项目的时候遇到再看吧，常规的目前完全够用了</p>
<h4 id="7-9-环境变量"><a href="#7-9-环境变量" class="headerlink" title="7.9 环境变量"></a>7.9 环境变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">	<span class="comment">//返回指向与name关联的value指针，若未周到，返回NULL</span></span><br></pre></td></tr></table></figure>

<p><strong>SingleUnixSpecification定义的环境变量:</strong></p>
<p><img src="/./../pic/image-20221023170134190.png" alt="image-20221023170134190"></p>
<p><strong>设置环境变量的三个函数: (只能影响当前进程及其生成和调用的子进程，不能影响父进程的环境)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putenv</span><span class="params">(<span class="type">char</span>* str)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回非0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* value, <span class="type">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>3函数的操作如下:</p>
<ol>
<li>putenv取形式为name&#x3D;value的字符串，将其放入环境表中，如果name已经存在，删除其原来的定义</li>
<li>setenv将name设置为value。如果name已经存在，那么(a) 若rewrite非0，则首先删除其现有的定义；(b) 若rewrite为0，则不删除现有定义，不设置新的value也不出错</li>
<li>unsetenv删除name的定义，即使不存在也不出错</li>
</ol>
<h4 id="7-10-函数setjmp和longjmp"><a href="#7-10-函数setjmp和longjmp" class="headerlink" title="7.10 函数setjmp和longjmp"></a>7.10 函数setjmp和longjmp</h4><p>longjmp的两个参数，第一个参数保存返回栈帧的状态，第二个是从set返回的返回值</p>
<p>这两个函数的作用类似于goto，但goto语句不能跨函数执行，这个可以。书中给出了这么一个场景</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOK_ADD 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_line</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmd_add</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_token</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> line[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(line, MAXLINE, stdin) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">do_line</span>(line);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* tok_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_line</span><span class="params">(<span class="type">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    </span><br><span class="line">    tok_ptr = ptr;</span><br><span class="line">    <span class="keyword">while</span> ((cmd = <span class="built_in">get_token</span>()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> TOK_ADD:</span><br><span class="line">                <span class="built_in">cmd_add</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmd_add</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    itn token;</span><br><span class="line">    </span><br><span class="line">    token = <span class="built_in">get_token</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_token</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行的时候会在栈里面不断创建栈帧</p>
<p><img src="/./../pic/image-20221023172616357.png" alt="image-20221023172616357"></p>
<p>如果在cmd_add中出错的话，我们希望它立刻返回main函数执行下一次读，即可通过这两个函数实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line">	<span class="comment">//直接调用返回0，从longjmp返回非0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOK_ADD 5</span></span><br><span class="line"></span><br><span class="line">jmp_buf jmpbuffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> line[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回的位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setjmp</span>(jmpbuffer) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(line, MAXLINE, stdin) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">do_line</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">	.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmd_add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> token;</span><br><span class="line">        token = <span class="built_in">get_token</span>();</span><br><span class="line">        <span class="keyword">if</span> (token &lt; <span class="number">0</span>) <span class="comment">/* an error has occured */</span></span><br><span class="line">            <span class="built_in">longjmp</span>(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>自动变量，寄存器变量和易失变量(volatile):</strong></p>
<p>简单来说，虽然恢复到了调用之前的栈帧，但也不是完全恢复调用前的状态，在不开优化的情况下，被改变的变量不会恢复，开优化的情况下，自动变量和寄存器变量存放在寄存器中，能得到恢复</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf jmpbuffer;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>			 autoval;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> regival;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> volaval;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>   statval;</span><br><span class="line">    </span><br><span class="line">    global = <span class="number">1</span>, autoval = <span class="number">2</span>, regival = <span class="number">3</span>, volaval = <span class="number">4</span>, statval = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setjmp</span>(jmpbuffer) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after longjmp\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;global = %d, autoval = %d, rigival = %d,&quot;</span></span><br><span class="line">              <span class="string">&quot; volaval = %d, statval = %d\n&quot;</span>,global, autoval, regival,</span><br><span class="line">              volaval, statval);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    global = <span class="number">95</span>, autoval = <span class="number">96</span>, regival = <span class="number">97</span>, volaval = <span class="number">98</span>, statval = <span class="number">99</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">f1</span>(<span class="comment">/*参数*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 打印longjmp前的参数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">longjmp</span>(jmpbuffer, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">//不开优化</span></span><br><span class="line">gcc testjmp.c</span><br><span class="line">./a.<span class="function">out </span></span><br><span class="line"><span class="function">in <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="number">95</span> <span class="number">96</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span>          /* global autoval regival volaval statval*/</span></span><br><span class="line"><span class="function">after longjmp:</span></span><br><span class="line"><span class="function"><span class="number">96</span> <span class="number">96</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span></span></span><br><span class="line"><span class="function">gcc -O testjmp.c</span></span><br><span class="line"><span class="function">./a.out</span></span><br><span class="line"><span class="function">in f1():</span></span><br><span class="line"><span class="function"><span class="number">95</span> <span class="number">96</span> <span class="number">97</span> <span class="number">98</span> <span class="number">99</span></span></span><br><span class="line"><span class="function">after longjmp:</span></span><br><span class="line"><span class="function"><span class="number">95</span> <span class="number">2</span> <span class="number">3</span> <span class="number">98</span> <span class="number">99</span></span></span><br></pre></td></tr></table></figure>

<p><strong>自动变量的潜在问题:</strong></p>
<p>这里举得例子就是，在函数中打开了一个流，并且在函数内创建了个局部变量，作为流的缓冲区，函数返回时，它在栈上使用的空间会被下一个函数调用使用，但这个流仍然使用这部分存储空间作为流的缓冲区</p>
<h4 id="7-11-函数getrlimit和setrlimit"><a href="#7-11-函数getrlimit和setrlimit" class="headerlink" title="7.11 函数getrlimit和setrlimit"></a>7.11 函数getrlimit和setrlimit</h4><p>每个进程都有一组资源限制，其中一些可以用getrlimit和setrlimit查询和更改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回非0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span> &#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur; <span class="comment">/* sofr limit: current limit */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max; <span class="comment">/* hard limit: maximum value for rlim_cur */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程的资源线程一般由0进程创建，然后由后续进程继承</p>
<p><strong>更改资源限制时，必须遵循下列3条规则:</strong></p>
<ol>
<li>任何一个进程都可将一个软限制值更改为小于或等于其硬限制值</li>
<li>任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值，且这种降低对于普通进程是不可逆的</li>
<li>只有超级用户进程才可以提高硬限制值</li>
</ol>
<p>然后就是一些具体的参数取值，以及代码示例</p>
<p><strong>参数如下:</strong></p>
<p><img src="/./../pic/image-20221023175227794.png" alt="image-20221023175227794"></p>
<p><strong>RLIMIT_AS:</strong> 进程的总的可用存储空间的最大长度,影响到sbrk函数和mmap函数</p>
<p><strong>RLIMIT_CORE:</strong> core文件的最大字节数，若值为0，阻止创建core文件</p>
<p><strong>RLIMIT_CPU:</strong> CPU时间的最大量值，当超过此软限制，向进程发送SIGXCPU信号</p>
<p><strong>RLIMIT_DATA:</strong> 数据段的最大字节长度，初始化数据、非初始化以及堆的综合</p>
<p><strong>RLIMIT_FSIZE:</strong> 可以创建的文件最大字节长度，超过此软限制，发送SIGXFSZ信号</p>
<p><strong>RLIMIT_MEMLOCK:</strong> 一个进程使用mlock能够锁定在存储空间中的最大字节长度</p>
<p><strong>RLIMIT_MSGQUEUE:</strong> 进程为POSIX消息队列可分配的最大存储字节</p>
<p><strong>RLIMIT_NICE:</strong> 为了影响进程的调度优先级。友好值的最大设置限制</p>
<p><strong>RLIMIT_NOFILE:</strong> 每个进程能打开的最多文件数</p>
<p>……..还有一些P177</p>
<p>资源限制影响到调用进程并由其子进程继承，所以为了影响一个用户的后续进程，需将资源限制的设置构造在shall中</p>
<h4 id="7-12-小结"><a href="#7-12-小结" class="headerlink" title="7.12 小结"></a>7.12 小结</h4><p>一些进程有关的基础内容，以及C程序的实际布局，程序怎么终止的，命令行模式下接触的多的命令行参数，比goto更强的可在函数中跳出的setjmp和longjmp，以及资源限制</p>
<h3 id="第8章-进程控制"><a href="#第8章-进程控制" class="headerlink" title="第8章 进程控制"></a>第8章 进程控制</h3><h4 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h4><p>进程相关控制，机制，属性</p>
<h4 id="8-2-进程标识"><a href="#8-2-进程标识" class="headerlink" title="8.2 进程标识"></a>8.2 进程标识</h4><p>每个进程运行的时候都会有一个唯一的进程ID，但进程终止之后，这个ID能被其他进程复用，当然这个复用有一个延迟机制，不会复用最近终止的进程，同时也举了一些特殊的进程ID，如0，1，2进程，交换进程，init进程，页守护进程，这些进程由系统专用，满足系统的一些需求，对于init进程还有个特殊的地方，它会成为所有孤儿进程的父进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//返回调用进程的进程ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//返回调用进程的父进程ID</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//返回进程的实际用户ID</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//返回进程的有效用户ID</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//返回进程的实际组ID</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getdgid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//返回进程的有效组ID</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-函数fork"><a href="#8-3-函数fork" class="headerlink" title="8.3 函数fork"></a>8.3 函数fork</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//父进程返回子进程ID，子进程返回0   出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globvar = <span class="number">6</span>; <span class="comment">/* external variable in initialized data */</span></span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;a write to stdout\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var; <span class="comment">/*automatic variable on the stack */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, <span class="built_in">sizeof</span>(buf) <span class="number">-1</span>) != <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork\n&quot;</span>); <span class="comment">/* we don&#x27;t flush stdout */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">/* child */</span></span><br><span class="line">        globvar++;</span><br><span class="line">        var++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);           <span class="comment">/* father */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %ld, glob = %d, var = %d\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">getpid</span>(), globvar, var);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">pid = <span class="number">430</span>, glob = <span class="number">7</span>, var = <span class="number">89</span>      子进程的值改变了</span><br><span class="line">pid = <span class="number">429</span>, glob = <span class="number">6</span>, var = <span class="number">88</span>      父进程的值不变</span><br><span class="line">$ ./a.out &gt; temp.out</span><br><span class="line">$ cat temp.out</span><br><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">pid = <span class="number">430</span>, glob = <span class="number">7</span>, var = <span class="number">89</span></span><br><span class="line">before fork</span><br><span class="line">pid = <span class="number">429</span>, glob = <span class="number">6</span>, var = <span class="number">88</span></span><br></pre></td></tr></table></figure>

<p>对于fork完后，先执行子进程还是父进程是不确定的，所以用sleep保证先执行子进程，对于两次执行结果，第一次直接对标准输出写，第二次将标准输出重定向到temp.out可以发现，此时before fork变成两行了，问题在于，write是不缓冲的，而对于标准库的I&#x2F;O，是带缓冲的，如果连接到设备终端是行缓冲，但重定向到文件之后，它是全缓冲的，缓冲区随着fork一起被复制了，在子进程结束时被写到相应文件</p>
<p><strong>文件共享:</strong></p>
<p>简单来说就是父子进程的文件描述符表中的文件描述符指向同一文件表项，就像执行了dup函数</p>
<p><img src="/./../pic/image-20221024154956178.png" alt="image-20221024154956178"></p>
<p>fork之后处理文件描述符表有以下两种常见的情况:</p>
<ol>
<li>父进程等待子进程完成。</li>
<li>父进程和子进程各自执行不同的程序段。各自关闭它们不需要的文件描述符</li>
</ol>
<p>除打开文件之外，其他子进程从父进程继承的属性:</p>
<ol>
<li>实际用户ID，实际组ID，有效用户ID，有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志的和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ol>
<p>父子进程的区别如下:</p>
<ol>
<li>fork的返回值不同</li>
<li>进程ID不同</li>
<li>子进程的tms_utime，tms_stime，tms_cutime和tms_ustime的值设置为0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集被设置为空集</li>
</ol>
<p>对于fork的一种常见用法时，fork之后子进程执行exec，spawn将这两个操作组合成一个操作</p>
<h4 id="8-4-函数vfork"><a href="#8-4-函数vfork" class="headerlink" title="8.4 函数vfork"></a>8.4 函数vfork</h4><p>函数用法上和fork相同，但语义不同。vfork的目的是，创建一个新进程，新进程的目的是执行一个新程序，所以它与fork的一个区别是，vfork保证子进程优先运行，在它调用exec或exit之后，父进程才可能被调度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试一下 vfork</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globval = <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = <span class="built_in">vfork</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;vfork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        globval++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %ld, glob = %d\n&quot;</span>, (<span class="type">long</span>)<span class="built_in">getpid</span>(), globval);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">pid = <span class="number">714</span>, glob = <span class="number">89</span></span><br><span class="line">pid = <span class="number">713</span>, glob = <span class="number">89</span></span><br><span class="line">    </span><br><span class="line">globval父子进程都一样，这是vfork的另一个区别，完全不复制，地址空间用的就是父进程的</span><br></pre></td></tr></table></figure>



<h4 id="8-5-函数exit"><a href="#8-5-函数exit" class="headerlink" title="8.5 函数exit"></a>8.5 函数exit</h4><p>7.3节曾说过，进程有5种正常终止以及3种异常终止方式。</p>
<p><strong>5种正常终止方式具体如下:</strong></p>
<ol>
<li>在main种调用return函数，相当于exit</li>
<li>调用exit函数，exit函数具体作用在 <strong>7.3</strong> 中提过，但对于UNIX系统不完整，因为它不处理文件描述符，多进程以及作业控制</li>
<li>调用_exit或 _Exit函数。其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法，对标准I&#x2F;O流是否冲洗，取决于实现。</li>
<li>进程的最后一个线程在其启动例程中执行return语句。</li>
<li>进程的最后一个线程调用pthread_exit函数。</li>
</ol>
<p><strong>3种异常终止具体如下:</strong></p>
<ol>
<li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。</li>
<li>当进程接收到某些信号时。(第10章会较详细地说明信号)</li>
<li>最后一个线程对 <strong>取消</strong> 请求作出相应。</li>
</ol>
<p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应的进程关闭所有打开描述符，释放它所使用的存储器。</p>
<p>这里也提及了以下僵尸进程和孤儿进程，僵尸进程产生于，子进程结束了但父进程没有对其进行wait处理，孤儿进程产生于，父进程先于子进程结束，这些子进程会称为init进程的子进程，被其处理</p>
<h4 id="8-6-函数wait和waitpid"><a href="#8-6-函数wait和waitpid" class="headerlink" title="8.6 函数wait和waitpid"></a>8.6 函数wait和waitpid</h4><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。可以注册信号捕捉函数来处理它，这种信号的默认处理是忽略。</p>
<p>调用wait或waitpid时可能发生的事情:</p>
<ol>
<li>如果其所有子进程都还在运行，则阻塞</li>
<li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该进程的终止状态立即返回</li>
<li>如果它没有任何子进程，则立即返回出错</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回进程ID，出错返回0(见后面说明)或-1 </span></span><br></pre></td></tr></table></figure>

<p>两函数区别:</p>
<ol>
<li>在一个子进程终止前，wait使其调用者阻塞吗，而waitpid有一选项，可使得调用者不阻塞</li>
<li>waitpid并不等待在其调用之后的第一个终止子进程，它有若干选项，可以控制它等待的进程</li>
</ol>
<p>statloc传出终止状态，配合特定的宏使用: (上面视频笔记部分的wati就有)</p>
<p><img src="/./../pic/image-20221024164930870.png" alt="image-20221024164930870"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pr_exit</span><span class="params">(<span class="type">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;normal termination, exit status = %d\n&quot;</span>,</span><br><span class="line">                <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;abnormal termination, signal number = %d%s\n&quot;</span>,</span><br><span class="line">                <span class="built_in">WTERMSIG</span>(status),</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">    			<span class="built_in">WCOREDUMP</span>(status) ? <span class="string">&quot; (core file generated)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    			<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child stopped, signal number = %d\n&quot;</span>,</span><br><span class="line">                  <span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用上述程序的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wait</span>(&amp;status) != pid) 	 	<span class="comment">/* wait fo child */</span></span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    <span class="built_in">pr_exit</span>(status);				<span class="comment">/* and print its status */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);		<span class="comment">/* child */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">abort</span>();					<span class="comment">/* generates SIGABRT */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wait</span>(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    <span class="built_in">pr_exit</span>(status);				<span class="comment">/* and print its status */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)				<span class="comment">/* child */</span></span><br><span class="line">        status /= <span class="number">0</span>;				<span class="comment">/* 除0错误，产生一个信号 */</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wait</span>(&amp;status) != pid)		<span class="comment">/* wait for child */</span></span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    <span class="built_in">pr_exit</span>(status);				<span class="comment">/* and print its status */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>waitpid的参数作用如下:</p>
<ol>
<li>pid &#x3D;&#x3D; -1 ,等待任一子进程，此时waitpid与wait等效</li>
<li>pid &gt; 0 ,等待进程ID与pid相等的子进程</li>
<li>pid &#x3D;&#x3D; 0 ,等待组ID等于调用进程组ID的任一子进程</li>
<li>pid &lt; -1 ,等待组ID等于pid绝对值的任一子进程</li>
</ol>
<p>options参数如下: 此参数或是0，或是如下常量</p>
<p><img src="/./../pic/image-20221024195636184.png" alt="image-20221024195636184"></p>
<h4 id="8-7-函数waitid"><a href="#8-7-函数waitid" class="headerlink" title="8.7 函数waitid"></a>8.7 函数waitid</h4><p>此函数类似于waitpid，但更灵活</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span>* infop, <span class="type">int</span> options)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221024200426117.png" alt="image-20221024200426117"></p>
<h4 id="8-8-函数wait3和wait4"><a href="#8-8-函数wait3和wait4" class="headerlink" title="8.8 函数wait3和wait4"></a>8.8 函数wait3和wait4</h4><p>多一个参数，该参数允许内核返回由终止进程及其子进程使用的资源概况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="type">int</span>* statloc, <span class="type">int</span> options, <span class="keyword">struct</span> rusage* rusage)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options, <span class="keyword">struct</span> rusage* rusage)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回进程ID,出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>资源统计信息，包括用户CPU时间总量，系统CPU时间总量，缺页次数，接收到信号的次数等。</p>
<p><img src="/./../pic/image-20221024200812484.png" alt="image-20221024200812484"></p>
<h4 id="8-9-竞争条件"><a href="#8-9-竞争条件" class="headerlink" title="8.9 竞争条件"></a>8.9 竞争条件</h4><p>就是上述视频笔记部分的时态竞争，由于不确定进程谁会优先执行，产生的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;apue.h&gt;</span>      <span class="comment">/* 假设apue里面包含了所有所需的头文件 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">charatatime</span>(<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">charatatime</span>(<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">charatatime</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* ptr;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);             </span><br><span class="line">    <span class="keyword">for</span> (ptr=str; (c=*ptr++); ) &#123;</span><br><span class="line">        <span class="built_in">putc</span>(c, stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述程序就存在竞争，父子进程谁先输出不确定</span></span><br><span class="line"><span class="comment">//改进示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TELL_WAIT</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">WAIT_PARENT</span>();         <span class="comment">/* parents go first */</span></span><br><span class="line">        <span class="built_in">charatatime</span>(<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">charatatime</span>(<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">        <span class="built_in">TELL_CHILD</span>(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">charatatime</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* ptr;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);             </span><br><span class="line">    <span class="keyword">for</span> (ptr=str; (c=*ptr++); ) &#123;</span><br><span class="line">        <span class="built_in">putc</span>(c, stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体wait怎么实现，可能是IPC，也可能是信号</span></span><br></pre></td></tr></table></figure>



<h4 id="8-10-函数exec"><a href="#8-10-函数exec" class="headerlink" title="8.10 函数exec"></a>8.10 函数exec</h4><p>调用exec并不创建新进程，所以前后的进程ID并未改变，exec只是用磁盘上的一个新程序替换了当前进程的正文段，数据段，堆段和栈段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">const</span> <span class="type">char</span>* arg0, ... <span class="comment">/* (char*)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">const</span> <span class="type">char</span>* arg0, ... <span class="comment">/* (char*)0, char* const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* arg0, ... <span class="comment">/* (char*)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span></span>;</span><br><span class="line">	<span class="comment">//出错返回-1，成功不返回</span></span><br></pre></td></tr></table></figure>

<p>这些函数的第一个区别，前四个函数以路径名(pathname)作为参数，后两个取文件名(filename)作为参数，最后一个取文件描述符作为参数。当指定文件名为参数时:</p>
<ol>
<li>如果filename中包含&#x2F;，则将其视为路径</li>
<li>否则就按PATH环境变量，在它所指定的目录中搜寻可执行文件</li>
</ol>
<p><img src="/./../pic/image-20221025164348556.png" alt="image-20221025164348556"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *env_init[] = &#123;<span class="string">&quot;USER=unknown&quot;</span>,<span class="string">&quot;PATH=/tmp&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">execle</span>(<span class="string">&quot;/home/sar/bin/echoall&quot;</span>, <span class="string">&quot;echoall&quot;</span>, <span class="string">&quot;myarg1&quot;</span>, <span class="string">&quot;MY arg2&quot;</span>, (<span class="type">char</span>*)<span class="number">0</span>, env_init) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ess_sys</span>(<span class="string">&quot;execle error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">execlp</span>(<span class="string">&quot;echoall&quot;</span>, <span class="string">&quot;echoall&quot;</span>, <span class="string">&quot;only 1 arg&quot;</span>, (<span class="type">char</span>*)<span class="number">0</span>,) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;execlp error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exec执行的程序如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span>** ptr;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ptr = environ; *ptr != <span class="number">0</span>; ptr++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-11-更改用户ID和更改组ID"><a href="#8-11-更改用户ID和更改组ID" class="headerlink" title="8.11 更改用户ID和更改组ID"></a>8.11 更改用户ID和更改组ID</h4><p>可以用setuid函数设置实际用户ID和有效用户ID，与此类似可以用setgid函数设置实际组ID和有效组ID</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>规则：如果几进程具有超级用户特权，设置的时候对实际用户ID，有效用户ID，保存的设置用户ID，都会被修改；反之，只会修改用户ID</p>
<p>更改3个ID位的另一个方法是执行exec函数的时候，exec会根据 <strong>设置用户ID位关闭与否</strong> 进行不同更改</p>
<ol>
<li>设置用户ID位关闭时，实际用户ID不变，有效用户ID不变，保存的用户ID从有效用户ID复制</li>
<li>设置用户ID位打开时，实际用户ID不变，有效用户ID设置为程序文件的用户ID，保存的用户ID从有效复制</li>
</ol>
<p><img src="/./../pic/image-20221025170303562.png" alt="image-20221025170303562"></p>
<p> <strong>函数setreudi和setregid</strong></p>
<p>历史上，BSD支持setreuid函数，其功能是交换实际用户ID和有效用户ID<img src="/./../pic/image-20221025170956259.png" alt="image-20221025170956259"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setreuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setregid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错-1</span></span><br></pre></td></tr></table></figure>

<p>这种非常规的函数，还是真遇到了再细看</p>
<p><strong>函数seteuid和setegid</strong></p>
<p>类似于setuid和setgid但只会更改有效用户ID和有效组ID</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错-1</span></span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221025170958630.png" alt="image-20221025170958630"></p>
<p>可以看出setreuid是比较奇怪的，遇到再细看</p>
<p><strong>组ID</strong></p>
<p>本章说的一切函数适用于各个组ID，附属组除外</p>
<h4 id="8-12-解释器文件"><a href="#8-12-解释器文件" class="headerlink" title="8.12 解释器文件"></a>8.12 解释器文件</h4><p>没看懂只能说，不知道干嘛用的，也没用过这东西，反之用来执行不同的脚本文件的，提高可移植性？以及提高效率，根据后面一节可能会更好理解，是shell能处理的命令更广泛?</p>
<h4 id="8-13-函数system"><a href="#8-13-函数system" class="headerlink" title="8.13 函数system"></a>8.13 函数system</h4><p>在函数中使用命令来执行操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdstring)</span></span>;</span><br><span class="line">	<span class="comment">//返回值见下</span></span><br></pre></td></tr></table></figure>

<p>因为system在它的实现中调用了fork，exec和waitpid，因此有3种返回值:</p>
<ol>
<li>fork失败或者waitpid返回除EINTR之外的出错，返回-1，并且设置errno</li>
<li>如果exec失败，则其返回值如同shell执行了exit(127)</li>
<li>否则所有3个函数都成功，那么system的返回值，是shell的终止状态(?) waitpid那个终止状态好像是</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system的一种实现，它不对信号处理，后续会修改</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdstring)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">                status = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((status = <span class="built_in">system</span>(<span class="string">&quot;date&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前面waitpid提过的，打印终止状态</span></span><br><span class="line">    <span class="built_in">pr_exit</span>(status);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((status = <span class="built_in">system</span>(<span class="string">&quot;nosuchcommand&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;system() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_exit</span>(status);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((status = <span class="built_in">system</span>(<span class="string">&quot;who; exit 44&quot;</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;system() error&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">pr_exit</span>(status);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">Sat Feb <span class="number">25</span> <span class="number">19</span>:<span class="number">36</span>:<span class="number">59</span> EST <span class="number">2012</span></span><br><span class="line">normal termination, exit status = <span class="number">0</span>   <span class="comment">//对于date</span></span><br><span class="line">sh: nosuchcomman: command <span class="keyword">not</span> found</span><br><span class="line">normal termination, exit status = <span class="number">127</span> <span class="comment">//对于无此种命令</span></span><br><span class="line">sar     console Jan  <span class="number">1</span> <span class="number">14</span>:<span class="number">59</span></span><br><span class="line">sar     ttys000 Feb  <span class="number">7</span> <span class="number">19</span>:<span class="number">08</span></span><br><span class="line">sar     ttys001 Jan <span class="number">15</span> <span class="number">15</span>:<span class="number">28</span></span><br><span class="line">sar     ttys002 Jan <span class="number">15</span> <span class="number">21</span>:<span class="number">50</span></span><br><span class="line">sar     ttys003 Jan <span class="number">21</span> <span class="number">16</span>:<span class="number">02</span></span><br><span class="line">normal tremination, exit status = <span class="number">44</span>  <span class="comment">//对于exit</span></span><br></pre></td></tr></table></figure>

<p>还有个注意点，如果一个进程正以特殊的权限(设置用户ID或设置组ID)运行，它又想生成另一个进程执行另一个程序，则它应当直接使用fork和exec，而且在fork之后，exec之前，要更改会普通权限。设置用户ID或设置组ID程序，绝不应调用system函数(意思应该就是，因为system将fork和exec组合了，没办法在之间进行操作)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">err_quit</span>(<span class="string">&quot;comman-line argument required&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((status = <span class="built_in">system</span>(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;system error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_exit</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="comment">/* 将次程序编译为可执行目标文件tsys */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real uid = %d, effective uid = %d\n&quot;</span>, <span class="built_in">getuid</span>(), <span class="built_in">geteuid</span>());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">/* 将次程序编译为可执行目标文件printuids */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ tsys printuids</span><br><span class="line">read uid = <span class="number">205</span>, effective uid = <span class="number">205</span>             <span class="comment">/* 正常执行无特权 */</span></span><br><span class="line">normal termination, exit status = <span class="number">0</span></span><br><span class="line">$su                                             <span class="comment">/* 成为超级用户并更改特权 */</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta"># chown root tsys</span></span><br><span class="line"><span class="meta"># chmod u+s tsys</span></span><br><span class="line"><span class="meta">#ls -l tsys</span></span><br><span class="line">-rwsrwxr-x <span class="number">1</span> root       <span class="number">7788</span> Feb <span class="number">25</span> <span class="number">22</span>:<span class="number">13</span> tsys</span><br><span class="line"><span class="meta"># exit</span></span><br><span class="line">$ tsys printuids                            </span><br><span class="line">read uid = <span class="number">205</span>, effective uid = <span class="number">0</span>               <span class="comment">/* 有效用户ID称为root */</span></span><br><span class="line">normal termination, exit status = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="8-14-进程会计"><a href="#8-14-进程会计" class="headerlink" title="8.14 进程会计"></a>8.14 进程会计</h4><p>大多数UNIX系统提供一个选项以进行进程会计。启用该选项后，每当进程结束的时候，内核就会写一个记录。一般包括命令名，所使用的CPU时间总量，用户ID和组ID，启动时间等。</p>
<p>acct函数用来启用和禁用进程会计，唯一使用这一函数的是accton命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会计记录结构</span></span><br><span class="line"><span class="keyword">typedef</span> u_short <span class="type">comp_t</span>;<span class="comment">/* 3-bit base 8 exponent; 13-bit fraction */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acct</span> &#123;</span><br><span class="line">    <span class="type">char</span>   ac_flag;    <span class="comment">/* flag (see Figure 8.26)</span></span><br><span class="line"><span class="comment">    char   ac_stat;	   /* termination status(signal &amp; core flag only) */</span>	</span><br><span class="line">    				   <span class="comment">/* (Solaris only)	</span></span><br><span class="line"><span class="comment">    uid_t  ac_uid;     /* read user ID */</span></span><br><span class="line">    <span class="type">gid_t</span>  ac_gid;     <span class="comment">/* read group ID */</span></span><br><span class="line">    <span class="type">dev_t</span>  ac_tty;     <span class="comment">/* controlling terminal */</span></span><br><span class="line">    <span class="type">time_t</span> ac_btime;   <span class="comment">/* starting calendear time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_utime;   <span class="comment">/* user CPU time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_stime;   <span class="comment">/* system CPU time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_etime;   <span class="comment">/* elapsed time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_mem;     <span class="comment">/* average memory uage */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_io;	   <span class="comment">/* bytes transferred (by read and write) */</span></span><br><span class="line">    				   <span class="comment">/* &quot;blocks&quot; on BSD systems */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_rw;      <span class="comment">/* blocks read or written */</span></span><br><span class="line">       	 	 	 	   <span class="comment">/* (not present on BSD systems) */</span></span><br><span class="line">    <span class="type">char</span>   ac_comm[<span class="number">8</span>]; <span class="comment">/* comman name: [8] for Solaris,*/</span></span><br><span class="line">    				   <span class="comment">/* [10] for Mac OX X, [16] for FreeBSD, and [17] for linux */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-15-用户标识"><a href="#8-15-用户标识" class="headerlink" title="8.15 用户标识"></a>8.15 用户标识</h4><p>获取运行该程序的用户的登录名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getlogin</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	<span class="comment">//成功，返回指向登录名字符串的指针，出错返回NULL</span></span><br></pre></td></tr></table></figure>



<h4 id="8-16-进程调度"><a href="#8-16-进程调度" class="headerlink" title="8.16 进程调度"></a>8.16 进程调度</h4><p>通过调整友好值，更改进程调度的优先级，友好值越小，优先级越高</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nice</span><span class="params">(<span class="type">int</span> incr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回新的友好值NZERO，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>incr参数被增加到调用进程的友好值上。如果incr太大，系统直接把它降到最大合法值(友好值是有范围的，书上提到的是<strong>0 ~ (2*NZERO)-1</strong>，不过应该取决于实现) ，类似如果incr太小，系统把他提高到最小合法值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回 -NZERO ~ NZERO-1 之间的友好值，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>which参数以下三个直之一:</p>
<ol>
<li>PRIO_PROCESS表示进程</li>
<li>PRIO_PGRP表示进程组</li>
<li>PRIO_USER表示用户ID</li>
</ol>
<p>如果who参数为0，表示调用进程，进程组或用户。当which设为PRIO_USR并且who为0，使用调用进程的实际用户ID。如果参数作用于多个进程，返回优先度最高的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MACOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syslimits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> count;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checktime</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (tv.tv_sec &gt;= end.tv_sec &amp;&amp; tv.tv_usec &gt;= end.tv_usec) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s count = %lld\n&quot;</span>, str, count);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span>* s;</span><br><span class="line">    <span class="type">int</span> nzero, ret;</span><br><span class="line">    <span class="type">int</span> adj = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(NZERO)</span></span><br><span class="line">    nzero = NZERO;</span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> defined(_SC_NZERO)</span></span><br><span class="line">    nzero = <span class="built_in">sysconf</span>(_SC_NZERO);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> NZERO undefined</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NZERO = %d\n&quot;</span>, nzero);</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        adj = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    end.tv_sec += <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current nice value int child is %d, adjusting by %d\n&quot;</span>,</span><br><span class="line">              <span class="built_in">nice</span>(<span class="number">0</span>) + nzero, adj);</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">nice</span>(adj)) == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_sys</span>(<span class="string">&quot;child set scheduling priority&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;now child nice value is %d\n&quot;</span>, ret + nzero);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;current nice value in parent is %d\n&quot;</span>, <span class="built_in">nice</span>(<span class="number">0</span>)+nzero);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++count == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_quit</span>(<span class="string">&quot;%s counter wrap&quot;</span>, s);</span><br><span class="line">        <span class="built_in">checktime</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ a.a.out</span><br><span class="line">NZERO = <span class="number">20</span></span><br><span class="line">current nice value in parent is <span class="number">20</span></span><br><span class="line">current nice value in child is <span class="number">20</span>, adjusting by <span class="number">0</span></span><br><span class="line">now child nice value is <span class="number">20</span></span><br><span class="line">child count = <span class="number">1859362</span></span><br><span class="line">parent count = <span class="number">1845338</span></span><br><span class="line">$ ./a.out</span><br><span class="line">NZERO = <span class="number">20</span></span><br><span class="line">current nice value in parent is <span class="number">20</span></span><br><span class="line">current nice value in child is <span class="number">20</span>, adjusting by <span class="number">20</span></span><br><span class="line">now child nice value is <span class="number">39</span></span><br><span class="line">parent count = <span class="number">3595709</span></span><br><span class="line">child count = <span class="number">52111</span></span><br></pre></td></tr></table></figure>

<p>当友好值相同时，父进程占有50.2%的CPU，子进程占用49.8%的CPU；当将子进程的友好值增加，即优先度降低，父进程占用98.5%的CPU，子进程只占用1.5%的CPU</p>
<h4 id="8-17-进程时间"><a href="#8-17-进程时间" class="headerlink" title="8.17 进程时间"></a>8.17 进程时间</h4><p>1.10节说明了我们可以度量的3个时间：墙上时钟时间，用户CPU时间和系统CPU时间。任一进程都可以调用times函数获得它自己以及已终止子进程的上述值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">clock_t</span> <span class="title">times</span><span class="params">(<span class="keyword">struct</span> tms* buf)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回流逝的墙上时间，出从返回-1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tms</span> &#123;</span><br><span class="line">    <span class="type">clock_t</span> tms_utime;  <span class="comment">/* user CPU time */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_stime;  <span class="comment">/* system CPU time */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cutime; <span class="comment">/* user CPU time, terminated children */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cstime; <span class="comment">/* system CPU time, terminated children */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pr_times</span><span class="params">(<span class="type">clock_t</span>, <span class="keyword">struct</span> tms*, <span class="keyword">struct</span> tms*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">do_cmd</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">do_cmd</span>(argv[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">do_cmd</span><span class="params">(<span class="type">char</span>* cmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tms</span> tmsstart, tmsend;</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ncommand: %s\n&quot;</span>,cmd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((start = <span class="built_in">times</span>(&amp;tmsstart)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;times error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((status = <span class="built_in">sytem</span>(cmd)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;system error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((end = <span class="built_in">times</span>(&amp;tmsend)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;times error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_times</span>(end - start, &amp;tmsstart, &amp;tmsend);</span><br><span class="line">    <span class="built_in">pr_exit</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pr_times</span><span class="params">(<span class="type">clock_t</span>, <span class="keyword">struct</span> tms*, <span class="keyword">struct</span> tms*)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> clktck = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (clktck == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> ((clktck = <span class="built_in">sysconf</span>(_SC_CLK_TCK)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">er_sys</span>(<span class="string">&quot;sysconf error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  real: %7.2f\n&quot;</span>, real / (<span class="type">double</span>) clktck);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  user: %7.2f\n&quot;</span>,</span><br><span class="line">          (tmsend-&gt;tms_utime - tmsstart-&gt;tms_utime) / (<span class="type">double</span>) clktck);</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  child sys: %7.2f\n&quot;</span>,</span><br><span class="line">          (tmsend-&gt;tms_cstime - tmsstart-&gt;tms_cstime) / (<span class="type">double</span>) clktck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/image-20221025212837098.png" alt="image-20221025212837098"></p>
<h4 id="8-18-小结"><a href="#8-18-小结" class="headerlink" title="8.18 小结"></a>8.18 小结</h4><p>比较熟悉的是之前视频部分看过的fork wait exec这些函数了，然后本小节，又详细的介绍了这些函数的一些变种，以及system函数的实际实现，进程会计对于进程再一次观察，以及对进程调度优先级的更改</p>
<h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><h4 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h4><p>信号是软件中断。信号提供了一种处理异步事件的方法。本章先对信号机制进行综述，说明每个信号的一般用法，然后分析早期实现的问题。</p>
<h4 id="10-2-信号概念"><a href="#10-2-信号概念" class="headerlink" title="10.2 信号概念"></a>10.2 信号概念</h4><p>产生信号的条件:</p>
<ol>
<li>当用户按某些终端键，引发终端产生的信号。如ctrl+c通常产生中断信号(SIGINT)</li>
<li>硬件异常产生的信号。如除0操作，非法内存访问</li>
<li>进程调用kill函数可将任意信号发送给另一个进程或进程组。</li>
<li>用户可用kill命令将信号发送给其他进程</li>
<li>当检测到某种软件条件已经发生，并应将其通知有关进程时产生信号。如闹钟产生SIGALRM</li>
</ol>
<p>信号的三种处理方式:</p>
<ol>
<li>忽略此信号。</li>
<li>捕捉信号。</li>
<li>执行默认动作。</li>
</ol>
<p>SIGKILL和SIGSTOP只执行默认动作，提供给系统一个有效的结束进程的方法</p>
<p>P252有各种信号的详细说明</p>
<h4 id="10-3-函数signal"><a href="#10-3-函数signal" class="headerlink" title="10.3 函数signal"></a>10.3 函数signal</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signo, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line">	<span class="comment">//成功返回以前的信号处理配置，出错返回SIG_ERR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可读性高的写法</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title">Sigfunc</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">Sigfunc* <span class="title">signal</span><span class="params">(<span class="type">int</span>, Sigfunc*)</span></span>;</span><br></pre></td></tr></table></figure>

<p>signo参数是信号名。func的参数有三种。</p>
<ol>
<li>如果指定SIG_IGN，表示忽略此信号</li>
<li>如果指定SIG_DFL，表示执行系统默认动作</li>
<li>如果指定函数地址，当信号发生时，调用该函数，称这种处理为捕捉该信号</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_usr</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">/* one handler for both signals */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR1, sig_usr) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t catch SIGUSR1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t catch SIGUSR3&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        pause;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_usr</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGUSR1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received SIGUSR1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGUSR2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received SIGUSR2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">err_dump</span>(<span class="string">&quot;received signal %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">[<span class="number">1</span>] <span class="number">7216</span>    <span class="comment">/* 查看进程ID */</span></span><br><span class="line">$ kill -USR1 <span class="number">7216</span></span><br><span class="line">received SIGUSR1</span><br><span class="line">$ kill -USR2 <span class="number">7216</span></span><br><span class="line">received SIGUSR2</span><br><span class="line">$ kill <span class="number">7216</span></span><br><span class="line">[<span class="number">1</span>+] Terminated   ./a.out</span><br></pre></td></tr></table></figure>

<p>进程exec之后，原捕捉函数无意义了，但fork之后，仍然有效，因为子进程在开始复制了父进程的内存映像。所以信号捕捉函数的地址在子进程中是有意义的</p>
<h4 id="10-4-不可靠的信号"><a href="#10-4-不可靠的信号" class="headerlink" title="10.4 不可靠的信号"></a>10.4 不可靠的信号</h4><p>早期信号的一些问题，比如阻塞信号的能力当时不具备。现在我们知道通过阻塞信号集和未决信号集实现了。以及，在进程每次接到信号对其进行处理时，随机将信号动作重置为默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个经典实例</span></span><br><span class="line"><span class="function"><span class="type">int</span>		<span class="title">sig_int</span><span class="params">()</span></span>;      <span class="comment">/* my signal handling function */</span></span><br><span class="line">... </span><br><span class="line"><span class="built_in">signal</span>(SIGINT, sig_int) <span class="comment">/* establish handler */</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">sig_int</span>() &#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sig_int);</span><br><span class="line">    					<span class="comment">/* reestablish handler for next time */</span></span><br><span class="line">    					<span class="comment">/* process the signal */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于，如果在sig_int中的signal重建捕捉之前，又发生一次中断信号，第二个信号执行默认动作，导致后续的捕捉函数失效。另一个问题在于，没有办法阻止信号发生，你只能忽略它，但没法阻止，现在通过阻塞信号集实现了</p>
<h4 id="10-5-中断的系统调用"><a href="#10-5-中断的系统调用" class="headerlink" title="10.5 中断的系统调用"></a>10.5 中断的系统调用</h4><p>早期UNIX的一个特性，如果进程在执行一个低速系统调用而阻塞期间捕捉到了一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其errno设置为EINTR。</p>
<p>低速系统调用:</p>
<ol>
<li>如果某些类型的文件数据不存在(管道，终端设备，网络设备)，则读操作可能使调用者永远阻塞</li>
<li>如果这些数据不能被相同类型文件立即接受，则写操作可能会使调用者永久阻塞</li>
<li>在某种条件发生之前打开某些类型文件，可能发生阻塞(例如打开一个终端设备，需要等待与之连接的调制解调器应答)</li>
<li>pause函数和wait函数</li>
<li>某些ioctl操作</li>
<li>某些进程间通信函数(15章)</li>
</ol>
<h4 id="10-6-可重入函数"><a href="#10-6-可重入函数" class="headerlink" title="10.6 可重入函数"></a>10.6 可重入函数</h4><p>可重入函数，也被称为异步信号安全的。它保证在执行信号处理函数的时候，不会对影响进程的执行。比如如果进程中正在malloc，此时信号产生，去执行信号处理函数，信号处理函数也malloc的话，通常malloc为它分配的存储区维护一个链表，信号处理函数可能更改此链表，由此可能对进程造成破坏</p>
<p><img src="/./../pic/image-20221027121914840.png" alt="image-20221027121914840"></p>
<p>不可重入函数的一些特征:</p>
<ol>
<li>它们使用静态数据结构</li>
<li>它们调用malloc或free</li>
<li>它们是标准I&#x2F;O函数，标准I&#x2F;O库中的很多实现都以不可重入的方式使用全局数据结构</li>
</ol>
<h4 id="10-7-SIGCLD语义"><a href="#10-7-SIGCLD语义" class="headerlink" title="10.7 SIGCLD语义"></a>10.7 SIGCLD语义</h4><p>SIGCLD现在貌似已经没了，了解一下就行</p>
<p>SIGCLD的早期处理方式:</p>
<ol>
<li>如果进程明确地将该信号的配置设置为SIG_IGN，则调用进程的子进程将不产生僵尸进程。注意，这与默认动作(SIG_DFL)”忽略”不同。子进程终止时，将其状态丢弃。如果调用进程随后调用一个wait函数，那么它将阻塞知道所有子进程都终止，然后wait会返回-1，并将其errno设置为ECHILD。(此信号的默认配置是忽略，但这不会使上述语义起作用，必须将其配置明确指定为SIG_IGN)</li>
<li>如果将SIGCLD的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用SIGCLD处理程序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_cld</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGCLD, sig_cld) == SIGERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pause</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_cld</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGCLD received\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGCLD, sig_cld) == SIGERR) </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = <span class="built_in">wait</span>(&amp;status)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的问题就在于signal会一直重复，因为它的语义是，每次signal的时候，如果有子进程准备wait，就再度执行信号处理函数，这样就会一直调用下去</p>
<p>这小节的意思就是，注意你的SIGCHLD到底是哪种语义，可能不同平台有区别，不过大部分都是SIGCHLD的常规语义</p>
<h4 id="10-8-可靠信号术语和语义"><a href="#10-8-可靠信号术语和语义" class="headerlink" title="10.8 可靠信号术语和语义"></a>10.8 可靠信号术语和语义</h4><p>这里就提到现在的信号机制了，当一个信号产生时，内核通常在进程表中以某种形式设置了一个标志。当信号采取了这种动作时，我们说向进程递送了一个信号，在信号产生和递送之间的时间间隔内(虽然以人的角度来说，很短的一段时间，但它依然存在)，称信号是为决的。</p>
<p>进程可以选用”阻塞信号递送”。如果进程产生了一个阻塞的信号，而且对该信号的动作是捕捉或默认，则为该进程的将此信号保持为未决状态，直到解除阻塞。</p>
<p>如果在当前信号解除阻塞之前，产生了多次信号，只递送一次</p>
<h4 id="10-9-函数kill和raise"><a href="#10-9-函数kill和raise" class="headerlink" title="10.9 函数kill和raise"></a>10.9 函数kill和raise</h4><p>kill函数将信号发送给进程或进程组，raise发送给自身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> signo)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>kill的pid参数如下:</p>
<ol>
<li>pid &gt; 0 ,将该信号发送给进程ID为pid的进程</li>
<li>pid &#x3D;&#x3D; 0 ,将信号发送给与发送进程属于同一进程组的所有进程，而且发送进程具有权限向这些进程发送信号</li>
<li>pid &lt; 0 ,将信号发送给进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程</li>
<li>pid &#x3D;&#x3D; -1 ,将该信号发送给发送进程具有权限向它们发送信号的所有进程</li>
</ol>
<p>前面说过信号0，不被信号占用，POSIX.1将信号0定义为空信号，可以用来测定进程是否存在，将signo的参数设置为0，如果向一个不存在的进程发送信号，kill返回-1，errno设置为ESRCH</p>
<p>注意测试进程是否存在，不是原子操作，可能在返回测试结果的时候，进程结束了，这样测试就没有意义了</p>
<h4 id="10-10-函数alarm和pause"><a href="#10-10-函数alarm和pause" class="headerlink" title="10.10 函数alarm和pause"></a>10.10 函数alarm和pause</h4><p>函数alarm设置一个定时器，定时器超时时，产生SIGALRM信号。默认动作时终止调用该alarm的进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alram</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line">	<span class="comment">//返回值0，或者以前设置闹钟时间的剩余秒数</span></span><br></pre></td></tr></table></figure>

<p>函数pause使调用进程挂起直至捕捉到一个信号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pause</span><span class="params">(<span class="type">void</span>)</span></span>;	<span class="comment">//返回-1，errno设置为EINTR</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* nothing to do, just return to wake up the pause */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGALRM, sig_alrm) == SIGERR)</span><br><span class="line">        <span class="keyword">return</span>(seconds);</span><br><span class="line">    <span class="built_in">alarm</span>(seconds);</span><br><span class="line">    <span class="built_in">pause</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">alarm</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现的3个问题：</p>
<ol>
<li>如果调用sleep之前，调用者已经设置了闹钟，那么sleep1的第一次alarm会将其清除，可用下列方法更正这一点:检查第一次调用alarm的返回值，若其值小于本次调用alarm的参数值，等待已有闹钟超时就行了，如果大于本次调用的值，在sleep1返回之前，重置此闹钟</li>
<li>程序中修改了对SIGALRM信号的配置，需要在sleep1返回之前，改回原有配置</li>
<li>本程序存在竞争问题，如果pause之前，信号超时，产生，然后已经被处理了，那么pause永远也无法再次收到信号，导致程序永久阻塞</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//借助setjmmp和longjmp解决的一种示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env_alrm;    <span class="comment">/* 这个变量存储set时的栈帧状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">longjmp</span>(env_alrm, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGALRM, sig_alrm) == SIGERR)</span><br><span class="line">        <span class="keyword">return</span> (seconds);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果信号触发了，返回值变为1，就算没pause也会返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setjmp</span>(env_alrm) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">alarm</span>(seconds);</span><br><span class="line">        <span class="built_in">pause</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">alram</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细考虑，该方法仍存在问题，如果涉及到两个信号的话，比如第一个信号被触发后去执行它的函数，此时超时了，出发SIGALRM信号，提早结束了第一个信号的处理程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> unslept;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, sig_int) == SIGERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal(SIGINT) error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    unslept = <span class="built_in">sleep2</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep2 returned: %u\n&quot;</span>, unslept);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> k;        <span class="comment">/* 阻止优化编译程序 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个循环保证这个程序运行时间大于sleep2的5s</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nsig_int starting\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">300000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4000</span>; j++) &#123;</span><br><span class="line">            k += i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sig_int finished\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">^c</span><br><span class="line">sig_int starting</span><br><span class="line">sleep2 <span class="keyword">return</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>简单讲一下程序执行过程，捕捉SIG_INT，然后调用sleep2捕捉signal，并阻塞在此，键入ctrl+c产生SIGINT信号，执行sig_int函数，alarm超时，产生SIGALRM信号，处理sig_alrm函数，然后直接返回到sleep2，使SIGINT处理程序中断</p>
<p>alram的另一个作用，对可能阻塞的操作设置时间上限值。例如程序中有一个读低速设备的可能阻塞操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> line[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGALRM, sig_alrm) == SIGERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal(SIGALRM) error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, line, MAXLINE)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, line, n);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* nothing to du, just return to interrupt the read */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个问题:</p>
<ol>
<li>仍然存在竞争条件，但我们知道竞争条件，算是一种概率性问题，一般这种需求的程序，alarm设置的很长，所以竞争导致的问题不会发生</li>
<li>如果系统调用是自动重启动的，则当SIGALRM信号处理程序返回时，read并不被中断。</li>
</ol>
<h4 id="10-11-信号集"><a href="#10-11-信号集" class="headerlink" title="10.11 信号集"></a>10.11 信号集</h4><p>信号集，用来表示多个信号的数据类型，以每一位代表一个信号，感觉linux里这种做法很多，这就是位图吧貌似</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span>* set)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span>* set)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span>* set, <span class="type">int</span> signo)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span>* set, <span class="type">int</span> signo)</span></span>;</span><br><span class="line">	<span class="comment">//4个函数成功返回0，出错返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismemeber</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* set, <span class="type">int</span> signo)</span></span>;</span><br><span class="line">	<span class="comment">//若真，返回1；若假，返回0</span></span><br></pre></td></tr></table></figure>

<p>函数sigemptyset初始化信号集，初始化(清除)由set指向的信号集，sigfillset与之相反，使每一位信号被包括，sigaddset添加一个信号，sigdelset删除一个信号</p>
<p>sigemptyset和sigfillset可以实现为宏:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sigemptyset(ptr) (*(ptr) = 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigfillset(ptr) (*(ptr) = !(sigset_t)0, 0)</span></span><br><span class="line"><span class="comment">//借助逗号表达式，实现返回值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下为另外三个函数的非宏实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &lt;signal.h&gt; usually defines NSIG TO include signal number 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGBAD(signo) ((signo) <span class="string">&lt;= || (signo) &gt;</span>= NSIG)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span>* set, <span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SIGBAD</span>(signo)) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *set |= <span class="number">1</span> &lt;&lt; (signo - <span class="number">1</span>);    <span class="comment">/* turn bit on */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span>* set, <span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SIGBAD</span>(signo)) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *set &amp;= ~(<span class="number">1</span> &lt;&lt; (signo<span class="number">-1</span>));   <span class="comment">/* turn bit off */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* set, <span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SIGBAD</span>(signo)) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((*set &amp; (<span class="number">1</span> &lt;&lt; (signo<span class="number">-1</span>))) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-12-函数sigprocmask"><a href="#10-12-函数sigprocmask" class="headerlink" title="10.12 函数sigprocmask"></a>10.12 函数sigprocmask</h4><p>调用sigprocmask可以检测或更改，或同时进行检测和更改进程的信号屏蔽字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* restrict set, <span class="type">sigset_t</span>* restrict oset)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>set是传入想要修改的信号屏蔽字，oset是返回之前的信号屏蔽字，how可选的参数如下:</p>
<ol>
<li>SIG_BLOCK 当前信号屏蔽字和set指定信号集的并集，简单来说，就是添加set中的信号</li>
<li>SIG_UNBLOCK 当前信号屏蔽字和set指定信号集补集的交集，简单来说，就是删除set中的信号</li>
<li>SIG_SETMASK 直接以set来代替当前信号屏蔽字</li>
</ol>
<p>如果set传入NULL，不论how取何值都不影响信号屏蔽字</p>
<p><strong>“注意”:在调用sigprocmask后如果有任何未决的、不再阻塞的信号，则在sigprocmask返回前，至少将其中之一递交给该进程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印调用进程信号屏蔽字中的信号名示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pr_mask</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> sigset;</span><br><span class="line">    <span class="type">int</span> errno_save;</span><br><span class="line">    </span><br><span class="line">    errno_save = errno;		<span class="comment">/* we can be called by signal handlers */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(<span class="number">0</span>, <span class="literal">NULL</span>, &amp;sigset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_set</span>(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;sigset, SIGINT))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; SIGINT&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;sigset, SIGQUIT))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; SIGQUIT&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;sigset, SIGUSR1))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; SIGUSR1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;sigset, SIGALRM))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; SIGALRM&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* remaining signals can go here */</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    errno = errno_save;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-13-函数sigpending"><a href="#10-13-函数sigpending" class="headerlink" title="10.13 函数sigpending"></a>10.13 函数sigpending</h4><p>返回未决信号集</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span>* set)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_quit</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, pendmask;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGQUIT, sig_quit) == SIGERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t catch SIGQUIT&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Block SIGQUIT and save current signal mask */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newmask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigpending</span>(&amp;pendmask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;sigpending error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;pendmask, SIGQUIT))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nSIGQUIT pending\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Restore signal mask which unblocks SIGQUIT */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT unblocked\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_quit</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;caught SIGQUIT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;can&#x27;t reset SIGQUIT&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">^\                      产生一次信号</span><br><span class="line">SIGQUIT pending         从sleep中返回</span><br><span class="line">caught SIGQUIT          在信号处理函数中</span><br><span class="line">SIGQUIT unblocked       从sigprocmask返回后</span><br><span class="line">^\<span class="built_in">Quit</span>(coredump)        再次产生信号</span><br><span class="line">$./a.out4</span><br><span class="line">^\^\^\^\^\^\^\^\^\^\    产生十次信号</span><br><span class="line">SIGQUIT pending         </span><br><span class="line">caught SIGQUIT          只产生一次信号</span><br><span class="line">SIGQUIT unblocked</span><br><span class="line">^\<span class="built_in">Quit</span>(coredump)        在产生信号</span><br></pre></td></tr></table></figure>

<p>注意sigprocmask返回之后的printf，比信号处理中的后执行，参考上一节的 <em><em><strong>注意</strong></em></em></p>
<h4 id="10-14-函数sigaction"><a href="#10-14-函数sigaction" class="headerlink" title="10.14 函数sigaction"></a>10.14 函数sigaction</h4><p>取代signal，我之前写的时候，signal用不了，而且这个函数能完全取代signal，除了便捷性上，signal用起来比较简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction* restrict act, <span class="keyword">struct</span> sigaction* restrict oact)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回-1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">/* 信号捕捉函数 */</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;			<span class="comment">/* 捕捉期间添加的信号屏蔽字 */</span></span><br><span class="line">    <span class="type">int</span> sa_flags;				<span class="comment">/* 一些可选参数 ,通常为0，默认属性*/</span></span><br><span class="line">    <span class="comment">/* sa_handler 的替代，可以传递一些信息，这两个是一个Union，只能选一个 */</span></span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span>*, <span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常用sa_handler，当sa_flags设置为SA_SIGINFO标志时，使用sa_sigaction，sa_flags的可选参数见P279图</p>
<p>siginfo结构包含了信号产生原因的有关消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">siginfo</span> &#123;</span><br><span class="line">    <span class="type">int</span> 	si_signo;</span><br><span class="line">    <span class="type">int</span> 	si_errno;</span><br><span class="line">    <span class="type">int</span> 	si_code;</span><br><span class="line">    <span class="type">pid_t</span> 	si_pid;</span><br><span class="line">    <span class="type">uid_t</span> 	si_uid;</span><br><span class="line">    <span class="type">void</span>*	si_addr;</span><br><span class="line">    <span class="type">int</span> 	si_status;</span><br><span class="line">    un;ion sigval si_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span>* sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sa_sigaction不多说，用的比较少，用到的时候再会过来细看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用sigaction实现signal的示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Sigfunc* <span class="title">signal</span><span class="params">(<span class="type">int</span> signo, Sigfunc* func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act, oact;</span><br><span class="line">    </span><br><span class="line">    act.sa_handler = func;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (signo == SIGARRM) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SA_INTERRUPT</span></span><br><span class="line">        act.sa_flags |= SA_INTERRUPT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        act.sa_flags |= SA_RESTRAT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(signo, &amp;act, &amp;oact) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (SIG_ERR);</span><br><span class="line">    <span class="keyword">return</span> (oact.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-15-函数sigsetjmp和siglongjmp"><a href="#10-15-函数sigsetjmp和siglongjmp" class="headerlink" title="10.15 函数sigsetjmp和siglongjmp"></a>10.15 函数sigsetjmp和siglongjmp</h4><p>setjmp和longjmp的改进，因为这两个函数对于是否恢复信号屏蔽字，不确定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savemask)</span></span>;</span><br><span class="line">	<span class="comment">//返回值:若直接调用，返回0;若从siglongjmp，返回非0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>唯一区别多了savemask参数，如果saemask非0，则sigsetjmp在env中保存进程当前的信号屏蔽字，如果保存了则恢复</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> 				 <span class="title">sig_usr1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> 				 <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="type">static</span> sigjmp_buf 			 jmpbuf;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> canjmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR1, sig_usr1) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal(SIGUSR1) error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal(SIGALRM) error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;starting main:&quot;</span>);		<span class="comment">/* 10.12 pr_mask 函数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigsetjmp</span>(jmpbuf, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">pr_mask</span>(<span class="string">&quot;ending main: &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    canjmp = <span class="number">1</span>;	<span class="comment">/* now sigsetjmp() is ok */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        <span class="built_in">pause</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_usr1</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> starttime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (canjump == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;		<span class="comment">/* unexpected signal, ignore */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;starting sig_usr1: &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">3</span>);		<span class="comment">/* SIGALRM in 3 seconds */</span></span><br><span class="line">    starttime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;)		<span class="comment">/* busy wait fo 5 seconds */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">time</span>(<span class="literal">NULL</span>) &gt; starttime + <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;finishing sig_usr1: &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    canjump = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">siglongjmp</span>(jmpbuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;int sig_alrm: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">starting main:</span><br><span class="line">[<span class="number">1</span>] <span class="number">531</span></span><br><span class="line">$ kill -USR1 <span class="number">531</span></span><br><span class="line">starting sig_usr1: SIGUSR1</span><br><span class="line">$ in sig_alrm: SIGUSR1 SIGALRM </span><br><span class="line">finishing sig_usr1: SIGUSR1</span><br><span class="line">ending main:</span><br><span class="line">[<span class="number">1</span>] + Done  ./a.out &amp;</span><br></pre></td></tr></table></figure>

<p>如果用普通的setjump和longjump则不会恢复信号屏蔽字</p>
<p><img src="/./../pic/image-20221027195129744.png" alt="image-20221027195129744"></p>
<h4 id="10-16-函数sigsuspend"><a href="#10-16-函数sigsuspend" class="headerlink" title="10.16 函数sigsuspend"></a>10.16 函数sigsuspend</h4><p>之前视频部分分析过这个情况参考(视频部分时序竞态)，sigsuspend作为一个原子操作，先恢复信号屏蔽字，然后执行pause的功能，使进程休眠。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* sigmask)</span></span>;	</span><br><span class="line">	<span class="comment">//返回值:-1，并将errno设置为EINTR</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, waitmask;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;program start: &quot;</span>); <span class="comment">/* 10.12 函数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal(SIGINT) error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//waitmask作为suspend解除屏蔽字的时候的临时信号屏蔽字，sigsuspend结束时，回到调用之前的屏蔽字</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;waitmask); </span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;waitmask, SIGUSR1);</span><br><span class="line">    <span class="comment">//newmask作为当前进程的信号屏蔽字</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newmask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGINT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isgprocmask</span>(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;in critical region: &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以waitmask作为目前临时的信号屏蔽字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigsuspend</span>(&amp;waitmask) != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;sigsuspend error&quot;</span>);</span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;after return from sigsuspend: &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//恢复最初的屏蔽字</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;program exit: &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pr_mask</span>(<span class="string">&quot;\nin sig_int: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">program start:</span><br><span class="line"><span class="type">int</span> critical region: SIGINT</span><br><span class="line">^C </span><br><span class="line">in sig_int: SIGINT SIGUSR1</span><br><span class="line">after <span class="keyword">return</span> from sigsuspend: SIGINT </span><br><span class="line">program exit:</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sigsuspend的另一个应用，等待一个信号处理程序设置一个全局变量。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> quitflag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ninterrupt\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGQUIT)</span><br><span class="line">        quitflag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, zeromask;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGQUIT, sig_int) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;zeromask);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newmask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGQUIT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;newmask, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (quitflag == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;zeromask);</span><br><span class="line">    </span><br><span class="line">    quitflag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">^c</span><br><span class="line">interrupt</span><br><span class="line">^c</span><br><span class="line">interrupt</span><br><span class="line">^c</span><br><span class="line">interrupt</span><br><span class="line">^\$          <span class="comment">//退出符退出</span></span><br></pre></td></tr></table></figure>

<p>有一说一没看出，这里和suspend的原子操作特性有啥关系，甚至感觉不用设置屏蔽字，你就while pause，直接就能处理了，我唯一想到的就是，防止sig_int执行SIGQUIT处理的时候，被抢走调度，去执行SIGINT的，但这样也没有影响啊，执行完它的再回来调用，一样的，顶多效率会低一点，suspend能保证每一次调用SIGQUIT的时候都成功执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以用信号实现父子进程之间的同步，这是信号应用的另一个示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> sigflag;</span><br><span class="line"><span class="type">static</span> <span class="type">sigset_t</span> newmask, oldmask, zeromask;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_usr</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    sigflag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TELL_WAIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR1, sig_usr) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal SIGUSR1 error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR2, sig_usr) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal SIGUSR2 error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;zeromask);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newmask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGUSR1);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;newmask, SIGUSR2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;newmaks, &amp;oldmask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TELL_PARENT</span><span class="params">(<span class="type">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">kill</span>(pid, SIGUSR2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WAIT_PARENT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sigflag == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;zeromask);</span><br><span class="line">    sigflag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TELL_CHILD</span><span class="params">(<span class="type">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">kill</span>(pid, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WAIT_CHILD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sigflag == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;zeromask);</span><br><span class="line">    sigflag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SIGUSR1由父进程发给子进程，SIGUSR2由子进程发给父进程</p>
<p>总之sigsuspend只是解除屏蔽和pause的原子操作，其他慢速系统调用如read如果有类似情况，则无效，不能用suspend解决</p>
<h4 id="10-17-函数abort"><a href="#10-17-函数abort" class="headerlink" title="10.17 函数abort"></a>10.17 函数abort</h4><p>使程序异常终止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//abort的一种实现，有一说一没看懂，为什么要这样，大概看了下，首先防止了调用者在调用abort之前对SIGABRT信号的一些配置，确保一定能调用成功，但为什么要fflush和，调用了两次kill(SIGARBT)，就没太明白，第二次调用是确保一定成功执行吗</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> action;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Caller can&#x27;t ignore SIGABRT, if so reset to default */</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGABRT, <span class="literal">NULL</span>, &amp;action);</span><br><span class="line">    <span class="keyword">if</span> (action.sa_handler == SIG_IGN) &#123;</span><br><span class="line">        action.sa_handler = SIG_DFL;</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGABRT, &amp;action, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (action.sa_handler == SIG_DFL)</span><br><span class="line">        <span class="built_in">fflush</span>(<span class="literal">NULL</span>);		<span class="comment">/* flush all open stdio streams */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Caller can&#x27;t block SIGABRT; make sure it&#x27;t unblocked */</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">sigdelset</span>(&amp;mask, SIGABRT); <span class="comment">/* mask has only SIGABRT turned off */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGABRE); <span class="comment">/* send the signal */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* if we&#x27;re here, process caught SIGABRT and returned */</span></span><br><span class="line">    <span class="built_in">fflush</span>(<span class="literal">NULL</span>);</span><br><span class="line">    action.sa_handler = SIG_DFL;        </span><br><span class="line">    <span class="built_in">sigaction</span>(SIGABRT, &amp;action, <span class="literal">NULL</span>);  <span class="comment">/* reset to default */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_ABRT, &amp;mask, <span class="literal">NULL</span>); <span class="comment">/* just in case ... */</span></span><br><span class="line">    <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGABRT); 			<span class="comment">/* and one more time */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);	<span class="comment">/* this should be excuted ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-18-函数system"><a href="#10-18-函数system" class="headerlink" title="10.18 函数system"></a>10.18 函数system</h4><p>POSIX.1要求system忽略SIGINT和SIGQUIT，阻塞SIGCHLD</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.13的system实现，不完整，因为他没有考虑上述需求，如果拿它运行ed编辑器</span></span><br><span class="line">$ ./a.out</span><br><span class="line">a                           将正文追加至编辑器</span><br><span class="line">Here is one line of text</span><br><span class="line">.                           行首的点停止追加方式</span><br><span class="line"><span class="number">1</span>,$p                        打印缓冲区中的第一行至最后一行，以便观察内容</span><br><span class="line">Here is one line of text</span><br><span class="line">w temp.foo                  将缓冲区写至一文件</span><br><span class="line"><span class="number">25</span>                          编辑器写了<span class="number">25</span>字节</span><br><span class="line">q                           离开编辑器</span><br><span class="line">caught SIGCHLD</span><br><span class="line">    </span><br><span class="line"><span class="comment">//如果键入中断符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_int</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;caught SIGINT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_chld</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;caught SIGCHLD\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal SIGINT error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">signal</span>(SIGCHLD, sig_chld) == SIG_ERR)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;signal SIGCHLD error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;/bin/ed&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;system error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">a                           将正文追加至编辑器</span><br><span class="line">hello, world</span><br><span class="line">.                           行首的点停止追加方式</span><br><span class="line"><span class="number">1</span>,$p                        打印缓冲区中的第一行至最后一行，以便观察内容</span><br><span class="line">hello, world</span><br><span class="line">w temp.foo                  将缓冲区写至一文件</span><br><span class="line"><span class="number">13</span>                          编辑器写了<span class="number">13</span>字节</span><br><span class="line">^c							键入中断符</span><br><span class="line">?							编辑器捕捉到信号，打印问号</span><br><span class="line">caught SIGINT				父进程执行统一操作</span><br><span class="line">q                           离开编辑器</span><br><span class="line">caught SIGCHLD</span><br></pre></td></tr></table></figure>

<p>这里的意思是，如果不做处理的话，键入中断符，会使中断信号传送给前台进程组中所有的进程。在这一例中，SIGINT被送给3个前台进程(shell进程忽略此信号)，但是当system运行另一个程序的时候，不应使父子进程两周都捕捉终端产生的两个信号：中断和退出。因为由system执行的命令可能是交互式命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//system的另一个实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclued <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmdstring)</span> </span>&#123; <span class="comment">/* with appropriate signal handling */</span></span><br><span class="line">    <span class="type">pid_t</span> 			 pid;</span><br><span class="line">    <span class="type">int</span> 			 status;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> ignore, saveintr, savequit;</span><br><span class="line">    <span class="type">sigset_t</span> 		 chldmask, savemask;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;					<span class="comment">/* always a command processor with UNXI */</span></span><br><span class="line">    </span><br><span class="line">    ignore.sa_handler = SIG_IGN;	<span class="comment">/* ignore SIGINT and SIGQUIT */</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;ignore.sa_mask);</span><br><span class="line">    ignore.sa_flags = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGINT, &amp;ignore, &amp;saveintr) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGQUIT, &amp;ignore, &amp;savequit) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;chldmask);			<span class="comment">/* now block SIGCHLD */</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;chldmask, SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;chldmask, &amp;savemask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        status = <span class="number">-1</span>; 				<span class="comment">/* probably out of processes */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* restore previous signal acton &amp; reset signal mask */</span></span><br><span class="line">        <span class="built_in">sigaction</span>(SIGINT, &amp;saveintr, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGQUIT, &amp;savequit, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;savemask, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">                status = <span class="number">-1</span>; 		<span class="comment">/* error other than EINTR from waidpid() */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* restore previous signal acton &amp; reset signal mask */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGINT, &amp;saveintr, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigaction</span>(SIGQUIT, &amp;savequit, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;savemask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前实现的区别:</p>
<ol>
<li>当我们键入中断符或退出符时，不向调用进程发送信号</li>
<li>当ed命令终止时，不想调用进程发送SIGCHLD信号。因为在system函数末尾调用sigprocmask之前，一直被阻塞，知道waitpid获取子进程的终止状态后</li>
</ol>
<p><strong>system的返回值</strong></p>
<p>system的返回值，时shell的终止状态</p>
<h4 id="10-19-函数sleep、nanosleep和clock-nanosleep"><a href="#10-19-函数sleep、nanosleep和clock-nanosleep" class="headerlink" title="10.19 函数sleep、nanosleep和clock_nanosleep"></a>10.19 函数sleep、nanosleep和clock_nanosleep</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line">	<span class="comment">//返回值：0或未休眠完的秒数</span></span><br></pre></td></tr></table></figure>

<p>此函数使得进程被挂起知道满足下面两个条件之一:</p>
<ol>
<li>已经过了seconds所指定的墙上时钟时间</li>
<li>调用进程捕捉到一个信号并从信号处理程序返回</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sleep的可靠实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* nothing to do, just returning wakes up sigsuspend() */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> newact, oldact;</span><br><span class="line">    <span class="type">sigset_t</span>         newmask, oldmask, suspmask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> 	 unslept;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* set our handler, save previous information */</span></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flag = <span class="number">00</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;newmask, &amp;oldmask);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">alrarm</span>(seconds);</span><br><span class="line">    suspmask = oldmask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* make sure SIGALRM ins&#x27;t blocked */</span></span><br><span class="line">    <span class="built_in">sigdelset</span>(&amp;suspmask, SIGALRM);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* wait for any signal to be caught */</span></span><br><span class="line">    <span class="built_in">sigsuspend</span>(&amp;suspmask);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* some signal has been caught, SIGALRM is no blocked */</span></span><br><span class="line">    </span><br><span class="line">    unslept = <span class="built_in">alarm</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* reset previous action */</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* reset signal mask, which unblocks SIGALRM */</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>(unslept);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nanosleep</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec* reqtp, <span class="keyword">struct</span> timespec* remtp)</span></span>;</span><br><span class="line">	<span class="comment">//若休眠到要求的时间返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>与sleep类似，但提供了纳秒级的精度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clock_nanosleep</span><span class="params">(<span class="type">clockid_t</span> clock_id, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> timespec* reqtp, <span class="keyword">struct</span> timespec* remtp)</span></span>;</span><br><span class="line">	<span class="comment">//若休眠到要求的时间返回0，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>总之也类似，用到再看 P300</p>
<h4 id="10-20-函数sigqueue"><a href="#10-20-函数sigqueue" class="headerlink" title="10.20 函数sigqueue"></a>10.20 函数sigqueue</h4><p>使用信号排队必须做以下几件事:</p>
<ol>
<li>使用sigaction函数安装信号处理程序时指定SA_SIGINFO标志，如果没有给出这个标志，信号会延迟，但信号是否进入队列取决于具体实现</li>
<li>在sigaction结构的sa_sigaction成员中提供信号处理程序。实现可能允许用户使用sa_handler字段，但不能获取sigqueue发送出来的额外信息</li>
<li>使用sigqueue函数发送信号</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>遇到再看吧，这里讲的也很简洁，就大概提了一下</p>
<h4 id="10-21-作业控制信号"><a href="#10-21-作业控制信号" class="headerlink" title="10.21 作业控制信号"></a>10.21 作业控制信号</h4><p>POSIX.1认为以下6个信号与作业控制有关</p>
<ol>
<li>SIGCHLD 子进程已停止或终止</li>
<li>SIGCONT 如果进程已停止，则使其继续运行</li>
<li>SIGSTOP 停止信号(不能被捕捉或忽略)</li>
<li>SIGTSTP 交互式停止信号</li>
<li>SIGTTIN 后台进程组成员读控制终端</li>
<li>SIGTTOU 后台进程组成员写控制终端</li>
</ol>
<p>除SIGCHLD之外，大多数应用程序并不处理这些信号，交互式shell通常会处理这些信号的所有工作。</p>
<p>在作业控制信号间有某些交互。当对一个进程产生4种停止信号(SIGTSTP,SIGSTOP,SIGTTIN,SIGTTOU)中的任意一种时，对该进程的任一未决SIGCONT信号就被丢弃，于此类似，当对一个进程产生SIGCONT信号时，同意进程的任一未决停止信号就被丢弃</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例:演示了一个程序处理作业控制时通常所用的代码序列。该程序只时将其标准输入复制到其标准输出，而在信号</span></span><br><span class="line"><span class="comment">//处理程序中以注释形式给出了管理屏幕的程序所执行的典型操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_tstp</span><span class="params">(<span class="type">int</span> signo)</span> </span>&#123; <span class="comment">/* signal handler for SIGTSTP</span></span><br><span class="line"><span class="comment">    sigset_t mask;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    /* ... move cursor to lower left corner, reset tty mode ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-22-信号名和编号"><a href="#10-22-信号名和编号" class="headerlink" title="10.22 信号名和编号"></a>10.22 信号名和编号</h4><p>如何在信号名和编号之间进行映射，有些系统提供数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>* sys_siglist[];</span><br></pre></td></tr></table></figure>

<p>可以使用psignal函数可移植地打印与信号编号对应的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">psignal</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="type">char</span>* msg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果在sigaction中有siginfo结构，可以使用psiginfo，能访问更更多信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">psiginfo</span><span class="params">(<span class="type">const</span> <span class="type">siginfo_t</span>* info, <span class="type">const</span> <span class="type">char</span>* msg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果只需要信号的字符描述部分，也不需要把它写到标准错误中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strsignal</span><span class="params">(<span class="type">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure>

<p>没啥难点，用到再细看</p>
<h4 id="10-23-小结"><a href="#10-23-小结" class="headerlink" title="10.23 小结"></a>10.23 小结</h4><p>详细的把信号的基本内容都讲了，还涉及到一些具体实现，以及早期实现的缺点</p>
<h3 id="第11章-线程"><a href="#第11章-线程" class="headerlink" title="第11章 线程"></a>第11章 线程</h3><h4 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h4><p>简单来说在单进程里执行多个任务，单进程也可以看作只有线程的进程</p>
<h4 id="11-2-线程概念"><a href="#11-2-线程概念" class="headerlink" title="11.2 线程概念"></a>11.2 线程概念</h4><p>线程的好处：</p>
<ol>
<li>简化处理异步事件的代码。就是用起来更简单吧</li>
<li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享。</li>
<li>改善响应时间，提高程序的吞吐量</li>
</ol>
<p>每个线程都包含表示执行环境所必需的信息，其中包括进程中的标识线程的ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量以及线程私有数据</p>
<h4 id="11-3-线程标识"><a href="#11-3-线程标识" class="headerlink" title="11.3 线程标识"></a>11.3 线程标识</h4><p>线程ID用pthread_t数据类型来表示，由于实现可能是一个结构体，所以对于线程ID的比较，要用以下函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> tid1, <span class="type">pthread_t</span> tid2)</span></span>;	</span><br><span class="line">	<span class="comment">//相等返回非0；否则返回0</span></span><br></pre></td></tr></table></figure>

<p>调用pthread_self获得自身线程ID</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-4-线程创建"><a href="#11-4-线程创建" class="headerlink" title="11.4 线程创建"></a>11.4 线程创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* restrict tidp, <span class="type">const</span> <span class="type">pthread_attr_t</span>* restirct attr, <span class="type">void</span>* (*start_rtn)(<span class="type">void</span>*), <span class="type">void</span>* restirct arg)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>tidp保存线程ID，atrr创建线程的一些属性，start_rtn线程函数，arg向线程函数传入的参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> ntid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printids</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> 		pid;</span><br><span class="line">    <span class="type">pthread_t</span> 	tid;</span><br><span class="line">    </span><br><span class="line">    pid = <span class="built_in">getpid</span>();</span><br><span class="line">    tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s pid %lu tid %lu (0x%lx)\n&quot;</span>, s, (<span class="type">unsigned</span> <span class="type">long</span>)pid, (<span class="type">unsigned</span> <span class="type">long</span>)tid, (<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printids</span>(<span class="string">&quot;new thread: &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>((<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">    <span class="built_in">printids</span>(<span class="string">&quot;main thread: &quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">main thread: pid <span class="number">37396</span> tid <span class="number">673290208</span> (<span class="number">0x28201140</span>)</span><br><span class="line"><span class="keyword">new</span> thread: pid <span class="number">37396</span> tid <span class="number">673280320</span> (<span class="number">0x28217140</span></span><br></pre></td></tr></table></figure>



<h4 id="11-5-线程终止"><a href="#11-5-线程终止" class="headerlink" title="11.5 线程终止"></a>11.5 线程终止</h4><p>如果进程中的任意线程调用了exit、_Exit或者 _exit，那么整个进程就会终止。单个线程可以通过3种方式退出:</p>
<ol>
<li>线程可以简单地从启动例程种返回，返回值是线程的退出码</li>
<li>线程可以被同一进程中的其他线程取消</li>
<li>线程调用pthread_exit</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* rval_ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>rval_ptr是一个无类型指针，用来保存返回值，进程中的其他线程可以通过调用pthread_join函数访问到这个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prhread_join</span><span class="params">(<span class="type">pthread_t</span> thred, <span class="type">void</span>** rval_ptr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>pthread_join类似于进程控制中的waitpid，如果对返回值不关心，可以设置rval_ptr为NULL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn1</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>((<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn2</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>			err;</span><br><span class="line">    <span class="type">pthread_t</span>	tid1, tid2;</span><br><span class="line">    <span class="type">void</span>* 		tret;</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err  = <span class="built_in">ptrhead_join</span>(tid1, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t join with thread 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_join</span>(tid2, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t join with thread 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">$ ./a.out</span><br><span class="line">thread <span class="number">1</span> returning</span><br><span class="line">thread <span class="number">2</span> exiting</span><br><span class="line">thread <span class="number">1</span> exit code <span class="number">1</span></span><br><span class="line">thread <span class="number">2</span> exit code <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>线程可以通过调用pthread_cancel函数来请求取消同一进程中的其他线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span>;	</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。称为 <strong>线程清理处理程序</strong> 。处理程序记录在栈中，它们的执行顺序与它们注册时相反</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*rtn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行以下动作时，清理函数rtn是由pthread_cleanup_push函数调度的，掉用时有一个arg参数:</p>
<ol>
<li>调用pthread_exit时</li>
<li>响应取消请求时</li>
<li>用非零execute参数调用pthread_cleanup_pop时</li>
</ol>
<p>如果execute参数设置为0，清理函数将不被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cleaning: %s\n&quot;</span>, (<span class="type">char</span>*)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn1</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 start\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_cleanup_push</span>(cleanup, <span class="string">&quot;thread 1 first handler&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_cleanup_push</span>(cleanup, <span class="string">&quot;thread 1 second handler&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 push complete\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arg)</span><br><span class="line">        <span class="keyword">return</span>((<span class="type">void</span>*)<span class="number">1</span>);		<span class="comment">//返回而终止</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_cleanup_pop</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_cleanup_pop</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn2</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 start\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_cleanup_push</span>(cleanup, <span class="string">&quot;thread 2 first handler&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_cleanup_push</span>(cleanup, <span class="string">&quot;thread 2 second handler&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 push complete\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arg)</span><br><span class="line">        <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">2</span>);	<span class="comment">//调用pthread_exit终止，满足执行处理函数的三个条件之一</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_cleanup_pop</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_cleanup_pop</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> 		err;</span><br><span class="line">    <span class="type">pthread_t</span> 	tid1, tid2;</span><br><span class="line">    <span class="type">void</span>*		tret;</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != -)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthead_join</span>(tid1, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t join with thread 1&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_join</span>(tid2, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t join with thread 2&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程分离，分离后，线程的底层存储资源可以在线程终止时，立即被收回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>



<h4 id="11-6-线程同步"><a href="#11-6-线程同步" class="headerlink" title="11.6 线程同步"></a>11.6 线程同步</h4><p>线程同步的需求出现在这样一个背景，多个线程对一个变量进行读写，因为写的操作需要两个存储器周期，如果在这两个存储器周期之间，另一个线程又进行操作，那么就会出现竞争导致的问题，为了让线程同步，引入了后续的概念，用于实现线程同步</p>
<p><img src="/./../pic/image-20221031135915620.png" alt="image-20221031135915620"></p>
<p><img src="/./../pic/image-20221031135929186.png" alt="image-20221031135929186"></p>
<h5 id="1-互斥量"><a href="#1-互斥量" class="headerlink" title="1.互斥量"></a>1.互斥量</h5><p>互斥量以pthread_mutex_t 数据类型来表示，使用之前需要对他进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* restirct mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* restritct attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>对互斥量加锁，调用pthrea_mutex_lock 。如果已经上锁，调用线程将阻塞直到互斥量被解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>trylock的区别是不会阻塞，如果加锁时，mutex已锁住，trylock失败，返回EBUSY</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例 一个类似shared_ptr机制的例子，引用计数，只有到0的时候才会删除，每次更改计数的时候，对计数上锁，防止竞争</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> 			f_count;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">    <span class="type">int</span> 			f_id;</span><br><span class="line">    <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* <span class="built_in">foo_alloc</span>(<span class="type">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* fp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">        fp-&gt;f_id = id;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo* fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    fp-&gt;f_count++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo* fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    <span class="keyword">if</span> (--fp-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//感觉这里有点问题，如果解锁后另一个线程，请求加锁了，那现在解锁后那边解除阻塞</span></span><br><span class="line">        <span class="comment">//这边后面销毁不就出问题了吗，因为引用计数已经不是0了，感觉锁不能放在foo里面，</span></span><br><span class="line">        <span class="comment">//应该是另一个全局变量，保证在引用计数为0的时候，能删除，其他地方感觉也需要对这个进行一个判断</span></span><br><span class="line">        <span class="comment">//被加锁的foo是否已经被销毁了，如果被销毁则重新初始化?</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2.避免死锁"></a>2.避免死锁</h5><p>两种导致死锁的可能，重复加锁，多个锁的时候，按不同的顺序加锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例11-10的更新</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(id) (((unsigned long)id)%NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* fh[NHASH];</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> 			f_count;</span><br><span class="line">    <span class="type">phtead_mutex_t</span> 	f_lock;</span><br><span class="line">    <span class="type">int</span> 			f_id;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* 	f_next;		<span class="comment">/* protected by hashlock */</span></span><br><span class="line">    <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* <span class="built_in">foo_alloc</span>(<span class="type">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>*	fp;</span><br><span class="line">    <span class="type">int</span> 		idx;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">        fp-&gt;f_id = id;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = <span class="built_in">HASH</span>(id);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;hashlock);</span><br><span class="line">        fp-&gt;f_next = fh[idx];</span><br><span class="line">        fh[idx] = fp;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">        <span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo* fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    fp-&gt;f_count++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* <span class="built_in">foo_find</span>(<span class="type">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* fp;      </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;hashlock);</span><br><span class="line">    <span class="keyword">for</span> (fp = fh[<span class="built_in">HASH</span>(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;f_id == id) &#123;</span><br><span class="line">            <span class="built_in">foo_hold</span>(fp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">    <span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo* fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* 	tfp;</span><br><span class="line">    <span class="type">int</span> 			idx;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;f_count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;hashlock);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新检查，因为之前被阻塞的时候，可能发生了变动</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;f_count != <span class="number">1</span>) &#123;</span><br><span class="line">            fp-&gt;f_count--;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        idx = <span class="built_in">HASH</span>(fp-&gt;f_id);</span><br><span class="line">        tfp = fh[idx];</span><br><span class="line">        <span class="keyword">if</span> (tfp == fp) &#123;</span><br><span class="line">            fh[idx] = fp-&gt;f_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">                tfp = tfp-&gt;f_next;</span><br><span class="line">            tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fp-&gt;f_count--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出两把锁的时候，设计麻烦复杂了很多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(id) (((unsigned long)id)%NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* fh[NHASH];</span><br><span class="line"><span class="type">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> 			f_count;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">    <span class="type">int</span> 			f_id;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* 	f_next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* <span class="built_in">foo_alloc</span>(<span class="type">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* fp;</span><br><span class="line">    <span class="type">int</span> 		idx;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">        fp-&gt;f_id = id;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = <span class="built_in">HASH</span>(id);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;hashlock);</span><br><span class="line">        fp-&gt;f_next = fh[idx];</span><br><span class="line">        fh[idx] = fp;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">        <span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo* fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;hashlock);</span><br><span class="line">    fp-&gt;f_count++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>* <span class="built_in">foo_find</span>(<span class="type">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* fp;      </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;hashlock);</span><br><span class="line">    <span class="keyword">for</span> (fp = fh[<span class="built_in">HASH</span>(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;f_id == id) &#123;</span><br><span class="line">            <span class="built_in">foo_hold</span>(fp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">    <span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo* fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">foo</span>* 	tfp;</span><br><span class="line">    <span class="type">int</span> 			idx;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;hashlockk);</span><br><span class="line">    <span class="keyword">if</span> (--fp-&gt;f_count == <span class="number">0</span>) &#123;</span><br><span class="line">        idx = <span class="built_in">HASH</span>(fp-&gt;f_id);</span><br><span class="line">        tfp = fh[idx];</span><br><span class="line">        <span class="keyword">if</span> (tfp == fp) &#123;</span><br><span class="line">            fh[idx] = fp-&gt;f_next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">                tfp = tfp-&gt;f_next;</span><br><span class="line">            tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fp-&gt;f_count--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;hashlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果锁少了，粒度太粗，就会出现很多线程阻塞等待相同的锁，这可能并不会改善并发现。如果锁多了，粒度细，过多锁的开销会使系统性能受影响，其代码更复杂。需要在代码复杂性和性能之间找到平衡</p>
<h5 id="3-函数pthread-mutex-timedlock"><a href="#3-函数pthread-mutex-timedlock" class="headerlink" title="3.函数pthread_mutex_timedlock"></a>3.函数pthread_mutex_timedlock</h5><p>与pthread_mutex_lock基本类似，但设置了阻塞时间，再超过时间值后，不再进行加锁，而是返回错误码ETIMEDOUT</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec* restrict tsptr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误码</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>				err;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> tout;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* temp;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mutex is locked\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">    tmp = <span class="built_in">localtime</span>(&amp;tout.tv_sec);</span><br><span class="line">    <span class="built_in">strftime</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current time is %s\n&quot;</span>, buf);</span><br><span class="line">    tout.tv_sec += <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次加锁(重复加锁)</span></span><br><span class="line">    err = <span class="built_in">pthread_mutex_timedlock</span>(&amp;lock, &amp;tout);</span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">    tmp = <span class="built_in">localtime</span>(&amp;tout.tv_sec);</span><br><span class="line">    <span class="built_in">strftime</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the time is now %s\n&quot;</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mutex locked again!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t lock mvtex again:%s\n&quot;</span>, <span class="built_in">strerror</span>(err));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要在实际中这样写，可能导致死锁</p>
<h5 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h5><p>三种状态，读锁，写锁，未上锁，写锁会阻塞其他操作，读锁的时候，其他的读锁操作不会被阻塞，但如果有一个写锁操作随后，写锁操作之后的其他操作会被阻塞，防止读锁长期占用读写锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span>* restrict rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* restrict attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phtread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>同样用PTHREAD_RWLOCK_INITIALIZER常量可以执行静态初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>部分实习可能对读锁共享模式下的读写锁次数进行限制，注意这方面的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样的try版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例，读写锁的使用，作业请求队列由单个读写锁保护 图11-1的一种可能实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">job</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job</span>*	j_next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job</span>* j_prev;</span><br><span class="line">    <span class="type">pthread_t</span> 	j_id;	<span class="comment">/* tell which thread handles this job */</span></span><br><span class="line">    <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">queue</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job</span>* 	 q_head;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job</span>* 	 q_tail;</span><br><span class="line">    <span class="type">pthread_rwlock_t</span> q_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize a queue */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queue_init</span><span class="params">(<span class="keyword">struct</span> queue* qp)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    qp-&gt;q_head = <span class="literal">NULL</span>;</span><br><span class="line">    qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">    err = <span class="built_in">pthread_rwlock_init</span>(&amp;qp-&gt;q_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>(err);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* continue initialization */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert a job at the head of queue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">job_insert</span><span class="params">(<span class="keyword">struct</span> queue* qp, <span class="keyword">struct</span> job* jp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_wrlock</span>(&amp;qp-&gt;q_lock);</span><br><span class="line">    jp-&gt;j_next = qp-&gt;q_head;</span><br><span class="line">    jp-&gt;j_prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (qp-&gt;q_head != <span class="literal">NULL</span>)</span><br><span class="line">        qp-&gt;q_head-&gt;j_prev = jp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        qp-&gt;q_tail = jp;</span><br><span class="line">    qp-&gt;q_head = jp;</span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* append a job on the tail of the queue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">job_append</span><span class="params">(<span class="keyword">struct</span> queue* qp, <span class="keyword">struct</span> job* jp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_wrlock</span>(&amp;qp-&gt;q_lock);</span><br><span class="line">    jp-&gt;j_next = <span class="literal">NULL</span>;</span><br><span class="line">    jp-&gt;j_prev = qp-&gt;q_tail;</span><br><span class="line">    <span class="keyword">if</span> (qp-&gt;q_tail != <span class="literal">NULL</span>)</span><br><span class="line">        qp-&gt;q_tail-&gt;j_next = jp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        qp-&gt;q_head = jp;</span><br><span class="line">    qp-&gt;q_tail = jp;</span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* remove the given job from a queue */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">job_remove</span><span class="params">(<span class="keyword">struct</span> queue* qp, <span class="keyword">struct</span> job* jp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_wrlock</span>(&amp;qp-&gt;q_lock);</span><br><span class="line">    <span class="keyword">if</span> (jp == qp-&gt;q_head) &#123;</span><br><span class="line">        qp-&gt;q_head = jp-&gt;j_next;</span><br><span class="line">        <span class="keyword">if</span> (qp-&gt;q_tail == jp)</span><br><span class="line">            qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jp == qp-&gt;q_tail) &#123;</span><br><span class="line">        qp-&gt;q_tail = jp-&gt;j_prev;</span><br><span class="line">        jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">        jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find a job for the given thread ID */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">job</span>* <span class="built_in">job_find</span>(<span class="keyword">struct</span> queue* qp, <span class="type">pthread_t</span> id) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job</span>* jp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_rwlock_rdlock</span>(&amp;qp-&gt;lock, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (jp = qp-&gt;q_head; jp != <span class="literal">NULL</span>; jp = jp-&gt;j_next) </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(jp-&gt;j_id, id))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;qp-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> (jp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-带有超时的读写锁"><a href="#5-带有超时的读写锁" class="headerlink" title="5.带有超时的读写锁"></a>5.带有超时的读写锁</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* restrict rwlock, <span class="type">const</span> <span class="keyword">struct</span> timespec* restrict tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span>* restrict rwlock, <span class="type">const</span> <span class="keyword">struct</span> timespec* restrict tsptr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>



<h5 id="6-条件变量"><a href="#6-条件变量" class="headerlink" title="6.条件变量"></a>6.条件变量</h5><p>条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程已无竞争的方式等待特定的条件发生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* restrict attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>同样也可以用常量PTHREAD_COND_INITIALIZER执行静态初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* restrict cond, <span class="type">pthread_mutex_t</span>* restrict mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span>* restrict cond, <span class="type">pthread_mutex_t</span>* restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec* restrict tsptr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，出错返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>注意在改变条件状态以后，再给线程发信号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msg</span>* m_next;</span><br><span class="line">    <span class="comment">/* more stuff here */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msg</span>* workq;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthreda_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msg</span>* mp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;qlock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;qready, &amp;qlock);</span><br><span class="line">        </span><br><span class="line">        mp = workq;</span><br><span class="line">        workq = mp-&gt;m_next;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;q_lock);</span><br><span class="line">        <span class="comment">/* now process the message mp */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue_msg</span><span class="params">(<span class="keyword">struct</span> msg* mp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;qlock);</span><br><span class="line">    mp-&gt;m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;qlock);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件是工作队列的状态，互斥量保护条件。在while循环中判断条件，</p>
<h5 id="7-自旋锁"><a href="#7-自旋锁" class="headerlink" title="7. 自旋锁"></a>7. 自旋锁</h5><p>与上述锁通过休眠实现阻塞的情况不同，自旋锁在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可以用于以下情况: 锁被持有的时间短，而且线程并不希望在重新调度上花费太多成本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#included <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span>* lock, <span class="type">int</span> pshaed)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span>* lock)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>pshared参数表示进程的共享属性，如果它设为PTHREAD_PROCESS_SHARED，则自旋锁能被可访问锁底层内存的线程所获取，即便那些线程属于不同进程，否则参数设为PTHREAD_PROCESS_PRIVATE，自旋锁只能被初始化该锁的进程内部的线程所访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span>* lock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span>* lock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span>* lock)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>重复加锁和对未加锁的自旋锁解锁都是未定义行为</p>
<h5 id="8-屏障"><a href="#8-屏障" class="headerlink" title="8.屏障"></a>8.屏障</h5><p>屏障是用户协调多个线程并行工作的同步机制。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有线程完成处理工作，而线程不需要退出。所有线程到达屏障后，可以接着工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="type">pthread_barrier_t</span>* restrict barrier, <span class="type">const</span> <span class="type">pthread_barrierattr_t</span>* restrict attr, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phtread_barrier_destroy</span><span class="params">(<span class="type">pthread_barrier_t</span>* barrier)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>count参数指定，在允许所有线程继续允许之前，必须到达屏障的线程数目。可以使用pthread_barrier_wait函数来表明，线程已完成工作，准备等待所有其他线程赶上来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="type">pthread_barrier_t</span>* barrier)</span></span>;</span><br><span class="line">	<span class="comment">////成功返回0或者PTHREAD_BARRIER_SERIAL_THREAD，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>对于任意一个线程，pthread_barrier_wait函数返回了PTHREAD_BARRIER_SERIAL_THREAD。剩下线程看到的返回值是0，这使得一个线程可以作为主线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHR 8				<span class="comment">/* number of threads */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMNUM 8000000L		<span class="comment">/* number of numbers to sort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THUM (NUMNUM/NTHR)	<span class="comment">/* number of sort per thread */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> nums[NUMNUM];</span><br><span class="line"><span class="type">long</span> snums[NUMNUM];</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_barrier_t</span> b;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SOLARIS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapsort qsort</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">heapsort</span><span class="params">(<span class="type">void</span>*, <span class="type">size_t</span>, <span class="type">size_t</span>, <span class="type">int</span> (*)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* compare two long integers (helper function for heapsort) */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">complong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* arg1, <span class="type">const</span> <span class="type">void</span>* arg2)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> l1 = *(<span class="type">long</span>*)arg1;</span><br><span class="line">    <span class="type">long</span> l2 = *(<span class="type">long</span>*)arg2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l1 == l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; l2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Worker thread to sort a portion of the set of numbers */</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span>	idx = (<span class="type">long</span>)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">heapsort</span>(&amp;nums[idx], THUM, <span class="built_in">sizeof</span>(<span class="type">long</span>), complong);</span><br><span class="line">    <span class="built_in">pthread_barrier_wait</span>(&amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Go off and perform more work ... */</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Merge the results of the individual sorted ranges */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span>	idx[NTHR];</span><br><span class="line">    <span class="type">long</span>	i, minidx, sidx, num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++)</span><br><span class="line">        idx[i] = i*TNUM;</span><br><span class="line">    <span class="keyword">for</span> (sidx = <span class="number">0</span>; sidx &lt; NUMNUM; sidx++) &#123;</span><br><span class="line">        num = LONG_MAX;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((idx[i] &lt; (i+<span class="number">1</span>) * TNUM) &amp;&amp; (nums[idx[i]] &lt; num)) &#123;</span><br><span class="line">                num = nums[idx[i]];</span><br><span class="line">                minidx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        snums[sidx] = nums[idx[minidx]];</span><br><span class="line">        idx[minidx]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>	i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> 	start, end;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> 		startusec, endusec;</span><br><span class="line">    <span class="type">double</span> 			elapsed;</span><br><span class="line">    <span class="type">int</span> 			err;</span><br><span class="line">    <span class="type">pthread_t</span> 		tid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* create the initial set of number to sort */</span></span><br><span class="line">    <span class="built_in">srandom</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; NUMNUM; i++)</span><br><span class="line">        num[i] = <span class="built_in">random</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* create 8 thread to sort the numbers */</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_barrier_init</span>(&amp;b, <span class="literal">NULL</span>, NTHR+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; NTHR; i++) &#123;</span><br><span class="line">        err = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thr_fn, (<span class="type">void</span>*)(i*THUM));</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_barrier_wait</span>(&amp;b);</span><br><span class="line">    <span class="built_in">merge</span>();</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* print the sorted list */</span></span><br><span class="line">    </span><br><span class="line">    startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">    endusec= end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">    elapsed = (<span class="type">double</span>)(endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sort took %.4f seconds\n&quot;</span>, elapsed);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMNUM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, snums[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个多线程排序的例子，可以看出barrier是怎么使用的，等待所有线程都完成各自的排序工作后，再执行merge将结果合并</p>
<h4 id="11-7-小结"><a href="#11-7-小结" class="headerlink" title="11.7 小结"></a>11.7 小结</h4><p>前面的大部分之前视频部分已经看过了，自旋锁没太看懂使用场合，屏障看起来是个不错的同步机制，更符合我对多线程的理解了，之前视频部分没讲这个函数，导致觉得多线程同步起来只能通过锁的话，写起来感觉太复杂了</p>
<h3 id="第12章-线程控制"><a href="#第12章-线程控制" class="headerlink" title="第12章 线程控制"></a>第12章 线程控制</h3><h4 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h4><p>本章讲继续前一章，一些更详细的内容。</p>
<h4 id="12-2-线程限制"><a href="#12-2-线程限制" class="headerlink" title="12.2 线程限制"></a>12.2 线程限制</h4><p>线程的一些限制，可以通过sysconf函数(2.5.4节)进行查询</p>
<table>
<thead>
<tr>
<th>限制名称</th>
<th>描述</th>
<th>name参数</th>
</tr>
</thead>
<tbody><tr>
<td>PTHREAD_DESTRUCTOR_ITERATIONS</td>
<td>线程退出时操作系统实现试图销毁线程特定数据的最大次数(12.6)</td>
<td>_SC_THREAD_DESTRUCTOR+ITERATIONS</td>
</tr>
<tr>
<td>PTHREAD_KEYS_MAX</td>
<td>线程可以创建的键的最大数目(12.6)</td>
<td>_SC_THREAD_KEYS_MAX</td>
</tr>
<tr>
<td>PTHREAD_STACK_MIN</td>
<td>一个线程的栈可用的最小字节数(12.3)</td>
<td>_SC_THREAD_STACK_MIN</td>
</tr>
<tr>
<td>PTHREAD_THREADS_MAX</td>
<td>进程可以创建的最大线程数(12.3)</td>
<td>_SC_THREAD_THREADS_MAX</td>
</tr>
</tbody></table>
<h4 id="12-3-线程属性"><a href="#12-3-线程属性" class="headerlink" title="12.3 线程属性"></a>12.3 线程属性</h4><p>视频部分的笔记也可以参考看看</p>
<p>pthrad接口为我们提供了每个对象关联不同属性来细调线程和同步对象的行为。通常，管理属性的函数遵循相同的模式</p>
<ol>
<li>每个对象与它自己类型的属性对象进行关联(线程与线程属性，互斥量与互斥量属性)。一个属性对象可以代表多个属性(意思是属性对象是一个结构，它包含多个属性的意思吗？)。属性对象对应用程序是不透明的，通过函数来管理这些属性对象</li>
<li>有一个初始化函数，把属性设置为默认值</li>
<li>还有一个销毁属性对象的函数。负责释放资源</li>
<li>每个属性都有一个属性对象中获取属性值的函数。</li>
<li>每个属性都一个设置属性值的函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span>* attr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>分离线程，如果对现有的某个线程的终止状态不关心，可以使用pthread_detach函数让操作系统再线程退出时收回它所占有的资源。可以修改pthread_attr_t中的detachastate线程属性，让线程一开始就处于分离状态。可以使用pthread_attr_setdetachstate函数把线程属性detachstate设置成以下两个合法值之一: PTHREAD_CREATE_DETACHED，以分离状态启动线程，或者PTHREAD_CREATE_JOINABLE，正常启动</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* restrict attr, <span class="type">int</span>* detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">makethread</span><span class="params">(<span class="type">void</span>*(*fn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> 			err;</span><br><span class="line">    <span class="type">pthread_t</span> 		tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span>  attr;</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        err = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, fn, arg);</span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程栈属性，不一定所有的操作系统都支持线程栈属性。可以在编译阶段使_POSIX_THREAD_ATTR_STACKADDR和 _POSIX_THREAD_ATTR_STACKSIZE符号来检查系统是否支持每一个线程栈属性。也可以通过sysconf函数检查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* restrict attr, <span class="type">void</span>** restrict stackaddr, <span class="type">size_t</span>* restrict stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* stackaddr, <span class="type">size_t</span> stacksize)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>用途的话，简单来说，一个进程中的虚拟空间中，只有一个栈，被线程共享，如果不够了的话，可以通过设置线程栈属性改变它的位置，通过malloc和mmap创建到堆上去。视频笔记有使用例子，一个在堆上不断创建线程的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span>* restrict attr, <span class="type">size_t</span>* restrict stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span> stacksize)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>如果希望改变默认栈大小，又不想自己处理线程栈的分配问题，可以用这个属性。设置stacksize属性时，选择的大小不能小于PTHREAD_STACK_MIN</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="type">const</span> <span class="type">phtread_attr_t</span>* restrict attr, <span class="type">size_t</span>* restrict guardsize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span> guardsize)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>线程属性guardsize控制着线程栈末尾之后用来避免栈溢出的扩展内存大小。默认值由实现决定，常用值是系统页大小。如果修改了线程属性的stackaddr，系统就认为我们自己管理栈，进而使栈警戒缓冲区机制无效，这等同于把guardsize设置为0。</p>
<p>如果guardsize被修改了，操作系统可能会把它取到页大小的整数倍</p>
<h4 id="12-4-同步属性"><a href="#12-4-同步属性" class="headerlink" title="12.4 同步属性"></a>12.4 同步属性</h4><h5 id="1-互斥量属性"><a href="#1-互斥量属性" class="headerlink" title="1.互斥量属性"></a>1.互斥量属性</h5><p>初始化和反初始化函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span>* attr)</span></span>;</span><br><span class="line">	<span class="comment">//若成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>值得注意的3个属性: <strong>进程共享属性，健壮属性以及类型属性</strong> ， 进程共享属性为可选的，注意系统中是否定义了_POSIX_THREAD_PROCESS_SHARED符号来判断平台是否支持这个属性</p>
<p>在进程中，多个<strong>线程</strong>可以访问同一个同步对象。这是默认的行为，在这种情况下，进程共享互斥量属性设置为PTHREAD_PROCESS_PRIVATE</p>
<p>存在这样的机制：允许相互独立的多个 <strong>进程</strong>把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果进程设置互斥量属性为PTHREAD_PROCESS_SHARED，就可以满足这样的需求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* restrict attr, <span class="type">int</span>* restrict pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">pthread_mutexattr_t</span>* attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>健壮属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* restrict attr, <span class="type">int</span>* restrict robust)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="type">pthread_mutexattr_t</span>* attr, <span class="type">int</span> roubust)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>有一说一没看懂是个什么意思，反正两种可能，默认值是PTHREAD_MUTEX_STALLED，意味着互斥量的进程终止时不需要采取特别的动作。看不懂，感觉描述有问题，而且没例子，以后遇到了再回过头了理解</p>
<p>类型互斥量属性</p>
<table>
<thead>
<tr>
<th>PTHREAD_MUTEX_NORMAL</th>
<th>一种标准互斥量类型，不做任何特殊的错误检查或死锁检测</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PTHREAD_MUTEX_ERRORCHECK</strong></td>
<td><strong>此互斥量类型提供错误检测</strong></td>
</tr>
<tr>
<td><strong>PTHREAD_MUTEX_RECURSIVE</strong></td>
<td><strong>此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以，如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量仍然处于加锁状态，对它再次解锁以前不能释放该锁</strong></td>
</tr>
<tr>
<td><strong>PTHREAD_MUTEX_DEFAULT</strong></td>
<td><strong>此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候可以把这种类型自由地映射到其他互斥量类型中的一种</strong>（自定义锁？）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>互斥量类型</th>
<th>没有解锁时重新加锁</th>
<th>不占用时解锁</th>
<th>在已解锁时解锁</th>
</tr>
</thead>
<tbody><tr>
<td>PTHREAD_MUTEX_NORMAL</td>
<td>死锁</td>
<td>未定义</td>
<td>未定义</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_ERRORCHECK</td>
<td>返回错误</td>
<td>返回错误</td>
<td>返回错误</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_RECURSIVE</td>
<td>允许</td>
<td>返回错误</td>
<td>返回错误</td>
</tr>
<tr>
<td>PTHREAD_MUTEX_DEFAULT</td>
<td>未定义</td>
<td>未定义</td>
<td>未定义</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* restrict attr, <span class="type">int</span>* restrict type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span>* attr, <span class="type">int</span> type)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>使用递归锁的情况可能是，在不改变单线程函数接口的情况下，解决并发问题，参考下面两图第一张图，使用递归锁，第二张图不使用</p>
<p><img src="/./../pic/image-20221101203410745.png" alt="image-20221101203410745"></p>
<p><img src="/./../pic/image-20221101203424061.png" alt="image-20221101203424061"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归互斥量的一个示例情况  也没看懂</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">makethread</span><span class="params">(<span class="type">void</span>*(*)(<span class="type">void</span>*), <span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">to_info</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*to_fn)(<span class="type">void</span>*);			<span class="comment">/* function */</span></span><br><span class="line">    <span class="type">void</span>* 			to_arg  		<span class="comment">/* argument */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> to_wait			<span class="comment">/* time to wait */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTONSEC 1000000000		<span class="comment">/* seconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CLOCK_REALTIME) || defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clock_nanosleep(ID, FL, REQ, REM)	nanosleep((REQ), (REM))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifnedf CLOCK_REALTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_REALTIME 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USECTONSEC 1000 			<span class="comment">/* microseconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clock_gettime</span><span class="params">(<span class="type">int</span> id, <span class="keyword">struct</span> timespec* tsp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    tsp-&gt;tv_sec = tv.tv_sec;</span><br><span class="line">    tsp-&gt;tv_nsec = tv.tv_usec * USECTONSEC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">timeout_helper</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">to_info</span>* tip;</span><br><span class="line">    </span><br><span class="line">    tip = (<span class="keyword">struct</span> to_info*)arg;</span><br><span class="line">    <span class="built_in">clock_nanosleep</span>(CLOCK_REALTIME, <span class="number">0</span>, &amp;tip-&gt;to_wait, <span class="literal">NULL</span>);</span><br><span class="line">    (*tip-&gt;to_fn)(tip-&gt;to_arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec* when, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>	now;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">to_info</span>* tip;</span><br><span class="line">    <span class="type">int</span>				err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;now);</span><br><span class="line">    <span class="keyword">if</span> ((when-&gt;tv_sec &gt; now.tv_sec) ||</span><br><span class="line">        (when-&gt;tv_sec == now.tv_sec &amp;&amp; when-&gt;tv_nsec &gt; now.tv_nsec)) &#123;</span><br><span class="line">        tip = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> to_info));</span><br><span class="line">        <span class="keyword">if</span> (tip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tip-&gt;to_fn = func;</span><br><span class="line">            tip-&gt;to_arg = arg;</span><br><span class="line">            tip-&gt;to_wait.tv_sec = when-&gt;tv_sec - now.tv_sec;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (when-&gt;tv_nsec &gt;= now.tv_nsec) &#123;</span><br><span class="line">                tip-&gt;to_wait.tv_nsec = when-&gt;tv_nsec - now.tv_nsec;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tip-&gt;to_wait.tv_sec--;</span><br><span class="line">                tip-&gt;to_wait.tv_nsec = SECTONSEC - now.tv_nsec + when-&gt;tv_nsec;</span><br><span class="line">            &#125;</span><br><span class="line">            err = <span class="built_in">makethread</span>(timeout_healper, (<span class="type">void</span>*)arg);</span><br><span class="line">            <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">free</span>(tip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    (*func)(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">retry</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="comment">/* perform retry steps ... */</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> 			err, condition, arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> when;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">pthread_mutexattr_init</span>(&amp;attr)) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;pthread mutexarttr init error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">pthread_mutexattr_settype</span>(&amp;atrr, PTHREAD_MUTEX_RECURSIVE)) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t set recursive type&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">pthread_mutex_init</span>(&amp;mutex, &amp;attr)) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create recursive mutex&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* continue processing ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* check the condition under the protection of a lack to </span></span><br><span class="line"><span class="comment">     * make the check and the call to timeout atomic </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="comment">/* Calculate the absolute time when we want to retry */</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;when);</span><br><span class="line">        when.tv_sec += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">timeout</span>(&amp;when, retry, (<span class="type">void</span>*)((<span class="type">unsigned</span> <span class="type">long</span>)arg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-读写锁属性"><a href="#2-读写锁属性" class="headerlink" title="2.读写锁属性"></a>2.读写锁属性</h5><p>只支持进程共享属性，与互斥量的进程共享属性是相同的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="type">pthread_rwlockattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="type">pthread_rwlockattr_t</span>* attr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span>* restrict attr, <span class="type">int</span>* restrict pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="type">pthread_rwlockattr_t</span>* attr, <span class="type">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="3-条件变量属性"><a href="#3-条件变量属性" class="headerlink" title="3.条件变量属性"></a>3.条件变量属性</h5><p>一般定义了两个属性:进程共享属性和时钟属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="type">pthread_condattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="type">pthread_condattr_t</span>* attr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>与其他同步属性一样，条件变量支持进程控制属性。它控制着条件变量是可以被单进程的多个线程使用，还是可以被多进程的线程使用，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span>* restrict attr, <span class="type">int</span>* restrict pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="type">pthread_condattr_t</span>* attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>时钟属性控制计算pthread_cond_timedowait函数的超时参数时采用的是哪个时钟</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="type">const</span> <span class="type">pthread_condattr_t</span>* restrict attr, <span class="type">clockid_t</span>* restrict clock_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="type">pthread_condattr_t</span>* attr, <span class="type">clockid_t</span> clock_id)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>



<h5 id="4-屏障属性"><a href="#4-屏障属性" class="headerlink" title="4.屏障属性"></a>4.屏障属性</h5><p>同样的初始化和反初始化函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="type">pthread_barrierattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="type">pthread_barrierattr_t</span>* attr)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>屏障也只有进程共享属性，它控制着屏障是可以被多进程的线程使用，还是只能被初始化屏障内的进程的多线程使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_barrierattr_t</span>* restrict attr, <span class="type">int</span>* restrict pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="type">pthread_barrierattr_t</span>* attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>可选值还是那两个 PTHREAD_PROCESS_SHARED 和 PTHREAD_PROCESS_PRIVATE</p>
<h4 id="12-5-重入"><a href="#12-5-重入" class="headerlink" title="12.5 重入"></a>12.5 重入</h4><p>在这两种情况下，多个控制线程在相同的时间有可能调用的函数。线程安全和可重入。 这里提到了以下标准下线程安全也就是可重入的函数，以及对于不可重入的一些函数的可重入版本。P355</p>
<p>对于线程的可重入概念和信号处理程序的可重入不一样。如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是异步信号安全的。</p>
<p>这里还提到了一些以线程安全管理FILE对象的方法，可使用flockfile和ftrylockfile获取给定的FILE对象关联的锁，这里看不太懂，用到的时候再看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftrylockfile</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，若不能获取锁返回非0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flockfile</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funlockfile</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不加锁版本的基于字符的标准I/O例程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getchar_unlocked</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc_unlocked</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回下一个字符，遇到文件尾或出错返回EOF</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putchar_unlocked</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">puc_unlocked</span><span class="params">(<span class="type">int</span> c, FILE* fp)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回c，出错返回EOF</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getenv(7.9节)的一个可能实现   非可重入版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRING32 4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> envbuf[MAXSTRING32];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, len;</span><br><span class="line">    </span><br><span class="line">    len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp; (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(envbuf, &amp;environ[i][len+<span class="number">1</span>], MAXSTRING32<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> envbuf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入版本 getenv_r。它使用pthread_once函数来确保不管多少线程同城竞争调用getenv_r，每个进程只调用treahd_init函数一次</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"><span class="type">pthread_mutex_t</span> env_mutex;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">thread_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutexattr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_mutexattr_settype</span>(&amp;attr, PTHREAD_MUTEX_RECURSIVE);	<span class="comment">//递归锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;env_mutex, &amp;attr);</span><br><span class="line">    <span class="built_in">pthread_mutexattr_destroy</span>(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getenv_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">char</span>* buf, <span class="type">int</span> buflen)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, len, olen;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;init_done, thread_init);</span><br><span class="line">    len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;env_mutex);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp; (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">            olen = <span class="built_in">strlen</span>(&amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (olen &gt;= buflen) &#123;</span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;env_mutex);</span><br><span class="line">                <span class="keyword">return</span> ENOSPC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, &amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;env_mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;env_mutex);</span><br><span class="line">    <span class="keyword">return</span> ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-6-线程特定数据"><a href="#12-6-线程特定数据" class="headerlink" title="12.6 线程特定数据"></a>12.6 线程特定数据</h4><p>存储和查询某个特定线程相关数据的一种机制。</p>
<p>在分配线程特定数据之前，需要创建与该数据关联的键，这个键将用于获取对线程特定数据的访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span>* keyp, <span class="type">void</span>(*destructor)(<span class="type">void</span>*))</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>对所有的线程可以通过调用pthread_key_delete取消键与线程特定数据之间的关联，但调用它并不会激活与键关联的析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>需要确保分配的键并不会由于初始化阶段的竞争而发生变动，入下面函数可能会导致两个线程都掉用key_create</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destructor</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">int</span> init_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadfunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line">        init_done = <span class="number">1</span>;</span><br><span class="line">        err = <span class="built_in">pthread_key_create</span>(&amp;key, destructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些线程可能看到一个键值，其他线程可能看到另一个不同的键值，这取决于系统的调度，解决这种的竞争的方法通过pthread_once 感觉mutex上锁也行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_once_t</span> initflag = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span>* initflag, <span class="type">void</span>(*initfn)(<span class="type">void</span>))</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>initflag必须是一个非本地变量(全局变量或静态变量)，而且必须初始化为PTHREAD_ONCE_INIT</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destructor</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    err = <span class="built_in">pthread_key_create</span>(&amp;key, destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">threadfunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;init_done, thread_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键创建后，就可以通过调用setspecific函数把键和线程特定数据关联起来，通过getspecific获取特定数据的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span>;</span><br><span class="line">	<span class="comment">//返回线程特定数据值，如果没有值与key关联，返回NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span>* value)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同样是getenv的一个实现，但这次不改变getenv的接口，前一节通过改变接口实现线程安全</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRINGSZ 4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">pthread_mutex_t</span> env_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">thread_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_key_create</span>(&amp;key, free);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> 	i, len;</span><br><span class="line">    <span class="type">char</span>* 	envbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;init_done, thread_init);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;env, mutex);		<span class="comment">//这里应该可以用读写锁，增加读时并发性</span></span><br><span class="line">    envbuf = (<span class="type">char</span>*)<span class="built_in">pthread_getspecific</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        envbuf = <span class="built_in">malloc</span>(MAXSTRINGSZ);</span><br><span class="line">        <span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;env_mutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_setspecific</span>(key, envbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp; (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(envbuf, &amp;environ[i][len+<span class="number">1</span>], MAXSTRINGSZ<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;env_mutex);</span><br><span class="line">            <span class="keyword">return</span> envbuf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;env_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意虽然这个版本的getenv是线程安全的，但它并不是异步信号安全的。对信号而言他不是可重入的，因为调用了malloc</p>
<h4 id="12-7-取消选项"><a href="#12-7-取消选项" class="headerlink" title="12.7 取消选项"></a>12.7 取消选项</h4><p>有两个属性没有包含在pthread_attr_t结构中，<strong>可取消状态</strong>和<strong>可取消类型</strong>。这两个属性影响着线程在响应pthread_cancel函数时所呈现的行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可取消状态属性可以是PTHREAD_CANCEL_ENABLE 或 PTHREAD_CANCEL_DISABLE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span>* oldstate)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>调用pthread_cancel函数并不等待线程终止，他会继续允许，直到到达某个取消点。</p>
<p>线程默认的可取消状态是PTHREAD_CANCEL_ENABLE，当状态设为PTHREAD_CANCEL_DISABLE时，对pthread_cancel的调用不会杀死线程。当状态变为PTHREAD_CANCEL_ENABLE时被处理，看起来应该是起到了一个延迟的作用，比如我们希望cancel后也能执行一部分行为再自己被取消</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_testcancel</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//手动添加取消点</span></span><br></pre></td></tr></table></figure>

<p>我们之前描述的这种默认的取消类型也称为<strong>推迟取消</strong>。线程在到达取消点之前，不会出出现真正的取消，通过pthread_setcanceltype可以修改取消类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span>* oldtype)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>参数类型: PTHREADCANCEL_DEFERRED 或 PTHREAD_CANCEL_ASYNCHRONOUS</p>
<h4 id="12-8-线程和信号"><a href="#12-8-线程和信号" class="headerlink" title="12.8 线程和信号"></a>12.8 线程和信号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, cosnt <span class="type">sigset_t</span>* restrict set, <span class="type">sigset_t</span>* restrict oset)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>用法基本和sigprocmask一样，但只对当前线程生效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程可以通过调用sigwait等待一个或多个信号的出现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span>* restrict set, <span class="type">int</span>* restrict signop)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<p>把信号发送给线程，pthread_kill</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#included <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> signo)</span></span>;</span><br><span class="line">	<span class="comment">//成功返回0，否则返回错误编号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> 		quitflag; 		<span class="comment">/* set nonzero by thread */</span></span><br><span class="line"><span class="type">sigset_t</span> 	mask;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> 	waitloc = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thr_fn</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> err, signo;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        err = <span class="built_in">sigwait</span>(&amp;mask, &amp;signo);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">err_exit</span>(err, <span class="string">&quot;sigwait error&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">            <span class="keyword">case</span> SIGINT:  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\ninterrupt\n&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SIGQUIT: </span><br><span class="line">                <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">                quitflag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;waitloc);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;unexpected signal %d\n&quot;</span>, signo);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> 		err;</span><br><span class="line">    <span class="type">sigset_t</span> 	oldmask;</span><br><span class="line">    <span class="type">pthread_t</span> 	tid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask, SIGINT);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> ((err = <span class="built_in">pthread_sigmask</span>(SIG_BLOCK, &amp;mask, &amp;oldmask)) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    err = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thr_fn, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_exit</span>(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">while</span> (quitflag == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;waitloc, &amp;lock);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* SIGQUIT has been caught and is now blocked; do whatever */</span></span><br><span class="line">    quitflag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* reset signal mask which unblocks SIGQUIT */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">err_sys</span>(err, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-9-线程和fork"><a href="#12-9-线程和fork" class="headerlink" title="12.9 线程和fork"></a>12.9 线程和fork</h4><h4 id="12-10-线程和I-x2F-O"><a href="#12-10-线程和I-x2F-O" class="headerlink" title="12.10 线程和I&#x2F;O"></a>12.10 线程和I&#x2F;O</h4><h4 id="12-11-小结"><a href="#12-11-小结" class="headerlink" title="12.11 小结"></a>12.11 小结</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AuroraFish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/16/APUE%20note/">http://example.com/2022/10/16/APUE%20note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Aurora</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/background.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/17/UNP%20note/"><img class="prev-cover" src="/./img/cat8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UNP 学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/"><img class="next-cover" src="/./img/suanfa.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法笔记note2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/headd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AuroraFish</div><div class="author-info__description">保持幻想</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AuroraFish"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AuroraFish" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:205878047@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">只是睡着了</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unix-%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Unix 环境高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">linux 一些零散的基础知识(视频系统编程部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">快捷命令:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">目录结构:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">常见文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%86%9F%E6%82%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">文件或目录熟悉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.1.5.</span> <span class="toc-text">安装和卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.1.6.</span> <span class="toc-text">压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.8.</span> <span class="toc-text">用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.9.</span> <span class="toc-text">三种服务器搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ftp%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">ftp服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nfs%E6%9C%8D%E5%8A%A1%E5%99%A8-%EF%BC%88%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">nfs服务器 （共享文件夹)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssh%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">ssh服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.10.</span> <span class="toc-text">vim 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc"><span class="toc-number">1.1.11.</span> <span class="toc-text">gcc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.1.12.</span> <span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.1.13.</span> <span class="toc-text">动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.14.</span> <span class="toc-text">GDB调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile"><span class="toc-number">1.1.15.</span> <span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.16.</span> <span class="toc-text">虚拟地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stat-lstat%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%A9%BF%E9%80%8F%E5%92%8C%E4%B8%8D%E7%A9%BF%E9%80%8F"><span class="toc-number">1.1.17.</span> <span class="toc-text">stat lstat区别，穿透和不穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.18.</span> <span class="toc-text">程序和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%9F%BA%E6%9C%AC%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.19.</span> <span class="toc-text">CPU基本运作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMU"><span class="toc-number">1.1.20.</span> <span class="toc-text">MMU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">1.1.21.</span> <span class="toc-text">进程控制块 PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.22.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.23.</span> <span class="toc-text">环境变量函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FORK"><span class="toc-number">1.1.24.</span> <span class="toc-text">FORK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.1.25.</span> <span class="toc-text">exec函数族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">1.1.26.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC"><span class="toc-number">1.1.27.</span> <span class="toc-text">IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-1"><span class="toc-number">1.1.27.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO"><span class="toc-number">1.1.27.2.</span> <span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mkfifo%E5%87%BD%E6%95%B0%E5%92%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.27.3.</span> <span class="toc-text">mkfifo函数和命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.27.4.</span> <span class="toc-text">共享存储映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strace"><span class="toc-number">1.1.28.</span> <span class="toc-text">strace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C-%E5%88%A9%E7%94%A8fifo%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">1.1.29.</span> <span class="toc-text">小实验 利用fifo实现简单的本地聊天室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.30.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">1.1.31.</span> <span class="toc-text">信号捕捉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.32.</span> <span class="toc-text">内核实现信号捕捉过程:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E7%AB%9E%E6%80%81"><span class="toc-number">1.1.33.</span> <span class="toc-text">时序竞态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%BC%82%E6%AD%A5I-x2F-O"><span class="toc-number">1.1.34.</span> <span class="toc-text">全局变量异步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0-x2F-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.35.</span> <span class="toc-text">可重入函数&#x2F;不可重入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHILD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.1.36.</span> <span class="toc-text">SIGCHILD信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%BC%A0%E5%8F%82"><span class="toc-number">1.1.37.</span> <span class="toc-text">信号传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.38.</span> <span class="toc-text">中断系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF"><span class="toc-number">1.1.39.</span> <span class="toc-text">终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">1.1.40.</span> <span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.1.41.</span> <span class="toc-text">会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.42.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.43.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linxu%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.44.</span> <span class="toc-text">Linxu内核线程的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB-x2F-%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.45.</span> <span class="toc-text">线程共享&#x2F;非共享资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.1.46.</span> <span class="toc-text">线程控制原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.47.</span> <span class="toc-text">线程属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">1.1.48.</span> <span class="toc-text">小实验 多线程拷贝并实现进度条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.49.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-Mutex-%E5%88%9D%E5%A7%8B%E5%80%BC1"><span class="toc-number">1.1.50.</span> <span class="toc-text">互斥量 Mutex (初始值1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E4%B8%8E%E8%A7%A3%E9%94%81"><span class="toc-number">1.1.51.</span> <span class="toc-text">加锁与解锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.1.52.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.1.53.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.54.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.1.55.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.56.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-number">1.1.57.</span> <span class="toc-text">文件锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APUE%E4%B9%A6%E7%B1%8D%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0"><span class="toc-number">1.2.</span> <span class="toc-text">APUE书籍部分笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%96%87%E4%BB%B6I-x2F-O"><span class="toc-number">1.2.1.</span> <span class="toc-text">第3章 文件I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">3.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">3.2 文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%87%BD%E6%95%B0open-%E5%92%8C-openat"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.3 函数open 和 openat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%87%BD%E6%95%B0create"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">3.4 函数create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0close"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">3.5 函数close</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%87%BD%E6%95%B0lseek"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">3.6 函数lseek</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%87%BD%E6%95%B0read"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">3.7 函数read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%87%BD%E6%95%B0write"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">3.8 函数write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-I-x2F-O%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">3.9 I&#x2F;O的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.1.10.</span> <span class="toc-text">3.10 文件共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.11.</span> <span class="toc-text">3.11 原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-%E5%87%BD%E6%95%B0dup%E5%92%8Cdup2"><span class="toc-number">1.2.1.12.</span> <span class="toc-text">3.12 函数dup和dup2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-%E5%87%BD%E6%95%B0sync-fsync-%E5%92%8C-fdatasync"><span class="toc-number">1.2.1.13.</span> <span class="toc-text">3.13 函数sync,fsync 和 fdatasync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-%E5%87%BD%E6%95%B0fcntl"><span class="toc-number">1.2.1.14.</span> <span class="toc-text">3.14 函数fcntl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-15-%E5%87%BD%E6%95%B0ioctl"><span class="toc-number">1.2.1.15.</span> <span class="toc-text">3.15 函数ioctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-16-x2F-dev-x2F-fd"><span class="toc-number">1.2.1.16.</span> <span class="toc-text">3.16 &#x2F;dev&#x2F;fd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.17.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">第4章 文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">4.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%87%BD%E6%95%B0stat%E3%80%81fstat%E3%80%81fstatat%E5%92%8Clstat"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">4.2 函数stat、fstat、fstatat和lstat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">4.3 文件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7ID%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BB%84ID"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4.4 设置用户ID和设置组ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">4.5 文件访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E6%96%B0%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">4.6 新文件和目录的所有权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-%E5%87%BD%E6%95%B0access%E5%92%8Cfaccessat"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">4.7 函数access和faccessat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-%E5%87%BD%E6%95%B0umask"><span class="toc-number">1.2.2.8.</span> <span class="toc-text">4.8 函数umask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-%E5%87%BD%E6%95%B0chmod%E3%80%81fchmod%E5%92%8Cfchmodat"><span class="toc-number">1.2.2.9.</span> <span class="toc-text">4.9 函数chmod、fchmod和fchmodat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-10-%E7%B2%98%E7%9D%80%E4%BD%8D"><span class="toc-number">1.2.2.10.</span> <span class="toc-text">4.10 粘着位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-11-%E5%87%BD%E6%95%B0chown%E3%80%81fchown%E3%80%81fchownat%E5%92%8Clchown"><span class="toc-number">1.2.2.11.</span> <span class="toc-text">4.11 函数chown、fchown、fchownat和lchown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-12-%E6%96%87%E4%BB%B6%E9%95%BF%E5%BA%A6"><span class="toc-number">1.2.2.12.</span> <span class="toc-text">4.12 文件长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-13-%E6%96%87%E4%BB%B6%E6%88%AA%E6%96%AD"><span class="toc-number">1.2.2.13.</span> <span class="toc-text">4.13 文件截断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-14-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.2.14.</span> <span class="toc-text">4.14 文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-%E5%87%BD%E6%95%B0link%E3%80%81linkat%E3%80%81unlink%E3%80%81unlinkat%E5%92%8Cremove"><span class="toc-number">1.2.2.15.</span> <span class="toc-text">4.15 函数link、linkat、unlink、unlinkat和remove</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-16-%E5%87%BD%E6%95%B0rename%E5%92%8Crenameat"><span class="toc-number">1.2.2.16.</span> <span class="toc-text">4.16 函数rename和renameat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-17-%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.2.17.</span> <span class="toc-text">4.17 符号链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-18-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%AF%BB%E5%8F%96%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.2.18.</span> <span class="toc-text">4.18 创建和读取符号链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-19-%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.2.19.</span> <span class="toc-text">4.19 文件的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-20-%E5%87%BD%E6%95%B0futimens%E3%80%81utimensat%E5%92%8Cutimes"><span class="toc-number">1.2.2.20.</span> <span class="toc-text">4.20 函数futimens、utimensat和utimes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-21-%E5%87%BD%E6%95%B0mkdir%E3%80%81mkdirat%E5%92%8Crmdir"><span class="toc-number">1.2.2.21.</span> <span class="toc-text">4.21 函数mkdir、mkdirat和rmdir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-22-%E8%AF%BB%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.2.22.</span> <span class="toc-text">4.22 读目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-23-%E5%87%BD%E6%95%B0chdir%E3%80%81fchdir%E5%92%8Cgetcwd"><span class="toc-number">1.2.2.23.</span> <span class="toc-text">4.23 函数chdir、fchdir和getcwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-24-%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.24.</span> <span class="toc-text">4.24 设备特殊文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-25-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.2.25.</span> <span class="toc-text">4.25 文件访问权限小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-26-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.2.26.</span> <span class="toc-text">4.26 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%A0%87%E5%87%86I-x2F-O%E5%BA%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">第5章 标准I&#x2F;O库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">5.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%B5%81%E5%92%8CFILE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">5.2 流和FILE对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">5.3 标准输入、标准输出和标准错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E7%BC%93%E5%86%B2"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">5.4 缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%89%93%E5%BC%80%E6%B5%81"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">5.5 打开流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E8%AF%BB%E5%92%8C%E5%86%99%E6%B5%81"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">5.6 读和写流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E6%AF%8F%E6%AC%A1%E4%B8%80%E8%A1%8CI-x2F-O"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">5.7 每次一行I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%A0%87%E5%87%86I-x2F-O%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.2.3.8.</span> <span class="toc-text">5.8 标准I&#x2F;O的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E4%BA%8C%E8%BF%9B%E5%88%B6I-x2F-O"><span class="toc-number">1.2.3.9.</span> <span class="toc-text">5.9 二进制I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-%E5%AE%9A%E4%BD%8D%E6%B5%81"><span class="toc-number">1.2.3.10.</span> <span class="toc-text">5.10 定位流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-%E6%A0%BC%E5%BC%8F%E5%8C%96I-x2F-O"><span class="toc-number">1.2.3.11.</span> <span class="toc-text">5.11 格式化I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.3.12.</span> <span class="toc-text">5.12 实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-13-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.13.</span> <span class="toc-text">5.13 临时文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-14-%E5%86%85%E5%AD%98%E6%B5%81"><span class="toc-number">1.2.3.14.</span> <span class="toc-text">5.14 内存流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-15-%E6%A0%87%E5%87%86I-x2F-O%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.3.15.</span> <span class="toc-text">5.15 标准I&#x2F;O的替代软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-16-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.3.16.</span> <span class="toc-text">5.16 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">第7章 进程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">7.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-main%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">7.2 main函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">7.3 进程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">7.4 命令行参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E7%8E%AF%E5%A2%83%E8%A1%A8"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">7.5 环境表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">7.6 C程序的存储空间布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">7.7 共享库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">7.8 存储空间分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">7.9 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-10-%E5%87%BD%E6%95%B0setjmp%E5%92%8Clongjmp"><span class="toc-number">1.2.4.10.</span> <span class="toc-text">7.10 函数setjmp和longjmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-%E5%87%BD%E6%95%B0getrlimit%E5%92%8Csetrlimit"><span class="toc-number">1.2.4.11.</span> <span class="toc-text">7.11 函数getrlimit和setrlimit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-12-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.4.12.</span> <span class="toc-text">7.12 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">第8章 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">8.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">8.2 进程标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E5%87%BD%E6%95%B0fork"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">8.3 函数fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E5%87%BD%E6%95%B0vfork"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">8.4 函数vfork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E5%87%BD%E6%95%B0exit"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">8.5 函数exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E5%87%BD%E6%95%B0wait%E5%92%8Cwaitpid"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">8.6 函数wait和waitpid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E5%87%BD%E6%95%B0waitid"><span class="toc-number">1.2.5.7.</span> <span class="toc-text">8.7 函数waitid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-%E5%87%BD%E6%95%B0wait3%E5%92%8Cwait4"><span class="toc-number">1.2.5.8.</span> <span class="toc-text">8.8 函数wait3和wait4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.5.9.</span> <span class="toc-text">8.9 竞争条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-%E5%87%BD%E6%95%B0exec"><span class="toc-number">1.2.5.10.</span> <span class="toc-text">8.10 函数exec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-11-%E6%9B%B4%E6%94%B9%E7%94%A8%E6%88%B7ID%E5%92%8C%E6%9B%B4%E6%94%B9%E7%BB%84ID"><span class="toc-number">1.2.5.11.</span> <span class="toc-text">8.11 更改用户ID和更改组ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.12.</span> <span class="toc-text">8.12 解释器文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-13-%E5%87%BD%E6%95%B0system"><span class="toc-number">1.2.5.13.</span> <span class="toc-text">8.13 函数system</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-14-%E8%BF%9B%E7%A8%8B%E4%BC%9A%E8%AE%A1"><span class="toc-number">1.2.5.14.</span> <span class="toc-text">8.14 进程会计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-15-%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86"><span class="toc-number">1.2.5.15.</span> <span class="toc-text">8.15 用户标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-16-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.5.16.</span> <span class="toc-text">8.16 进程调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-17-%E8%BF%9B%E7%A8%8B%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.5.17.</span> <span class="toc-text">8.17 进程时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-18-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.5.18.</span> <span class="toc-text">8.18 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.6.</span> <span class="toc-text">第10章 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">10.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E4%BF%A1%E5%8F%B7%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">10.2 信号概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E5%87%BD%E6%95%B0signal"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">10.3 函数signal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">10.4 不可靠的信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">10.5 中断的系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.6.</span> <span class="toc-text">10.6 可重入函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-SIGCLD%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.6.7.</span> <span class="toc-text">10.7 SIGCLD语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-8-%E5%8F%AF%E9%9D%A0%E4%BF%A1%E5%8F%B7%E6%9C%AF%E8%AF%AD%E5%92%8C%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.6.8.</span> <span class="toc-text">10.8 可靠信号术语和语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-9-%E5%87%BD%E6%95%B0kill%E5%92%8Craise"><span class="toc-number">1.2.6.9.</span> <span class="toc-text">10.9 函数kill和raise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-10-%E5%87%BD%E6%95%B0alarm%E5%92%8Cpause"><span class="toc-number">1.2.6.10.</span> <span class="toc-text">10.10 函数alarm和pause</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-11-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">1.2.6.11.</span> <span class="toc-text">10.11 信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-12-%E5%87%BD%E6%95%B0sigprocmask"><span class="toc-number">1.2.6.12.</span> <span class="toc-text">10.12 函数sigprocmask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-13-%E5%87%BD%E6%95%B0sigpending"><span class="toc-number">1.2.6.13.</span> <span class="toc-text">10.13 函数sigpending</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-14-%E5%87%BD%E6%95%B0sigaction"><span class="toc-number">1.2.6.14.</span> <span class="toc-text">10.14 函数sigaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-15-%E5%87%BD%E6%95%B0sigsetjmp%E5%92%8Csiglongjmp"><span class="toc-number">1.2.6.15.</span> <span class="toc-text">10.15 函数sigsetjmp和siglongjmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-16-%E5%87%BD%E6%95%B0sigsuspend"><span class="toc-number">1.2.6.16.</span> <span class="toc-text">10.16 函数sigsuspend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-17-%E5%87%BD%E6%95%B0abort"><span class="toc-number">1.2.6.17.</span> <span class="toc-text">10.17 函数abort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-18-%E5%87%BD%E6%95%B0system"><span class="toc-number">1.2.6.18.</span> <span class="toc-text">10.18 函数system</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-19-%E5%87%BD%E6%95%B0sleep%E3%80%81nanosleep%E5%92%8Cclock-nanosleep"><span class="toc-number">1.2.6.19.</span> <span class="toc-text">10.19 函数sleep、nanosleep和clock_nanosleep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-20-%E5%87%BD%E6%95%B0sigqueue"><span class="toc-number">1.2.6.20.</span> <span class="toc-text">10.20 函数sigqueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-21-%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.6.21.</span> <span class="toc-text">10.21 作业控制信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-22-%E4%BF%A1%E5%8F%B7%E5%90%8D%E5%92%8C%E7%BC%96%E5%8F%B7"><span class="toc-number">1.2.6.22.</span> <span class="toc-text">10.22 信号名和编号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-23-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.6.23.</span> <span class="toc-text">10.23 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">第11章 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">11.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">11.2 线程概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">11.3 线程标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">11.4 线程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">11.5 线程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.7.6.</span> <span class="toc-text">11.6 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">1.2.7.6.1.</span> <span class="toc-text">1.互斥量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.7.6.2.</span> <span class="toc-text">2.避免死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0pthread-mutex-timedlock"><span class="toc-number">1.2.7.6.3.</span> <span class="toc-text">3.函数pthread_mutex_timedlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.2.7.6.4.</span> <span class="toc-text">4.读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%B8%A6%E6%9C%89%E8%B6%85%E6%97%B6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.2.7.6.5.</span> <span class="toc-text">5.带有超时的读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.7.6.6.</span> <span class="toc-text">6.条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.2.7.6.7.</span> <span class="toc-text">7. 自旋锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.7.6.8.</span> <span class="toc-text">8.屏障</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.7.7.</span> <span class="toc-text">11.7 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.8.</span> <span class="toc-text">第12章 线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">12.1 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E7%BA%BF%E7%A8%8B%E9%99%90%E5%88%B6"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">12.2 线程限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">12.3 线程属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">12.4 同步属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.8.4.1.</span> <span class="toc-text">1.互斥量属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.8.4.2.</span> <span class="toc-text">2.读写锁属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.8.4.3.</span> <span class="toc-text">3.条件变量属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.8.4.4.</span> <span class="toc-text">4.屏障属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-%E9%87%8D%E5%85%A5"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">12.5 重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-6-%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">12.6 线程特定数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-7-%E5%8F%96%E6%B6%88%E9%80%89%E9%A1%B9"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">12.7 取消选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-8-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.8.8.</span> <span class="toc-text">12.8 线程和信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-9-%E7%BA%BF%E7%A8%8B%E5%92%8Cfork"><span class="toc-number">1.2.8.9.</span> <span class="toc-text">12.9 线程和fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-10-%E7%BA%BF%E7%A8%8B%E5%92%8CI-x2F-O"><span class="toc-number">1.2.8.10.</span> <span class="toc-text">12.10 线程和I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-11-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.8.11.</span> <span class="toc-text">12.11 小结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记"><img src="/./img/cat1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux高性能服务器笔记"/></a><div class="content"><a class="title" href="/2023/04/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%20note/" title="Linux高性能服务器笔记">Linux高性能服务器笔记</a><time datetime="2023-04-21T10:38:55.000Z" title="发表于 2023-04-21 18:38:55">2023-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记"><img src="/./img/cat8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UNP 学习笔记"/></a><div class="content"><a class="title" href="/2023/03/17/UNP%20note/" title="UNP 学习笔记">UNP 学习笔记</a><time datetime="2023-03-17T09:38:55.000Z" title="发表于 2023-03-17 17:38:55">2023-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记"><img src="/./img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="APUE 学习笔记"/></a><div class="content"><a class="title" href="/2022/10/16/APUE%20note/" title="APUE 学习笔记">APUE 学习笔记</a><time datetime="2022-10-16T13:00:55.000Z" title="发表于 2022-10-16 21:00:55">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记note2"/></a><div class="content"><a class="title" href="/2022/05/05/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20note%202/" title="算法笔记note2">算法笔记note2</a><time datetime="2022-05-05T10:48:47.000Z" title="发表于 2022-05-05 18:48:47">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目"><img src="/./img/suanfa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法笔记题目"/></a><div class="content"><a class="title" href="/2022/04/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%A2%98%E7%9B%AE%20(PAT%E9%83%A8%E5%88%86)/" title="算法笔记题目">算法笔记题目</a><time datetime="2022-04-19T06:35:55.000Z" title="发表于 2022-04-19 14:35:55">2022-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: 颜色(white)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By AuroraFish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">饿死了</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>